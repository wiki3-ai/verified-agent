<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>type-set-b - ACL2 Book</title>
  <meta property="name" content="type-set-b">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">type-set-b</h1>
    <div class="path"><a href="type-set-b.lisp" class="source-link">type-set-b</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block constant" id="def-_2Anumber-of-numeric-type-set-bits_2A" data-defines="*NUMBER-OF-NUMERIC-TYPE-SET-BITS*" data-references="DEFCONST" data-used-by="*TYPE-SET-BINARY-*-TABLE-LIST*,*TYPE-SET-BINARY-+-TABLE-LIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*NUMBER-OF-NUMERIC-TYPE-SET-BITS*">*number-of-numeric-type-set-bits*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Anumber-of-numeric-type-set-bits_2A" data-sym="*NUMBER-OF-NUMERIC-TYPE-SET-BITS*" title="(defconst *number-of-numeric-type-set-bits* 7)">*number-of-numeric-type-set-bits*</a> <span class="number">7</span>)</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-binary-_2B-table-list_2A" data-defines="*TYPE-SET-BINARY-+-TABLE-LIST*" data-references="1-,TYPE-SET-BINARY-+-ALIST,*TYPE-SET-BINARY-+-TABLE*,QUOTE,*TS-ACL2-NUMBER*,*,1+,LIST,CONS,*NUMBER-OF-NUMERIC-TYPE-SET-BITS*,EXPT,LEN,LET,DEFCONST" data-used-by="*TYPE-SET-BINARY-+-TABLE*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-BINARY-+-TABLE-LIST*">*type-set-binary-+-table-list*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table-list_2A" data-sym="*TYPE-SET-BINARY-+-TABLE-LIST*" title="(defconst *type-set-binary-+-table-list*
          (let ((len (expt 2 *number-of-numeric-type-set-bits*)))
            (cons
             (list :header :dimensions (list len len) :maximum-length
                   (1+ (* len len)) :default *ts-acl2-number* :name
...">*type-set-binary-+-table-list*</a>
  (let ((<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (expt <span class="number">2</span> <a class="sym-link local-def" href="#def-_2Anumber-of-numeric-type-set-bits_2A" data-sym="*NUMBER-OF-NUMERIC-TYPE-SET-BITS*" title="(defconst *number-of-numeric-type-set-bits* 7)">*number-of-numeric-type-set-bits*</a>)))
    (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:header</span> <span class="keyword">:dimensions</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>)
        <span class="keyword">:maximum-length</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>))
        <span class="keyword">:default</span> *ts-acl2-number*
        <span class="keyword">:name</span> '<a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table_2A" data-sym="*TYPE-SET-BINARY-+-TABLE*" title="(defconst *type-set-binary-+-table*
          (compress2 &#39;type-set-binary-+-table *type-set-binary-+-table-list*))">*type-set-binary-+-table*</a>)
      (type-set-binary-+-alist (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) nil))))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-binary-_2B-table_2A" data-defines="*TYPE-SET-BINARY-+-TABLE*" data-references="*TYPE-SET-BINARY-+-TABLE-LIST*,TYPE-SET-BINARY-+-TABLE,QUOTE,COMPRESS2,DEFCONST" data-used-by="TYPE-SET-FINISH-1,TYPE-SET-BINARY-+,*TYPE-SET-BINARY-+-TABLE-LIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-BINARY-+-TABLE*">*type-set-binary-+-table*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table_2A" data-sym="*TYPE-SET-BINARY-+-TABLE*" title="(defconst *type-set-binary-+-table*
          (compress2 &#39;type-set-binary-+-table *type-set-binary-+-table-list*))">*type-set-binary-+-table*</a>
  (<a class="sym-link system" href="axioms.html#def-compress2" data-sym="COMPRESS2">compress2</a> 'type-set-binary-+-table
    <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table-list_2A" data-sym="*TYPE-SET-BINARY-+-TABLE-LIST*" title="(defconst *type-set-binary-+-table-list*
          (let ((len (expt 2 *number-of-numeric-type-set-bits*)))
            (cons
             (list :header :dimensions (list len len) :maximum-length
                   (1+ (* len len)) :default *ts-acl2-number* :name
...">*type-set-binary-+-table-list*</a>))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-binary-_2A-table-list_2A" data-defines="*TYPE-SET-BINARY-*-TABLE-LIST*" data-references="1-,TYPE-SET-BINARY-*-ALIST,*TYPE-SET-BINARY-*-TABLE*,QUOTE,*TS-ACL2-NUMBER*,*,1+,LIST,CONS,*NUMBER-OF-NUMERIC-TYPE-SET-BITS*,EXPT,LEN,LET,DEFCONST" data-used-by="*TYPE-SET-BINARY-*-TABLE*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-BINARY-*-TABLE-LIST*">*type-set-binary-*-table-list*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table-list_2A" data-sym="*TYPE-SET-BINARY-*-TABLE-LIST*" title="(defconst *type-set-binary-*-table-list*
          (let ((len (expt 2 *number-of-numeric-type-set-bits*)))
            (cons
             (list :header :dimensions (list len len) :maximum-length
                   (1+ (* len len)) :default *ts-acl2-number* :name
...">*type-set-binary-*-table-list*</a>
  (let ((<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (expt <span class="number">2</span> <a class="sym-link local-def" href="#def-_2Anumber-of-numeric-type-set-bits_2A" data-sym="*NUMBER-OF-NUMERIC-TYPE-SET-BITS*" title="(defconst *number-of-numeric-type-set-bits* 7)">*number-of-numeric-type-set-bits*</a>)))
    (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:header</span> <span class="keyword">:dimensions</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>)
        <span class="keyword">:maximum-length</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>))
        <span class="keyword">:default</span> *ts-acl2-number*
        <span class="keyword">:name</span> '<a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table_2A" data-sym="*TYPE-SET-BINARY-*-TABLE*" title="(defconst *type-set-binary-*-table*
          (compress2 &#39;type-set-binary-*-table *type-set-binary-*-table-list*))">*type-set-binary-*-table*</a>)
      (type-set-binary-*-alist (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) nil))))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-binary-_2A-table_2A" data-defines="*TYPE-SET-BINARY-*-TABLE*" data-references="*TYPE-SET-BINARY-*-TABLE-LIST*,TYPE-SET-BINARY-*-TABLE,QUOTE,COMPRESS2,DEFCONST" data-used-by="TYPE-SET-FINISH-1,TYPE-SET-BINARY-*,*TYPE-SET-BINARY-*-TABLE-LIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-BINARY-*-TABLE*">*type-set-binary-*-table*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table_2A" data-sym="*TYPE-SET-BINARY-*-TABLE*" title="(defconst *type-set-binary-*-table*
          (compress2 &#39;type-set-binary-*-table *type-set-binary-*-table-list*))">*type-set-binary-*-table*</a>
  (<a class="sym-link system" href="axioms.html#def-compress2" data-sym="COMPRESS2">compress2</a> 'type-set-binary-*-table
    <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table-list_2A" data-sym="*TYPE-SET-BINARY-*-TABLE-LIST*" title="(defconst *type-set-binary-*-table-list*
          (let ((len (expt 2 *number-of-numeric-type-set-bits*)))
            (cons
             (list :header :dimensions (list len len) :maximum-length
                   (1+ (* len len)) :default *ts-acl2-number* :name
...">*type-set-binary-*-table-list*</a>))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-_3C-table-list_2A" data-defines="*TYPE-SET-<-TABLE-LIST*" data-references="TYPE-SET-<-ALIST,*TYPE-SET-<-TABLE*,*,1+,QUOTE,LIST,CONS,DEFCONST" data-used-by="*TYPE-SET-<-TABLE*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-<-TABLE-LIST*">*type-set-&lt;-table-list*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-_3C-table-list_2A" data-sym="*TYPE-SET-&lt;-TABLE-LIST*" title="(defconst *type-set-&lt;-table-list*
          (cons
           (list :header :dimensions &#39;(64 64) :maximum-length (1+ (* 64 64))
                 :name &#39;*type-set-&lt;-table*)
           (type-set-&lt;-alist 63 63 nil)))">*type-set-&lt;-table-list*</a>
  (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:header</span> <span class="keyword">:dimensions</span> '(<span class="number">64</span> <span class="number">64</span>)
      <span class="keyword">:maximum-length</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">64</span> <span class="number">64</span>))
      <span class="keyword">:name</span> '<a class="sym-link local-def" href="#def-_2Atype-set-_3C-table_2A" data-sym="*TYPE-SET-&lt;-TABLE*" title="(defconst *type-set-&lt;-table*
          (compress2 &#39;type-set-&lt;-table *type-set-&lt;-table-list*))">*type-set-&lt;-table*</a>)
    (type-set-&lt;-alist <span class="number">63</span> <span class="number">63</span> nil)))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-set-_3C-table_2A" data-defines="*TYPE-SET-<-TABLE*" data-references="*TYPE-SET-<-TABLE-LIST*,TYPE-SET-<-TABLE,QUOTE,COMPRESS2,DEFCONST" data-used-by="TYPE-SET-<,*TYPE-SET-<-TABLE-LIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-SET-<-TABLE*">*type-set-&lt;-table*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-set-_3C-table_2A" data-sym="*TYPE-SET-&lt;-TABLE*" title="(defconst *type-set-&lt;-table*
          (compress2 &#39;type-set-&lt;-table *type-set-&lt;-table-list*))">*type-set-&lt;-table*</a>
  (<a class="sym-link system" href="axioms.html#def-compress2" data-sym="COMPRESS2">compress2</a> 'type-set-&lt;-table <a class="sym-link local-def" href="#def-_2Atype-set-_3C-table-list_2A" data-sym="*TYPE-SET-&lt;-TABLE-LIST*" title="(defconst *type-set-&lt;-table-list*
          (cons
           (list :header :dimensions &#39;(64 64) :maximum-length (1+ (* 64 64))
                 :name &#39;*type-set-&lt;-table*)
           (type-set-&lt;-alist 63 63 nil)))">*type-set-&lt;-table-list*</a>))</pre>
  </div>

<div class="form-block function" id="def-assoc-equal-cdr" data-defines="ASSOC-EQUAL-CDR" data-references="CDR,T,CAR,CDAR,EQUAL,ENDP,COND,ALISTP,XARGS,DECLARE,ALIST,X,DEFUN" data-used-by="FRUNIC-MAPPING-PAIR,FNUME,RUNEP" data-part-name="ASSOC-EQUAL-CDR" data-part-args="ALIST,X" data-part-declare="ALIST,ALISTP,XARGS,DECLARE" data-part-body="CDR,ASSOC-EQUAL-CDR,T,CAR,CDAR,X,EQUAL,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-EQUAL-CDR">assoc-equal-cdr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assoc-equal-cdr" data-sym="ASSOC-EQUAL-CDR" title="(defun assoc-equal-cdr (x alist)
  (declare (xargs :mode :logic :guard (alistp alist)))
  (cond ((endp alist) nil) ((equal x (cdar alist)) (car alist))
        (t (assoc-equal-cdr x (cdr alist)))))">assoc-equal-cdr</a>
  (x alist)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) nil)
    ((equal x (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)) (car alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assoc-equal-cdr" data-sym="ASSOC-EQUAL-CDR" title="(defun assoc-equal-cdr (x alist)
  (declare (xargs :mode :logic :guard (alistp alist)))
  (cond ((endp alist) nil) ((equal x (cdar alist)) (car alist))
        (t (assoc-equal-cdr x (cdr alist)))))">assoc-equal-cdr</a> x (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-runep" data-defines="RUNEP" data-references="ASSOC-EQUAL-CDR,CAR,COND,T,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,ALISTP,PLIST-WORLDP,CADR,SYMBOLP,CDR,CONSP,AND,IF,XARGS,DECLARE,WRLD,X,DEFUN" data-used-by="RUNIC-THEORYP1,RULE-NAME-DESIGNATORP" data-part-name="RUNEP" data-part-args="WRLD,X" data-part-declare="T,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,ALISTP,WRLD,PLIST-WORLDP,CADR,SYMBOLP,CDR,X,CONSP,AND,IF,XARGS,DECLARE" data-part-body="T,WRLD,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,ASSOC-EQUAL-CDR,CAR,CADR,SYMBOLP,CDR,X,CONSP,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RUNEP">runep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-runep" data-sym="RUNEP" title="(defun runep (x wrld)
  (declare
   (xargs :guard
    (if (and (consp x) (consp (cdr x)) (symbolp (cadr x)))
        (and (plist-worldp wrld)
...">runep</a>
  (x wrld)
  (declare (xargs <span class="keyword">:guard</span> (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp x) (consp (cdr x)) (symbolp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)
          (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x) 'runic-mapping-pairs nil wrld)))
        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp x) (consp (cdr x)) (symbolp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x))) (car (<a class="sym-link local-def" href="#def-assoc-equal-cdr" data-sym="ASSOC-EQUAL-CDR" title="(defun assoc-equal-cdr (x alist)
  (declare (xargs :mode :logic :guard (alistp alist)))
  (cond ((endp alist) nil) ((equal x (cdar alist)) (car alist))
        (t (assoc-equal-cdr x (cdr alist)))))">assoc-equal-cdr</a> x
          (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x) 'runic-mapping-pairs nil wrld))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block macro" id="def-base-symbol" data-defines="BASE-SYMBOL" data-references="CADR,QUASIQUOTE,RUNE,DEFMACRO" data-used-by="ENABLED-RUNEP,FIND-MAPPING-PAIRS-TAIL,RULE-NAME-DESIGNATORP,FRUNIC-MAPPING-PAIR,FNUME" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BASE-SYMBOL">base-symbol</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> (rune) `(<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ,RUNE))</pre>
  </div>

<div class="form-block macro" id="def-strip-base-symbols" data-defines="STRIP-BASE-SYMBOLS" data-references="STRIP-CADRS,QUASIQUOTE,RUNES,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="STRIP-BASE-SYMBOLS">strip-base-symbols</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-strip-base-symbols" data-sym="STRIP-BASE-SYMBOLS" title="(defmacro strip-base-symbols (runes) `(strip-cadrs ,runes))">strip-base-symbols</a> (runes) `(<a class="sym-link system" href="axioms.html#def-strip-cadrs" data-sym="STRIP-CADRS">strip-cadrs</a> ,RUNES))</pre>
  </div>

<div class="form-block function" id="def-fnume" data-defines="FNUME" data-references="ASSOC-EQUAL-CDR,CAR,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,ALISTP,BASE-SYMBOL,SYMBOLP,CDR,CONSP,PLIST-WORLDP,AND,XARGS,DECLARE,WRLD,RUNE,DEFUN" data-used-by="ACTIVE-OR-NON-RUNEP,ACTIVE-RUNEP,ENABLED-RUNEP" data-part-name="FNUME" data-part-args="WRLD,RUNE" data-part-declare="RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,ALISTP,BASE-SYMBOL,SYMBOLP,CDR,RUNE,CONSP,WRLD,PLIST-WORLDP,AND,XARGS,DECLARE" data-part-body="WRLD,RUNIC-MAPPING-PAIRS,QUOTE,BASE-SYMBOL,GETPROPC,RUNE,ASSOC-EQUAL-CDR,CAR" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FNUME">fnume</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fnume" data-sym="FNUME" title="(defun fnume (rune wrld)
  (declare
   (xargs :guard
    (and (plist-worldp wrld) (consp rune) (consp (cdr rune))
         (symbolp (base-symbol rune))
...">fnume</a>
  (rune wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)
        (consp rune)
        (consp (cdr rune))
        (symbolp (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune))
        (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) 'runic-mapping-pairs nil wrld)))))
  (car (<a class="sym-link local-def" href="#def-assoc-equal-cdr" data-sym="ASSOC-EQUAL-CDR" title="(defun assoc-equal-cdr (x alist)
  (declare (xargs :mode :logic :guard (alistp alist)))
  (cond ((endp alist) nil) ((equal x (cdar alist)) (car alist))
        (t (assoc-equal-cdr x (cdr alist)))))">assoc-equal-cdr</a> rune
      (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) 'runic-mapping-pairs nil wrld))))</pre>
  </div>

<div class="form-block function" id="def-frunic-mapping-pair" data-defines="FRUNIC-MAPPING-PAIR" data-references="RUNIC-MAPPING-PAIRS,QUOTE,BASE-SYMBOL,GETPROPC,ASSOC-EQUAL-CDR,WRLD,RUNE,DEFUN" data-used-by="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" data-part-name="FRUNIC-MAPPING-PAIR" data-part-args="WRLD,RUNE" data-part-body="WRLD,RUNIC-MAPPING-PAIRS,QUOTE,BASE-SYMBOL,GETPROPC,RUNE,ASSOC-EQUAL-CDR" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FRUNIC-MAPPING-PAIR">frunic-mapping-pair</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-frunic-mapping-pair" data-sym="FRUNIC-MAPPING-PAIR" title="(defun frunic-mapping-pair (rune wrld)
  (assoc-equal-cdr rune
                   (getpropc (base-symbol rune) &#39;runic-mapping-pairs nil wrld)))">frunic-mapping-pair</a>
  (rune wrld)
  (<a class="sym-link local-def" href="#def-assoc-equal-cdr" data-sym="ASSOC-EQUAL-CDR" title="(defun assoc-equal-cdr (x alist)
  (declare (xargs :mode :logic :guard (alistp alist)))
  (cond ((endp alist) nil) ((equal x (cdar alist)) (car alist))
        (t (assoc-equal-cdr x (cdr alist)))))">assoc-equal-cdr</a> rune
    (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) 'runic-mapping-pairs nil wrld)))</pre>
  </div>

<div class="form-block function" id="def-fn-rune-nume" data-defines="FN-RUNE-NUME" data-references="CDR,CAR,CADR,IF,PAIR,QUOTE,GETPROPC,RUNIC-MAPPING-PAIRS,LET*,WRLD,XFLG,NFLG,FN,DEFUN" data-used-by="SUBLIS-VAR!,ENABLED-XFNP,DEFINITION-RUNES" data-part-name="FN-RUNE-NUME" data-part-args="WRLD,XFLG,NFLG,FN" data-part-body="CDR,NFLG,CAR,CADR,XFLG,IF,PAIR,WRLD,QUOTE,FN,GETPROPC,RUNIC-MAPPING-PAIRS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FN-RUNE-NUME">fn-rune-nume</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fn-rune-nume" data-sym="FN-RUNE-NUME" title="(defun fn-rune-nume (fn nflg xflg wrld)
  (let* ((runic-mapping-pairs (getpropc fn &#39;runic-mapping-pairs nil wrld))
         (pair
          (if xflg
              (cadr runic-mapping-pairs)
...">fn-rune-nume</a>
  (fn nflg xflg wrld)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((runic-mapping-pairs (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'runic-mapping-pairs nil wrld)) (pair (if xflg
          (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> runic-mapping-pairs)
          (car runic-mapping-pairs))))
    (if nflg
      (car pair)
      (cdr pair))))</pre>
  </div>

<div class="form-block function" id="def-definition-runes" data-defines="DEFINITION-RUNES" data-references="CDR,CAR,FN-RUNE-NUME,CONS,T,NULL,COND,WRLD,XFLG,FNS,DEFUN" data-part-name="DEFINITION-RUNES" data-part-args="WRLD,XFLG,FNS" data-part-body="CDR,DEFINITION-RUNES,WRLD,XFLG,CAR,FN-RUNE-NUME,CONS,T,FNS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFINITION-RUNES">definition-runes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-definition-runes" data-sym="DEFINITION-RUNES" title="(defun definition-runes (fns xflg wrld)
  (cond ((null fns) nil)
        (t
         (cons (fn-rune-nume (car fns) nil xflg wrld)
               (definition-runes (cdr fns) xflg wrld)))))">definition-runes</a>
  (fns xflg wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fns) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-fn-rune-nume" data-sym="FN-RUNE-NUME" title="(defun fn-rune-nume (fn nflg xflg wrld)
  (let* ((runic-mapping-pairs (getpropc fn &#39;runic-mapping-pairs nil wrld))
         (pair
          (if xflg
              (cadr runic-mapping-pairs)
...">fn-rune-nume</a> (car fns) nil xflg wrld)
        (<a class="sym-link local-def" href="#def-definition-runes" data-sym="DEFINITION-RUNES" title="(defun definition-runes (fns xflg wrld)
  (cond ((null fns) nil)
        (t
         (cons (fn-rune-nume (car fns) nil xflg wrld)
               (definition-runes (cdr fns) xflg wrld)))))">definition-runes</a> (cdr fns) xflg wrld)))))</pre>
  </div>

<div class="form-block function" id="def-get-next-nume" data-defines="GET-NEXT-NUME" data-references="CDR,T,LENGTH,+,CDDR,CONSP,RUNIC-MAPPING-PAIRS,QUOTE,CAR,CADR,EQ,AND,NULL,COND,LST,DEFUN" data-used-by="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" data-part-name="GET-NEXT-NUME" data-part-args="LST" data-part-body="CDR,GET-NEXT-NUME,T,LENGTH,+,CDDR,CONSP,RUNIC-MAPPING-PAIRS,QUOTE,CAR,CADR,EQ,AND,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-NEXT-NUME">get-next-nume</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-next-nume" data-sym="GET-NEXT-NUME" title="(defun get-next-nume (lst)
  (cond ((null lst) 0)
        ((and (eq (cadr (car lst)) &#39;runic-mapping-pairs)
              (consp (cddr (car lst))))
         (+ (car (car (cddr (car lst)))) (length (cddr (car lst)))))">get-next-nume</a>
  (lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) <span class="number">0</span>)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car lst)) 'runic-mapping-pairs)
       (consp (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car lst)))) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (car (car (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car lst)))) (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car lst)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-get-next-nume" data-sym="GET-NEXT-NUME" title="(defun get-next-nume (lst)
  (cond ((null lst) 0)
        ((and (eq (cadr (car lst)) &#39;runic-mapping-pairs)
              (consp (cddr (car lst))))
         (+ (car (car (cddr (car lst)))) (length (cddr (car lst)))))">get-next-nume</a> (cdr lst)))))</pre>
  </div>

<div class="form-block function" id="def-deref-macro-name-lst" data-defines="DEREF-MACRO-NAME-LST" data-references="CDR,CAR,DEREF-MACRO-NAME,CONS,T,ATOM,COND,MACRO-ALIASES,MACRO-NAME-LST,DEFUN" data-part-name="DEREF-MACRO-NAME-LST" data-part-args="MACRO-ALIASES,MACRO-NAME-LST" data-part-body="CDR,DEREF-MACRO-NAME-LST,MACRO-ALIASES,CAR,DEREF-MACRO-NAME,CONS,T,MACRO-NAME-LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEREF-MACRO-NAME-LST">deref-macro-name-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deref-macro-name-lst" data-sym="DEREF-MACRO-NAME-LST" title="(defun deref-macro-name-lst (macro-name-lst macro-aliases)
  (cond ((atom macro-name-lst) nil)
        (t
         (cons (deref-macro-name (car macro-name-lst) macro-aliases)
               (deref-macro-name-lst (cdr macro-name-lst) macro-aliases)))))">deref-macro-name-lst</a>
  (macro-name-lst <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> macro-name-lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> (car macro-name-lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
        (<a class="sym-link local-def" href="#def-deref-macro-name-lst" data-sym="DEREF-MACRO-NAME-LST" title="(defun deref-macro-name-lst (macro-name-lst macro-aliases)
  (cond ((atom macro-name-lst) nil)
        (t
         (cons (deref-macro-name (car macro-name-lst) macro-aliases)
               (deref-macro-name-lst (cdr macro-name-lst) macro-aliases)))))">deref-macro-name-lst</a> (cdr macro-name-lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)))))</pre>
  </div>

<div class="form-block constant" id="def-_2Aabbrev-rune-alist_2A" data-defines="*ABBREV-RUNE-ALIST*" data-references="QUOTE,DEFCONST" data-used-by="TRANSLATE-ABBREV-RUNE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*ABBREV-RUNE-ALIST*">*abbrev-rune-alist*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aabbrev-rune-alist_2A" data-sym="*ABBREV-RUNE-ALIST*" title="(defconst *abbrev-rune-alist*
          &#39;((:d . :definition) (:e . :executable-counterpart) (:i . :induction)
            (:r . :rewrite) (:t . :type-prescription)))">*abbrev-rune-alist*</a>
  '((<span class="keyword">:d</span> . <span class="keyword">:definition</span>) (<span class="keyword">:e</span> . <span class="keyword">:executable-counterpart</span>)
    (<span class="keyword">:i</span> . <span class="keyword">:induction</span>)
    (<span class="keyword">:r</span> . <span class="keyword">:rewrite</span>)
    (<span class="keyword">:t</span> . <span class="keyword">:type-prescription</span>)))</pre>
  </div>

<div class="form-block function" id="def-translate-abbrev-rune" data-defines="TRANSLATE-ABBREV-RUNE" data-references="T,CDDR,DEREF-MACRO-NAME,LIST*,COND,*ABBREV-RUNE-ALIST*,CAR,ASSOC-EQ,CADR,SYMBOLP,CDR,CONSP,AND,KWD,LET,ALISTP,XARGS,DECLARE,MACRO-ALIASES,X,DEFUN" data-used-by="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1,RULE-NAME-DESIGNATORP" data-part-name="TRANSLATE-ABBREV-RUNE" data-part-args="MACRO-ALIASES,X" data-part-declare="MACRO-ALIASES,ALISTP,XARGS,DECLARE" data-part-body="T,CDDR,MACRO-ALIASES,DEREF-MACRO-NAME,LIST*,COND,*ABBREV-RUNE-ALIST*,CAR,ASSOC-EQ,CADR,SYMBOLP,CDR,X,CONSP,AND,KWD,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TRANSLATE-ABBREV-RUNE">translate-abbrev-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-translate-abbrev-rune" data-sym="TRANSLATE-ABBREV-RUNE" title="(defun translate-abbrev-rune (x macro-aliases)
  (declare (xargs :guard (alistp macro-aliases)))
  (let ((kwd
         (and (consp x) (consp (cdr x)) (symbolp (cadr x))
              (cdr (assoc-eq (car x) *abbrev-rune-alist*)))))
...">translate-abbrev-rune</a>
  (x <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)))
  (let ((kwd (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp x)
         (consp (cdr x))
         (symbolp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
         (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car x) <a class="sym-link local-def" href="#def-_2Aabbrev-rune-alist_2A" data-sym="*ABBREV-RUNE-ALIST*" title="(defconst *abbrev-rune-alist*
          &#39;((:d . :definition) (:e . :executable-counterpart) (:i . :induction)
            (:r . :rewrite) (:t . :type-prescription)))">*abbrev-rune-alist*</a>)))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (kwd (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> kwd
          (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
          (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> x)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x))))</pre>
  </div>

<div class="form-block function" id="def-rule-name-designatorp" data-defines="RULE-NAME-DESIGNATORP" data-references="BASE-SYMBOL,TRANSLATE-ABBREV-RUNE,LIST,RUNEP,FUNCTION-SYMBOLP,FN,LET*,CAR,CDR,NULL,CONSP,THEORY,EQ,NOT,AND,T,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,DEREF-MACRO-NAME,LET,SYMBOLP,COND,WRLD,MACRO-ALIASES,X,DEFUN" data-used-by="THEORYP1" data-part-name="RULE-NAME-DESIGNATORP" data-part-args="WRLD,MACRO-ALIASES,X" data-part-body="BASE-SYMBOL,TRANSLATE-ABBREV-RUNE,LIST,RUNEP,FUNCTION-SYMBOLP,FN,LET*,CAR,CDR,NULL,CONSP,THEORY,EQ,NOT,AND,T,WRLD,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,MACRO-ALIASES,DEREF-MACRO-NAME,LET,X,SYMBOLP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RULE-NAME-DESIGNATORP">rule-name-designatorp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rule-name-designatorp" data-sym="RULE-NAME-DESIGNATORP" title="(defun rule-name-designatorp (x macro-aliases wrld)
  (cond
   ((symbolp x)
    (let ((x (deref-macro-name x macro-aliases)))
      (cond ((getpropc x &#39;runic-mapping-pairs nil wrld) x)
...">rule-name-designatorp</a>
  (x <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp x) (let ((x (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> x <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> x 'runic-mapping-pairs nil wrld) x)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> x 'theory <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)) x)))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp x) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr x)) (symbolp (car x))) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> (car x) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> fn wrld)
          (<a class="sym-link local-def" href="#def-runep" data-sym="RUNEP" title="(defun runep (x wrld)
  (declare
   (xargs :guard
    (if (and (consp x) (consp (cdr x)) (symbolp (cadr x)))
        (and (plist-worldp wrld)
...">runep</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:executable-counterpart</span> fn) wrld)
          fn)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((x (<a class="sym-link local-def" href="#def-translate-abbrev-rune" data-sym="TRANSLATE-ABBREV-RUNE" title="(defun translate-abbrev-rune (x macro-aliases)
  (declare (xargs :guard (alistp macro-aliases)))
  (let ((kwd
         (and (consp x) (consp (cdr x)) (symbolp (cadr x))
              (cdr (assoc-eq (car x) *abbrev-rune-alist*)))))
...">translate-abbrev-rune</a> x <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-runep" data-sym="RUNEP" title="(defun runep (x wrld)
  (declare
   (xargs :guard
    (if (and (consp x) (consp (cdr x)) (symbolp (cadr x)))
        (and (plist-worldp wrld)
...">runep</a> x wrld) (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> x))))))</pre>
  </div>

<div class="form-block function" id="def-theoryp1" data-defines="THEORYP1" data-references="T,CDR,CAR,RULE-NAME-DESIGNATORP,NULL,ATOM,COND,WRLD,MACRO-ALIASES,LST,DEFUN" data-used-by="THEORYP" data-part-name="THEORYP1" data-part-args="WRLD,MACRO-ALIASES,LST" data-part-body="T,CDR,THEORYP1,WRLD,MACRO-ALIASES,CAR,RULE-NAME-DESIGNATORP,NULL,LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORYP1">theoryp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theoryp1" data-sym="THEORYP1" title="(defun theoryp1 (lst macro-aliases wrld)
  (cond ((atom lst) (null lst))
        ((rule-name-designatorp (car lst) macro-aliases wrld)
         (theoryp1 (cdr lst) macro-aliases wrld))
        (t nil)))">theoryp1</a>
  (lst <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> lst) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst))
    ((<a class="sym-link local-def" href="#def-rule-name-designatorp" data-sym="RULE-NAME-DESIGNATORP" title="(defun rule-name-designatorp (x macro-aliases wrld)
  (cond
   ((symbolp x)
    (let ((x (deref-macro-name x macro-aliases)))
      (cond ((getpropc x &#39;runic-mapping-pairs nil wrld) x)
...">rule-name-designatorp</a> (car lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld) (<a class="sym-link local-def" href="#def-theoryp1" data-sym="THEORYP1" title="(defun theoryp1 (lst macro-aliases wrld)
  (cond ((atom lst) (null lst))
        ((rule-name-designatorp (car lst) macro-aliases wrld)
         (theoryp1 (cdr lst) macro-aliases wrld))
        (t nil)))">theoryp1</a> (cdr lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-theoryp" data-defines="THEORYP" data-references="MACRO-ALIASES,THEORYP1,WRLD,LST,DEFUN" data-used-by="AUGMENT-THEORY" data-part-name="THEORYP" data-part-args="WRLD,LST" data-part-body="WRLD,MACRO-ALIASES,LST,THEORYP1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORYP">theoryp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theoryp" data-sym="THEORYP" title="(defun theoryp (lst wrld) (theoryp1 lst (macro-aliases wrld) wrld))">theoryp</a>
  (lst wrld)
  (<a class="sym-link local-def" href="#def-theoryp1" data-sym="THEORYP1" title="(defun theoryp1 (lst macro-aliases wrld)
  (cond ((atom lst) (null lst))
        ((rule-name-designatorp (car lst) macro-aliases wrld)
         (theoryp1 (cdr lst) macro-aliases wrld))
        (t nil)))">theoryp1</a> lst (<a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld) wrld))</pre>
  </div>

<div class="form-block function" id="def-runic-theoryp1" data-defines="RUNIC-THEORYP1" data-references="CDR,>,OR,AND,CAR,RUNEP,NUME,LET,T,NULL,ATOM,COND,WRLD,LST,PREV-NUME,DEFUN" data-used-by="RUNIC-THEORYP" data-part-name="RUNIC-THEORYP1" data-part-args="WRLD,LST,PREV-NUME" data-part-body="CDR,RUNIC-THEORYP1,>,PREV-NUME,OR,AND,WRLD,CAR,RUNEP,NUME,LET,T,NULL,LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RUNIC-THEORYP1">runic-theoryp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-runic-theoryp1" data-sym="RUNIC-THEORYP1" title="(defun runic-theoryp1 (prev-nume lst wrld)
  (cond ((atom lst) (null lst))
        (t
         (let ((nume (runep (car lst) wrld)))
           (cond
...">runic-theoryp1</a>
  (prev-nume lst wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> lst) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((nume (<a class="sym-link local-def" href="#def-runep" data-sym="RUNEP" title="(defun runep (x wrld)
  (declare
   (xargs :guard
    (if (and (consp x) (consp (cdr x)) (symbolp (cadr x)))
        (and (plist-worldp wrld)
...">runep</a> (car lst) wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> nume (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-nume) (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> prev-nume nume))) (<a class="sym-link local-def" href="#def-runic-theoryp1" data-sym="RUNIC-THEORYP1" title="(defun runic-theoryp1 (prev-nume lst wrld)
  (cond ((atom lst) (null lst))
        (t
         (let ((nume (runep (car lst) wrld)))
           (cond
...">runic-theoryp1</a> nume (cdr lst) wrld))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))))</pre>
  </div>

<div class="form-block function" id="def-runic-theoryp" data-defines="RUNIC-THEORYP" data-references="RUNIC-THEORYP1,WRLD,LST,DEFUN" data-used-by="RUNIC-THEORY,AUGMENT-THEORY" data-part-name="RUNIC-THEORYP" data-part-args="WRLD,LST" data-part-body="WRLD,LST,RUNIC-THEORYP1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RUNIC-THEORYP">runic-theoryp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-runic-theoryp" data-sym="RUNIC-THEORYP" title="(defun runic-theoryp (lst wrld) (runic-theoryp1 nil lst wrld))">runic-theoryp</a>
  (lst wrld)
  (<a class="sym-link local-def" href="#def-runic-theoryp1" data-sym="RUNIC-THEORYP1" title="(defun runic-theoryp1 (prev-nume lst wrld)
  (cond ((atom lst) (null lst))
        (t
         (let ((nume (runep (car lst) wrld)))
           (cond
...">runic-theoryp1</a> nil lst wrld))</pre>
  </div>

<div class="form-block function" id="def-find-mapping-pairs-tail1" data-defines="FIND-MAPPING-PAIRS-TAIL1" data-references="T,CAR,CDR,EQUAL,NULL,COND,MAPPING-PAIRS,RUNE,DEFUN" data-used-by="FIND-MAPPING-PAIRS-TAIL" data-part-name="FIND-MAPPING-PAIRS-TAIL1" data-part-args="MAPPING-PAIRS,RUNE" data-part-body="FIND-MAPPING-PAIRS-TAIL1,T,CAR,CDR,RUNE,EQUAL,MAPPING-PAIRS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-MAPPING-PAIRS-TAIL1">find-mapping-pairs-tail1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-mapping-pairs-tail1" data-sym="FIND-MAPPING-PAIRS-TAIL1" title="(defun find-mapping-pairs-tail1 (rune mapping-pairs)
  (cond ((null mapping-pairs) nil)
        ((equal rune (cdr (car mapping-pairs))) mapping-pairs)
        (t (find-mapping-pairs-tail1 rune (cdr mapping-pairs)))))">find-mapping-pairs-tail1</a>
  (rune mapping-pairs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> mapping-pairs) nil)
    ((equal rune (cdr (car mapping-pairs))) mapping-pairs)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-mapping-pairs-tail1" data-sym="FIND-MAPPING-PAIRS-TAIL1" title="(defun find-mapping-pairs-tail1 (rune mapping-pairs)
  (cond ((null mapping-pairs) nil)
        ((equal rune (cdr (car mapping-pairs))) mapping-pairs)
        (t (find-mapping-pairs-tail1 rune (cdr mapping-pairs)))))">find-mapping-pairs-tail1</a> rune (cdr mapping-pairs)))))</pre>
  </div>

<div class="form-block function" id="def-find-mapping-pairs-tail" data-defines="FIND-MAPPING-PAIRS-TAIL" data-references="RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,T,FIND-MAPPING-PAIRS-TAIL1,CAR,CDR,CADR,BASE-SYMBOL,EQ,AND,COND,WRLD,MAPPING-PAIRS,RUNE,DEFUN" data-used-by="AUGMENT-RUNIC-THEORY1" data-part-name="FIND-MAPPING-PAIRS-TAIL" data-part-args="WRLD,MAPPING-PAIRS,RUNE" data-part-body="WRLD,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,T,FIND-MAPPING-PAIRS-TAIL1,CAR,CDR,CADR,RUNE,BASE-SYMBOL,EQ,MAPPING-PAIRS,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-MAPPING-PAIRS-TAIL">find-mapping-pairs-tail</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-mapping-pairs-tail" data-sym="FIND-MAPPING-PAIRS-TAIL" title="(defun find-mapping-pairs-tail (rune mapping-pairs wrld)
  (cond
   ((and mapping-pairs
         (eq (base-symbol rune) (cadr (cdr (car mapping-pairs)))))
    (find-mapping-pairs-tail1 rune mapping-pairs))
...">find-mapping-pairs-tail</a>
  (rune mapping-pairs wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> mapping-pairs
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (cdr (car mapping-pairs))))) (<a class="sym-link local-def" href="#def-find-mapping-pairs-tail1" data-sym="FIND-MAPPING-PAIRS-TAIL1" title="(defun find-mapping-pairs-tail1 (rune mapping-pairs)
  (cond ((null mapping-pairs) nil)
        ((equal rune (cdr (car mapping-pairs))) mapping-pairs)
        (t (find-mapping-pairs-tail1 rune (cdr mapping-pairs)))))">find-mapping-pairs-tail1</a> rune mapping-pairs))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-mapping-pairs-tail1" data-sym="FIND-MAPPING-PAIRS-TAIL1" title="(defun find-mapping-pairs-tail1 (rune mapping-pairs)
  (cond ((null mapping-pairs) nil)
        ((equal rune (cdr (car mapping-pairs))) mapping-pairs)
        (t (find-mapping-pairs-tail1 rune (cdr mapping-pairs)))))">find-mapping-pairs-tail1</a> rune
        (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) 'runic-mapping-pairs nil wrld)))))</pre>
  </div>

<div class="form-block function" id="def-augment-runic-theory1" data-defines="AUGMENT-RUNIC-THEORY1" data-references="CONS,CDR,CAR,FIND-MAPPING-PAIRS-TAIL,LET,T,NULL,COND,ANS,WRLD,MAPPING-PAIRS,LST,DEFUN" data-used-by="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1,AUGMENT-RUNIC-THEORY" data-part-name="AUGMENT-RUNIC-THEORY1" data-part-args="ANS,WRLD,MAPPING-PAIRS,LST" data-part-body="CONS,CDR,AUGMENT-RUNIC-THEORY1,WRLD,CAR,FIND-MAPPING-PAIRS-TAIL,MAPPING-PAIRS,LET,T,ANS,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="AUGMENT-RUNIC-THEORY1">augment-runic-theory1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-augment-runic-theory1" data-sym="AUGMENT-RUNIC-THEORY1" title="(defun augment-runic-theory1 (lst mapping-pairs wrld ans)
  (cond ((null lst) ans)
        (t
         (let ((mapping-pairs
                (find-mapping-pairs-tail (car lst) mapping-pairs wrld)))
...">augment-runic-theory1</a>
  (lst mapping-pairs wrld ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((mapping-pairs (<a class="sym-link local-def" href="#def-find-mapping-pairs-tail" data-sym="FIND-MAPPING-PAIRS-TAIL" title="(defun find-mapping-pairs-tail (rune mapping-pairs wrld)
  (cond
   ((and mapping-pairs
         (eq (base-symbol rune) (cadr (cdr (car mapping-pairs)))))
    (find-mapping-pairs-tail1 rune mapping-pairs))
...">find-mapping-pairs-tail</a> (car lst) mapping-pairs wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (mapping-pairs (<a class="sym-link local-def" href="#def-augment-runic-theory1" data-sym="AUGMENT-RUNIC-THEORY1" title="(defun augment-runic-theory1 (lst mapping-pairs wrld ans)
  (cond ((null lst) ans)
        (t
         (let ((mapping-pairs
                (find-mapping-pairs-tail (car lst) mapping-pairs wrld)))
...">augment-runic-theory1</a> (cdr lst)
              (cdr mapping-pairs)
              wrld
              (cons (car mapping-pairs) ans)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-augment-runic-theory1" data-sym="AUGMENT-RUNIC-THEORY1" title="(defun augment-runic-theory1 (lst mapping-pairs wrld ans)
  (cond ((null lst) ans)
        (t
         (let ((mapping-pairs
                (find-mapping-pairs-tail (car lst) mapping-pairs wrld)))
...">augment-runic-theory1</a> (cdr lst) mapping-pairs wrld ans)))))))</pre>
  </div>

<div class="form-block function" id="def-augment-runic-theory" data-defines="AUGMENT-RUNIC-THEORY" data-references="REVERSE,AUGMENT-RUNIC-THEORY1,WRLD,LST,DEFUN" data-used-by="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1,AUGMENT-THEORY" data-part-name="AUGMENT-RUNIC-THEORY" data-part-args="WRLD,LST" data-part-body="WRLD,LST,REVERSE,AUGMENT-RUNIC-THEORY1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="AUGMENT-RUNIC-THEORY">augment-runic-theory</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-augment-runic-theory" data-sym="AUGMENT-RUNIC-THEORY" title="(defun augment-runic-theory (lst wrld)
  (augment-runic-theory1 (reverse lst) nil wrld nil))">augment-runic-theory</a>
  (lst wrld)
  (<a class="sym-link local-def" href="#def-augment-runic-theory1" data-sym="AUGMENT-RUNIC-THEORY1" title="(defun augment-runic-theory1 (lst mapping-pairs wrld ans)
  (cond ((null lst) ans)
        (t
         (let ((mapping-pairs
                (find-mapping-pairs-tail (car lst) mapping-pairs wrld)))
...">augment-runic-theory1</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> lst) nil wrld nil))</pre>
  </div>

<div class="form-block constant" id="def-_2Abad-runic-designator-string_2A" data-defines="*BAD-RUNIC-DESIGNATOR-STRING*" data-references="DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*BAD-RUNIC-DESIGNATOR-STRING*">*bad-runic-designator-string*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Abad-runic-designator-string_2A" data-sym="*BAD-RUNIC-DESIGNATOR-STRING*" title="(defconst *bad-runic-designator-string*
          &quot;This symbol was expected to be suitable for theory expressions; see :DOC ~
   theories, in particular the discussion of runic designators.  One possible ~
   source of this problem is an attempt to include an uncertified book with a ~
   deftheory event that attempts to use the above symbol in a deftheory event.&quot;)">*bad-runic-designator-string*</a>
  <span class="string">"This symbol was expected to be suitable for theory expressions; see :DOC ~
   theories, in particular the discussion of runic designators.  One possible ~
   source of this problem is an attempt to include an uncertified book with a ~
   deftheory event that attempts to use the above symbol in a deftheory event."</span>)</pre>
  </div>

<div class="form-block function" id="def-convert-theory-to-unordered-mapping-pairs1" data-defines="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" data-references="TRANSLATE-ABBREV-RUNE,FRUNIC-MAPPING-PAIR,QUASIQUOTE,THEORY,REVERSE,AUGMENT-RUNIC-THEORY1,T,REVAPPEND,CADDDR,CONS,LENGTH,EQUAL,IF,CADR,CDR,EQ,AND,RUNIC-MAPPING-PAIRS,QUOTE,DEREF-MACRO-NAME,GETPROPC,TEMP,LET,CAR,SYMBOLP,NULL,COND,ANS,WRLD,MACRO-ALIASES,LST,DEFUN" data-used-by="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" data-part-name="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" data-part-args="ANS,WRLD,MACRO-ALIASES,LST" data-part-body="TRANSLATE-ABBREV-RUNE,FRUNIC-MAPPING-PAIR,QUASIQUOTE,THEORY,REVERSE,AUGMENT-RUNIC-THEORY1,T,REVAPPEND,CADDDR,CONS,LENGTH,EQUAL,IF,CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1,CADR,CDR,EQ,AND,WRLD,RUNIC-MAPPING-PAIRS,QUOTE,MACRO-ALIASES,DEREF-MACRO-NAME,GETPROPC,TEMP,LET,CAR,SYMBOLP,ANS,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1">convert-theory-to-unordered-mapping-pairs1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a>
  (lst <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) ans)
    ((symbolp (car lst)) (let ((temp (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> (car lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
             'runic-mapping-pairs
             nil
             wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp
             (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (cdr (car temp))) <span class="keyword">:definition</span>)
             (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (cdr (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp))) <span class="keyword">:executable-counterpart</span>)) (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> (cdr lst)
              <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>
              wrld
              (if (equal (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> temp) <span class="number">4</span>)
                (cons (car temp) (cons (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> temp) ans))
                (cons (car temp) ans))))
          (temp (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> (cdr lst)
              <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>
              wrld
              (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> temp ans)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> (cdr lst)
              <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>
              wrld
              (<a class="sym-link local-def" href="#def-augment-runic-theory1" data-sym="AUGMENT-RUNIC-THEORY1" title="(defun augment-runic-theory1 (lst mapping-pairs wrld ans)
  (cond ((null lst) ans)
        (t
         (let ((mapping-pairs
                (find-mapping-pairs-tail (car lst) mapping-pairs wrld)))
...">augment-runic-theory1</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (car lst)
                    'theory
                    `(<span class="keyword">:error</span> ,*BAD-RUNIC-DESIGNATOR-STRING*)
                    wrld))
                nil
                wrld
                ans))))))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr (car lst))) (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> (cdr lst)
        <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>
        wrld
        (cons (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-deref-macro-name" data-sym="DEREF-MACRO-NAME">deref-macro-name</a> (car (car lst)) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
              'runic-mapping-pairs
              `(<span class="keyword">:error</span> ,*BAD-RUNIC-DESIGNATOR-STRING*)
              wrld))
          ans)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> (cdr lst)
        <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>
        wrld
        (cons (<a class="sym-link local-def" href="#def-frunic-mapping-pair" data-sym="FRUNIC-MAPPING-PAIR" title="(defun frunic-mapping-pair (rune wrld)
  (assoc-equal-cdr rune
                   (getpropc (base-symbol rune) &#39;runic-mapping-pairs nil wrld)))">frunic-mapping-pair</a> (<a class="sym-link local-def" href="#def-translate-abbrev-rune" data-sym="TRANSLATE-ABBREV-RUNE" title="(defun translate-abbrev-rune (x macro-aliases)
  (declare (xargs :guard (alistp macro-aliases)))
  (let ((kwd
         (and (consp x) (consp (cdr x)) (symbolp (cadr x))
              (cdr (assoc-eq (car x) *abbrev-rune-alist*)))))
...">translate-abbrev-rune</a> (car lst) <a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a>)
            wrld)
          ans)))))</pre>
  </div>

<div class="form-block function" id="def-convert-theory-to-unordered-mapping-pairs" data-defines="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" data-references="MACRO-ALIASES,CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1,WRLD,LST,DEFUN" data-used-by="RUNIC-THEORY,AUGMENT-THEORY" data-part-name="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" data-part-args="WRLD,LST" data-part-body="WRLD,MACRO-ALIASES,LST,CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS">convert-theory-to-unordered-mapping-pairs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" title="(defun convert-theory-to-unordered-mapping-pairs (lst wrld)
  (convert-theory-to-unordered-mapping-pairs1 lst (macro-aliases wrld) wrld
                                              nil))">convert-theory-to-unordered-mapping-pairs</a>
  (lst wrld)
  (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs1" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS1" title="(defun convert-theory-to-unordered-mapping-pairs1 (lst macro-aliases wrld ans)
  (cond ((null lst) ans)
        ((symbolp (car lst))
         (let ((temp
                (getpropc (deref-macro-name (car lst) macro-aliases)
...">convert-theory-to-unordered-mapping-pairs1</a> lst
    (<a class="sym-link system" href="axioms.html#def-macro-aliases" data-sym="MACRO-ALIASES">macro-aliases</a> wrld)
    wrld
    nil))</pre>
  </div>

<div class="form-block function" id="def-duplicitous-cons-car" data-defines="DUPLICITOUS-CONS-CAR" data-references="CONS,T,CAAR,CAR,EQUAL,COND,Y,X,DEFUN" data-used-by="DUPLICITOUS-MERGE-CAR,DUPLICITOUS-REVAPPEND-CAR" data-part-name="DUPLICITOUS-CONS-CAR" data-part-args="Y,X" data-part-body="CONS,T,Y,CAAR,X,CAR,EQUAL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICITOUS-CONS-CAR">duplicitous-cons-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicitous-cons-car" data-sym="DUPLICITOUS-CONS-CAR" title="(defun duplicitous-cons-car (x y)
  (cond ((equal (car x) (caar y)) y) (t (cons x y))))">duplicitous-cons-car</a>
  (x y)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (car x) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> y)) y) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons x y))))</pre>
  </div>

<div class="form-block function" id="def-duplicitous-revappend-car" data-defines="DUPLICITOUS-REVAPPEND-CAR" data-references="CAR,DUPLICITOUS-CONS-CAR,CDR,T,NULL,COND,ANS,LST,DEFUN" data-used-by="DUPLICITOUS-MERGE-CAR" data-part-name="DUPLICITOUS-REVAPPEND-CAR" data-part-args="ANS,LST" data-part-body="CAR,DUPLICITOUS-CONS-CAR,CDR,DUPLICITOUS-REVAPPEND-CAR,T,ANS,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICITOUS-REVAPPEND-CAR">duplicitous-revappend-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicitous-revappend-car" data-sym="DUPLICITOUS-REVAPPEND-CAR" title="(defun duplicitous-revappend-car (lst ans)
  (cond ((null lst) ans)
        (t
         (duplicitous-revappend-car (cdr lst)
                                    (duplicitous-cons-car (car lst) ans)))))">duplicitous-revappend-car</a>
  (lst ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicitous-revappend-car" data-sym="DUPLICITOUS-REVAPPEND-CAR" title="(defun duplicitous-revappend-car (lst ans)
  (cond ((null lst) ans)
        (t
         (duplicitous-revappend-car (cdr lst)
                                    (duplicitous-cons-car (car lst) ans)))))">duplicitous-revappend-car</a> (cdr lst)
        (<a class="sym-link local-def" href="#def-duplicitous-cons-car" data-sym="DUPLICITOUS-CONS-CAR" title="(defun duplicitous-cons-car (x y)
  (cond ((equal (car x) (caar y)) y) (t (cons x y))))">duplicitous-cons-car</a> (car lst) ans)))))</pre>
  </div>

<div class="form-block function" id="def-duplicitous-merge-car" data-defines="DUPLICITOUS-MERGE-CAR" data-references="T,DUPLICITOUS-CONS-CAR,CDR,<,CAR,>,IF,DUPLICITOUS-REVAPPEND-CAR,NULL,COND,ANS,LST2,LST1,PARITY,DEFUN" data-used-by="DUPLICITOUS-SORT-CAR" data-part-name="DUPLICITOUS-MERGE-CAR" data-part-args="ANS,LST2,LST1,PARITY" data-part-body="T,DUPLICITOUS-CONS-CAR,CDR,DUPLICITOUS-MERGE-CAR,<,CAR,>,PARITY,IF,ANS,LST2,DUPLICITOUS-REVAPPEND-CAR,LST1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICITOUS-MERGE-CAR">duplicitous-merge-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicitous-merge-car" data-sym="DUPLICITOUS-MERGE-CAR" title="(defun duplicitous-merge-car (parity lst1 lst2 ans)
  (cond ((null lst1) (duplicitous-revappend-car lst2 ans))
        ((null lst2) (duplicitous-revappend-car lst1 ans))
        ((if parity
             (&gt; (car (car lst1)) (car (car lst2)))
...">duplicitous-merge-car</a>
  (parity lst1 lst2 ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst1) (<a class="sym-link local-def" href="#def-duplicitous-revappend-car" data-sym="DUPLICITOUS-REVAPPEND-CAR" title="(defun duplicitous-revappend-car (lst ans)
  (cond ((null lst) ans)
        (t
         (duplicitous-revappend-car (cdr lst)
                                    (duplicitous-cons-car (car lst) ans)))))">duplicitous-revappend-car</a> lst2 ans))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst2) (<a class="sym-link local-def" href="#def-duplicitous-revappend-car" data-sym="DUPLICITOUS-REVAPPEND-CAR" title="(defun duplicitous-revappend-car (lst ans)
  (cond ((null lst) ans)
        (t
         (duplicitous-revappend-car (cdr lst)
                                    (duplicitous-cons-car (car lst) ans)))))">duplicitous-revappend-car</a> lst1 ans))
    ((if parity
       (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (car (car lst1)) (car (car lst2)))
       (&lt; (car (car lst1)) (car (car lst2)))) (<a class="sym-link local-def" href="#def-duplicitous-merge-car" data-sym="DUPLICITOUS-MERGE-CAR" title="(defun duplicitous-merge-car (parity lst1 lst2 ans)
  (cond ((null lst1) (duplicitous-revappend-car lst2 ans))
        ((null lst2) (duplicitous-revappend-car lst1 ans))
        ((if parity
             (&gt; (car (car lst1)) (car (car lst2)))
...">duplicitous-merge-car</a> parity
        (cdr lst1)
        lst2
        (<a class="sym-link local-def" href="#def-duplicitous-cons-car" data-sym="DUPLICITOUS-CONS-CAR" title="(defun duplicitous-cons-car (x y)
  (cond ((equal (car x) (caar y)) y) (t (cons x y))))">duplicitous-cons-car</a> (car lst1) ans)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicitous-merge-car" data-sym="DUPLICITOUS-MERGE-CAR" title="(defun duplicitous-merge-car (parity lst1 lst2 ans)
  (cond ((null lst1) (duplicitous-revappend-car lst2 ans))
        ((null lst2) (duplicitous-revappend-car lst1 ans))
        ((if parity
             (&gt; (car (car lst1)) (car (car lst2)))
...">duplicitous-merge-car</a> parity
        lst1
        (cdr lst2)
        (<a class="sym-link local-def" href="#def-duplicitous-cons-car" data-sym="DUPLICITOUS-CONS-CAR" title="(defun duplicitous-cons-car (x y)
  (cond ((equal (car x) (caar y)) y) (t (cons x y))))">duplicitous-cons-car</a> (car lst2) ans)))))</pre>
  </div>

<div class="form-block function" id="def-duplicitous-sort-car" data-defines="DUPLICITOUS-SORT-CAR" data-references="ODDS,EVENS,NOT,DUPLICITOUS-MERGE-CAR,T,CDR,NULL,COND,LST,PARITY,DEFUN" data-used-by="RUNIC-THEORY,AUGMENT-THEORY" data-part-name="DUPLICITOUS-SORT-CAR" data-part-args="LST,PARITY" data-part-body="ODDS,EVENS,NOT,DUPLICITOUS-SORT-CAR,PARITY,DUPLICITOUS-MERGE-CAR,T,LST,CDR,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICITOUS-SORT-CAR">duplicitous-sort-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicitous-sort-car" data-sym="DUPLICITOUS-SORT-CAR" title="(defun duplicitous-sort-car (parity lst)
  (cond ((null (cdr lst)) lst)
        (t
         (duplicitous-merge-car parity
                                (duplicitous-sort-car (not parity) (evens lst))
...">duplicitous-sort-car</a>
  (parity lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr lst)) lst)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicitous-merge-car" data-sym="DUPLICITOUS-MERGE-CAR" title="(defun duplicitous-merge-car (parity lst1 lst2 ans)
  (cond ((null lst1) (duplicitous-revappend-car lst2 ans))
        ((null lst2) (duplicitous-revappend-car lst1 ans))
        ((if parity
             (&gt; (car (car lst1)) (car (car lst2)))
...">duplicitous-merge-car</a> parity
        (<a class="sym-link local-def" href="#def-duplicitous-sort-car" data-sym="DUPLICITOUS-SORT-CAR" title="(defun duplicitous-sort-car (parity lst)
  (cond ((null (cdr lst)) lst)
        (t
         (duplicitous-merge-car parity
                                (duplicitous-sort-car (not parity) (evens lst))
...">duplicitous-sort-car</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> parity) (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> lst))
        (<a class="sym-link local-def" href="#def-duplicitous-sort-car" data-sym="DUPLICITOUS-SORT-CAR" title="(defun duplicitous-sort-car (parity lst)
  (cond ((null (cdr lst)) lst)
        (t
         (duplicitous-merge-car parity
                                (duplicitous-sort-car (not parity) (evens lst))
...">duplicitous-sort-car</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> parity) (<a class="sym-link system" href="axioms.html#def-odds" data-sym="ODDS">odds</a> lst))
        nil))))</pre>
  </div>

<div class="form-block function" id="def-augment-theory" data-defines="AUGMENT-THEORY" data-references="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS,DUPLICITOUS-SORT-CAR,T,AUGMENT-RUNIC-THEORY,RUNIC-THEORYP,COND,THEORYP,XARGS,DECLARE,WRLD,LST,DEFUN" data-part-name="AUGMENT-THEORY" data-part-args="WRLD,LST" data-part-declare="WRLD,LST,THEORYP,XARGS,DECLARE" data-part-body="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS,DUPLICITOUS-SORT-CAR,T,AUGMENT-RUNIC-THEORY,WRLD,LST,RUNIC-THEORYP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="AUGMENT-THEORY">augment-theory</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-augment-theory" data-sym="AUGMENT-THEORY" title="(defun augment-theory (lst wrld)
  (declare (xargs :guard (theoryp lst wrld)))
  (cond ((runic-theoryp lst wrld) (augment-runic-theory lst wrld))
        (t
         (duplicitous-sort-car nil
...">augment-theory</a>
  (lst wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-theoryp" data-sym="THEORYP" title="(defun theoryp (lst wrld) (theoryp1 lst (macro-aliases wrld) wrld))">theoryp</a> lst wrld)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-runic-theoryp" data-sym="RUNIC-THEORYP" title="(defun runic-theoryp (lst wrld) (runic-theoryp1 nil lst wrld))">runic-theoryp</a> lst wrld) (<a class="sym-link local-def" href="#def-augment-runic-theory" data-sym="AUGMENT-RUNIC-THEORY" title="(defun augment-runic-theory (lst wrld)
  (augment-runic-theory1 (reverse lst) nil wrld nil))">augment-runic-theory</a> lst wrld))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicitous-sort-car" data-sym="DUPLICITOUS-SORT-CAR" title="(defun duplicitous-sort-car (parity lst)
  (cond ((null (cdr lst)) lst)
        (t
         (duplicitous-merge-car parity
                                (duplicitous-sort-car (not parity) (evens lst))
...">duplicitous-sort-car</a> nil
        (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" title="(defun convert-theory-to-unordered-mapping-pairs (lst wrld)
  (convert-theory-to-unordered-mapping-pairs1 lst (macro-aliases wrld) wrld
                                              nil))">convert-theory-to-unordered-mapping-pairs</a> lst wrld)))))</pre>
  </div>

<div class="form-block macro" id="def-assert_24-runic-theoryp" data-defines="ASSERT$-RUNIC-THEORYP" data-references="IGNORE,DECLARE,WRLD,RUNIC-THEORY-EXPR,DEFMACRO" data-used-by="RUNIC-THEORY" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSERT$-RUNIC-THEORYP">assert$-runic-theoryp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-assert_24-runic-theoryp" data-sym="ASSERT$-RUNIC-THEORYP" title="(defmacro assert$-runic-theoryp (runic-theory-expr wrld)
  (declare (ignore wrld))
  runic-theory-expr)">assert$-runic-theoryp</a>
  (runic-theory-expr wrld)
  (declare (ignore wrld))
  runic-theory-expr)</pre>
  </div>

<div class="form-block function" id="def-runic-theory" data-defines="RUNIC-THEORY" data-references="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS,DUPLICITOUS-SORT-CAR,STRIP-CDRS,ASSERT$-RUNIC-THEORYP,T,RUNIC-THEORYP,COND,WRLD,LST,DEFUN" data-part-name="RUNIC-THEORY" data-part-args="WRLD,LST" data-part-body="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS,DUPLICITOUS-SORT-CAR,STRIP-CDRS,ASSERT$-RUNIC-THEORYP,T,WRLD,LST,RUNIC-THEORYP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RUNIC-THEORY">runic-theory</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-runic-theory" data-sym="RUNIC-THEORY" title="(defun runic-theory (lst wrld)
  (cond ((runic-theoryp lst wrld) lst)
        (t
         (assert$-runic-theoryp
          (strip-cdrs
...">runic-theory</a>
  (lst wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-runic-theoryp" data-sym="RUNIC-THEORYP" title="(defun runic-theoryp (lst wrld) (runic-theoryp1 nil lst wrld))">runic-theoryp</a> lst wrld) lst)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assert_24-runic-theoryp" data-sym="ASSERT$-RUNIC-THEORYP" title="(defmacro assert$-runic-theoryp (runic-theory-expr wrld)
  (declare (ignore wrld))
  runic-theory-expr)">assert$-runic-theoryp</a> (<a class="sym-link system" href="axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> (<a class="sym-link local-def" href="#def-duplicitous-sort-car" data-sym="DUPLICITOUS-SORT-CAR" title="(defun duplicitous-sort-car (parity lst)
  (cond ((null (cdr lst)) lst)
        (t
         (duplicitous-merge-car parity
                                (duplicitous-sort-car (not parity) (evens lst))
...">duplicitous-sort-car</a> nil
            (<a class="sym-link local-def" href="#def-convert-theory-to-unordered-mapping-pairs" data-sym="CONVERT-THEORY-TO-UNORDERED-MAPPING-PAIRS" title="(defun convert-theory-to-unordered-mapping-pairs (lst wrld)
  (convert-theory-to-unordered-mapping-pairs1 lst (macro-aliases wrld) wrld
                                              nil))">convert-theory-to-unordered-mapping-pairs</a> lst wrld)))
        wrld))))</pre>
  </div>

<div class="form-block other" id="form-39" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> enabled-structure
  ((index-of-last-enabling . theory-array) (array-name . array-length)
    array-name-root . array-name-suffix)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-enabled-structure-p" data-defines="ENABLED-STRUCTURE-P" data-references="DIMENSIONS,CAR,EQUAL,NATP,CHARACTER-LISTP,<,*FIXNUM-BITS*,SIGNED-BYTE-P,SYMBOLP,ENABLED-STRUCTURE,ACCESS,ARRAY1P,WEAK-ENABLED-STRUCTURE-P,AND,T,XARGS,DECLARE,ENS,DEFUN" data-used-by="ENABLED-RUNEP,ENABLED-NUMEP" data-part-name="ENABLED-STRUCTURE-P" data-part-args="ENS" data-part-declare="T,XARGS,DECLARE" data-part-body="DIMENSIONS,CAR,EQUAL,NATP,CHARACTER-LISTP,<,*FIXNUM-BITS*,SIGNED-BYTE-P,SYMBOLP,ENABLED-STRUCTURE,ACCESS,ARRAY1P,ENS,WEAK-ENABLED-STRUCTURE-P,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-STRUCTURE-P">enabled-structure-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-structure-p" data-sym="ENABLED-STRUCTURE-P" title="(defun enabled-structure-p (ens)
  (declare (xargs :guard t))
  (and (weak-enabled-structure-p ens)
       (array1p (access enabled-structure ens :array-name)
                (access enabled-structure ens :theory-array))
...">enabled-structure-p</a>
  (<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (weak-enabled-structure-p <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
    (<a class="sym-link system" href="axioms.html#def-array1p" data-sym="ARRAY1P">array1p</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>)
      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:theory-array</span>))
    (symbolp (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>))
    (<a class="sym-link system" href="axioms.html#def-signed-byte-p" data-sym="SIGNED-BYTE-P">signed-byte-p</a> <a class="sym-link system" href="axioms.html#def-_2Afixnum-bits_2A" data-sym="*FIXNUM-BITS*">*fixnum-bits*</a>
      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-length</span>))
    (<a class="sym-link system" href="axioms.html#def-signed-byte-p" data-sym="SIGNED-BYTE-P">signed-byte-p</a> <a class="sym-link system" href="axioms.html#def-_2Afixnum-bits_2A" data-sym="*FIXNUM-BITS*">*fixnum-bits*</a>
      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:index-of-last-enabling</span>))
    (&lt; (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:index-of-last-enabling</span>)
      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-length</span>))
    (<a class="sym-link system" href="axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name-root</span>))
    (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name-suffix</span>))
    (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-length</span>)
      (car (<a class="sym-link system" href="axioms.html#def-dimensions" data-sym="DIMENSIONS">dimensions</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>)
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:theory-array</span>))))))</pre>
  </div>

<div class="form-block function" id="def-enabled-numep" data-defines="ENABLED-NUMEP" data-references="THE-FIXNAT,AREF1,ENABLED-STRUCTURE,ACCESS,THE-FIXNUM,>,T,COND,ENABLED-STRUCTURE-P,XARGS,UNSIGNED-BYTE,NULL,OR,TYPE,DECLARE,ENS,NUME,DEFUN" data-used-by="OK-TO-FORCE-ENS,TYPE-SET-REC,MOST-RECENT-ENABLED-RECOG-TUPLE1,IMMEDIATE-FORCEP,ENABLED-XFNP,ACTIVE-OR-NON-RUNEP,ACTIVE-RUNEP,ENABLED-RUNEP" data-part-name="ENABLED-NUMEP" data-part-args="ENS,NUME" data-part-declare="ENS,ENABLED-STRUCTURE-P,XARGS,NUME,UNSIGNED-BYTE,NULL,OR,TYPE,DECLARE" data-part-body="THE-FIXNAT,AREF1,ENS,ENABLED-STRUCTURE,ACCESS,THE-FIXNUM,>,T,NUME,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-NUMEP">enabled-numep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a>
  (nume <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (declare (type (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (unsigned-byte <span class="number">60</span>)) nume)
    (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-enabled-structure-p" data-sym="ENABLED-STRUCTURE-P" title="(defun enabled-structure-p (ens)
  (declare (xargs :guard t))
  (and (weak-enabled-structure-p ens)
       (array1p (access enabled-structure ens :array-name)
                (access enabled-structure ens :theory-array))
...">enabled-structure-p</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> nume) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> nume
       (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:index-of-last-enabling</span>))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-aref1" data-sym="AREF1">aref1</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:theory-array</span>)
        (<a class="sym-link system" href="axioms.html#def-the-fixnat" data-sym="THE-FIXNAT">the-fixnat</a> nume)))))</pre>
  </div>

<div class="form-block function" id="def-enabled-arith-numep" data-defines="ENABLED-ARITH-NUMEP" data-references="AREF1,ENABLED-STRUCTURE,ACCESS,THE-FIXNUM,THE-FIXNAT,>,T,NULL,COND,ENS,NUME,DEFUN" data-part-name="ENABLED-ARITH-NUMEP" data-part-args="ENS,NUME" data-part-body="AREF1,ENS,ENABLED-STRUCTURE,ACCESS,THE-FIXNUM,THE-FIXNAT,>,T,NUME,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-ARITH-NUMEP">enabled-arith-numep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-arith-numep" data-sym="ENABLED-ARITH-NUMEP" title="(defun enabled-arith-numep (nume ens)
  (cond ((null nume) t)
        ((&gt; (the-fixnat nume)
            (the-fixnum
             (access enabled-structure ens :index-of-last-enabling)))
...">enabled-arith-numep</a>
  (nume <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> nume) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="axioms.html#def-the-fixnat" data-sym="THE-FIXNAT">the-fixnat</a> nume)
       (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:index-of-last-enabling</span>))) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-aref1" data-sym="AREF1">aref1</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:theory-array</span>)
        (<a class="sym-link system" href="axioms.html#def-the-fixnat" data-sym="THE-FIXNAT">the-fixnat</a> nume)))))</pre>
  </div>

<div class="form-block function" id="def-enabled-runep" data-defines="ENABLED-RUNEP" data-references="FNUME,ENABLED-NUMEP,T,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,FIXNAT-ALISTP,ENABLED-STRUCTURE-P,BASE-SYMBOL,SYMBOLP,CDR,CONSP,PLIST-WORLDP,AND,XARGS,DECLARE,WRLD,ENS,RUNE,DEFUN" data-part-name="ENABLED-RUNEP" data-part-args="WRLD,ENS,RUNE" data-part-declare="T,RUNIC-MAPPING-PAIRS,QUOTE,GETPROPC,FIXNAT-ALISTP,ENS,ENABLED-STRUCTURE-P,BASE-SYMBOL,SYMBOLP,CDR,RUNE,CONSP,WRLD,PLIST-WORLDP,AND,XARGS,DECLARE" data-part-body="ENS,WRLD,RUNE,FNUME,ENABLED-NUMEP" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-RUNEP">enabled-runep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-runep" data-sym="ENABLED-RUNEP" title="(defun enabled-runep (rune ens wrld)
  (declare
   (xargs :guard
    (and (plist-worldp wrld) (consp rune) (consp (cdr rune))
         (symbolp (base-symbol rune)) (enabled-structure-p ens)
...">enabled-runep</a>
  (rune <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)
        (consp rune)
        (consp (cdr rune))
        (symbolp (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune))
        (<a class="sym-link local-def" href="#def-enabled-structure-p" data-sym="ENABLED-STRUCTURE-P" title="(defun enabled-structure-p (ens)
  (declare (xargs :guard t))
  (and (weak-enabled-structure-p ens)
       (array1p (access enabled-structure ens :array-name)
                (access enabled-structure ens :theory-array))
...">enabled-structure-p</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
        (<a class="sym-link system" href="axioms.html#def-fixnat-alistp" data-sym="FIXNAT-ALISTP">fixnat-alistp</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link local-def" href="#def-base-symbol" data-sym="BASE-SYMBOL" title="(defmacro base-symbol (rune) `(cadr ,rune))">base-symbol</a> rune) 'runic-mapping-pairs nil wrld)))
      <span class="keyword">:guard-hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:do-not-induct</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))
  (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> (<a class="sym-link local-def" href="#def-fnume" data-sym="FNUME" title="(defun fnume (rune wrld)
  (declare
   (xargs :guard
    (and (plist-worldp wrld) (consp rune) (consp (cdr rune))
         (symbolp (base-symbol rune))
...">fnume</a> rune wrld) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))</pre>
  </div>

<div class="form-block macro" id="def-active-runep" data-defines="ACTIVE-RUNEP" data-references="ENS,ENABLED-NUMEP,STATE,W,FNUME,CADR,SYMBOLP,CDR,CONSP,AND,NUME,LET*,QUASIQUOTE,RUNE,DEFMACRO" data-used-by="THEORY-INVARIANT-MSG,THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST,ENABLED-DISABLED-RUNEPS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTIVE-RUNEP">active-runep</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-active-runep" data-sym="ACTIVE-RUNEP" title="(defmacro active-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-runep</a>
  (rune)
  `(<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rune ,RUNE) (nume (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp rune)
          (consp (cdr rune))
          (symbolp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> rune))
          (<a class="sym-link local-def" href="#def-fnume" data-sym="FNUME" title="(defun fnume (rune wrld)
  (declare
   (xargs :guard
    (and (plist-worldp wrld) (consp rune) (consp (cdr rune))
         (symbolp (base-symbol rune))
...">fnume</a> rune (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)))))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> nume (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> nume <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block macro" id="def-active-or-non-runep" data-defines="ACTIVE-OR-NON-RUNEP" data-references="ENS,ENABLED-NUMEP,NOT,OR,STATE,W,FNUME,CADR,SYMBOLP,CDR,CONSP,AND,NUME,LET*,QUASIQUOTE,RUNE,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTIVE-OR-NON-RUNEP">active-or-non-runep</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-active-or-non-runep" data-sym="ACTIVE-OR-NON-RUNEP" title="(defmacro active-or-non-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-or-non-runep</a>
  (rune)
  `(<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rune ,RUNE) (nume (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp rune)
          (consp (cdr rune))
          (symbolp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> rune))
          (<a class="sym-link local-def" href="#def-fnume" data-sym="FNUME" title="(defun fnume (rune wrld)
  (declare
   (xargs :guard
    (and (plist-worldp wrld) (consp rune) (consp (cdr rune))
         (symbolp (base-symbol rune))
...">fnume</a> rune (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)))))
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> nume) (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> nume <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block function" id="def-enabled-xfnp" data-defines="ENABLED-XFNP" data-references="FN-RUNE-NUME,ENABLED-NUMEP,T,FLAMBDAP,COND,WRLD,ENS,FN,DEFUN" data-used-by="SUBLIS-VAR!" data-part-name="ENABLED-XFNP" data-part-args="WRLD,ENS,FN" data-part-body="ENS,WRLD,FN-RUNE-NUME,ENABLED-NUMEP,T,FN,FLAMBDAP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-XFNP">enabled-xfnp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-xfnp" data-sym="ENABLED-XFNP" title="(defun enabled-xfnp (fn ens wrld)
  (cond ((flambdap fn) t) (t (enabled-numep (fn-rune-nume fn t t wrld) ens))))">enabled-xfnp</a>
  (fn <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> (<a class="sym-link local-def" href="#def-fn-rune-nume" data-sym="FN-RUNE-NUME" title="(defun fn-rune-nume (fn nflg xflg wrld)
  (let* ((runic-mapping-pairs (getpropc fn &#39;runic-mapping-pairs nil wrld))
         (pair
          (if xflg
              (cadr runic-mapping-pairs)
...">fn-rune-nume</a> fn <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-sublis-var_21" data-defines="SUBLIS-VAR!" data-references="CONS,Y,CAR,X,NULL,LST,FN-RUNE-NUME,PUSH-LEMMA,KWOTE,STRIP-CADRS,EV-FNCALL-W,PSTK,VAL,ERP,CONSTRAINEDP,GETPROPC,NOT,ENABLED-XFNP,LOGICP,AND,FCONS-TERM*,EQUAL,IGNORE,DECLARE,FLG3,ARG3,FLG2,ARG2,CADR,FARGN,FLG1,ARG1,IF,QUOTE,EQ,CONS-TERM,LAMBDA-BODY,FFN-SYMB,LAMBDA-FORMALS,PAIRLIS$,FARGS,SUBLIS-VAR!-LST,FLG,ARGS,MV-LET,FLAMBDA-APPLICATIONP,FQUOTEP,T,QUOTEP,CDR,MV,ASSOC-EQ,A,LET,VARIABLEP,COND,TTREE,WRLD,ENS,TERM,ALIST,DEFUN,MUTUAL-RECURSION" data-used-by="TYPE-SET-REC" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBLIS-VAR!">sublis-var!</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a>
    (alist term <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (let ((a (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (a (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cdr a) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (cdr a)) ttree))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term nil ttree)))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree))
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> flg ttree)
          (sublis-var!-lst alist (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                ttree))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil ttree)))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (arg1 flg1 ttree)
          (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg1 (if (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1)
                (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
                (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (arg2 flg2 ttree)
                (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (arg3 flg3 ttree)
                  (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
                  (declare (ignore flg3))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg2 arg3) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> arg2 flg2 ttree))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> 'if arg1 arg2 arg3) nil ttree)))))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> flg ttree)
          (sublis-var!-lst alist (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg
               (<a class="sym-link system" href="axioms.html#def-logicp" data-sym="LOGICP">logicp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld)
               (<a class="sym-link local-def" href="#def-enabled-xfnp" data-sym="ENABLED-XFNP" title="(defun enabled-xfnp (fn ens wrld)
  (cond ((flambdap fn) t) (t (enabled-numep (fn-rune-nume fn t t wrld) ens))))">enabled-xfnp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'constrainedp nil wrld))) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val)
                (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (ev-fncall-w (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                    (<a class="sym-link system" href="axioms.html#def-strip-cadrs" data-sym="STRIP-CADRS">strip-cadrs</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                    wrld
                    nil
                    nil
                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    nil))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil ttree))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> val)
                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                      (push-lemma (<a class="sym-link local-def" href="#def-fn-rune-nume" data-sym="FN-RUNE-NUME" title="(defun fn-rune-nume (fn nflg xflg wrld)
  (let* ((runic-mapping-pairs (getpropc fn &#39;runic-mapping-pairs nil wrld))
         (pair
          (if xflg
              (cadr runic-mapping-pairs)
...">fn-rune-nume</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld) ttree))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil ttree)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> sublis-var!-lst
    (alist lst <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x flg1 ttree)
          (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist (car lst) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (y flg2 ttree)
            (sublis-var!-lst alist (cdr lst) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons x y) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg1 flg2) ttree)))))))</pre>
  </div>

<div class="form-block function" id="def-theory-warning-fns-aux" data-defines="THEORY-WARNING-FNS-AUX" data-references="CONS,CADR,FORMALS,NOT,NULL,CAR,EQ,1+F,REST-RUNES2,CDR,IF,REST-RUNES1,CURR-RUNE2,CDAR,AND,CURR-RUNE1,FOUND2,CAAR,FOUND1,LET*,T,REVERSE,EQL,COND,UNSIGNED-BYTE,TYPE,DECLARE,ACC,W,PREV-RUNE2,PREV-RUNE1,NUME,MAX-NUME,RUNES2,RUNES1,DEFUN" data-used-by="THEORY-WARNING-FNS" data-part-name="THEORY-WARNING-FNS-AUX" data-part-args="ACC,W,PREV-RUNE2,PREV-RUNE1,NUME,MAX-NUME,RUNES2,RUNES1" data-part-declare="NUME,UNSIGNED-BYTE,TYPE,DECLARE" data-part-body="CONS,CADR,FORMALS,PREV-RUNE1,NOT,PREV-RUNE2,NULL,CAR,EQ,W,1+F,THEORY-WARNING-FNS-AUX,REST-RUNES2,CDR,IF,REST-RUNES1,CURR-RUNE2,CDAR,AND,CURR-RUNE1,RUNES2,FOUND2,RUNES1,CAAR,FOUND1,LET*,T,ACC,REVERSE,MAX-NUME,NUME,EQL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORY-WARNING-FNS-AUX">theory-warning-fns-aux</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theory-warning-fns-aux" data-sym="THEORY-WARNING-FNS-AUX" title="(defun theory-warning-fns-aux
       (runes1 runes2 max-nume nume prev-rune1 prev-rune2 w acc)
  (declare (type (unsigned-byte 60) nume))
  (cond ((eql nume max-nume) (reverse acc))
        (t
...">theory-warning-fns-aux</a>
  (runes1 runes2 max-nume nume prev-rune1 prev-rune2 <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> acc)
  (declare (type (unsigned-byte <span class="number">60</span>) nume))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> nume max-nume) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> acc))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((found1 (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> runes1) nume)) (found2 (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> runes2) nume))
          (curr-rune1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> found1 (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> runes1)))
          (curr-rune2 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> found2 (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> runes2)))
          (rest-runes1 (if found1
              (cdr runes1)
              runes1))
          (rest-runes2 (if found2
              (cdr runes2)
              runes2)))
        (<a class="sym-link local-def" href="#def-theory-warning-fns-aux" data-sym="THEORY-WARNING-FNS-AUX" title="(defun theory-warning-fns-aux
       (runes1 runes2 max-nume nume prev-rune1 prev-rune2 w acc)
  (declare (type (unsigned-byte 60) nume))
  (cond ((eql nume max-nume) (reverse acc))
        (t
...">theory-warning-fns-aux</a> rest-runes1
          rest-runes2
          max-nume
          (<a class="sym-link system" href="basis-a.html#def-1_2Bf" data-sym="1+F">1+f</a> nume)
          curr-rune1
          curr-rune2
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car curr-rune2) <span class="keyword">:executable-counterpart</span>)
              (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-rune2)
              (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> curr-rune1 (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-rune1)))
              (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> curr-rune2) <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
            (cons (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> curr-rune2) acc)
            acc))))))</pre>
  </div>

<div class="form-block function" id="def-theory-warning-fns" data-defines="THEORY-WARNING-FNS" data-references="1+,ENABLED-STRUCTURE,ACCESS,CDR,THEORY-WARNING-FNS-AUX,W,ENS2,ENS1,DEFUN" data-part-name="THEORY-WARNING-FNS" data-part-args="W,ENS2,ENS1" data-part-body="W,1+,ENS2,ENS1,ENABLED-STRUCTURE,ACCESS,CDR,THEORY-WARNING-FNS-AUX" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORY-WARNING-FNS">theory-warning-fns</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theory-warning-fns" data-sym="THEORY-WARNING-FNS" title="(defun theory-warning-fns (ens1 ens2 w)
  (theory-warning-fns-aux (cdr (access enabled-structure ens1 :theory-array))
                          (cdr (access enabled-structure ens2 :theory-array))
                          (1+
                           (access enabled-structure ens2
...">theory-warning-fns</a>
  (ens1 ens2 <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
  (<a class="sym-link local-def" href="#def-theory-warning-fns-aux" data-sym="THEORY-WARNING-FNS-AUX" title="(defun theory-warning-fns-aux
       (runes1 runes2 max-nume nume prev-rune1 prev-rune2 w acc)
  (declare (type (unsigned-byte 60) nume))
  (cond ((eql nume max-nume) (reverse acc))
        (t
...">theory-warning-fns-aux</a> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure ens1 <span class="keyword">:theory-array</span>))
    (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure ens2 <span class="keyword">:theory-array</span>))
    (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure ens2 <span class="keyword">:index-of-last-enabling</span>))
    <span class="number">0</span>
    nil
    nil
    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
    nil))</pre>
  </div>

<div class="form-block other" id="form-50" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun_40par" data-sym="DEFUN@PAR">defun@par</a> maybe-warn-about-theory
  (ens1 force-xnume-en1 imm-xnume-en1 ens2 ctx wrld state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-a.html#def-warning-disabled-p" data-sym="WARNING-DISABLED-P">warning-disabled-p</a> <span class="string">"Disable"</span>) (state-mac@par))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (pprogn@par (let ((fns (<a class="sym-link local-def" href="#def-theory-warning-fns" data-sym="THEORY-WARNING-FNS" title="(defun theory-warning-fns (ens1 ens2 w)
  (theory-warning-fns-aux (cdr (access enabled-structure ens1 :theory-array))
                          (cdr (access enabled-structure ens2 :theory-array))
                          (1+
                           (access enabled-structure ens2
...">theory-warning-fns</a> ens1 ens2 wrld)))
          (if fns
            (warning$@par ctx
              (<span class="string">"Disable"</span>)
              <span class="string">"The following 0-ary function~#0~[~/s~] will now have ~#0~[its ~
                :definition rune~/their :definition runes~] disabled but ~
                ~#0~[its :executable-counterpart rune~/their ~
                :executable-counterpart runes~] enabled, which will allow ~
                ~#0~[its definition~/their definitions~] to open up after ~
                all:  ~&amp;0.~|See :DOC theories."</span>
              fns)
            (state-mac@par)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> force-xnume-en1
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aforce-xnume_2A" data-sym="*FORCE-XNUME*">*force-xnume*</a> ens2))) (warning$@par ctx
              (<span class="string">"Disable"</span>)
              <span class="string">"Forcing has transitioned from enabled to disabled.~|See :DOC ~
            force."</span>))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> force-xnume-en1)
             (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aforce-xnume_2A" data-sym="*FORCE-XNUME*">*force-xnume*</a> ens2)) (warning$@par ctx
              (<span class="string">"Disable"</span>)
              <span class="string">"Forcing has transitioned from disabled to enabled.~|See :DOC ~
            force."</span>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (state-mac@par)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> imm-xnume-en1
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aimmediate-force-modep-xnume_2A" data-sym="*IMMEDIATE-FORCE-MODEP-XNUME*">*immediate-force-modep-xnume*</a> ens2))) (warning$@par ctx
              (<span class="string">"Disable"</span>)
              <span class="string">"IMMEDIATE-FORCE-MODEP has transitioned from enabled to ~
            disabled.~|See :DOC force."</span>))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> imm-xnume-en1)
             (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aimmediate-force-modep-xnume_2A" data-sym="*IMMEDIATE-FORCE-MODEP-XNUME*">*immediate-force-modep-xnume*</a> ens2)) (warning$@par ctx
              (<span class="string">"Disable"</span>)
              <span class="string">"IMMEDIATE-FORCE-MODEP has transitioned from disabled to ~
            enabled.~|See :DOC immediate-force-modep."</span>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (state-mac@par)))))))</pre>
  </div>

<div class="form-block other" id="form-51" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> theory-invariant-record
  ((tterm . error) untrans-term . book)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-enabled-disabled-runeps" data-defines="ENABLED-DISABLED-RUNEPS" data-references="&,NOT,CONS,CDR,RUNE,ACTIVE-RUNEP,QUOTE,CASE-MATCH,CAR,E,LET,T,REVERSE,MV,ENDP,COND,DISABLEDS,ENABLEDS,EXPRS,DEFUN" data-used-by="THEORY-INVARIANT-MSG-IMPLICATION" data-part-name="ENABLED-DISABLED-RUNEPS" data-part-args="DISABLEDS,ENABLEDS,EXPRS" data-part-body="&,NOT,CONS,CDR,ENABLED-DISABLED-RUNEPS,RUNE,ACTIVE-RUNEP,QUOTE,CASE-MATCH,CAR,E,LET,T,DISABLEDS,ENABLEDS,REVERSE,MV,EXPRS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENABLED-DISABLED-RUNEPS">enabled-disabled-runeps</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-enabled-disabled-runeps" data-sym="ENABLED-DISABLED-RUNEPS" title="(defun enabled-disabled-runeps (exprs enableds disableds)
  (cond ((endp exprs) (mv nil (reverse enableds) (reverse disableds)))
        (t
         (let ((e (car exprs)))
           (case-match e
...">enabled-disabled-runeps</a>
  (exprs enableds disableds)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> exprs) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> enableds) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> disableds)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((e (car exprs)))
        (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> e
          (('<a class="sym-link local-def" href="#def-active-runep" data-sym="ACTIVE-RUNEP" title="(defmacro active-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-runep</a> ('quote rune)) (<a class="sym-link local-def" href="#def-enabled-disabled-runeps" data-sym="ENABLED-DISABLED-RUNEPS" title="(defun enabled-disabled-runeps (exprs enableds disableds)
  (cond ((endp exprs) (mv nil (reverse enableds) (reverse disableds)))
        (t
         (let ((e (car exprs)))
           (case-match e
...">enabled-disabled-runeps</a> (cdr exprs)
              (cons rune enableds)
              disableds))
          (('<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link local-def" href="#def-active-runep" data-sym="ACTIVE-RUNEP" title="(defmacro active-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-runep</a> ('quote rune))) (<a class="sym-link local-def" href="#def-enabled-disabled-runeps" data-sym="ENABLED-DISABLED-RUNEPS" title="(defun enabled-disabled-runeps (exprs enableds disableds)
  (cond ((endp exprs) (mv nil (reverse enableds) (reverse disableds)))
        (t
         (let ((e (car exprs)))
           (case-match e
...">enabled-disabled-runeps</a> (cdr exprs)
              enableds
              (cons rune disableds)))
          (&amp; (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil nil)))))))</pre>
  </div>

<div class="form-block function" id="def-theory-invariant-msg-implication" data-defines="THEORY-INVARIANT-MSG-IMPLICATION" data-references="MSG5,MSG4,MSG3,MSG2,MSG1,MSG,MSG0,DIS,EN,LET*,OR,DISABLEDS2,ENABLEDS2,NULL,LIST,CDR,AND,QUOTE,CAR,EQ,IF,ENABLED-DISABLED-RUNEPS,DISABLEDS1,ENABLEDS1,FLG,MV-LET,RUNEPS2,RUNEPS1,DEFUN" data-used-by="THEORY-INVARIANT-MSG" data-part-name="THEORY-INVARIANT-MSG-IMPLICATION" data-part-args="RUNEPS2,RUNEPS1" data-part-body="MSG5,MSG4,MSG3,MSG2,MSG1,MSG,MSG0,DIS,EN,LET*,OR,RUNEPS2,DISABLEDS2,ENABLEDS2,NULL,LIST,CDR,AND,QUOTE,RUNEPS1,CAR,EQ,IF,ENABLED-DISABLED-RUNEPS,DISABLEDS1,ENABLEDS1,FLG,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORY-INVARIANT-MSG-IMPLICATION">theory-invariant-msg-implication</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theory-invariant-msg-implication" data-sym="THEORY-INVARIANT-MSG-IMPLICATION" title="(defun theory-invariant-msg-implication (runeps1 runeps2)
  (mv-let (flg enableds1 disableds1)
          (enabled-disabled-runeps
           (if (eq (car runeps1) &#39;and)
               (cdr runeps1)
...">theory-invariant-msg-implication</a>
  (runeps1 runeps2)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg enableds1 disableds1)
    (<a class="sym-link local-def" href="#def-enabled-disabled-runeps" data-sym="ENABLED-DISABLED-RUNEPS" title="(defun enabled-disabled-runeps (exprs enableds disableds)
  (cond ((endp exprs) (mv nil (reverse enableds) (reverse disableds)))
        (t
         (let ((e (car exprs)))
           (case-match e
...">enabled-disabled-runeps</a> (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car runeps1) '<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a>)
        (cdr runeps1)
        (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> runeps1))
      nil
      nil)
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg enableds2 disableds2)
        (<a class="sym-link local-def" href="#def-enabled-disabled-runeps" data-sym="ENABLED-DISABLED-RUNEPS" title="(defun enabled-disabled-runeps (exprs enableds disableds)
  (cond ((endp exprs) (mv nil (reverse enableds) (reverse disableds)))
        (t
         (let ((e (car exprs)))
           (case-match e
...">enabled-disabled-runeps</a> (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car runeps2) '<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a>)
            (cdr runeps2)
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> runeps2))
          nil
          nil)
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg)
          (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> enableds1 disableds1)
          (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> enableds2 disableds2)
          (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((en <span class="string">"the rune~#0~[ ~&amp;0 is~/s ~&amp;0 are~] enabled"</span>) (dis <span class="string">"the rune~#0~[ ~&amp;0 is~/s ~&amp;0 are~] not enabled"</span>)
              (msg0 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> enableds1 (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> en enableds1)))
              (msg1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> enableds1 disableds1 <span class="string">" and "</span>))
              (msg2 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> disableds1 (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> dis disableds1)))
              (msg3 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> enableds2 (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> en enableds2)))
              (msg4 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> enableds2 disableds2 <span class="string">" and "</span>))
              (msg5 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> disableds2 (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> dis disableds2))))
            (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|which asserts that if ~@0~@1~@2, then ~@3~@4~@5"</span>
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg0 <span class="string">""</span>)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg1 <span class="string">""</span>)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg2 <span class="string">""</span>)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg3 <span class="string">""</span>)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg4 <span class="string">""</span>)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> msg5 <span class="string">""</span>))))))))</pre>
  </div>

<div class="form-block function" id="def-combine-ands" data-defines="COMBINE-ANDS" data-references="&,QUASIQUOTE,B,A,AND,QUOTE,CASE-MATCH,Y,X,DEFUN" data-part-name="COMBINE-ANDS" data-part-args="Y,X" data-part-body="&,QUASIQUOTE,B,Y,A,AND,QUOTE,X,CASE-MATCH" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-ANDS">combine-ands</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-combine-ands" data-sym="COMBINE-ANDS" title="(defun combine-ands (x y)
  (case-match x
              ((&#39;and . a)
               (case-match y ((&#39;and . b) `(and ,@a ,@b)) (&amp; `(and ,@a y))))
              (&amp; (case-match y ((&#39;and . a) `(and ,x ,@a)) (&amp; `(and ,x ,y))))))">combine-ands</a>
  (x y)
  (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> x
    (('<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> . a) (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> y (('<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> . b) `(<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,@A ,@B)) (&amp; `(<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,@A y))))
    (&amp; (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> y (('<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> . a) `(<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,X ,@A)) (&amp; `(<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,X ,Y))))))</pre>
  </div>

<div class="form-block function" id="def-theory-invariant-msg-active-runep-lst" data-defines="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST" data-references="CONS,RUNE,ACTIVE-RUNEP,QUOTE,CASE-MATCH,CAR,FORM,LET,T,REVERSE,MSG,CDR,AND,ATOM,COND,ACC,LST,DEFUN" data-used-by="THEORY-INVARIANT-MSG" data-part-name="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST" data-part-args="ACC,LST" data-part-body="CONS,THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST,RUNE,ACTIVE-RUNEP,QUOTE,CASE-MATCH,CAR,FORM,LET,T,REVERSE,MSG,ACC,CDR,AND,LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST">theory-invariant-msg-active-runep-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theory-invariant-msg-active-runep-lst" data-sym="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST" title="(defun theory-invariant-msg-active-runep-lst (lst acc)
  (cond
   ((atom lst)
    (and (cdr acc)
         (msg &quot;~|which asserts that the runes ~&amp;0 are not ~
...">theory-invariant-msg-active-runep-lst</a>
  (lst acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> lst) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (cdr acc)
        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|which asserts that the runes ~&amp;0 are not ~
                    ~#1~[both~/all~] enabled at the same time"</span>
          (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> acc)
          (cdr acc))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((form (car lst)))
        (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> form
          (('<a class="sym-link local-def" href="#def-active-runep" data-sym="ACTIVE-RUNEP" title="(defmacro active-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-runep</a> ('quote rune)) (<a class="sym-link local-def" href="#def-theory-invariant-msg-active-runep-lst" data-sym="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST" title="(defun theory-invariant-msg-active-runep-lst (lst acc)
  (cond
   ((atom lst)
    (and (cdr acc)
         (msg &quot;~|which asserts that the runes ~&amp;0 are not ~
...">theory-invariant-msg-active-runep-lst</a> (cdr lst)
              (cons rune acc)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">""</span>))))))</pre>
  </div>

<div class="form-block function" id="def-theory-invariant-msg" data-defines="THEORY-INVARIANT-MSG" data-references="THEORY-INVARIANT-MSG-IMPLICATION,CONCL,T,IF,QUASIQUOTE,ACTIVE-RUNEPS2,ACTIVE-RUNEPS1,OR,INCOMPATIBLE!,&,RUNE2,RUNE1,INCOMPATIBLE,MSG,RUNE,ACTIVE-RUNEP,THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST,CDR,CONSP,ACTIVE-RUNEP-LST,AND,NOT,QUOTE,CASE-MATCH,FORM,DEFUN" data-part-name="THEORY-INVARIANT-MSG" data-part-args="FORM" data-part-body="THEORY-INVARIANT-MSG-IMPLICATION,CONCL,T,IF,QUASIQUOTE,THEORY-INVARIANT-MSG,ACTIVE-RUNEPS2,ACTIVE-RUNEPS1,OR,INCOMPATIBLE!,&,RUNE2,RUNE1,INCOMPATIBLE,MSG,RUNE,ACTIVE-RUNEP,THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST,CDR,CONSP,ACTIVE-RUNEP-LST,AND,NOT,QUOTE,FORM,CASE-MATCH" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="THEORY-INVARIANT-MSG">theory-invariant-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-theory-invariant-msg" data-sym="THEORY-INVARIANT-MSG" title="(defun theory-invariant-msg (form)
  (case-match form
              ((&#39;not (&#39;and . active-runep-lst))
               (and (consp active-runep-lst) (consp (cdr active-runep-lst))
                    (theory-invariant-msg-active-runep-lst active-runep-lst
...">theory-invariant-msg</a>
  (form)
  (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> form
    (('<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> . active-runep-lst)) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp active-runep-lst)
        (consp (cdr active-runep-lst))
        (<a class="sym-link local-def" href="#def-theory-invariant-msg-active-runep-lst" data-sym="THEORY-INVARIANT-MSG-ACTIVE-RUNEP-LST" title="(defun theory-invariant-msg-active-runep-lst (lst acc)
  (cond
   ((atom lst)
    (and (cdr acc)
         (msg &quot;~|which asserts that the runes ~&amp;0 are not ~
...">theory-invariant-msg-active-runep-lst</a> active-runep-lst nil)))
    (('<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link local-def" href="#def-active-runep" data-sym="ACTIVE-RUNEP" title="(defmacro active-runep (rune)
  `(let* ((rune ,rune)
          (nume
           (and (consp rune) (consp (cdr rune)) (symbolp (cadr rune))
                (fnume rune (w state)))))">active-runep</a> ('quote rune))) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|which asserts that the rune ~x0 is not enabled"</span>
        rune))
    (('incompatible rune1 rune2 . &amp;) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|which asserts that the runes ~x0 and ~x1 are not both enabled at ~
           the same time"</span>
        rune1
        rune2))
    (('incompatible! rune1 rune2 . &amp;) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|which asserts that the runes ~x0 and ~x1 are not both enabled at ~
           the same time"</span>
        rune1
        rune2))
    (('<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> ('<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> active-runeps1) active-runeps2) (<a class="sym-link local-def" href="#def-theory-invariant-msg" data-sym="THEORY-INVARIANT-MSG" title="(defun theory-invariant-msg (form)
  (case-match form
              ((&#39;not (&#39;and . active-runep-lst))
               (and (consp active-runep-lst) (consp (cdr active-runep-lst))
                    (theory-invariant-msg-active-runep-lst active-runep-lst
...">theory-invariant-msg</a> `(if ,ACTIVE-RUNEPS1
          ,ACTIVE-RUNEPS2
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
    (('if active-runeps1 ('if active-runeps2 concl '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-theory-invariant-msg" data-sym="THEORY-INVARIANT-MSG" title="(defun theory-invariant-msg (form)
  (case-match form
              ((&#39;not (&#39;and . active-runep-lst))
               (and (consp active-runep-lst) (consp (cdr active-runep-lst))
                    (theory-invariant-msg-active-runep-lst active-runep-lst
...">theory-invariant-msg</a> `(if ,(COMBINE-ANDS ACTIVE-RUNEPS1 ACTIVE-RUNEPS2)
          ,CONCL
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
    (('if active-runeps1 ('<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> ('<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> active-runeps2) concl) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-theory-invariant-msg" data-sym="THEORY-INVARIANT-MSG" title="(defun theory-invariant-msg (form)
  (case-match form
              ((&#39;not (&#39;and . active-runep-lst))
               (and (consp active-runep-lst) (consp (cdr active-runep-lst))
                    (theory-invariant-msg-active-runep-lst active-runep-lst
...">theory-invariant-msg</a> `(if ,(COMBINE-ANDS ACTIVE-RUNEPS1 ACTIVE-RUNEPS2)
          ,CONCL
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
    (('if active-runeps1 active-runeps2 '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-theory-invariant-msg-implication" data-sym="THEORY-INVARIANT-MSG-IMPLICATION" title="(defun theory-invariant-msg-implication (runeps1 runeps2)
  (mv-let (flg enableds1 disableds1)
          (enabled-disabled-runeps
           (if (eq (car runeps1) &#39;and)
               (cdr runeps1)
...">theory-invariant-msg-implication</a> active-runeps1
        active-runeps2))
    (&amp; nil)))</pre>
  </div>

<div class="form-block other" id="form-57" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> certify-book-info
  (cert-op full-book-name . event-data-channel)
  nil)</pre>
  </div>

<div class="form-block other" id="form-58" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> (tag data . full-book-string) nil)</pre>
  </div>

<div class="form-block function" id="def-active-useless-runes" data-defines="ACTIVE-USELESS-RUNES" data-references="THEORY,ACCESS,EQ,AND,QUOTE,F-GET-GLOBAL,USELESS-RUNES,LET,STATE,DEFUN" data-part-name="ACTIVE-USELESS-RUNES" data-part-args="STATE" data-part-body="THEORY,ACCESS,EQ,AND,STATE,QUOTE,F-GET-GLOBAL,USELESS-RUNES,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTIVE-USELESS-RUNES">active-useless-runes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-active-useless-runes" data-sym="ACTIVE-USELESS-RUNES" title="(defun active-useless-runes (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (and (eq (access useless-runes useless-runes :tag) &#39;theory)
              (access useless-runes useless-runes :data)))))">active-useless-runes</a>
  (state)
  (let ((<a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> state)))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a>
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <span class="keyword">:tag</span>) 'theory)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <span class="keyword">:data</span>)))))</pre>
  </div>

<div class="form-block constant" id="def-_2Adot-sys-dir_2A" data-defines="*DOT-SYS-DIR*" data-references="DEFCONST" data-used-by="DOT-SYS-FILENAME" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*DOT-SYS-DIR*">*dot-sys-dir*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Adot-sys-dir_2A" data-sym="*DOT-SYS-DIR*" title="(defconst *dot-sys-dir* &quot;.sys&quot;)">*dot-sys-dir*</a> <span class="string">".sys"</span>)</pre>
  </div>

<div class="form-block function" id="def-dot-sys-filename" data-defines="DOT-SYS-FILENAME" data-references="*DOT-SYS-DIR*,1+,STRING,QUOTE,CONCATENATE,-,SUBSEQ,EQUAL,AND,ASSERT$,T,*DIRECTORY-SEPARATOR-STRING*,SEARCH,POSN,LENGTH,LEN,LET,SUFFIX,FULL-BOOK-STRING,DEFUN" data-used-by="USELESS-RUNES-FILENAME" data-part-name="DOT-SYS-FILENAME" data-part-args="SUFFIX,FULL-BOOK-STRING" data-part-body="SUFFIX,*DOT-SYS-DIR*,1+,STRING,QUOTE,CONCATENATE,-,SUBSEQ,EQUAL,AND,ASSERT$,T,*DIRECTORY-SEPARATOR-STRING*,SEARCH,POSN,FULL-BOOK-STRING,LENGTH,LEN,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DOT-SYS-FILENAME">dot-sys-filename</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-dot-sys-filename" data-sym="DOT-SYS-FILENAME" title="(defun dot-sys-filename (full-book-string suffix)
  (let ((len (length full-book-string))
        (posn
         (search *directory-separator-string* full-book-string :from-end t)))
    (assert$ (and (equal (subseq full-book-string (- len 5) len) &quot;.lisp&quot;) posn)
...">dot-sys-filename</a>
  (full-book-string suffix)
  (let ((<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> full-book-string)) (posn (<a class="sym-link system" href="axioms.html#def-search" data-sym="SEARCH">search</a> <a class="sym-link system" href="axioms.html#def-_2Adirectory-separator-string_2A" data-sym="*DIRECTORY-SEPARATOR-STRING*">*directory-separator-string*</a>
          full-book-string
          <span class="keyword">:from-end</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
    (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> full-book-string (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>) <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) <span class="string">".lisp"</span>)
        posn)
      (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
        (<a class="sym-link system" href="axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> full-book-string <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> posn))
        <a class="sym-link local-def" href="#def-_2Adot-sys-dir_2A" data-sym="*DOT-SYS-DIR*" title="(defconst *dot-sys-dir* &quot;.sys&quot;)">*dot-sys-dir*</a>
        (<a class="sym-link system" href="axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> full-book-string posn (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>))
        suffix))))</pre>
  </div>

<div class="form-block function" id="def-useless-runes-filename" data-defines="USELESS-RUNES-FILENAME" data-references="DOT-SYS-FILENAME,FULL-BOOK-STRING,DEFUN" data-used-by="ACTIVE-USELESS-RUNES-FILENAME" data-part-name="USELESS-RUNES-FILENAME" data-part-args="FULL-BOOK-STRING" data-part-body="FULL-BOOK-STRING,DOT-SYS-FILENAME" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="USELESS-RUNES-FILENAME">useless-runes-filename</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-useless-runes-filename" data-sym="USELESS-RUNES-FILENAME" title="(defun useless-runes-filename (full-book-string)
  (dot-sys-filename full-book-string &quot;@useless-runes.lsp&quot;))">useless-runes-filename</a>
  (full-book-string)
  (<a class="sym-link local-def" href="#def-dot-sys-filename" data-sym="DOT-SYS-FILENAME" title="(defun dot-sys-filename (full-book-string suffix)
  (let ((len (length full-book-string))
        (posn
         (search *directory-separator-string* full-book-string :from-end t)))
    (assert$ (and (equal (subseq full-book-string (- len 5) len) &quot;.lisp&quot;) posn)
...">dot-sys-filename</a> full-book-string <span class="string">"@useless-runes.lsp"</span>))</pre>
  </div>

<div class="form-block function" id="def-event-data-filename" data-defines="EVENT-DATA-FILENAME" data-references="IF,STRING,QUOTE,CONCATENATE,-,SUBSEQ,EQUAL,ASSERT$,LENGTH,LEN,LET,TMP-P,FILE,DEFUN" data-part-name="EVENT-DATA-FILENAME" data-part-args="TMP-P,FILE" data-part-body="TMP-P,IF,STRING,QUOTE,CONCATENATE,-,SUBSEQ,EQUAL,ASSERT$,FILE,LENGTH,LEN,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EVENT-DATA-FILENAME">event-data-filename</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-event-data-filename" data-sym="EVENT-DATA-FILENAME" title="(defun event-data-filename (file tmp-p)
  (let ((len (length file)))
    (assert$ (equal (subseq file (- len 5) len) &quot;.lisp&quot;)
             (concatenate &#39;string (subseq file 0 (- len 5))
                          (if tmp-p
...">event-data-filename</a>
  (file tmp-p)
  (let ((<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> file)))
    (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (equal (<a class="sym-link system" href="axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> file (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>) <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>) <span class="string">".lisp"</span>)
      (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
        (<a class="sym-link system" href="axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> file <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>))
        (if tmp-p
          <span class="string">"@event-data.lsp.temp"</span>
          <span class="string">"@event-data.lsp"</span>)))))</pre>
  </div>

<div class="form-block function" id="def-active-useless-runes-filename" data-defines="ACTIVE-USELESS-RUNES-FILENAME" data-references="ACCESS,USELESS-RUNES-FILENAME,AND,QUOTE,F-GET-GLOBAL,USELESS-RUNES,LET,STATE,DEFUN" data-part-name="ACTIVE-USELESS-RUNES-FILENAME" data-part-args="STATE" data-part-body="ACCESS,USELESS-RUNES-FILENAME,AND,STATE,QUOTE,F-GET-GLOBAL,USELESS-RUNES,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTIVE-USELESS-RUNES-FILENAME">active-useless-runes-filename</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-active-useless-runes-filename" data-sym="ACTIVE-USELESS-RUNES-FILENAME" title="(defun active-useless-runes-filename (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (useless-runes-filename
          (access useless-runes useless-runes :full-book-string)))))">active-useless-runes-filename</a>
  (state)
  (let ((<a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> state)))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a>
      (<a class="sym-link local-def" href="#def-useless-runes-filename" data-sym="USELESS-RUNES-FILENAME" title="(defun useless-runes-filename (full-book-string)
  (dot-sys-filename full-book-string &quot;@useless-runes.lsp&quot;))">useless-runes-filename</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <a class="sym-link system" href="defuns.html#def-useless-runes" data-sym="USELESS-RUNES">useless-runes</a> <span class="keyword">:full-book-string</span>)))))</pre>
  </div>

<div class="form-block other" id="form-65" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun_40par" data-sym="DEFUN@PAR">defun@par</a> chk-theory-invariant1
  (theory-expr <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> invariant-alist errp-acc ctx state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> invariant-alist) (mv@par errp-acc nil state))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((table-entry (car invariant-alist)) (inv-name (car table-entry))
          (inv-rec (cdr table-entry))
          (theory-inv (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:tterm</span>)))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp okp latches)
          (ev theory-inv
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons '<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
              (cons 'state (<a class="sym-link system" href="axioms.html#def-coerce-state-to-object" data-sym="COERCE-STATE-TO-OBJECT">coerce-state-to-object</a> state)))
            state
            nil
            nil
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          (declare (ignore latches))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((produced-by-msg (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> theory-expr <span class="keyword">:from-hint</span>) <span class="string">"an :in-theory hint"</span>)
                     ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> theory-expr <span class="keyword">:install</span>) <span class="string">"the current event"</span>)
                     (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~x0"</span> theory-expr)))) (theory-invariant-term (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:untrans-term</span>))
                  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Theory invariant ~x0 could not be evaluated on ~
                              the theory produced by ~@1~@2.  Theory invariant ~
                              ~P43 produced the error message:~%~@5~@6  See ~
                              :DOC theory-invariant."</span>
                      inv-name
                      produced-by-msg
                      (if (<a class="sym-link local-def" href="#def-active-useless-runes" data-sym="ACTIVE-USELESS-RUNES" title="(defun active-useless-runes (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (and (eq (access useless-runes useless-runes :tag) &#39;theory)
              (access useless-runes useless-runes :data)))))">active-useless-runes</a> state)
                        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">", modified by subtracting the theory ~
                                       for the current event stored in file ~
                                       ~s0"</span>
                          (<a class="sym-link local-def" href="#def-active-useless-runes-filename" data-sym="ACTIVE-USELESS-RUNES-FILENAME" title="(defun active-useless-runes-filename (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (useless-runes-filename
          (access useless-runes useless-runes :full-book-string)))))">active-useless-runes-filename</a> state))
                        <span class="string">""</span>)
                      (<a class="sym-link system" href="basis-a.html#def-term-evisc-tuple" data-sym="TERM-EVISC-TUPLE">term-evisc-tuple</a> nil state)
                      theory-invariant-term
                      okp
                      (if (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:error</span>)
                        <span class="string">"~|This theory invariant violation causes an ~
                                  error."</span>
                        <span class="string">""</span>))))
                (mv-let@par (errp-acc state)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:error</span>) (mv-let@par (erp val state)
                        (er-soft@par ctx <span class="string">"Theory"</span> <span class="string">"~@0"</span> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>)
                        (declare (ignore erp val))
                        (mv@par <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state)))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (pprogn@par (warning$@par ctx
                          <span class="string">"Theory"</span>
                          `(<span class="string">"~@0"</span> (<span class="keyword">:error-msg</span> ,OKP)
                            (<span class="keyword">:produced-by-msg</span> ,PRODUCED-BY-MSG)
                            (<span class="keyword">:theory-invariant-name</span> ,INV-NAME)
                            (<span class="keyword">:theory-invariant-term</span> ,THEORY-INVARIANT-TERM))
                          <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>)
                        (mv@par errp-acc state))))
                  (chk-theory-invariant1@par theory-expr
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    (cdr invariant-alist)
                    errp-acc
                    ctx
                    state))))
            (okp (chk-theory-invariant1@par theory-expr
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                (cdr invariant-alist)
                errp-acc
                ctx
                state))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((produced-by-msg (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> theory-expr <span class="keyword">:from-hint</span>) <span class="string">"an :in-theory hint"</span>)
                     ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> theory-expr <span class="keyword">:install</span>) <span class="string">"the current event"</span>)
                     (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~x0"</span> theory-expr)))) (theory-invariant-term (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:untrans-term</span>))
                  (theory-invariant-book (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:book</span>))
                  (thy-inv-msg (<a class="sym-link local-def" href="#def-theory-invariant-msg" data-sym="THEORY-INVARIANT-MSG" title="(defun theory-invariant-msg (form)
  (case-match form
              ((&#39;not (&#39;and . active-runep-lst))
               (and (consp active-runep-lst) (consp (cdr active-runep-lst))
                    (theory-invariant-msg-active-runep-lst active-runep-lst
...">theory-invariant-msg</a> theory-invariant-term))
                  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Theory invariant ~x0, defined ~@1, failed on the ~
                            theory produced by ~@2~@3.  Theory invariant ~x0 ~
                            is ~@4~@5  See :DOC theory-invariant."</span>
                      inv-name
                      (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> theory-invariant-book)
                        <span class="string">"at the top-level"</span>
                        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"in book ~x0"</span>
                          (<a class="sym-link system" href="basis-a.html#def-book-name-to-filename" data-sym="BOOK-NAME-TO-FILENAME">book-name-to-filename</a> theory-invariant-book (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state) ctx)))
                      produced-by-msg
                      (if (<a class="sym-link local-def" href="#def-active-useless-runes" data-sym="ACTIVE-USELESS-RUNES" title="(defun active-useless-runes (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (and (eq (access useless-runes useless-runes :tag) &#39;theory)
              (access useless-runes useless-runes :data)))))">active-useless-runes</a> state)
                        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">", modified by subtracting the theory for ~
                                     the current event stored in file ~s0"</span>
                          (<a class="sym-link local-def" href="#def-active-useless-runes-filename" data-sym="ACTIVE-USELESS-RUNES-FILENAME" title="(defun active-useless-runes-filename (state)
  (let ((useless-runes (f-get-global &#39;useless-runes state)))
    (and useless-runes
         (useless-runes-filename
          (access useless-runes useless-runes :full-book-string)))))">active-useless-runes-filename</a> state))
                        <span class="string">""</span>)
                      (if thy-inv-msg
                        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~P10~@2."</span>
                          (<a class="sym-link system" href="basis-a.html#def-term-evisc-tuple" data-sym="TERM-EVISC-TUPLE">term-evisc-tuple</a> nil state)
                          theory-invariant-term
                          thy-inv-msg)
                        (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~P10."</span>
                          (<a class="sym-link system" href="basis-a.html#def-term-evisc-tuple" data-sym="TERM-EVISC-TUPLE">term-evisc-tuple</a> nil state)
                          theory-invariant-term))
                      (if (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:error</span>)
                        <span class="string">"~|This theory invariant violation causes an ~
                                error."</span>
                        <span class="string">""</span>))))
                (mv-let@par (errp-acc state)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> theory-invariant-record inv-rec <span class="keyword">:error</span>) (mv-let@par (erp val state)
                        (er-soft@par ctx <span class="string">"Theory"</span> <span class="string">"~@0"</span> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>)
                        (declare (ignore erp val))
                        (mv@par <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state)))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (pprogn@par (warning$@par ctx
                          <span class="string">"Theory"</span>
                          `(<span class="string">"~@0"</span> (<span class="keyword">:produced-by-msg</span> ,PRODUCED-BY-MSG)
                            (<span class="keyword">:theory-invariant-name</span> ,INV-NAME)
                            (<span class="keyword">:theory-invariant-term</span> ,THEORY-INVARIANT-TERM))
                          <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>)
                        (mv@par errp-acc state))))
                  (chk-theory-invariant1@par theory-expr
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    (cdr invariant-alist)
                    errp-acc
                    ctx
                    state))))))))))</pre>
  </div>

<div class="form-block other" id="form-66" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun_40par" data-sym="DEFUN@PAR">defun@par</a> chk-theory-invariant
  (theory-expr <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> ctx state)
  (chk-theory-invariant1@par theory-expr
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'theory-invariant-table (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state))
    nil
    ctx
    state))</pre>
  </div>

<div class="form-block other" id="form-67" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> clause-id
  ((forcing-round . <a class="sym-link system" href="history-management.html#def-pool-lst" data-sym="POOL-LST">pool-lst</a>) case-lst . primes)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-pos-listp" data-defines="POS-LISTP" data-references="CDR,CAR,POSP,AND,EQ,ATOM,COND,T,XARGS,DECLARE,L,DEFUN" data-used-by="CLAUSE-ID-P" data-part-name="POS-LISTP" data-part-args="L" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,POS-LISTP,CAR,POSP,AND,T,EQ,L,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POS-LISTP">pos-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pos-listp" data-sym="POS-LISTP" title="(defun pos-listp (l)
  (declare (xargs :guard t))
  (cond ((atom l) (eq l nil)) (t (and (posp (car l)) (pos-listp (cdr l))))))">pos-listp</a>
  (l)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> l) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> l nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-posp" data-sym="POSP">posp</a> (car l)) (<a class="sym-link local-def" href="#def-pos-listp" data-sym="POS-LISTP" title="(defun pos-listp (l)
  (declare (xargs :guard t))
  (cond ((atom l) (eq l nil)) (t (and (posp (car l)) (pos-listp (cdr l))))))">pos-listp</a> (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-all-digits-p" data-defines="ALL-DIGITS-P" data-references="CDR,CAR,DIGIT-CHAR-P,T,ENDP,COND,<=,INTEGERP,CHARACTER-LISTP,AND,XARGS,DECLARE,RADIX,LST,DEFUN" data-used-by="D-POS-LISTP" data-part-name="ALL-DIGITS-P" data-part-args="RADIX,LST" data-part-declare="<=,RADIX,INTEGERP,LST,CHARACTER-LISTP,AND,XARGS,DECLARE" data-part-body="CDR,ALL-DIGITS-P,RADIX,CAR,DIGIT-CHAR-P,AND,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-DIGITS-P">all-digits-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-digits-p" data-sym="ALL-DIGITS-P" title="(defun all-digits-p (lst radix)
  (declare
   (xargs :guard
    (and (character-listp lst) (integerp radix) (&lt;= 2 radix) (&lt;= radix 36))))
  (cond ((endp lst) t)
...">all-digits-p</a>
  (lst radix)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> lst)
        (integerp radix)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">2</span> radix)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> radix <span class="number">36</span>))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-digit-char-p" data-sym="DIGIT-CHAR-P">digit-char-p</a> (car lst) radix)
        (<a class="sym-link local-def" href="#def-all-digits-p" data-sym="ALL-DIGITS-P" title="(defun all-digits-p (lst radix)
  (declare
   (xargs :guard
    (and (character-listp lst) (integerp radix) (&lt;= 2 radix) (&lt;= radix 36))))
  (cond ((endp lst) t)
...">all-digits-p</a> (cdr lst) radix)))))</pre>
  </div>

<div class="form-block function" id="def-d-pos-listp" data-defines="D-POS-LISTP" data-references="LIST,QUOTE,COERCE,ALL-DIGITS-P,CHAR,EQL,EQUAL,NOT,SYMBOL-NAME,NAME,LET,SYMBOLP,AND,CDR,CAR,NATP,NULL,ATOM,COND,T,XARGS,DECLARE,LST,DEFUN" data-used-by="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS,CLAUSE-ID-P" data-part-name="D-POS-LISTP" data-part-args="LST" data-part-declare="T,XARGS,DECLARE" data-part-body="LIST,QUOTE,COERCE,ALL-DIGITS-P,CHAR,EQL,EQUAL,NOT,SYMBOL-NAME,NAME,LET,SYMBOLP,AND,T,CDR,D-POS-LISTP,CAR,NATP,NULL,LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="D-POS-LISTP">d-pos-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-d-pos-listp" data-sym="D-POS-LISTP" title="(defun d-pos-listp (lst)
  (declare (xargs :guard t))
  (cond ((atom lst) (null lst)) ((natp (car lst)) (d-pos-listp (cdr lst)))
        (t
         (and (symbolp (car lst))
...">d-pos-listp</a>
  (lst)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> lst) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst))
    ((<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (car lst)) (<a class="sym-link local-def" href="#def-d-pos-listp" data-sym="D-POS-LISTP" title="(defun d-pos-listp (lst)
  (declare (xargs :guard t))
  (cond ((atom lst) (null lst)) ((natp (car lst)) (d-pos-listp (cdr lst)))
        (t
         (and (symbolp (car lst))
...">d-pos-listp</a> (cdr lst)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp (car lst))
        (let ((name (symbol-name (car lst))))
          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal name <span class="string">""</span>))
            (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> name <span class="number">0</span>) #\D)
            (<a class="sym-link local-def" href="#def-all-digits-p" data-sym="ALL-DIGITS-P" title="(defun all-digits-p (lst radix)
  (declare
   (xargs :guard
    (and (character-listp lst) (integerp radix) (&lt;= 2 radix) (&lt;= radix 36))))
  (cond ((endp lst) t)
...">all-digits-p</a> (cdr (coerce name '<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>)) <span class="number">10</span>)))
        (<a class="sym-link local-def" href="#def-d-pos-listp" data-sym="D-POS-LISTP" title="(defun d-pos-listp (lst)
  (declare (xargs :guard t))
  (cond ((atom lst) (null lst)) ((natp (car lst)) (d-pos-listp (cdr lst)))
        (t
         (and (symbolp (car lst))
...">d-pos-listp</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-clause-id-p" data-defines="CLAUSE-ID-P" data-references="&,D-POS-LISTP,POS-LISTP,NATP,AND,PRIMES,CASE-LST,POOL-LST,FORCING-ROUND,CASE-MATCH,T,XARGS,DECLARE,CL-ID,DEFUN" data-used-by="STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-name="CLAUSE-ID-P" data-part-args="CL-ID" data-part-declare="T,XARGS,DECLARE" data-part-body="&,D-POS-LISTP,POS-LISTP,NATP,AND,PRIMES,CASE-LST,POOL-LST,FORCING-ROUND,CL-ID,CASE-MATCH" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CLAUSE-ID-P">clause-id-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-clause-id-p" data-sym="CLAUSE-ID-P" title="(defun clause-id-p (cl-id)
  (declare (xargs :guard t))
  (case-match cl-id
              (((forcing-round . pool-lst) case-lst . primes)
               (and (natp forcing-round) (pos-listp pool-lst)
...">clause-id-p</a>
  (cl-id)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> cl-id
    (((forcing-round . <a class="sym-link system" href="history-management.html#def-pool-lst" data-sym="POOL-LST">pool-lst</a>) case-lst . primes) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> forcing-round)
        (<a class="sym-link local-def" href="#def-pos-listp" data-sym="POS-LISTP" title="(defun pos-listp (l)
  (declare (xargs :guard t))
  (cond ((atom l) (eq l nil)) (t (and (posp (car l)) (pos-listp (cdr l))))))">pos-listp</a> <a class="sym-link system" href="history-management.html#def-pool-lst" data-sym="POOL-LST">pool-lst</a>)
        (<a class="sym-link local-def" href="#def-d-pos-listp" data-sym="D-POS-LISTP" title="(defun d-pos-listp (lst)
  (declare (xargs :guard t))
  (cond ((atom lst) (null lst)) ((natp (car lst)) (d-pos-listp (cdr lst)))
        (t
         (and (symbolp (car lst))
...">d-pos-listp</a> case-lst)
        (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> primes)))
    (&amp; nil)))</pre>
  </div>

<div class="form-block constant" id="def-_2Ainitial-clause-id_2A" data-defines="*INITIAL-CLAUSE-ID*" data-references="CLAUSE-ID,MAKE,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*INITIAL-CLAUSE-ID*">*initial-clause-id*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Ainitial-clause-id_2A" data-sym="*INITIAL-CLAUSE-ID*" title="(defconst *initial-clause-id*
          (make clause-id :forcing-round 0 :pool-lst nil :case-lst nil :primes
                0))">*initial-clause-id*</a>
  (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> clause-id
    <span class="keyword">:forcing-round</span> <span class="number">0</span>
    <span class="keyword">:pool-lst</span> nil
    <span class="keyword">:case-lst</span> nil
    <span class="keyword">:primes</span> <span class="number">0</span>))</pre>
  </div>

<div class="form-block function" id="def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-defines="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" data-references="CONS,APPEND,T,CAR,EXPLODE-ATOM,CDR,NULL,COND,D-POS-LISTP,XARGS,DECLARE,LST,DEFUN" data-used-by="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-name="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" data-part-args="LST" data-part-declare="LST,D-POS-LISTP,XARGS,DECLARE" data-part-body="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS,CONS,APPEND,T,CAR,EXPLODE-ATOM,CDR,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS">chars-for-tilde-@-clause-id-phrase/periods</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" title="(defun chars-for-tilde-@-clause-id-phrase/periods (lst)
  (declare (xargs :guard (d-pos-listp lst)))
  (cond ((null lst) nil) ((null (cdr lst)) (explode-atom (car lst) 10))
        (t
         (append (explode-atom (car lst) 10)
...">chars-for-tilde-@-clause-id-phrase/periods</a>
  (lst)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-d-pos-listp" data-sym="D-POS-LISTP" title="(defun d-pos-listp (lst)
  (declare (xargs :guard t))
  (cond ((atom lst) (null lst)) ((natp (car lst)) (d-pos-listp (cdr lst)))
        (t
         (and (symbolp (car lst))
...">d-pos-listp</a> lst)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr lst)) (<a class="sym-link system" href="axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> (car lst) <span class="number">10</span>))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> (car lst) <span class="number">10</span>)
        (cons #\.
          (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" title="(defun chars-for-tilde-@-clause-id-phrase/periods (lst)
  (declare (xargs :guard (d-pos-listp lst)))
  (cond ((null lst) nil) ((null (cdr lst)) (explode-atom (car lst) 10))
        (t
         (append (explode-atom (car lst) 10)
...">chars-for-tilde-@-clause-id-phrase/periods</a> (cdr lst)))))))</pre>
  </div>

<div class="form-block function" id="def-chars-for-tilde-_40-clause-id-phrase_2Fprimes" data-defines="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" data-references="EXPLODE-ATOM,APPEND,CONS,T,QUOTE,=,COND,>=,INTEGERP,AND,XARGS,DECLARE,N,DEFUN" data-used-by="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-name="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" data-part-args="N" data-part-declare=">=,N,INTEGERP,AND,XARGS,DECLARE" data-part-body="EXPLODE-ATOM,APPEND,CONS,T,QUOTE,N,=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES">chars-for-tilde-@-clause-id-phrase/primes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fprimes" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" title="(defun chars-for-tilde-@-clause-id-phrase/primes (n)
  (declare (xargs :guard (and (integerp n) (&gt;= n 0))))
  (cond ((= n 0) nil) ((= n 1) &#39;(#\&#39;)) ((= n 2) &#39;(#\&#39; #\&#39;))
        ((= n 3) &#39;(#\&#39; #\&#39; #\&#39;))
        (t (cons #\&#39; (append (explode-atom n 10) &#39;(#\&#39;))))))">chars-for-tilde-@-clause-id-phrase/primes</a>
  (n)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp n) (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> n <span class="number">0</span>))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>) nil)
    ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">1</span>) '(#\&#39;))
    ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">2</span>) '(#\&#39; #\&#39;))
    ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">3</span>) '(#\&#39; #\&#39; #\&#39;))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons #\&#39; (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> n <span class="number">10</span>) '(#\&#39;))))))</pre>
  </div>

<div class="form-block function" id="def-chars-for-tilde-_40-clause-id-phrase" data-defines="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-references="CONS,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS,T,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES,QUOTE,NULL,COND,QUASIQUOTE,CLAUSE-ID,ACCESS,=,IF,APPEND,CLAUSE-ID-P,XARGS,DECLARE,ID,DEFUN" data-used-by="INCREMENT-ARRAY-NAME,STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-name="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-args="ID" data-part-declare="ID,CLAUSE-ID-P,XARGS,DECLARE" data-part-body="CONS,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS,T,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES,QUOTE,NULL,COND,QUASIQUOTE,ID,CLAUSE-ID,ACCESS,=,IF,APPEND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE">chars-for-tilde-@-clause-id-phrase</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" title="(defun chars-for-tilde-@-clause-id-phrase (id)
  (declare (xargs :guard (clause-id-p id)))
  (append
   (if (= (access clause-id id :forcing-round) 0)
       nil
...">chars-for-tilde-@-clause-id-phrase</a>
  (id)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-clause-id-p" data-sym="CLAUSE-ID-P" title="(defun clause-id-p (cl-id)
  (declare (xargs :guard t))
  (case-match cl-id
              (((forcing-round . pool-lst) case-lst . primes)
               (and (natp forcing-round) (pos-listp pool-lst)
...">clause-id-p</a> id)))
  (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:forcing-round</span>) <span class="number">0</span>)
      nil
      `(#\[ ,@(EXPLODE-ATOM (ACCESS CLAUSE-ID ID :FORCING-ROUND) 10)
        #\]))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:pool-lst</span>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:case-lst</span>)) (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> '(#\G #\o #\a #\l)
              (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fprimes" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" title="(defun chars-for-tilde-@-clause-id-phrase/primes (n)
  (declare (xargs :guard (and (integerp n) (&gt;= n 0))))
  (cond ((= n 0) nil) ((= n 1) &#39;(#\&#39;)) ((= n 2) &#39;(#\&#39; #\&#39;))
        ((= n 3) &#39;(#\&#39; #\&#39; #\&#39;))
        (t (cons #\&#39; (append (explode-atom n 10) &#39;(#\&#39;))))))">chars-for-tilde-@-clause-id-phrase/primes</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:primes</span>))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> '(#\S #\u #\b #\g #\o #\a #\l #\ )
              (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" title="(defun chars-for-tilde-@-clause-id-phrase/periods (lst)
  (declare (xargs :guard (d-pos-listp lst)))
  (cond ((null lst) nil) ((null (cdr lst)) (explode-atom (car lst) 10))
        (t
         (append (explode-atom (car lst) 10)
...">chars-for-tilde-@-clause-id-phrase/periods</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:case-lst</span>))
              (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fprimes" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" title="(defun chars-for-tilde-@-clause-id-phrase/primes (n)
  (declare (xargs :guard (and (integerp n) (&gt;= n 0))))
  (cond ((= n 0) nil) ((= n 1) &#39;(#\&#39;)) ((= n 2) &#39;(#\&#39; #\&#39;))
        ((= n 3) &#39;(#\&#39; #\&#39; #\&#39;))
        (t (cons #\&#39; (append (explode-atom n 10) &#39;(#\&#39;))))))">chars-for-tilde-@-clause-id-phrase/primes</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:primes</span>))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> '(#\S #\u #\b #\g #\o #\a #\l #\  #\*)
          (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" title="(defun chars-for-tilde-@-clause-id-phrase/periods (lst)
  (declare (xargs :guard (d-pos-listp lst)))
  (cond ((null lst) nil) ((null (cdr lst)) (explode-atom (car lst) 10))
        (t
         (append (explode-atom (car lst) 10)
...">chars-for-tilde-@-clause-id-phrase/periods</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:pool-lst</span>))
          (cons #\/
            (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fperiods" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PERIODS" title="(defun chars-for-tilde-@-clause-id-phrase/periods (lst)
  (declare (xargs :guard (d-pos-listp lst)))
  (cond ((null lst) nil) ((null (cdr lst)) (explode-atom (car lst) 10))
        (t
         (append (explode-atom (car lst) 10)
...">chars-for-tilde-@-clause-id-phrase/periods</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:case-lst</span>))
              (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase_2Fprimes" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE/PRIMES" title="(defun chars-for-tilde-@-clause-id-phrase/primes (n)
  (declare (xargs :guard (and (integerp n) (&gt;= n 0))))
  (cond ((= n 0) nil) ((= n 1) &#39;(#\&#39;)) ((= n 2) &#39;(#\&#39; #\&#39;))
        ((= n 3) &#39;(#\&#39; #\&#39; #\&#39;))
        (t (cons #\&#39; (append (explode-atom n 10) &#39;(#\&#39;))))))">chars-for-tilde-@-clause-id-phrase/primes</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> clause-id id <span class="keyword">:primes</span>)))))))))</pre>
  </div>

<div class="form-block function" id="def-string-for-tilde-_40-clause-id-phrase" data-defines="STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-references="STRING,QUOTE,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE,COERCE,CLAUSE-ID-P,XARGS,DECLARE,ID,DEFUN" data-part-name="STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE" data-part-args="ID" data-part-declare="ID,CLAUSE-ID-P,XARGS,DECLARE" data-part-body="STRING,QUOTE,ID,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE,COERCE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE">string-for-tilde-@-clause-id-phrase</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-string-for-tilde-_40-clause-id-phrase" data-sym="STRING-FOR-TILDE-@-CLAUSE-ID-PHRASE" title="(defun string-for-tilde-@-clause-id-phrase (id)
  (declare (xargs :guard (clause-id-p id)))
  (coerce (chars-for-tilde-@-clause-id-phrase id) &#39;string))">string-for-tilde-@-clause-id-phrase</a>
  (id)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-clause-id-p" data-sym="CLAUSE-ID-P" title="(defun clause-id-p (cl-id)
  (declare (xargs :guard t))
  (case-match cl-id
              (((forcing-round . pool-lst) case-lst . primes)
               (and (natp forcing-round) (pos-listp pool-lst)
...">clause-id-p</a> id)))
  (coerce (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" title="(defun chars-for-tilde-@-clause-id-phrase (id)
  (declare (xargs :guard (clause-id-p id)))
  (append
   (if (= (access clause-id id :forcing-round) 0)
       nil
...">chars-for-tilde-@-clause-id-phrase</a> id) '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>))</pre>
  </div>

<div class="form-block function" id="def-update-enabled-structure-array" data-defines="UPDATE-ENABLED-STRUCTURE-ARRAY" data-references="COMPRESS1,IGNORE,LENGTH,<=,NATP,EQ,OR,ARRAY-ORDER,NULL,CONS,ARRAY1P,AND,XARGS,DECLARE,NEW-N,D,OLD,K,ALIST,HEADER,NAME,DEFUN" data-part-name="UPDATE-ENABLED-STRUCTURE-ARRAY" data-part-args="NEW-N,D,OLD,K,ALIST,HEADER,NAME" data-part-declare="OLD,IGNORE,NEW-N,D,LENGTH,<=,NATP,K,EQ,OR,ARRAY-ORDER,NULL,ALIST,HEADER,CONS,NAME,ARRAY1P,AND,XARGS,DECLARE" data-part-body="ALIST,HEADER,CONS,NAME,COMPRESS1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-ENABLED-STRUCTURE-ARRAY">update-enabled-structure-array</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-enabled-structure-array" data-sym="UPDATE-ENABLED-STRUCTURE-ARRAY" title="(defun update-enabled-structure-array (name header alist k old d new-n)
  (declare
   (xargs :guard
    (and (array1p name (cons header alist)) (null (array-order header))
         (or (eq k nil) (and (natp k) (&lt;= k (length alist)))) (natp d)
...">update-enabled-structure-array</a>
  (name <a class="sym-link system" href="axioms.html#def-header" data-sym="HEADER">header</a> alist k old d new-n)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-array1p" data-sym="ARRAY1P">array1p</a> name (cons <a class="sym-link system" href="axioms.html#def-header" data-sym="HEADER">header</a> alist))
        (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-array-order" data-sym="ARRAY-ORDER">array-order</a> <a class="sym-link system" href="axioms.html#def-header" data-sym="HEADER">header</a>))
        (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> k nil) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> k) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> k (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> alist))))
        (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> d)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> new-n d)))
    (ignore k old d new-n))
  (<a class="sym-link system" href="axioms.html#def-compress1" data-sym="COMPRESS1">compress1</a> name (cons <a class="sym-link system" href="axioms.html#def-header" data-sym="HEADER">header</a> alist)))</pre>
  </div>

<div class="form-block function" id="def-increment-array-name" data-defines="INCREMENT-ARRAY-NAME" data-references="MV,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE,KEYWORDP,STRING,QUOTE,EXPLODE-NONNEGATIVE-INTEGER,APPEND,COERCE,INTERN,NAME,1+,T,EQ,COND,SUFFIX,ENABLED-STRUCTURE,ACCESS,ROOT,LET*,INCRMT-ARRAY-NAME-INFO,ENS,DEFUN" data-used-by="UPDATE-ENABLED-STRUCTURE" data-part-name="INCREMENT-ARRAY-NAME" data-part-args="INCRMT-ARRAY-NAME-INFO,ENS" data-part-body="MV,CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE,KEYWORDP,STRING,QUOTE,EXPLODE-NONNEGATIVE-INTEGER,APPEND,COERCE,INTERN,NAME,1+,T,INCRMT-ARRAY-NAME-INFO,EQ,COND,SUFFIX,ENS,ENABLED-STRUCTURE,ACCESS,ROOT,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INCREMENT-ARRAY-NAME">increment-array-name</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-increment-array-name" data-sym="INCREMENT-ARRAY-NAME" title="(defun increment-array-name (ens incrmt-array-name-info)
  (let* ((root (access enabled-structure ens :array-name-root))
         (suffix
          (cond
           ((eq incrmt-array-name-info t)
...">increment-array-name</a>
  (<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> incrmt-array-name-info)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((root (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name-root</span>)) (suffix (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> incrmt-array-name-info <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name-suffix</span>)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name-suffix</span>))))
      (name (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> incrmt-array-name-info <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-intern" data-sym="INTERN">intern</a> (coerce (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> root (<a class="sym-link system" href="axioms.html#def-explode-nonnegative-integer" data-sym="EXPLODE-NONNEGATIVE-INTEGER">explode-nonnegative-integer</a> suffix <span class="number">10</span> nil))
                '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>)
              <span class="string">"ACL2"</span>))
          ((<a class="sym-link system" href="axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> incrmt-array-name-info) incrmt-array-name-info)
          (incrmt-array-name-info (<a class="sym-link system" href="axioms.html#def-intern" data-sym="INTERN">intern</a> (coerce (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> root
                  (<a class="sym-link local-def" href="#def-chars-for-tilde-_40-clause-id-phrase" data-sym="CHARS-FOR-TILDE-@-CLAUSE-ID-PHRASE" title="(defun chars-for-tilde-@-clause-id-phrase (id)
  (declare (xargs :guard (clause-id-p id)))
  (append
   (if (= (access clause-id id :forcing-round) 0)
       nil
...">chars-for-tilde-@-clause-id-phrase</a> incrmt-array-name-info))
                '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>)
              <span class="string">"ACL2"</span>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-name</span>)))))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> root suffix name)))</pre>
  </div>

<div class="form-block function" id="def-update-enabled-structure" data-defines="UPDATE-ENABLED-STRUCTURE" data-references="1+,LIST,CONS,COMPRESS1,ENABLED-STRUCTURE,MAKE,INCREMENT-ARRAY-NAME,NAME,SUFFIX,ROOT,MV-LET,IGNORE,DECLARE,INCRMT-ARRAY-NAME-INFO,AUGMENTED-P,ALIST,NEW-D,D,N,ENS,DEFUN" data-used-by="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" data-part-name="UPDATE-ENABLED-STRUCTURE" data-part-args="INCRMT-ARRAY-NAME-INFO,AUGMENTED-P,ALIST,NEW-D,D,N,ENS" data-part-declare="AUGMENTED-P,D,IGNORE,DECLARE" data-part-body="ALIST,1+,NEW-D,LIST,CONS,COMPRESS1,N,ENABLED-STRUCTURE,MAKE,INCRMT-ARRAY-NAME-INFO,ENS,INCREMENT-ARRAY-NAME,NAME,SUFFIX,ROOT,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-ENABLED-STRUCTURE">update-enabled-structure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-enabled-structure" data-sym="UPDATE-ENABLED-STRUCTURE" title="(defun update-enabled-structure
       (ens n d new-d alist augmented-p incrmt-array-name-info)
  (declare (ignore d augmented-p))
  (mv-let (root suffix name) (increment-array-name ens incrmt-array-name-info)
          (make enabled-structure :index-of-last-enabling n :theory-array
...">update-enabled-structure</a>
  (<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> n d new-d alist augmented-p incrmt-array-name-info)
  (declare (ignore d augmented-p))
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (root suffix name)
    (<a class="sym-link local-def" href="#def-increment-array-name" data-sym="INCREMENT-ARRAY-NAME" title="(defun increment-array-name (ens incrmt-array-name-info)
  (let* ((root (access enabled-structure ens :array-name-root))
         (suffix
          (cond
           ((eq incrmt-array-name-info t)
...">increment-array-name</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> incrmt-array-name-info)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> enabled-structure
      <span class="keyword">:index-of-last-enabling</span> n
      <span class="keyword">:theory-array</span> (<a class="sym-link system" href="axioms.html#def-compress1" data-sym="COMPRESS1">compress1</a> name
        (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:header</span> <span class="keyword">:dimensions</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> new-d)
            <span class="keyword">:maximum-length</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> new-d)
            <span class="keyword">:default</span> nil
            <span class="keyword">:name</span> name
            <span class="keyword">:order</span> nil)
          alist))
      <span class="keyword">:array-name</span> name
      <span class="keyword">:array-length</span> new-d
      <span class="keyword">:array-name-root</span> root
      <span class="keyword">:array-name-suffix</span> suffix)))</pre>
  </div>

<div class="form-block function" id="def-load-theory-into-enabled-structure-1" data-defines="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" data-references="UPDATE-ENABLED-STRUCTURE,AUGMENT-RUNIC-THEORY,IF,ALIST,-,FLOOR,+,T,<,1+,*,CAAR,>=,CONSP,EXT-P,QUOTE,EQ,AND,COND,NEW-D,ENABLED-STRUCTURE,ACCESS,D,GET-NEXT-NUME,1-,MAX,OR,N,LET*,WRLD,INDEX-OF-LAST-ENABLING,INCRMT-ARRAY-NAME-INFO,ENS,AUGMENTED-P,THEORY,DEFUN" data-part-name="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" data-part-args="WRLD,INDEX-OF-LAST-ENABLING,INCRMT-ARRAY-NAME-INFO,ENS,AUGMENTED-P,THEORY" data-part-body="INCRMT-ARRAY-NAME-INFO,UPDATE-ENABLED-STRUCTURE,AUGMENT-RUNIC-THEORY,IF,ALIST,-,FLOOR,+,T,<,1+,*,CAAR,>=,THEORY,CONSP,EXT-P,QUOTE,AUGMENTED-P,EQ,AND,COND,NEW-D,ENS,ENABLED-STRUCTURE,ACCESS,D,WRLD,GET-NEXT-NUME,1-,MAX,INDEX-OF-LAST-ENABLING,OR,N,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1">load-theory-into-enabled-structure-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-load-theory-into-enabled-structure-1" data-sym="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" title="(defun load-theory-into-enabled-structure-1
       (theory augmented-p ens incrmt-array-name-info index-of-last-enabling
        wrld)
  (let* ((n (or index-of-last-enabling (max 0 (1- (get-next-nume wrld)))))
         (d (access enabled-structure ens :array-length))
...">load-theory-into-enabled-structure-1</a>
  (theory augmented-p
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    incrmt-array-name-info
    index-of-last-enabling
    wrld)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> index-of-last-enabling
         (max <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link local-def" href="#def-get-next-nume" data-sym="GET-NEXT-NUME" title="(defun get-next-nume (lst)
  (cond ((null lst) 0)
        ((and (eq (cadr (car lst)) &#39;runic-mapping-pairs)
              (consp (cddr (car lst))))
         (+ (car (car (cddr (car lst)))) (length (cddr (car lst)))))">get-next-nume</a> wrld))))) (d (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <span class="keyword">:array-length</span>))
      (new-d (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> augmented-p 'ext-p)
             (consp theory)
             (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> theory) d)) (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">2</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> theory))))
          ((&lt; n d) d)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (max (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">2</span> d) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> d (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">500</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (floor (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n d) <span class="number">500</span>))))))))
      (alist (if augmented-p
          theory
          (<a class="sym-link local-def" href="#def-augment-runic-theory" data-sym="AUGMENT-RUNIC-THEORY" title="(defun augment-runic-theory (lst wrld)
  (augment-runic-theory1 (reverse lst) nil wrld nil))">augment-runic-theory</a> theory wrld))))
    (<a class="sym-link local-def" href="#def-update-enabled-structure" data-sym="UPDATE-ENABLED-STRUCTURE" title="(defun update-enabled-structure
       (ens n d new-d alist augmented-p incrmt-array-name-info)
  (declare (ignore d augmented-p))
  (mv-let (root suffix name) (increment-array-name ens incrmt-array-name-info)
          (make enabled-structure :index-of-last-enabling n :theory-array
...">update-enabled-structure</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      n
      d
      new-d
      alist
      augmented-p
      incrmt-array-name-info)))</pre>
  </div>

<div class="form-block other" id="form-81" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun_40par" data-sym="DEFUN@PAR">defun@par</a> load-theory-into-enabled-structure
  (theory-expr theory
    augmented-p
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    incrmt-array-name-info
    index-of-last-enabling
    wrld
    ctx
    state)
  (let ((<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> (<a class="sym-link local-def" href="#def-load-theory-into-enabled-structure-1" data-sym="LOAD-THEORY-INTO-ENABLED-STRUCTURE-1" title="(defun load-theory-into-enabled-structure-1
       (theory augmented-p ens incrmt-array-name-info index-of-last-enabling
        wrld)
  (let* ((n (or index-of-last-enabling (max 0 (1- (get-next-nume wrld)))))
         (d (access enabled-structure ens :array-length))
...">load-theory-into-enabled-structure-1</a> theory
         augmented-p
         <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
         incrmt-array-name-info
         index-of-last-enabling
         wrld)))
    (er-progn@par (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> theory-expr <span class="keyword">:no-check</span>)
          (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state) '<a class="sym-link system" href="axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a>)
          (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state) 'include-book-with-locals))
        (value@par nil)
        (chk-theory-invariant@par theory-expr <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> ctx state))
      (value@par <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block function" id="def-initial-global-enabled-structure" data-defines="INITIAL-GLOBAL-ENABLED-STRUCTURE" data-references="1+,CONS,COMPRESS1,ENABLED-STRUCTURE,MAKE,D,STRING,APPEND,INTERN,NAME,LIST,QUOTE,COERCE,ROOT,LET*,ROOT-STRING,DEFUN" data-part-name="INITIAL-GLOBAL-ENABLED-STRUCTURE" data-part-args="ROOT-STRING" data-part-body="1+,CONS,COMPRESS1,ENABLED-STRUCTURE,MAKE,D,STRING,APPEND,INTERN,NAME,LIST,QUOTE,ROOT-STRING,COERCE,ROOT,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INITIAL-GLOBAL-ENABLED-STRUCTURE">initial-global-enabled-structure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-initial-global-enabled-structure" data-sym="INITIAL-GLOBAL-ENABLED-STRUCTURE" title="(defun initial-global-enabled-structure (root-string)
  (let* ((root (coerce root-string &#39;list))
         (name (intern (coerce (append root &#39;(#\0)) &#39;string) &quot;ACL2&quot;))
         (d 1000))
    (make enabled-structure :index-of-last-enabling -1 :theory-array
...">initial-global-enabled-structure</a>
  (root-string)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((root (coerce root-string '<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>)) (name (<a class="sym-link system" href="axioms.html#def-intern" data-sym="INTERN">intern</a> (coerce (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> root '(#\0)) '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>) <span class="string">"ACL2"</span>))
      (d <span class="number">1000</span>))
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> enabled-structure
      <span class="keyword">:index-of-last-enabling</span> <span class="number">-1</span>
      <span class="keyword">:theory-array</span> (<a class="sym-link system" href="axioms.html#def-compress1" data-sym="COMPRESS1">compress1</a> name
        (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:header</span> <span class="keyword">:dimensions</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> d)
            <span class="keyword">:maximum-length</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> d)
            <span class="keyword">:default</span> nil
            <span class="keyword">:name</span> name)
          nil))
      <span class="keyword">:array-name</span> name
      <span class="keyword">:array-length</span> d
      <span class="keyword">:array-name-root</span> root
      <span class="keyword">:array-name-suffix</span> <span class="number">0</span>)))</pre>
  </div>

<div class="form-block function" id="def-recompress-global-enabled-structure" data-defines="RECOMPRESS-GLOBAL-ENABLED-STRUCTURE" data-references="T,ENABLED-STRUCTURE,ACCESS,MAYBE-FLUSH-AND-COMPRESS1,PROG2$,COND,GLOBAL-VALUE,QUOTE,GETPROPC,GES1,LET,WRLD,VARNAME,DEFUN" data-part-name="RECOMPRESS-GLOBAL-ENABLED-STRUCTURE" data-part-args="WRLD,VARNAME" data-part-body="T,ENABLED-STRUCTURE,ACCESS,MAYBE-FLUSH-AND-COMPRESS1,PROG2$,COND,WRLD,GLOBAL-VALUE,QUOTE,VARNAME,GETPROPC,GES1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECOMPRESS-GLOBAL-ENABLED-STRUCTURE">recompress-global-enabled-structure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-recompress-global-enabled-structure" data-sym="RECOMPRESS-GLOBAL-ENABLED-STRUCTURE" title="(defun recompress-global-enabled-structure (varname wrld)
  (let ((ges1 (getpropc varname &#39;global-value nil wrld)))
    (cond
     (ges1
      (prog2$
...">recompress-global-enabled-structure</a>
  (varname wrld)
  (let ((ges1 (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> varname 'global-value nil wrld)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ges1 (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-maybe-flush-and-compress1" data-sym="MAYBE-FLUSH-AND-COMPRESS1">maybe-flush-and-compress1</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure ges1 <span class="keyword">:array-name</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> enabled-structure ges1 <span class="keyword">:theory-array</span>))
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))</pre>
  </div>

<div class="form-block function" id="def-recompress-stobj-accessor-arrays" data-defines="RECOMPRESS-STOBJ-ACCESSOR-ARRAYS" data-references="CDR,MAYBE-FLUSH-AND-COMPRESS1,NULL,OR,PROG2$,ACCESSOR-NAMES,QUOTE,GETPROPC,AR,CAR,ST,LET*,T,ENDP,IF,WRLD,STOBJ-NAMES,DEFUN" data-part-name="RECOMPRESS-STOBJ-ACCESSOR-ARRAYS" data-part-args="WRLD,STOBJ-NAMES" data-part-body="CDR,RECOMPRESS-STOBJ-ACCESSOR-ARRAYS,MAYBE-FLUSH-AND-COMPRESS1,NULL,OR,PROG2$,WRLD,ACCESSOR-NAMES,QUOTE,GETPROPC,AR,CAR,ST,LET*,T,STOBJ-NAMES,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECOMPRESS-STOBJ-ACCESSOR-ARRAYS">recompress-stobj-accessor-arrays</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-recompress-stobj-accessor-arrays" data-sym="RECOMPRESS-STOBJ-ACCESSOR-ARRAYS" title="(defun recompress-stobj-accessor-arrays (stobj-names wrld)
  (if (endp stobj-names)
      t
      (let* ((st (car stobj-names)) (ar (getpropc st &#39;accessor-names nil wrld)))
        (prog2$ (or (null ar) (maybe-flush-and-compress1 st ar))">recompress-stobj-accessor-arrays</a>
  (stobj-names wrld)
  (if (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> stobj-names)
    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((st (car stobj-names)) (ar (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> st 'accessor-names nil wrld)))
      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ar) (<a class="sym-link system" href="axioms.html#def-maybe-flush-and-compress1" data-sym="MAYBE-FLUSH-AND-COMPRESS1">maybe-flush-and-compress1</a> st ar))
        (<a class="sym-link local-def" href="#def-recompress-stobj-accessor-arrays" data-sym="RECOMPRESS-STOBJ-ACCESSOR-ARRAYS" title="(defun recompress-stobj-accessor-arrays (stobj-names wrld)
  (if (endp stobj-names)
      t
      (let* ((st (car stobj-names)) (ar (getpropc st &#39;accessor-names nil wrld)))
        (prog2$ (or (null ar) (maybe-flush-and-compress1 st ar))">recompress-stobj-accessor-arrays</a> (cdr stobj-names) wrld)))))</pre>
  </div>

<div class="form-block constant" id="def-_2Afake-rune-for-type-set_2A" data-defines="*FAKE-RUNE-FOR-TYPE-SET*" data-references="QUOTE,DEFCONST" data-used-by="PUFFERT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*FAKE-RUNE-FOR-TYPE-SET*">*fake-rune-for-type-set*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Afake-rune-for-type-set_2A" data-sym="*FAKE-RUNE-FOR-TYPE-SET*" title="(defconst *fake-rune-for-type-set* &#39;(:fake-rune-for-type-set nil))">*fake-rune-for-type-set*</a>
  '(<span class="keyword">:fake-rune-for-type-set</span> nil))</pre>
  </div>

<div class="form-block function" id="def-puffert" data-defines="PUFFERT" data-references="*FAKE-RUNE-FOR-TYPE-SET*,PUSH-LEMMA,TTREE,DEFUN" data-used-by="TYPE-ALIST-EQUALITY-LOOP1,TYPE-SET-REC,TYPE-SET-FINISH-1,ASSOC-EQUIV+,EXTEND-TYPE-ALIST,EXTEND-TYPE-ALIST1,SUBST-TYPE-ALIST1,TYPE-SET-CHAR-CODE,TYPE-SET-EQUAL,TYPE-SET-CONS,TYPE-SET-LENGTH,TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL,TYPE-SET-COERCE,TYPE-SET-CDR,TYPE-SET-COMPLEX,TYPE-SET-IMAGPART,TYPE-SET-REALPART,TYPE-SET-DENOMINATOR,TYPE-SET-NUMERATOR,TYPE-SET-UNARY-/,TYPE-SET-UNARY--,TYPE-SET-<,TYPE-SET-<-1,TYPE-SET-NOT,TYPE-SET-BINARY-*,TYPE-SET-BINARY-+" data-part-name="PUFFERT" data-part-args="TTREE" data-part-body="TTREE,*FAKE-RUNE-FOR-TYPE-SET*,PUSH-LEMMA" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUFFERT">puffert</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a>
  (ttree)
  (push-lemma <a class="sym-link local-def" href="#def-_2Afake-rune-for-type-set_2A" data-sym="*FAKE-RUNE-FOR-TYPE-SET*" title="(defconst *fake-rune-for-type-set* &#39;(:fake-rune-for-type-set nil))">*fake-rune-for-type-set*</a> ttree))</pre>
  </div>

<div class="form-block function" id="def-immediate-forcep" data-defines="IMMEDIATE-FORCEP" data-references="T,*IMMEDIATE-FORCE-MODEP-XNUME*,ENABLED-NUMEP,CASE-SPLIT,QUOTE,EQ,COND,ENS,FN,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="IMMEDIATE-FORCEP" data-part-args="ENS,FN" data-part-body="T,ENS,*IMMEDIATE-FORCE-MODEP-XNUME*,ENABLED-NUMEP,CASE-SPLIT,QUOTE,FN,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IMMEDIATE-FORCEP">immediate-forcep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a>
  (fn <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-case-split" data-sym="CASE-SPLIT">case-split</a>) '<a class="sym-link system" href="axioms.html#def-case-split" data-sym="CASE-SPLIT">case-split</a>)
    ((<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aimmediate-force-modep-xnume_2A" data-sym="*IMMEDIATE-FORCE-MODEP-XNUME*">*immediate-force-modep-xnume*</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block macro" id="def-numeric-type-set" data-defines="NUMERIC-TYPE-SET" data-references="*TS-ZERO*,TS-UNION,TS=,IF,*TS-ACL2-NUMBER*,CHECK-VARS-NOT-FREE,TS-INTERSECTION,NUMERIC-TS-USE-NOWHERE-ELSE,LET,QUASIQUOTE,TS,DEFMACRO" data-used-by="TYPE-SET-REALPART,TYPE-SET-UNARY-/,TYPE-SET-UNARY--,TYPE-SET-<,TYPE-SET-BINARY-*,TYPE-SET-BINARY-+" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="NUMERIC-TYPE-SET">numeric-type-set</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a>
  (ts)
  `(let ((numeric-ts-use-nowhere-else (ts-intersection (<a class="sym-link system" href="axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (numeric-ts-use-nowhere-else) ,TS)
         *ts-acl2-number*)))
    (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> numeric-ts-use-nowhere-else ,TS)
      ,TS
      (ts-union numeric-ts-use-nowhere-else *ts-zero*))))</pre>
  </div>

<div class="form-block macro" id="def-rational-type-set" data-defines="RATIONAL-TYPE-SET" data-references="*TS-ZERO*,TS-UNION,TS=,IF,*TS-RATIONAL*,CHECK-VARS-NOT-FREE,TS-INTERSECTION,NUMERIC-TS-USE-NOWHERE-ELSE,LET,QUASIQUOTE,TS,DEFMACRO" data-used-by="TYPE-SET-COMPLEX,TYPE-SET-DENOMINATOR,TYPE-SET-NUMERATOR" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="RATIONAL-TYPE-SET">rational-type-set</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rational-type-set" data-sym="RATIONAL-TYPE-SET" title="(defmacro rational-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-rational*)))
...">rational-type-set</a>
  (ts)
  `(let ((numeric-ts-use-nowhere-else (ts-intersection (<a class="sym-link system" href="axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (numeric-ts-use-nowhere-else) ,TS)
         *ts-rational*)))
    (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> numeric-ts-use-nowhere-else ,TS)
      ,TS
      (ts-union numeric-ts-use-nowhere-else *ts-zero*))))</pre>
  </div>

<div class="form-block function" id="def-type-set-binary-_2B" data-defines="TYPE-SET-BINARY-+" data-references="*TS-ACL2-NUMBER*,IF,NUMERIC-TYPE-SET,*TYPE-SET-BINARY-+-TABLE*,TYPE-SET-BINARY-+-TABLE,AREF2,ANS,T,PUFFERT,*TS-NON-NEGATIVE-INTEGER*,*TS-POSITIVE-INTEGER*,TS-SUBSETP,QUOTE,EQUAL,AND,MV,*TS-EMPTY*,TS=,OR,COND,ARG2,FARGN,ARG1,LET,TTREE0,TTREE,TS2,TS1,TERM,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-BINARY-+" data-part-args="TTREE0,TTREE,TS2,TS1,TERM" data-part-body="TTREE0,*TS-ACL2-NUMBER*,IF,NUMERIC-TYPE-SET,*TYPE-SET-BINARY-+-TABLE*,TYPE-SET-BINARY-+-TABLE,AREF2,ANS,T,PUFFERT,*TS-NON-NEGATIVE-INTEGER*,*TS-POSITIVE-INTEGER*,TS-SUBSETP,QUOTE,EQUAL,AND,TTREE,MV,TS2,*TS-EMPTY*,TS1,TS=,OR,COND,ARG2,TERM,FARGN,ARG1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-BINARY-+">type-set-binary-+</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-binary-_2B" data-sym="TYPE-SET-BINARY-+" title="(defun type-set-binary-+ (term ts1 ts2 ttree ttree0)
  (let ((arg1 (fargn term 1)) (arg2 (fargn term 2)))
    (cond
     ((or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) (mv *ts-empty* ttree))
     ((and (equal arg2 &#39;&#39;-1) (ts-subsetp ts1 *ts-positive-integer*))
...">type-set-binary-+</a>
  (term ts1 ts2 ttree ttree0)
  (let ((arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-empty*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-empty*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-empty* ttree))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg2 ''<span class="number">-1</span>)
         (ts-subsetp ts1 *ts-positive-integer*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-non-negative-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 ''<span class="number">-1</span>)
         (ts-subsetp ts2 *ts-positive-integer*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-non-negative-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ans (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-+-table
               <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table_2A" data-sym="*TYPE-SET-BINARY-+-TABLE*" title="(defconst *type-set-binary-+-table*
          (compress2 &#39;type-set-binary-+-table *type-set-binary-+-table-list*))">*type-set-binary-+-table*</a>
               (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts1)
               (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts2))))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans
            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-acl2-number*)
                ttree0
                ttree))))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-binary-_2A" data-defines="TYPE-SET-BINARY-*" data-references="*TS-ACL2-NUMBER*,IF,PUFFERT,NUMERIC-TYPE-SET,*TYPE-SET-BINARY-*-TABLE*,TYPE-SET-BINARY-*-TABLE,QUOTE,AREF2,ANS,LET,T,MV,*TS-EMPTY*,TS=,OR,COND,TTREE0,TTREE,TS2,TS1,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-BINARY-*" data-part-args="TTREE0,TTREE,TS2,TS1" data-part-body="TTREE0,*TS-ACL2-NUMBER*,IF,PUFFERT,NUMERIC-TYPE-SET,*TYPE-SET-BINARY-*-TABLE*,TYPE-SET-BINARY-*-TABLE,QUOTE,AREF2,ANS,LET,T,TTREE,MV,TS2,*TS-EMPTY*,TS1,TS=,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-BINARY-*">type-set-binary-*</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-binary-_2A" data-sym="TYPE-SET-BINARY-*" title="(defun type-set-binary-* (ts1 ts2 ttree ttree0)
  (cond ((or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) (mv *ts-empty* ttree))
        (t
         (let ((ans
                (aref2 &#39;type-set-binary-*-table *type-set-binary-*-table*
...">type-set-binary-*</a>
  (ts1 ts2 ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-empty*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-empty*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-empty* ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ans (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-*-table
             <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table_2A" data-sym="*TYPE-SET-BINARY-*-TABLE*" title="(defconst *type-set-binary-*-table*
          (compress2 &#39;type-set-binary-*-table *type-set-binary-*-table-list*))">*type-set-binary-*-table*</a>
             (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts1)
             (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts2))))
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans
          (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-acl2-number*)
              ttree0
              ttree)))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-not" data-defines="TYPE-SET-NOT" data-references="T,*TS-BOOLEAN*,TS-SUBSETP,PUFFERT,*TS-T*,MV,*TS-NIL*,TS=,COND,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC,TYPE-SET-<" data-part-name="TYPE-SET-NOT" data-part-args="TTREE0,TTREE,TS" data-part-body="T,TTREE0,*TS-BOOLEAN*,TS-SUBSETP,TTREE,PUFFERT,*TS-T*,MV,*TS-NIL*,TS,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-NOT">type-set-not</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-not" data-sym="TYPE-SET-NOT" title="(defun type-set-not (ts ttree ttree0)
  (cond ((ts= ts *ts-nil*) (mv *ts-t* (puffert ttree)))
        ((ts-subsetp *ts-nil* ts) (mv *ts-boolean* ttree0))
        (t (mv *ts-nil* (puffert ttree)))))">type-set-not</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
    ((ts-subsetp *ts-nil* ts) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* ttree0))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-_3C-1" data-defines="TYPE-SET-<-1" data-references="PUFFERT,*TS-NIL*,EQUAL,*TS-T*,TS=,<=,AND,CDR,NULL,&,RATIONALP,IF,<,QUOTE,X,LEFTP,C,MV-LET,TTREE,TYPE,TYPED-TERM,CASE-MATCH,CAR,TYPE-ALIST-ENTRY,LET,T,*TS-BOOLEAN*,MV,ENDP,COND,TYPE-ALIST,COMMUTEDP,ARG2,R,DEFUN" data-used-by="TYPE-SET-<" data-part-name="TYPE-SET-<-1" data-part-args="TYPE-ALIST,COMMUTEDP,ARG2,R" data-part-body="PUFFERT,*TS-NIL*,EQUAL,*TS-T*,TS=,<=,AND,CDR,COMMUTEDP,ARG2,R,TYPE-SET-<-1,NULL,&,RATIONALP,IF,<,QUOTE,X,LEFTP,C,MV-LET,TTREE,TYPE,TYPED-TERM,CASE-MATCH,CAR,TYPE-ALIST-ENTRY,LET,T,*TS-BOOLEAN*,MV,TYPE-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-<-1">type-set-&lt;-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a>
  (r arg2 commutedp type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((type-alist-entry (car type-alist)))
        (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> type-alist-entry
          ((typed-term type . ttree) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (c leftp x)
              (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> typed-term
                (('&lt; ('quote c) x) (if (rationalp c)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> c <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil x)))
                (('&lt; x ('quote c)) (if (rationalp c)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> c nil x)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil)))
                (&amp; (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> c) (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> r arg2 commutedp (cdr type-alist)))
                (leftp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> r c) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> type *ts-t*) (equal x arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if commutedp
                          *ts-nil*
                          *ts-t*)
                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if commutedp
                         (&lt; c r)
                         (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> c r))
                       (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> type *ts-nil*)
                       (equal x arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if commutedp
                          *ts-t*
                          *ts-nil*)
                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> r arg2 commutedp (cdr type-alist)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if commutedp
                         (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> r c)
                         (&lt; r c))
                       (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> type *ts-nil*)
                       (equal x arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if commutedp
                          *ts-nil*
                          *ts-t*)
                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> c r) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> type *ts-t*) (equal x arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if commutedp
                          *ts-t*
                          *ts-nil*)
                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> r arg2 commutedp (cdr type-alist))))))))
          (&amp; (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> r arg2 commutedp (cdr type-alist))))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-_3C" data-defines="TYPE-SET-<" data-references="<,POLY,ACCESS,IGNORE,DECLARE,<=,BASE-POLY,ADD-LINEAR-TERMS,NORMALIZE-POLY,LIST,ADD-POLYS0,NEW-POT-LST,CONTRADICTIONP,NULL,*TS-NIL*,*TS-T*,*TYPE-SET-<-TABLE*,TYPE-SET-<-TABLE,QUOTE,AREF2,*TS-COMPLEX-RATIONAL*,TS-INTERSECTP,OR,TEMP-TS,LET,CONS-TAG-TREES,TS=,NOT,IF,*TS-BOOLEAN*,MV,TYPE-SET-<-1,CADR,RATIONALP,QUOTEP,RETURNED-TTREE,RETURNED-TS,T,*-1*,TYPE-SET-NOT,PUFFERT,*TS-ZERO*,*0*,TS,MV-LET,*TS-INTEGER*,TS-SUBSETP,*1*,EQUAL,AND,COND,NTS2,NUMERIC-TYPE-SET,NTS1,LET*,PT,POT-LST,TTREE0,TTREE,TYPE-ALIST,TS2,TS1,ARG2,ARG1,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-<" data-part-args="PT,POT-LST,TTREE0,TTREE,TYPE-ALIST,TS2,TS1,ARG2,ARG1" data-part-body="<,POLY,ACCESS,IGNORE,DECLARE,<=,BASE-POLY,ADD-LINEAR-TERMS,NORMALIZE-POLY,LIST,ADD-POLYS0,NEW-POT-LST,CONTRADICTIONP,NULL,*TS-NIL*,*TS-T*,*TYPE-SET-<-TABLE*,TYPE-SET-<-TABLE,QUOTE,AREF2,*TS-COMPLEX-RATIONAL*,TS-INTERSECTP,OR,TEMP-TS,LET,CONS-TAG-TREES,TS=,NOT,IF,*TS-BOOLEAN*,MV,TYPE-SET-<-1,CADR,RATIONALP,QUOTEP,RETURNED-TTREE,RETURNED-TS,T,*-1*,TTREE0,TYPE-SET-NOT,PT,POT-LST,PUFFERT,TYPE-ALIST,*TS-ZERO*,ARG1,*0*,TYPE-SET-<,TTREE,TS,MV-LET,*TS-INTEGER*,TS-SUBSETP,*1*,ARG2,EQUAL,AND,COND,TS2,NTS2,TS1,NUMERIC-TYPE-SET,NTS1,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-<">type-set-&lt;</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-_3C" data-sym="TYPE-SET-&lt;" title="(defun type-set-&lt; (arg1 arg2 ts1 ts2 type-alist ttree ttree0 pot-lst pt)
  (let* ((nts1 (numeric-type-set ts1)) (nts2 (numeric-type-set ts2)))
    (cond
     ((and (equal arg2 *1*) (ts-subsetp nts1 *ts-integer*))
      (mv-let (ts ttree)
...">type-set-&lt;</a>
  (arg1 arg2 ts1 ts2 type-alist ttree ttree0 pot-lst pt)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((nts1 (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts1)) (nts2 (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts2)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg2 <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>) (ts-subsetp nts1 *ts-integer*)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
          (<a class="sym-link local-def" href="#def-type-set-_3C" data-sym="TYPE-SET-&lt;" title="(defun type-set-&lt; (arg1 arg2 ts1 ts2 type-alist ttree ttree0 pot-lst pt)
  (let* ((nts1 (numeric-type-set ts1)) (nts2 (numeric-type-set ts2)))
    (cond
     ((and (equal arg2 *1*) (ts-subsetp nts1 *ts-integer*))
      (mv-let (ts ttree)
...">type-set-&lt;</a> <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>
            arg1
            *ts-zero*
            ts1
            type-alist
            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)
            ttree
            pot-lst
            pt)
          (<a class="sym-link local-def" href="#def-type-set-not" data-sym="TYPE-SET-NOT" title="(defun type-set-not (ts ttree ttree0)
  (cond ((ts= ts *ts-nil*) (mv *ts-t* (puffert ttree)))
        ((ts-subsetp *ts-nil* ts) (mv *ts-boolean* ttree0))
        (t (mv *ts-nil* (puffert ttree)))))">type-set-not</a> ts ttree ttree0)))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 <a class="sym-link system" href="axioms.html#def-_2A-1_2A" data-sym="*-1*">*-1*</a>) (ts-subsetp nts2 *ts-integer*)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
          (<a class="sym-link local-def" href="#def-type-set-_3C" data-sym="TYPE-SET-&lt;" title="(defun type-set-&lt; (arg1 arg2 ts1 ts2 type-alist ttree ttree0 pot-lst pt)
  (let* ((nts1 (numeric-type-set ts1)) (nts2 (numeric-type-set ts2)))
    (cond
     ((and (equal arg2 *1*) (ts-subsetp nts1 *ts-integer*))
      (mv-let (ts ttree)
...">type-set-&lt;</a> arg2
            <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>
            ts2
            *ts-zero*
            type-alist
            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)
            ttree
            pot-lst
            pt)
          (<a class="sym-link local-def" href="#def-type-set-not" data-sym="TYPE-SET-NOT" title="(defun type-set-not (ts ttree ttree0)
  (cond ((ts= ts *ts-nil*) (mv *ts-t* (puffert ttree)))
        ((ts-subsetp *ts-nil* ts) (mv *ts-boolean* ttree0))
        (t (mv *ts-nil* (puffert ttree)))))">type-set-not</a> ts ttree ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (returned-ts returned-ttree)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1) (rationalp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1))) (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1) arg2 nil type-alist))
            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2) (rationalp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg2))) (<a class="sym-link local-def" href="#def-type-set-_3C-1" data-sym="TYPE-SET-&lt;-1" title="(defun type-set-&lt;-1 (r arg2 commutedp type-alist)
  (cond ((endp type-alist) (mv *ts-boolean* nil))
        (t
         (let ((type-alist-entry (car type-alist)))
           (case-match type-alist-entry
...">type-set-&lt;-1</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg2) arg1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* nil)))
          (if (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> returned-ts *ts-boolean*))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> returned-ts (cons-tag-trees returned-ttree ttree0))
            (let ((temp-ts (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 *ts-complex-rational*)
                     (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts2 *ts-complex-rational*))
                   *ts-boolean*
                   (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-&lt;-table <a class="sym-link local-def" href="#def-_2Atype-set-_3C-table_2A" data-sym="*TYPE-SET-&lt;-TABLE*" title="(defconst *type-set-&lt;-table*
          (compress2 &#39;type-set-&lt;-table *type-set-&lt;-table-list*))">*type-set-&lt;-table*</a> nts1 nts2))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> temp-ts *ts-t*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> temp-ts *ts-nil*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> temp-ts (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* ttree0))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
                    (add-polys0 (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (normalize-poly (add-linear-terms <span class="keyword">:lhs</span> arg2
                            <span class="keyword">:rhs</span> arg1
                            (base-poly ttree0 '<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> nil nil))))
                      pot-lst
                      pt
                      nil
                      <span class="number">2</span>)
                    (declare (ignore new-pot-lst))
                    (if contradictionp
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>))
                      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
                        (add-polys0 (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (normalize-poly (add-linear-terms <span class="keyword">:lhs</span> arg1
                                <span class="keyword">:rhs</span> arg2
                                (base-poly ttree0 '&lt; nil nil))))
                          pot-lst
                          pt
                          nil
                          <span class="number">2</span>)
                        (declare (ignore new-pot-lst))
                        (if contradictionp
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>))
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* ttree0))))))))))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-unary--" data-defines="TYPE-SET-UNARY--" data-references="PUFFERT,*TS-COMPLEX-RATIONAL*,*TS-POSITIVE-INTEGER*,*TS-NEGATIVE-RATIO*,*TS-POSITIVE-RATIO*,*TS-INTEGER>1*,*TS-NEGATIVE-INTEGER*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,T,MV,*TS-ACL2-NUMBER*,TS=,COND,NUMERIC-TYPE-SET,TS1,LET,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-UNARY--" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,PUFFERT,*TS-COMPLEX-RATIONAL*,*TS-POSITIVE-INTEGER*,*TS-NEGATIVE-RATIO*,*TS-POSITIVE-RATIO*,*TS-INTEGER>1*,*TS-NEGATIVE-INTEGER*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,T,TTREE0,MV,*TS-ACL2-NUMBER*,TS=,COND,TS,NUMERIC-TYPE-SET,TS1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-UNARY--">type-set-unary--</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-unary--" data-sym="TYPE-SET-UNARY--" title="(defun type-set-unary-- (ts ttree ttree0)
  (let ((ts1 (numeric-type-set ts)))
    (cond ((ts= ts1 *ts-acl2-number*) (mv *ts-acl2-number* ttree0))
          (t
           (mv
...">type-set-unary--</a>
  (ts ttree ttree0)
  (let ((ts1 (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-acl2-number*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-acl2-number* ttree0))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts1
            (*ts-zero* *ts-zero*)
            (*ts-one* *ts-negative-integer*)
            (*ts-integer&gt;1* *ts-negative-integer*)
            (*ts-positive-ratio* *ts-negative-ratio*)
            (*ts-negative-integer* *ts-positive-integer*)
            (*ts-negative-ratio* *ts-positive-ratio*)
            (*ts-complex-rational* *ts-complex-rational*))
          (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-unary-_2F" data-defines="TYPE-SET-UNARY-/" data-references="T,PUFFERT,MV,*TS-ACL2-NUMBER*,TS=,COND,*TS-COMPLEX-RATIONAL*,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-COMPLEMENT0,*TS-POSITIVE-RATIO*,TS-INTERSECTION0,*TS-INTEGER>1*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,ANS,NUMERIC-TYPE-SET,TS1,LET*,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-UNARY-/" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,T,TTREE0,PUFFERT,MV,*TS-ACL2-NUMBER*,TS=,COND,*TS-COMPLEX-RATIONAL*,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-COMPLEMENT0,*TS-POSITIVE-RATIO*,TS-INTERSECTION0,*TS-INTEGER>1*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,ANS,TS,NUMERIC-TYPE-SET,TS1,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-UNARY-/">type-set-unary-/</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-unary-_2F" data-sym="TYPE-SET-UNARY-/" title="(defun type-set-unary-/ (ts ttree ttree0)
  (let* ((ts1 (numeric-type-set ts))
         (ans
          (ts-builder ts1 (*ts-zero* *ts-zero*) (*ts-one* *ts-one*)
                      (*ts-integer&gt;1*
...">type-set-unary-/</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ts1 (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts)) (ans (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts1
          (*ts-zero* *ts-zero*)
          (*ts-one* *ts-one*)
          (*ts-integer&gt;1* (<a class="sym-link system" href="basis-b.html#def-ts-intersection0" data-sym="TS-INTERSECTION0">ts-intersection0</a> *ts-positive-ratio*
              (<a class="sym-link system" href="basis-b.html#def-ts-complement0" data-sym="TS-COMPLEMENT0">ts-complement0</a> *ts-zero*)
              (<a class="sym-link system" href="basis-b.html#def-ts-complement0" data-sym="TS-COMPLEMENT0">ts-complement0</a> *ts-one*)))
          (*ts-positive-ratio* *ts-positive-rational*)
          (*ts-negative-rational* *ts-negative-rational*)
          (*ts-complex-rational* *ts-complex-rational*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-acl2-number*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-acl2-number* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-numerator" data-defines="TYPE-SET-NUMERATOR" data-references="T,PUFFERT,MV,*TS-INTEGER*,TS=,COND,*TS-NEGATIVE-INTEGER*,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-INTEGER*,*TS-POSITIVE-RATIO*,*TS-INTEGER>1*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,ANS,RATIONAL-TYPE-SET,TS1,LET*,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-NUMERATOR" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,T,TTREE0,PUFFERT,MV,*TS-INTEGER*,TS=,COND,*TS-NEGATIVE-INTEGER*,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-INTEGER*,*TS-POSITIVE-RATIO*,*TS-INTEGER>1*,*TS-ONE*,*TS-ZERO*,TS-BUILDER,ANS,TS,RATIONAL-TYPE-SET,TS1,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-NUMERATOR">type-set-numerator</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-numerator" data-sym="TYPE-SET-NUMERATOR" title="(defun type-set-numerator (ts ttree ttree0)
  (let* ((ts1 (rational-type-set ts))
         (ans
          (ts-builder ts1 (*ts-zero* *ts-zero*) (*ts-one* *ts-one*)
                      (*ts-integer&gt;1* *ts-integer&gt;1*)
...">type-set-numerator</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ts1 (<a class="sym-link local-def" href="#def-rational-type-set" data-sym="RATIONAL-TYPE-SET" title="(defmacro rational-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-rational*)))
...">rational-type-set</a> ts)) (ans (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts1
          (*ts-zero* *ts-zero*)
          (*ts-one* *ts-one*)
          (*ts-integer&gt;1* *ts-integer&gt;1*)
          (*ts-positive-ratio* *ts-positive-integer*)
          (*ts-negative-rational* *ts-negative-integer*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-integer*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-denominator" data-defines="TYPE-SET-DENOMINATOR" data-references="T,PUFFERT,MV,*TS-POSITIVE-INTEGER*,TS=,COND,*TS-INTEGER>1*,*TS-RATIO*,*TS-ONE*,*TS-INTEGER*,TS-BUILDER,ANS,RATIONAL-TYPE-SET,TS1,LET*,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-DENOMINATOR" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,T,TTREE0,PUFFERT,MV,*TS-POSITIVE-INTEGER*,TS=,COND,*TS-INTEGER>1*,*TS-RATIO*,*TS-ONE*,*TS-INTEGER*,TS-BUILDER,ANS,TS,RATIONAL-TYPE-SET,TS1,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-DENOMINATOR">type-set-denominator</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-denominator" data-sym="TYPE-SET-DENOMINATOR" title="(defun type-set-denominator (ts ttree ttree0)
  (let* ((ts1 (rational-type-set ts))
         (ans
          (ts-builder ts1 (*ts-integer* *ts-one*) (*ts-ratio* *ts-integer&gt;1*))))
    (cond
...">type-set-denominator</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ts1 (<a class="sym-link local-def" href="#def-rational-type-set" data-sym="RATIONAL-TYPE-SET" title="(defmacro rational-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-rational*)))
...">rational-type-set</a> ts)) (ans (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts1
          (*ts-integer* *ts-one*)
          (*ts-ratio* *ts-integer&gt;1*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-positive-integer*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-positive-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-realpart" data-defines="TYPE-SET-REALPART" data-references="NUMERIC-TYPE-SET,T,PUFFERT,*TS-RATIONAL*,MV,*TS-COMPLEX-RATIONAL*,TS-INTERSECTP,COND,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-REALPART" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,NUMERIC-TYPE-SET,T,TTREE0,PUFFERT,*TS-RATIONAL*,MV,*TS-COMPLEX-RATIONAL*,TS,TS-INTERSECTP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-REALPART">type-set-realpart</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-realpart" data-sym="TYPE-SET-REALPART" title="(defun type-set-realpart (ts ttree ttree0)
  (cond
   ((ts-intersectp ts *ts-complex-rational*)
    (mv *ts-rational* (puffert ttree0)))
   (t (mv (numeric-type-set ts) (puffert ttree)))))">type-set-realpart</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-complex-rational*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-rational* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-numeric-type-set" data-sym="NUMERIC-TYPE-SET" title="(defmacro numeric-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-acl2-number*)))
...">numeric-type-set</a> ts) (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-imagpart" data-defines="TYPE-SET-IMAGPART" data-references="*TS-ZERO*,T,*TS-RATIONAL*,TS-INTERSECTP,PUFFERT,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-UNION,MV,*TS-COMPLEX-RATIONAL*,TS-SUBSETP,COND,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-IMAGPART" data-part-args="TTREE0,TTREE,TS" data-part-body="*TS-ZERO*,T,TTREE0,*TS-RATIONAL*,TS-INTERSECTP,TTREE,PUFFERT,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-UNION,MV,*TS-COMPLEX-RATIONAL*,TS,TS-SUBSETP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-IMAGPART">type-set-imagpart</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-imagpart" data-sym="TYPE-SET-IMAGPART" title="(defun type-set-imagpart (ts ttree ttree0)
  (cond
   ((ts-subsetp ts *ts-complex-rational*)
    (mv (ts-union *ts-positive-rational* *ts-negative-rational*)
        (puffert ttree)))
...">type-set-imagpart</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts *ts-complex-rational*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-union *ts-positive-rational* *ts-negative-rational*)
        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
    ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-complex-rational*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-rational* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-zero* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-complex" data-defines="TYPE-SET-COMPLEX" data-references="TS-UNION,T,*TS-ACL2-NUMBER*,*TS-RATIONAL*,*TS-COMPLEX-RATIONAL*,*TS-EMPTY*,TS-INTERSECTION,PUFFERT,MV,*TS-ZERO*,TS=,COND,RATIONAL-TYPE-SET,LET,TTREE0,TTREE,TS2,TS1,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-COMPLEX" data-part-args="TTREE0,TTREE,TS2,TS1" data-part-body="TS-UNION,T,TTREE0,*TS-ACL2-NUMBER*,*TS-RATIONAL*,*TS-COMPLEX-RATIONAL*,*TS-EMPTY*,TS-INTERSECTION,TTREE,PUFFERT,MV,*TS-ZERO*,TS=,COND,TS2,RATIONAL-TYPE-SET,TS1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-COMPLEX">type-set-complex</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-complex" data-sym="TYPE-SET-COMPLEX" title="(defun type-set-complex (ts1 ts2 ttree ttree0)
  (let ((ts1 (rational-type-set ts1)) (ts2 (rational-type-set ts2)))
    (cond ((ts= ts2 *ts-zero*) (mv ts1 (puffert ttree)))
          ((ts= (ts-intersection ts2 *ts-zero*) *ts-empty*)
           (mv *ts-complex-rational* (puffert ttree)))
...">type-set-complex</a>
  (ts1 ts2 ttree ttree0)
  (let ((ts1 (<a class="sym-link local-def" href="#def-rational-type-set" data-sym="RATIONAL-TYPE-SET" title="(defmacro rational-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-rational*)))
...">rational-type-set</a> ts1)) (ts2 (<a class="sym-link local-def" href="#def-rational-type-set" data-sym="RATIONAL-TYPE-SET" title="(defmacro rational-type-set (ts)
  `(let ((numeric-ts-use-nowhere-else
          (ts-intersection
           (check-vars-not-free (numeric-ts-use-nowhere-else) ,ts)
           *ts-rational*)))
...">rational-type-set</a> ts2)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-zero*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts1 (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
      ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (ts-intersection ts2 *ts-zero*) *ts-empty*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-complex-rational* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
      ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-rational*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-acl2-number* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-union ts1 *ts-complex-rational*) (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block other" id="form-102" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> recognizer-tuple
  (fn (nume . true-ts) (false-ts . strongp) . rune)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block constant" id="def-_2Ainitial-recognizer-alist_2A" data-defines="*INITIAL-RECOGNIZER-ALIST*" data-references="*TS-SYMBOL*,SYMBOLP,NULL,*TS-STRING*,STRINGP,*TS-CHARACTER*,CHARACTERP,*TS-TRUE-LIST*,TRUE-LISTP,*TS-NIL*,TS-UNION,LISTP,ATOM,*TS-CONS*,CONSP,*TS-ACL2-NUMBER*,ACL2-NUMBERP,*TS-COMPLEX-RATIONAL*,COMPLEX-RATIONALP,*TS-RATIONAL*,RATIONALP,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,T,TS-COMPLEMENT,*TS-INTEGER*,INTEGERP,QUOTE,RECOGNIZER-TUPLE,MAKE,LIST,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*INITIAL-RECOGNIZER-ALIST*">*initial-recognizer-alist*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Ainitial-recognizer-alist_2A" data-sym="*INITIAL-RECOGNIZER-ALIST*" title="(defconst *initial-recognizer-alist*
          (list
           (make recognizer-tuple :fn &#39;integerp :true-ts *ts-integer* :false-ts
                 (ts-complement *ts-integer*) :strongp t :nume nil :rune
                 *fake-rune-for-anonymous-enabled-rule*)
...">*initial-recognizer-alist*</a>
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'integerp
      <span class="keyword">:true-ts</span> *ts-integer*
      <span class="keyword">:false-ts</span> (ts-complement *ts-integer*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'rationalp
      <span class="keyword">:true-ts</span> *ts-rational*
      <span class="keyword">:false-ts</span> (ts-complement *ts-rational*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'complex-rationalp
      <span class="keyword">:true-ts</span> *ts-complex-rational*
      <span class="keyword">:false-ts</span> (ts-complement *ts-complex-rational*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'acl2-numberp
      <span class="keyword">:true-ts</span> *ts-acl2-number*
      <span class="keyword">:false-ts</span> (ts-complement *ts-acl2-number*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'consp
      <span class="keyword">:true-ts</span> *ts-cons*
      <span class="keyword">:false-ts</span> (ts-complement *ts-cons*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> '<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a>
      <span class="keyword">:true-ts</span> (ts-complement *ts-cons*)
      <span class="keyword">:false-ts</span> *ts-cons*
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> '<a class="sym-link system" href="axioms.html#def-listp" data-sym="LISTP">listp</a>
      <span class="keyword">:true-ts</span> (ts-union *ts-cons* *ts-nil*)
      <span class="keyword">:false-ts</span> (ts-complement (ts-union *ts-cons* *ts-nil*))
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> '<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>
      <span class="keyword">:true-ts</span> *ts-true-list*
      <span class="keyword">:false-ts</span> (ts-complement *ts-true-list*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'characterp
      <span class="keyword">:true-ts</span> *ts-character*
      <span class="keyword">:false-ts</span> (ts-complement *ts-character*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'stringp
      <span class="keyword">:true-ts</span> *ts-string*
      <span class="keyword">:false-ts</span> (ts-complement *ts-string*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> '<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a>
      <span class="keyword">:true-ts</span> *ts-nil*
      <span class="keyword">:false-ts</span> (ts-complement *ts-nil*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)
    (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> recognizer-tuple
      <span class="keyword">:fn</span> 'symbolp
      <span class="keyword">:true-ts</span> *ts-symbol*
      <span class="keyword">:false-ts</span> (ts-complement *ts-symbol*)
      <span class="keyword">:strongp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:nume</span> nil
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*)))</pre>
  </div>

<div class="form-block function" id="def-most-recent-enabled-recog-tuple1" data-defines="MOST-RECENT-ENABLED-RECOG-TUPLE1" data-references="CDR,T,CAR,RECOGNIZER-TUPLE,ACCESS,ENABLED-NUMEP,ENDP,COND,ENS,LST,DEFUN" data-used-by="MOST-RECENT-ENABLED-RECOG-TUPLE" data-part-name="MOST-RECENT-ENABLED-RECOG-TUPLE1" data-part-args="ENS,LST" data-part-body="CDR,MOST-RECENT-ENABLED-RECOG-TUPLE1,T,ENS,CAR,RECOGNIZER-TUPLE,ACCESS,ENABLED-NUMEP,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE1">most-recent-enabled-recog-tuple1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple1" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE1" title="(defun most-recent-enabled-recog-tuple1 (lst ens)
  (cond ((endp lst) nil)
        ((enabled-numep (access recognizer-tuple (car lst) :nume) ens)
         (car lst))
        (t (most-recent-enabled-recog-tuple1 (cdr lst) ens))))">most-recent-enabled-recog-tuple1</a>
  (lst <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    ((<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple (car lst) <span class="keyword">:nume</span>)
       <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>) (car lst))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple1" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE1" title="(defun most-recent-enabled-recog-tuple1 (lst ens)
  (cond ((endp lst) nil)
        ((enabled-numep (access recognizer-tuple (car lst) :nume) ens)
         (car lst))
        (t (most-recent-enabled-recog-tuple1 (cdr lst) ens))))">most-recent-enabled-recog-tuple1</a> (cdr lst) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block function" id="def-most-recent-enabled-recog-tuple" data-defines="MOST-RECENT-ENABLED-RECOG-TUPLE" data-references="MOST-RECENT-ENABLED-RECOG-TUPLE1,AND,RECOGNIZER-ALIST,QUOTE,GETPROPC,LST,LET,ENS,WRLD,FN,DEFUN" data-used-by="TYPE-SET-REC,RECOGNIZER-EXPR-P,STRONG-RECOGNIZER-EXPR-P,TERM-AND-TYP-TO-LOOKUP" data-part-name="MOST-RECENT-ENABLED-RECOG-TUPLE" data-part-args="ENS,WRLD,FN" data-part-body="ENS,MOST-RECENT-ENABLED-RECOG-TUPLE1,AND,WRLD,RECOGNIZER-ALIST,QUOTE,FN,GETPROPC,LST,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE">most-recent-enabled-recog-tuple</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE" title="(defun most-recent-enabled-recog-tuple (fn wrld ens)
  (let ((lst (getpropc fn &#39;recognizer-alist nil wrld)))
    (and lst (most-recent-enabled-recog-tuple1 lst ens))))">most-recent-enabled-recog-tuple</a>
  (fn wrld <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (let ((lst (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'recognizer-alist nil wrld)))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> lst (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple1" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE1" title="(defun most-recent-enabled-recog-tuple1 (lst ens)
  (cond ((endp lst) nil)
        ((enabled-numep (access recognizer-tuple (car lst) :nume) ens)
         (car lst))
        (t (most-recent-enabled-recog-tuple1 (cdr lst) ens))))">most-recent-enabled-recog-tuple1</a> lst <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))</pre>
  </div>

<div class="form-block function" id="def-type-set-recognizer" data-defines="TYPE-SET-RECOGNIZER" data-references="T,PUSH-LEMMA,MV,*TS-BOOLEAN*,TS=,COND,*TS-NIL*,*TS-T*,RECOGNIZER-TUPLE,ACCESS,TS-BUILDER,TS,LET,TTREE0,TTREE,ARG-TS,RECOG-TUPLE,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-RECOGNIZER" data-part-args="TTREE0,TTREE,ARG-TS,RECOG-TUPLE" data-part-body="TTREE,T,TTREE0,PUSH-LEMMA,MV,*TS-BOOLEAN*,TS=,COND,*TS-NIL*,*TS-T*,RECOG-TUPLE,RECOGNIZER-TUPLE,ACCESS,ARG-TS,TS-BUILDER,TS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-RECOGNIZER">type-set-recognizer</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-recognizer" data-sym="TYPE-SET-RECOGNIZER" title="(defun type-set-recognizer (recog-tuple arg-ts ttree ttree0)
  (let ((ts
         (ts-builder arg-ts
                     ((access recognizer-tuple recog-tuple :true-ts) *ts-t*)
                     ((access recognizer-tuple recog-tuple :false-ts)
...">type-set-recognizer</a>
  (recog-tuple arg-ts ttree ttree0)
  (let ((ts (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> arg-ts
         ((<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:true-ts</span>) *ts-t*)
         ((<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:false-ts</span>) *ts-nil*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-boolean*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean*
          (push-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:rune</span>)
            ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts
          (push-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:rune</span>)
            ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-car" data-defines="TYPE-SET-CAR" data-references="*TS-NIL*,T,*TS-UNKNOWN*,MV,*TS-CONS*,TS-INTERSECTP,COND,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-CAR" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,*TS-NIL*,T,TTREE0,*TS-UNKNOWN*,MV,*TS-CONS*,TS,TS-INTERSECTP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-CAR">type-set-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-car" data-sym="TYPE-SET-CAR" title="(defun type-set-car (ts ttree ttree0)
  (cond ((ts-intersectp ts *ts-cons*) (mv *ts-unknown* ttree0))
        (t (mv *ts-nil* ttree))))">type-set-car</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-cons*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-unknown* ttree0))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* ttree))))</pre>
  </div>

<div class="form-block function" id="def-type-set-cdr" data-defines="TYPE-SET-CDR" data-references="PUFFERT,*TS-UNKNOWN*,TS=,IF,MV,*TS-NIL*,OTHERWISE,TS-COMPLEMENT,*TS-IMPROPER-CONS*,*TS-TRUE-LIST*,*TS-PROPER-CONS*,TS-BUILDER,CDR-TS,LET,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-CDR" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,PUFFERT,TTREE0,*TS-UNKNOWN*,TS=,IF,MV,*TS-NIL*,OTHERWISE,TS-COMPLEMENT,*TS-IMPROPER-CONS*,*TS-TRUE-LIST*,*TS-PROPER-CONS*,TS,TS-BUILDER,CDR-TS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-CDR">type-set-cdr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-cdr" data-sym="TYPE-SET-CDR" title="(defun type-set-cdr (ts ttree ttree0)
  (let ((cdr-ts
         (ts-builder ts (*ts-proper-cons* *ts-true-list*)
                     (*ts-improper-cons* (ts-complement *ts-true-list*))
                     (otherwise *ts-nil*))))
...">type-set-cdr</a>
  (ts ttree ttree0)
  (let ((cdr-ts (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts
         (*ts-proper-cons* *ts-true-list*)
         (*ts-improper-cons* (ts-complement *ts-true-list*))
         (otherwise *ts-nil*))))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> cdr-ts
      (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> cdr-ts *ts-unknown*)
        ttree0
        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-coerce" data-defines="TYPE-SET-COERCE" data-references="TS-UNION,*TS-NON-T-NON-NIL-SYMBOL*,TS-DISJOINTP,QUOTEP,*TS-NIL*,T,PUFFERT,*TS-TRUE-LIST*,MV,*TS-STRING*,TS-INTERSECTP,LIST,QUOTE,FARGN,EQUAL,COND,TTREE0,TTREE2,TTREE1,TS2,TS1,TERM,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-COERCE" data-part-args="TTREE0,TTREE2,TTREE1,TS2,TS1,TERM" data-part-body="TS-UNION,TTREE2,TS2,*TS-NON-T-NON-NIL-SYMBOL*,TS-DISJOINTP,QUOTEP,TTREE1,*TS-NIL*,T,TTREE0,PUFFERT,*TS-TRUE-LIST*,MV,TS1,*TS-STRING*,TS-INTERSECTP,LIST,QUOTE,TERM,FARGN,EQUAL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-COERCE">type-set-coerce</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-coerce" data-sym="TYPE-SET-COERCE" title="(defun type-set-coerce (term ts1 ts2 ttree1 ttree2 ttree0)
  (cond
   ((equal (fargn term 2) &#39;&#39;list)
    (cond
     ((ts-intersectp *ts-string* ts1) (mv *ts-true-list* (puffert ttree0)))
...">type-set-coerce</a>
  (term ts1 ts2 ttree1 ttree2 ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) ''<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> *ts-string* ts1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-true-list* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree1)))))
    ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-string* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
    ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> *ts-non-t-non-nil-symbol* ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-string* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-union *ts-true-list* *ts-string*) (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-intern-in-package-of-symbol" data-defines="TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL" data-references="T,*TS-SYMBOL*,PUFFERT,*TS-NIL*,MV,*TS-STRING*,TS-DISJOINTP,COND,TTREE0,TTREE2,TTREE1,TS2,TS1,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL" data-part-args="TTREE0,TTREE2,TTREE1,TS2,TS1" data-part-body="TTREE0,T,TTREE2,*TS-SYMBOL*,TS2,TTREE1,PUFFERT,*TS-NIL*,MV,*TS-STRING*,TS1,TS-DISJOINTP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL">type-set-intern-in-package-of-symbol</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-intern-in-package-of-symbol" data-sym="TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL" title="(defun type-set-intern-in-package-of-symbol (ts1 ts2 ttree1 ttree2 ttree0)
  (cond ((ts-disjointp ts1 *ts-string*) (mv *ts-nil* (puffert ttree1)))
        ((ts-disjointp ts2 *ts-symbol*) (mv *ts-nil* (puffert ttree2)))
        (t (mv *ts-symbol* (puffert ttree0)))))">type-set-intern-in-package-of-symbol</a>
  (ts1 ts2 ttree1 ttree2 ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts1 *ts-string*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree1)))
    ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts2 *ts-symbol*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-symbol* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-length" data-defines="TYPE-SET-LENGTH" data-references="T,PUFFERT,MV,*TS-INTEGER*,TS=,COND,*TS-ZERO*,OTHERWISE,*TS-POSITIVE-INTEGER*,*TS-CONS*,*TS-NON-NEGATIVE-INTEGER*,*TS-STRING*,TS-BUILDER,ANS,LET,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-LENGTH" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE,T,TTREE0,PUFFERT,MV,*TS-INTEGER*,TS=,COND,*TS-ZERO*,OTHERWISE,*TS-POSITIVE-INTEGER*,*TS-CONS*,*TS-NON-NEGATIVE-INTEGER*,*TS-STRING*,TS,TS-BUILDER,ANS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-LENGTH">type-set-length</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-length" data-sym="TYPE-SET-LENGTH" title="(defun type-set-length (ts ttree ttree0)
  (let ((ans
         (ts-builder ts (*ts-string* *ts-non-negative-integer*)
                     (*ts-cons* *ts-positive-integer*) (otherwise *ts-zero*))))
    (cond ((ts= ans *ts-integer*) (mv *ts-integer* (puffert ttree0)))">type-set-length</a>
  (ts ttree ttree0)
  (let ((ans (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts
         (*ts-string* *ts-non-negative-integer*)
         (*ts-cons* *ts-positive-integer*)
         (otherwise *ts-zero*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ans *ts-integer*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-cons" data-defines="TYPE-SET-CONS" data-references="T,PUFFERT,MV,*TS-CONS*,TS=,COND,*TS-IMPROPER-CONS*,OTHERWISE,*TS-PROPER-CONS*,*TS-TRUE-LIST*,TS-BUILDER,TS,LET,TTREE0,TTREE,TS2,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-CONS" data-part-args="TTREE0,TTREE,TS2" data-part-body="TTREE,T,TTREE0,PUFFERT,MV,*TS-CONS*,TS=,COND,*TS-IMPROPER-CONS*,OTHERWISE,*TS-PROPER-CONS*,*TS-TRUE-LIST*,TS2,TS-BUILDER,TS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-CONS">type-set-cons</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-cons" data-sym="TYPE-SET-CONS" title="(defun type-set-cons (ts2 ttree ttree0)
  (let ((ts
         (ts-builder ts2 (*ts-true-list* *ts-proper-cons*)
                     (otherwise *ts-improper-cons*))))
    (cond ((ts= ts *ts-cons*) (mv ts (puffert ttree0)))">type-set-cons</a>
  (ts2 ttree ttree0)
  (let ((ts (<a class="sym-link system" href="basis-b.html#def-ts-builder" data-sym="TS-BUILDER">ts-builder</a> ts2
         (*ts-true-list* *ts-proper-cons*)
         (otherwise *ts-improper-cons*))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-cons*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))))</pre>
  </div>

<div class="form-block constant" id="def-_2Asingleton-type-sets_2A" data-defines="*SINGLETON-TYPE-SETS*" data-references="*TS-ONE*,*TS-ZERO*,*TS-NIL*,*TS-T*,LIST,DEFCONST" data-used-by="TYPE-SET-REC,TYPE-SET-EQUAL" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*SINGLETON-TYPE-SETS*">*singleton-type-sets*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Asingleton-type-sets_2A" data-sym="*SINGLETON-TYPE-SETS*" title="(defconst *singleton-type-sets* (list *ts-t* *ts-nil* *ts-zero* *ts-one*))">*singleton-type-sets*</a>
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> *ts-t* *ts-nil* *ts-zero* *ts-one*))</pre>
  </div>

<div class="form-block function" id="def-type-set-equal" data-defines="TYPE-SET-EQUAL" data-references="*TS-NIL*,T,*TS-BOOLEAN*,TS-INTERSECTP,PUFFERT,*TS-T*,MV,TS=,*SINGLETON-TYPE-SETS*,MEMBER,COND,TTREE0,TTREE,TS2,TS1,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-EQUAL" data-part-args="TTREE0,TTREE,TS2,TS1" data-part-body="*TS-NIL*,T,TTREE0,*TS-BOOLEAN*,TS-INTERSECTP,TTREE,PUFFERT,*TS-T*,MV,TS2,TS=,*SINGLETON-TYPE-SETS*,TS1,MEMBER,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-EQUAL">type-set-equal</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-equal" data-sym="TYPE-SET-EQUAL" title="(defun type-set-equal (ts1 ts2 ttree ttree0)
  (cond
   ((member ts1 *singleton-type-sets*)
    (cond ((ts= ts1 ts2) (mv *ts-t* (puffert ttree)))
          ((ts-intersectp ts1 ts2) (mv *ts-boolean* (puffert ttree0)))
...">type-set-equal</a>
  (ts1 ts2 ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-member" data-sym="MEMBER">member</a> ts1 <a class="sym-link local-def" href="#def-_2Asingleton-type-sets_2A" data-sym="*SINGLETON-TYPE-SETS*" title="(defconst *singleton-type-sets* (list *ts-t* *ts-nil* *ts-zero* *ts-one*))">*singleton-type-sets*</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
        ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))
    ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-boolean* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-quote" data-defines="TYPE-SET-QUOTE" data-references="*TS-IMPROPER-CONS*,*TS-PROPER-CONS*,TRUE-LISTP,*TS-CHARACTER*,*TS-STRING*,STRINGP,*TS-NON-T-NON-NIL-SYMBOL*,*TS-NIL*,*TS-T*,EQ,SYMBOLP,*TS-COMPLEX-RATIONAL*,COMPLEX-RATIONALP,*TS-NEGATIVE-RATIO*,*TS-POSITIVE-RATIO*,*TS-NEGATIVE-INTEGER*,T,*TS-INTEGER>1*,>,*TS-ONE*,*TS-ZERO*,INT=,INTEGERP,RATIONALP,ATOM,COND,EVG,DEFUN" data-used-by="TYPE-SET-REC,TYPE-SET-FINISH-1" data-part-name="TYPE-SET-QUOTE" data-part-args="EVG" data-part-body="*TS-IMPROPER-CONS*,*TS-PROPER-CONS*,TRUE-LISTP,*TS-CHARACTER*,*TS-STRING*,STRINGP,*TS-NON-T-NON-NIL-SYMBOL*,*TS-NIL*,*TS-T*,EQ,SYMBOLP,*TS-COMPLEX-RATIONAL*,COMPLEX-RATIONALP,*TS-NEGATIVE-RATIO*,*TS-POSITIVE-RATIO*,*TS-NEGATIVE-INTEGER*,T,*TS-INTEGER>1*,>,*TS-ONE*,*TS-ZERO*,INT=,INTEGERP,RATIONALP,EVG,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-QUOTE">type-set-quote</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a>
  (evg)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> evg) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((rationalp evg) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((integerp evg) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> evg <span class="number">0</span>) *ts-zero*)
                ((<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> evg <span class="number">1</span>) *ts-one*)
                ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> evg <span class="number">0</span>) *ts-integer&gt;1*)
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-negative-integer*)))
            ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> evg <span class="number">0</span>) *ts-positive-ratio*)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-negative-ratio*)))
        ((complex-rationalp evg) *ts-complex-rational*)
        ((symbolp evg) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> evg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) *ts-t*)
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> evg nil) *ts-nil*)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-non-t-non-nil-symbol*)))
        ((stringp evg) *ts-string*)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-character*)))
    ((<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> evg) *ts-proper-cons*)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-improper-cons*)))</pre>
  </div>

<div class="form-block function" id="def-type-set-char-code" data-defines="TYPE-SET-CHAR-CODE" data-references="*TS-NON-NEGATIVE-INTEGER*,T,PUFFERT,*TS-ZERO*,MV,*TS-CHARACTER*,TS-DISJOINTP,COND,TTREE0,TTREE,TS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-CHAR-CODE" data-part-args="TTREE0,TTREE,TS" data-part-body="TTREE0,*TS-NON-NEGATIVE-INTEGER*,T,TTREE,PUFFERT,*TS-ZERO*,MV,*TS-CHARACTER*,TS,TS-DISJOINTP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-CHAR-CODE">type-set-char-code</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-char-code" data-sym="TYPE-SET-CHAR-CODE" title="(defun type-set-char-code (ts ttree ttree0)
  (cond ((ts-disjointp ts *ts-character*) (mv *ts-zero* (puffert ttree)))
        (t (mv *ts-non-negative-integer* (puffert ttree0)))))">type-set-char-code</a>
  (ts ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts *ts-character*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-zero* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-non-negative-integer* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))))</pre>
  </div>

<div class="form-block function" id="def-fn-count-1" data-defines="FN-COUNT-1" data-references="1+,FARGS,CADR,FN-COUNT-EVG,+,FQUOTEP,VARIABLEP,CDR,CAR,P-FN-CNT,FN-CNT,MV-LET,T,MV,ATOM,COND,INTEGERP,PSEUDO-TERMP,PSEUDO-TERM-LISTP,IF,AND,XARGS,DECLARE,P-FN-COUNT-ACC,FN-COUNT-ACC,X,FLG,DEFUN" data-used-by="FN-COUNT" data-part-name="FN-COUNT-1" data-part-args="P-FN-COUNT-ACC,FN-COUNT-ACC,X,FLG" data-part-declare="P-FN-COUNT-ACC,FN-COUNT-ACC,INTEGERP,PSEUDO-TERMP,X,PSEUDO-TERM-LISTP,FLG,IF,AND,XARGS,DECLARE" data-part-body="1+,FARGS,CADR,FN-COUNT-EVG,+,FQUOTEP,VARIABLEP,CDR,CAR,FN-COUNT-1,P-FN-CNT,FN-CNT,MV-LET,T,P-FN-COUNT-ACC,FN-COUNT-ACC,MV,X,ATOM,FLG,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FN-COUNT-1">fn-count-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fn-count-1" data-sym="FN-COUNT-1" title="(defun fn-count-1 (flg x fn-count-acc p-fn-count-acc)
  (declare
   (xargs :guard
    (and
     (if flg
...">fn-count-1</a>
  (flg x fn-count-acc p-fn-count-acc)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if flg
          (pseudo-term-listp x)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> x))
        (integerp fn-count-acc)
        (integerp p-fn-count-acc))
      <span class="keyword">:verify-guards</span> nil))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> fn-count-acc p-fn-count-acc))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (fn-cnt p-fn-cnt)
            (<a class="sym-link local-def" href="#def-fn-count-1" data-sym="FN-COUNT-1" title="(defun fn-count-1 (flg x fn-count-acc p-fn-count-acc)
  (declare
   (xargs :guard
    (and
     (if flg
...">fn-count-1</a> nil (car x) fn-count-acc p-fn-count-acc)
            (<a class="sym-link local-def" href="#def-fn-count-1" data-sym="FN-COUNT-1" title="(defun fn-count-1 (flg x fn-count-acc p-fn-count-acc)
  (declare
   (xargs :guard
    (and
     (if flg
...">fn-count-1</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cdr x) fn-cnt p-fn-cnt)))))
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> fn-count-acc p-fn-count-acc))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> fn-count-acc (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> p-fn-count-acc (fn-count-evg (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-fn-count-1" data-sym="FN-COUNT-1" title="(defun fn-count-1 (flg x fn-count-acc p-fn-count-acc)
  (declare
   (xargs :guard
    (and
     (if flg
...">fn-count-1</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x) (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> fn-count-acc) p-fn-count-acc))))</pre>
  </div>

<div class="form-block macro" id="def-fn-count" data-defines="FN-COUNT" data-references="FN-COUNT-1,QUASIQUOTE,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FN-COUNT">fn-count</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-fn-count" data-sym="FN-COUNT" title="(defmacro fn-count (term) `(fn-count-1 nil ,term 0 0))">fn-count</a> (term) `(<a class="sym-link local-def" href="#def-fn-count-1" data-sym="FN-COUNT-1" title="(defun fn-count-1 (flg x fn-count-acc p-fn-count-acc)
  (declare
   (xargs :guard
    (and
     (if flg
...">fn-count-1</a> nil ,TERM <span class="number">0</span> <span class="number">0</span>))</pre>
  </div>

<div class="form-block function" id="def-term-order" data-defines="TERM-ORDER" data-references="TERM-ORDER1,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM2,TERM1,DEFUN" data-used-by="TYPE-SET-REC,SEARCH-TYPE-ALIST-WITH-REST,INSERT-CDR-TERM-ORDER,EXTEND-TYPE-ALIST" data-part-name="TERM-ORDER" data-part-args="TERM2,TERM1" data-part-declare="TERM2,TERM1,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="TERM2,TERM1,TERM-ORDER1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERM-ORDER">term-order</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a>
  (term1 term2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
  (term-order1 term1 term2 nil))</pre>
  </div>

<div class="form-block other" id="form-120" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> type-prescription
  (basic-ts (nume . term)
    (hyps . backchain-limit-lst)
    (vars . rune) . <a class="sym-link system" href="history-management.html#def-corollary" data-sym="COROLLARY">corollary</a>)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-find-runed-type-prescription" data-defines="FIND-RUNED-TYPE-PRESCRIPTION" data-references="CDR,T,CAR,TYPE-PRESCRIPTION,ACCESS,EQUAL,NULL,COND,LST,RUNE,DEFUN" data-part-name="FIND-RUNED-TYPE-PRESCRIPTION" data-part-args="LST,RUNE" data-part-body="CDR,FIND-RUNED-TYPE-PRESCRIPTION,T,CAR,TYPE-PRESCRIPTION,ACCESS,RUNE,EQUAL,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-RUNED-TYPE-PRESCRIPTION">find-runed-type-prescription</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-runed-type-prescription" data-sym="FIND-RUNED-TYPE-PRESCRIPTION" title="(defun find-runed-type-prescription (rune lst)
  (cond ((null lst) nil)
        ((equal rune (access type-prescription (car lst) :rune)) (car lst))
        (t (find-runed-type-prescription rune (cdr lst)))))">find-runed-type-prescription</a>
  (rune lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    ((equal rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription (car lst) <span class="keyword">:rune</span>)) (car lst))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-runed-type-prescription" data-sym="FIND-RUNED-TYPE-PRESCRIPTION" title="(defun find-runed-type-prescription (rune lst)
  (cond ((null lst) nil)
        ((equal rune (access type-prescription (car lst) :rune)) (car lst))
        (t (find-runed-type-prescription rune (cdr lst)))))">find-runed-type-prescription</a> rune (cdr lst)))))</pre>
  </div>

<div class="form-block function" id="def-mv-atf" data-defines="MV-ATF" data-references="CONS-TAG-TREES,OR,MV,IF,TTREE2,TTREE1,FTA,TTA,MBF,MBT,NOT-FLG,DEFUN" data-used-by="TYPE-SET-REC,MV-ATF-2" data-part-name="MV-ATF" data-part-args="TTREE2,TTREE1,FTA,TTA,MBF,MBT,NOT-FLG" data-part-body="TTREE2,TTREE1,CONS-TAG-TREES,OR,TTA,FTA,MBT,MBF,MV,NOT-FLG,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MV-ATF">mv-atf</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a>
  (not-flg <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree1 ttree2)
  (if not-flg
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> mbf
      <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a>
      fta
      tta
      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf)
        (cons-tag-trees ttree1 ttree2)
        nil))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a>
      mbf
      tta
      fta
      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf)
        (cons-tag-trees ttree1 ttree2)
        nil))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false-error" data-defines="ASSUME-TRUE-FALSE-ERROR" data-references="FFN-SYMB,QUOTE,HARD,ER,TEMP-TEMP,X,TYPE-ALIST,DEFUN" data-used-by="TYPE-SET-REC,ASSOC-EQUIV+" data-part-name="ASSUME-TRUE-FALSE-ERROR" data-part-args="TEMP-TEMP,X,TYPE-ALIST" data-part-body="TEMP-TEMP,TYPE-ALIST,X,FFN-SYMB,ASSUME-TRUE-FALSE-ERROR,QUOTE,HARD,ER" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE-ERROR">assume-true-false-error</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false-error" data-sym="ASSUME-TRUE-FALSE-ERROR" title="(defun assume-true-false-error (type-alist x temp-temp)
  (er hard &#39;assume-true-false-error
      &quot;It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
...">assume-true-false-error</a>
  (type-alist x temp-temp)
  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
    '<a class="sym-link local-def" href="#def-assume-true-false-error" data-sym="ASSUME-TRUE-FALSE-ERROR" title="(defun assume-true-false-error (type-alist x temp-temp)
  (er hard &#39;assume-true-false-error
      &quot;It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
...">assume-true-false-error</a>
    <span class="string">"It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
    term ~x2 has type set ~x3."</span>
    (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)
    type-alist
    x
    temp-temp))</pre>
  </div>

<div class="form-block function" id="def-non-cons-cdr" data-defines="NON-CONS-CDR" data-references="T,FARGN,CONS,QUOTE,FFN-SYMB,EQ,FQUOTEP,VARIABLEP,COND,TERM,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="NON-CONS-CDR" data-part-args="TERM" data-part-body="T,FARGN,NON-CONS-CDR,CONS,QUOTE,FFN-SYMB,EQ,FQUOTEP,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NON-CONS-CDR">non-cons-cdr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-non-cons-cdr" data-sym="NON-CONS-CDR" title="(defun non-cons-cdr (term)
  (cond ((variablep term) term) ((fquotep term) term)
        ((eq (ffn-symb term) &#39;cons) (non-cons-cdr (fargn term 2))) (t term)))">non-cons-cdr</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) term)
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) term)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'cons) (<a class="sym-link local-def" href="#def-non-cons-cdr" data-sym="NON-CONS-CDR" title="(defun non-cons-cdr (term)
  (cond ((variablep term) term) ((fquotep term) term)
        ((eq (ffn-symb term) &#39;cons) (non-cons-cdr (fargn term 2))) (t term)))">non-cons-cdr</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term)))</pre>
  </div>

<div class="form-block function" id="def-canonical-representative" data-defines="CANONICAL-REPRESENTATIVE" data-references="CDDAR,*TS-T*,TS=,FARGN,EQUAL,CDR,FFN-SYMB,EQ,NOT,VARIABLEP,OR,CADAR,TS,CAAR,FIRST-TERM,LET,T,MV,NULL,COND,SYMBOLP,XARGS,DECLARE,TYPE-ALIST,TERM,EQUIV,DEFUN" data-used-by="TYPE-SET-REC,ASSOC-EQUIV+,EXTEND-TYPE-ALIST" data-part-name="CANONICAL-REPRESENTATIVE" data-part-args="TYPE-ALIST,TERM,EQUIV" data-part-declare="EQUIV,SYMBOLP,XARGS,DECLARE" data-part-body="CDDAR,*TS-T*,TS=,FARGN,EQUAL,CDR,CANONICAL-REPRESENTATIVE,EQUIV,FFN-SYMB,EQ,NOT,VARIABLEP,OR,CADAR,TS,CAAR,FIRST-TERM,LET,TERM,T,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CANONICAL-REPRESENTATIVE">canonical-representative</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a>
  (equiv term type-alist)
  (declare (xargs <span class="keyword">:guard</span> (symbolp equiv)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((first-term (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)) (ts (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> first-term)
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> first-term) equiv))) (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv term (cdr type-alist)))
          ((equal term (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> first-term <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-t*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> first-term <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> type-alist)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term nil))))
          ((equal term (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> first-term <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term nil))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv term (cdr type-alist))))))))</pre>
  </div>

<div class="form-block function" id="def-subst-type-alist1-check" data-defines="SUBST-TYPE-ALIST1-CHECK" data-references="CDR,FARGN,EQUAL,FFN-SYMB-P,AND,CAAR,TERM,LET,OR,T,NULL,COND,TYPE-ALIST,EQUIV,OLD,DEFUN" data-used-by="SUBST-TYPE-ALIST" data-part-name="SUBST-TYPE-ALIST1-CHECK" data-part-args="TYPE-ALIST,EQUIV,OLD" data-part-body="CDR,SUBST-TYPE-ALIST1-CHECK,FARGN,OLD,EQUAL,EQUIV,FFN-SYMB-P,AND,CAAR,TERM,LET,OR,T,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TYPE-ALIST1-CHECK">subst-type-alist1-check</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-type-alist1-check" data-sym="SUBST-TYPE-ALIST1-CHECK" title="(defun subst-type-alist1-check (old equiv type-alist)
  (cond ((null type-alist) nil)
        (t
         (or
          (let ((term (caar type-alist)))
...">subst-type-alist1-check</a>
  (old equiv type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (let ((term (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)))
          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term equiv)
            (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (equal old (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (equal old (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))))
        (<a class="sym-link local-def" href="#def-subst-type-alist1-check" data-sym="SUBST-TYPE-ALIST1-CHECK" title="(defun subst-type-alist1-check (old equiv type-alist)
  (cond ((null type-alist) nil)
        (t
         (or
          (let ((term (caar type-alist)))
...">subst-type-alist1-check</a> old equiv (cdr type-alist))))))</pre>
  </div>

<div class="form-block function" id="def-nil-fn" data-defines="NIL-FN" data-references="T,XARGS,DECLARE,DEFUN" data-used-by="*NIL-FN-TS-ENTRY*" data-part-name="NIL-FN" data-part-declare="T,XARGS,DECLARE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NIL-FN">nil-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-nil-fn" data-sym="NIL-FN" title="(defun nil-fn () (declare (xargs :guard t :mode :logic)) nil)">nil-fn</a>
  nil
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:mode</span> <span class="keyword">:logic</span>))
  nil)</pre>
  </div>

<div class="form-block constant" id="def-_2Anil-fn-ts-entry_2A" data-defines="*NIL-FN-TS-ENTRY*" data-references="PUSH-LEMMA,*TS-NIL*,NIL-FN,QUOTE,CONS-TERM,LIST*,DEFCONST" data-used-by="SUBST-TYPE-ALIST1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*NIL-FN-TS-ENTRY*">*nil-fn-ts-entry*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Anil-fn-ts-entry_2A" data-sym="*NIL-FN-TS-ENTRY*" title="(defconst *nil-fn-ts-entry*
          (list* (cons-term &#39;nil-fn nil) *ts-nil*
                 (push-lemma &#39;(:definition nil-fn) nil)))">*nil-fn-ts-entry*</a>
  (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> '<a class="sym-link local-def" href="#def-nil-fn" data-sym="NIL-FN" title="(defun nil-fn () (declare (xargs :guard t :mode :logic)) nil)">nil-fn</a> nil)
    *ts-nil*
    (push-lemma '(<span class="keyword">:definition</span> <a class="sym-link local-def" href="#def-nil-fn" data-sym="NIL-FN" title="(defun nil-fn () (declare (xargs :guard t :mode :logic)) nil)">nil-fn</a>) nil)))</pre>
  </div>

<div class="form-block function" id="def-subst-type-alist1" data-defines="SUBST-TYPE-ALIST1" data-references="CAR,CDDAR,CONS-TAG-TREES,PUFFERT,CADAR,LIST*,*NIL-FN-TS-ENTRY*,CONS,QUOTEP,CONS-TERM*,IF,EQUIV-CALL,FARGN,EQUAL,OR,FFN-SYMB-P,AND,CAAR,TERM,LET,CDR,T,REVERSE,NULL,COND,ACC,TYPE-ALIST,TTREE,EQUIV,OLD,NEW,DEFUN" data-used-by="SUBST-TYPE-ALIST" data-part-name="SUBST-TYPE-ALIST1" data-part-args="ACC,TYPE-ALIST,TTREE,EQUIV,OLD,NEW" data-part-body="CAR,CDDAR,CONS-TAG-TREES,PUFFERT,CADAR,LIST*,*NIL-FN-TS-ENTRY*,CONS,QUOTEP,CONS-TERM*,IF,EQUIV-CALL,FARGN,EQUAL,OR,FFN-SYMB-P,AND,CAAR,TERM,LET,CDR,TTREE,EQUIV,OLD,NEW,SUBST-TYPE-ALIST1,T,ACC,REVERSE,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TYPE-ALIST1">subst-type-alist1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-type-alist1" data-sym="SUBST-TYPE-ALIST1" title="(defun subst-type-alist1 (new old equiv ttree type-alist acc)
  (cond ((null type-alist) (reverse acc))
        (t
         (subst-type-alist1 new old equiv ttree (cdr type-alist)
                            (let ((term (caar type-alist)))
...">subst-type-alist1</a>
  (new old equiv ttree type-alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> acc))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subst-type-alist1" data-sym="SUBST-TYPE-ALIST1" title="(defun subst-type-alist1 (new old equiv ttree type-alist acc)
  (cond ((null type-alist) (reverse acc))
        (t
         (subst-type-alist1 new old equiv ttree (cdr type-alist)
                            (let ((term (caar type-alist)))
...">subst-type-alist1</a> new
        old
        equiv
        ttree
        (cdr type-alist)
        (let ((term (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term equiv)
               (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (equal old (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (equal old (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))) (let ((equiv-call (if (equal old (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                     (<a class="sym-link system" href="basis-b.html#def-cons-term_2A" data-sym="CONS-TERM*">cons-term*</a> equiv new (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                     (<a class="sym-link system" href="basis-b.html#def-cons-term_2A" data-sym="CONS-TERM*">cons-term*</a> equiv (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) new))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> equiv-call) (cons <a class="sym-link local-def" href="#def-_2Anil-fn-ts-entry_2A" data-sym="*NIL-FN-TS-ENTRY*" title="(defconst *nil-fn-ts-entry*
          (list* (cons-term &#39;nil-fn nil) *ts-nil*
                 (push-lemma &#39;(:definition nil-fn) nil)))">*nil-fn-ts-entry*</a> acc))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> equiv-call
                        (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist)
                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> type-alist) ttree)))
                      acc)))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car type-alist) acc))))))))</pre>
  </div>

<div class="form-block function" id="def-subst-type-alist" data-defines="SUBST-TYPE-ALIST" data-references="T,SUBST-TYPE-ALIST1,SUBST-TYPE-ALIST1-CHECK,COND,TYPE-ALIST,TTREE,EQUIV,OLD,NEW,DEFUN" data-used-by="EXTEND-TYPE-ALIST1" data-part-name="SUBST-TYPE-ALIST" data-part-args="TYPE-ALIST,TTREE,EQUIV,OLD,NEW" data-part-body="T,TTREE,NEW,SUBST-TYPE-ALIST1,TYPE-ALIST,EQUIV,OLD,SUBST-TYPE-ALIST1-CHECK,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TYPE-ALIST">subst-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-type-alist" data-sym="SUBST-TYPE-ALIST" title="(defun subst-type-alist (new old equiv ttree type-alist)
  (cond
   ((subst-type-alist1-check old equiv type-alist)
    (subst-type-alist1 new old equiv ttree type-alist nil))
   (t type-alist)))">subst-type-alist</a>
  (new old equiv ttree type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-subst-type-alist1-check" data-sym="SUBST-TYPE-ALIST1-CHECK" title="(defun subst-type-alist1-check (old equiv type-alist)
  (cond ((null type-alist) nil)
        (t
         (or
          (let ((term (caar type-alist)))
...">subst-type-alist1-check</a> old equiv type-alist) (<a class="sym-link local-def" href="#def-subst-type-alist1" data-sym="SUBST-TYPE-ALIST1" title="(defun subst-type-alist1 (new old equiv ttree type-alist acc)
  (cond ((null type-alist) (reverse acc))
        (t
         (subst-type-alist1 new old equiv ttree (cdr type-alist)
                            (let ((term (caar type-alist)))
...">subst-type-alist1</a> new old equiv ttree type-alist nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist)))</pre>
  </div>

<div class="form-block function" id="def-infect-type-alist-entry" data-defines="INFECT-TYPE-ALIST-ENTRY" data-references="CDDR,CONS-TAG-TREES,CADR,CAR,CONS,TTREE,ENTRY,DEFUN" data-used-by="INFECT-NEW-TYPE-ALIST-ENTRIES1,INFECT-NEW-TYPE-ALIST-ENTRIES2" data-part-name="INFECT-TYPE-ALIST-ENTRY" data-part-args="TTREE,ENTRY" data-part-body="TTREE,CDDR,CONS-TAG-TREES,CADR,ENTRY,CAR,CONS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INFECT-TYPE-ALIST-ENTRY">infect-type-alist-entry</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-infect-type-alist-entry" data-sym="INFECT-TYPE-ALIST-ENTRY" title="(defun infect-type-alist-entry (entry ttree)
  (cons (car entry) (cons (cadr entry) (cons-tag-trees (cddr entry) ttree))))">infect-type-alist-entry</a>
  (entry ttree)
  (cons (car entry)
    (cons (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> entry) (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> entry) ttree))))</pre>
  </div>

<div class="form-block function" id="def-infect-new-type-alist-entries2" data-defines="INFECT-NEW-TYPE-ALIST-ENTRIES2" data-references="INFECT-TYPE-ALIST-ENTRY,T,CDR,CAR,CONS,CAAR,EQUAL,NULL,COND,TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST,DEFUN" data-used-by="INFECT-NEW-TYPE-ALIST-ENTRIES1" data-part-name="INFECT-NEW-TYPE-ALIST-ENTRIES2" data-part-args="TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST" data-part-body="INFECT-TYPE-ALIST-ENTRY,T,TTREE,CDR,INFECT-NEW-TYPE-ALIST-ENTRIES2,CAR,CONS,OLD-TYPE-ALIST,CAAR,EQUAL,NEW-TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES2">infect-new-type-alist-entries2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-infect-new-type-alist-entries2" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES2" title="(defun infect-new-type-alist-entries2 (new-type-alist old-type-alist ttree)
  (cond ((null new-type-alist) nil)
        ((equal (caar new-type-alist) (caar old-type-alist))
         (cons (car new-type-alist)
               (infect-new-type-alist-entries2 (cdr new-type-alist)
...">infect-new-type-alist-entries2</a>
  (new-type-alist old-type-alist ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-type-alist) nil)
    ((equal (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> new-type-alist) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> old-type-alist)) (cons (car new-type-alist)
        (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries2" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES2" title="(defun infect-new-type-alist-entries2 (new-type-alist old-type-alist ttree)
  (cond ((null new-type-alist) nil)
        ((equal (caar new-type-alist) (caar old-type-alist))
         (cons (car new-type-alist)
               (infect-new-type-alist-entries2 (cdr new-type-alist)
...">infect-new-type-alist-entries2</a> (cdr new-type-alist)
          (cdr old-type-alist)
          ttree)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-infect-type-alist-entry" data-sym="INFECT-TYPE-ALIST-ENTRY" title="(defun infect-type-alist-entry (entry ttree)
  (cons (car entry) (cons (cadr entry) (cons-tag-trees (cddr entry) ttree))))">infect-type-alist-entry</a> (car new-type-alist) ttree)
        (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries2" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES2" title="(defun infect-new-type-alist-entries2 (new-type-alist old-type-alist ttree)
  (cond ((null new-type-alist) nil)
        ((equal (caar new-type-alist) (caar old-type-alist))
         (cons (car new-type-alist)
               (infect-new-type-alist-entries2 (cdr new-type-alist)
...">infect-new-type-alist-entries2</a> (cdr new-type-alist)
          (cdr old-type-alist)
          ttree)))))</pre>
  </div>

<div class="form-block function" id="def-infect-new-type-alist-entries1" data-defines="INFECT-NEW-TYPE-ALIST-ENTRIES1" data-references="1-,CDR,CAR,INFECT-TYPE-ALIST-ENTRY,CONS,INFECT-NEW-TYPE-ALIST-ENTRIES2,ZP,IF,N,TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST,DEFUN" data-used-by="INFECT-NEW-TYPE-ALIST-ENTRIES" data-part-name="INFECT-NEW-TYPE-ALIST-ENTRIES1" data-part-args="N,TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST" data-part-body="1-,CDR,INFECT-NEW-TYPE-ALIST-ENTRIES1,CAR,INFECT-TYPE-ALIST-ENTRY,CONS,TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST,INFECT-NEW-TYPE-ALIST-ENTRIES2,N,ZP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES1">infect-new-type-alist-entries1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-infect-new-type-alist-entries1" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES1" title="(defun infect-new-type-alist-entries1 (new-type-alist old-type-alist ttree n)
  (if (zp n)
      (infect-new-type-alist-entries2 new-type-alist old-type-alist ttree)
      (cons (infect-type-alist-entry (car new-type-alist) ttree)
            (infect-new-type-alist-entries1 (cdr new-type-alist) old-type-alist">infect-new-type-alist-entries1</a>
  (new-type-alist old-type-alist ttree n)
  (if (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> n)
    (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries2" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES2" title="(defun infect-new-type-alist-entries2 (new-type-alist old-type-alist ttree)
  (cond ((null new-type-alist) nil)
        ((equal (caar new-type-alist) (caar old-type-alist))
         (cons (car new-type-alist)
               (infect-new-type-alist-entries2 (cdr new-type-alist)
...">infect-new-type-alist-entries2</a> new-type-alist
      old-type-alist
      ttree)
    (cons (<a class="sym-link local-def" href="#def-infect-type-alist-entry" data-sym="INFECT-TYPE-ALIST-ENTRY" title="(defun infect-type-alist-entry (entry ttree)
  (cons (car entry) (cons (cadr entry) (cons-tag-trees (cddr entry) ttree))))">infect-type-alist-entry</a> (car new-type-alist) ttree)
      (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries1" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES1" title="(defun infect-new-type-alist-entries1 (new-type-alist old-type-alist ttree n)
  (if (zp n)
      (infect-new-type-alist-entries2 new-type-alist old-type-alist ttree)
      (cons (infect-type-alist-entry (car new-type-alist) ttree)
            (infect-new-type-alist-entries1 (cdr new-type-alist) old-type-alist">infect-new-type-alist-entries1</a> (cdr new-type-alist)
        old-type-alist
        ttree
        (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n)))))</pre>
  </div>

<div class="form-block function" id="def-infect-new-type-alist-entries" data-defines="INFECT-NEW-TYPE-ALIST-ENTRIES" data-references="LENGTH,-,INFECT-NEW-TYPE-ALIST-ENTRIES1,NULL,IF,TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="INFECT-NEW-TYPE-ALIST-ENTRIES" data-part-args="TTREE,OLD-TYPE-ALIST,NEW-TYPE-ALIST" data-part-body="LENGTH,-,OLD-TYPE-ALIST,INFECT-NEW-TYPE-ALIST-ENTRIES1,NEW-TYPE-ALIST,TTREE,NULL,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES">infect-new-type-alist-entries</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a>
  (new-type-alist old-type-alist ttree)
  (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ttree)
    new-type-alist
    (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries1" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES1" title="(defun infect-new-type-alist-entries1 (new-type-alist old-type-alist ttree n)
  (if (zp n)
      (infect-new-type-alist-entries2 new-type-alist old-type-alist ttree)
      (cons (infect-type-alist-entry (car new-type-alist) ttree)
            (infect-new-type-alist-entries1 (cdr new-type-alist) old-type-alist">infect-new-type-alist-entries1</a> new-type-alist
      old-type-alist
      ttree
      (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> new-type-alist) (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> old-type-alist)))))</pre>
  </div>

<div class="form-block function" id="def-extend-type-alist-simple" data-defines="EXTEND-TYPE-ALIST-SIMPLE" data-references="T,FQUOTEP,LIST*,CONS,VARIABLEP,*TS-UNKNOWN*,TS=,COND,TYPE-ALIST,TTREE,TS,TERM,DEFUN" data-used-by="TYPE-SET-REC,MV-ATF-2,EXTEND-TYPE-ALIST" data-part-name="EXTEND-TYPE-ALIST-SIMPLE" data-part-args="TYPE-ALIST,TTREE,TS,TERM" data-part-body="T,FQUOTEP,TTREE,LIST*,CONS,TERM,VARIABLEP,TYPE-ALIST,*TS-UNKNOWN*,TS,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-TYPE-ALIST-SIMPLE">extend-type-alist-simple</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a>
  (term ts ttree type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-unknown*) type-alist)
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (cons (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> term ts ttree) type-alist))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) type-alist)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> term ts ttree) type-alist))))</pre>
  </div>

<div class="form-block function" id="def-extend-type-alist1" data-defines="EXTEND-TYPE-ALIST1" data-references="SUBST-TYPE-ALIST,*TS-NIL*,TS=,T,PUFFERT,CONS-TERM*,LIST*,NOT,AND,COND,CONS,TYPE-ALIST,TTREE,TS,TERM,SWAP-FLG,ARG2-CANON,ARG1-CANON,BOTH-CANONICALP,OCCURSP2,OCCURSP1,EQUIV,DEFUN" data-used-by="TYPE-SET-REC,EXTEND-TYPE-ALIST" data-part-name="EXTEND-TYPE-ALIST1" data-part-args="TYPE-ALIST,TTREE,TS,TERM,SWAP-FLG,ARG2-CANON,ARG1-CANON,BOTH-CANONICALP,OCCURSP2,OCCURSP1,EQUIV" data-part-body="OCCURSP1,SUBST-TYPE-ALIST,OCCURSP2,TYPE-ALIST,*TS-NIL*,TS=,T,PUFFERT,ARG1-CANON,ARG2-CANON,EQUIV,CONS-TERM*,TTREE,TS,TERM,LIST*,BOTH-CANONICALP,SWAP-FLG,NOT,AND,COND,CONS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-TYPE-ALIST1">extend-type-alist1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a>
  (equiv occursp1
    occursp2
    both-canonicalp
    arg1-canon
    arg2-canon
    swap-flg
    term
    ts
    ttree
    type-alist)
  (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> swap-flg) both-canonicalp) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> term ts ttree))
      (swap-flg (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> (<a class="sym-link system" href="basis-b.html#def-cons-term_2A" data-sym="CONS-TERM*">cons-term*</a> equiv arg2-canon arg1-canon)
          ts
          (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> (<a class="sym-link system" href="basis-b.html#def-cons-term_2A" data-sym="CONS-TERM*">cons-term*</a> equiv arg1-canon arg2-canon)
          ts
          (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) type-alist)
      (swap-flg (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (occursp2 (<a class="sym-link local-def" href="#def-subst-type-alist" data-sym="SUBST-TYPE-ALIST" title="(defun subst-type-alist (new old equiv ttree type-alist)
  (cond
   ((subst-type-alist1-check old equiv type-alist)
    (subst-type-alist1 new old equiv ttree type-alist nil))
   (t type-alist)))">subst-type-alist</a> arg1-canon
              arg2-canon
              equiv
              ttree
              type-alist))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (occursp1 (<a class="sym-link local-def" href="#def-subst-type-alist" data-sym="SUBST-TYPE-ALIST" title="(defun subst-type-alist (new old equiv ttree type-alist)
  (cond
   ((subst-type-alist1-check old equiv type-alist)
    (subst-type-alist1 new old equiv ttree type-alist nil))
   (t type-alist)))">subst-type-alist</a> arg2-canon
              arg1-canon
              equiv
              ttree
              type-alist))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist))))))</pre>
  </div>

<div class="form-block function" id="def-extend-type-alist" data-defines="EXTEND-TYPE-ALIST" data-references="EXTEND-TYPE-ALIST-SIMPLE,CONS-TAG-TREES,EXTEND-TYPE-ALIST1,TERM-ORDER,SWAP-FLG,TTREE2,ARG2-CANON,CANONICALP2,OCCURSP2,CANONICAL-REPRESENTATIVE,TTREE1,ARG1-CANON,CANONICALP1,OCCURSP1,MV-LET,ARG2,ARG1,EQUIV,LET,PUFFERT,T,TS-INTERSECTP,*TS-NIL*,*TS-T*,TS=,OR,FARGN,EQUAL,FFN-SYMB,EQUIVALENCE-RELATIONP,FQUOTEP,NVARIABLEP,COND,QUOTEP,NOT,PSEUDO-TERMP,AND,XARGS,DECLARE,WRLD,TYPE-ALIST,TTREE,TS,TERM,DEFUN" data-used-by="RETURN-TYPE-ALIST,ASSUME-TRUE-FALSE-AGGRESSIVE-1,TYPE-SET-REC,ASSUME-TRUE-FALSE-<" data-part-name="EXTEND-TYPE-ALIST" data-part-args="WRLD,TYPE-ALIST,TTREE,TS,TERM" data-part-declare="QUOTEP,NOT,TERM,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="EXTEND-TYPE-ALIST-SIMPLE,CONS-TAG-TREES,EXTEND-TYPE-ALIST1,TERM-ORDER,SWAP-FLG,TTREE2,ARG2-CANON,CANONICALP2,OCCURSP2,CANONICAL-REPRESENTATIVE,TTREE1,ARG1-CANON,CANONICALP1,OCCURSP1,MV-LET,ARG2,ARG1,EQUIV,LET,TTREE,PUFFERT,EXTEND-TYPE-ALIST,T,TS-INTERSECTP,*TS-NIL*,*TS-T*,TS,TS=,OR,TYPE-ALIST,FARGN,EQUAL,WRLD,FFN-SYMB,EQUIVALENCE-RELATIONP,FQUOTEP,NOT,TERM,NVARIABLEP,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-TYPE-ALIST">extend-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a>
  (term ts ttree type-alist wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> term)
       (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term))
       (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) type-alist)
        ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-t*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-nil*) type-alist)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> term
                *ts-t*
                (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)
                type-alist
                wrld))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((equiv (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) (arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
              (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp1 canonicalp1 arg1-canon ttree1)
              (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg1 type-alist)
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp2 canonicalp2 arg2-canon ttree2)
                (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg2 type-alist)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1-canon arg2-canon) type-alist)
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((swap-flg (<a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a> arg1-canon arg2-canon)))
                      (<a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a> equiv
                        occursp1
                        occursp2
                        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                        arg1-canon
                        arg2-canon
                        swap-flg
                        term
                        ts
                        (cons-tag-trees ttree1 (cons-tag-trees ttree2 ttree))
                        type-alist))))))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> term ts ttree type-alist))))</pre>
  </div>

<div class="form-block function" id="def-zip-variable-type-alist" data-defines="ZIP-VARIABLE-TYPE-ALIST" data-references="CAR,CONS,T,CDR,*TS-UNKNOWN*,CAAR,TS=,NULL,COND,PAIRS,VARS,DEFUN" data-used-by="NORMALIZE,TYPE-SET-REC" data-part-name="ZIP-VARIABLE-TYPE-ALIST" data-part-args="PAIRS,VARS" data-part-body="CAR,CONS,T,CDR,ZIP-VARIABLE-TYPE-ALIST,*TS-UNKNOWN*,PAIRS,CAAR,TS=,VARS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ZIP-VARIABLE-TYPE-ALIST">zip-variable-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-zip-variable-type-alist" data-sym="ZIP-VARIABLE-TYPE-ALIST" title="(defun zip-variable-type-alist (vars pairs)
  (cond ((null vars) nil)
        ((ts= (caar pairs) *ts-unknown*)
         (zip-variable-type-alist (cdr vars) (cdr pairs)))
        (t
...">zip-variable-type-alist</a>
  (vars pairs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> vars) nil)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> pairs) *ts-unknown*) (<a class="sym-link local-def" href="#def-zip-variable-type-alist" data-sym="ZIP-VARIABLE-TYPE-ALIST" title="(defun zip-variable-type-alist (vars pairs)
  (cond ((null vars) nil)
        ((ts= (caar pairs) *ts-unknown*)
         (zip-variable-type-alist (cdr vars) (cdr pairs)))
        (t
...">zip-variable-type-alist</a> (cdr vars) (cdr pairs)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (car vars) (car pairs))
        (<a class="sym-link local-def" href="#def-zip-variable-type-alist" data-sym="ZIP-VARIABLE-TYPE-ALIST" title="(defun zip-variable-type-alist (vars pairs)
  (cond ((null vars) nil)
        ((ts= (caar pairs) *ts-unknown*)
         (zip-variable-type-alist (cdr vars) (cdr pairs)))
        (t
...">zip-variable-type-alist</a> (cdr vars) (cdr pairs))))))</pre>
  </div>

<div class="form-block function" id="def-assoc-equiv" data-defines="ASSOC-EQUIV" data-references="CDR,T,CAR,FARGN,EQUAL,IF,CAAR,FFN-SYMB-P,AND,EQ,COND,ALIST,ARG2,ARG1,FN,DEFUN" data-used-by="TYPE-SET-REC,ASSOC-EQUIV+" data-part-name="ASSOC-EQUIV" data-part-args="ALIST,ARG2,ARG1,FN" data-part-body="CDR,ASSOC-EQUIV,T,CAR,ARG1,ARG2,FARGN,EQUAL,IF,FN,CAAR,FFN-SYMB-P,AND,ALIST,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-EQUIV">assoc-equiv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a>
  (fn arg1 arg2 alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> alist nil) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) fn)
       (if (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) <span class="number">2</span>) arg2)
         (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) <span class="number">1</span>) arg1)
         (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) <span class="number">1</span>) arg2)
           (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) <span class="number">2</span>) arg1)))) (car alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a> fn arg1 arg2 (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-assoc-equiv_2B" data-defines="ASSOC-EQUIV+" data-references="MCONS-TERM*,ASSUME-TRUE-FALSE-ERROR,ERP,CDDR,<SAME_TYPE-ALIST>,KWOTE,LIST,HARD,ER,CADR,TS=,ASSOC-EQUIV,TEMP-TEMP,LET,CONS-TAG-TREES,TTREE2,ARG2-CANON,CANONICALP2,OCCURSP2,IGNORE,DECLARE,CANONICAL-REPRESENTATIVE,TTREE1,ARG1-CANON,CANONICALP1,OCCURSP1,MV-LET,T,PUSH-LEMMA,*TS-NIL*,QUOTEP,QUOTE,EQ,AND,PUFFERT,*TS-T*,MV,EQUAL,COND,TYPE-ALIST,ARG2,ARG1,EQUIV,DEFUN" data-used-by="ASSOC-TYPE-ALIST" data-part-name="ASSOC-EQUIV+" data-part-args="TYPE-ALIST,ARG2,ARG1,EQUIV" data-part-body="MCONS-TERM*,ASSUME-TRUE-FALSE-ERROR,ERP,CDDR,<SAME_TYPE-ALIST>,KWOTE,LIST,ASSOC-EQUIV+,HARD,ER,CADR,TS=,ASSOC-EQUIV,TEMP-TEMP,LET,CONS-TAG-TREES,TTREE2,ARG2-CANON,CANONICALP2,OCCURSP2,IGNORE,DECLARE,TYPE-ALIST,CANONICAL-REPRESENTATIVE,TTREE1,ARG1-CANON,CANONICALP1,OCCURSP1,MV-LET,T,PUSH-LEMMA,*TS-NIL*,QUOTEP,QUOTE,EQUIV,EQ,AND,PUFFERT,*TS-T*,MV,ARG2,ARG1,EQUAL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-EQUIV+">assoc-equiv+</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assoc-equiv_2B" data-sym="ASSOC-EQUIV+" title="(defun assoc-equiv+ (equiv arg1 arg2 type-alist)
  (cond ((equal arg1 arg2) (mv *ts-t* (puffert nil)))
        ((and (eq equiv &#39;equal) (quotep arg1) (quotep arg2))
         (mv *ts-nil* (push-lemma &#39;(:executable-counterpart equal) nil)))
        (t
...">assoc-equiv+</a>
  (equiv arg1 arg2 type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1 arg2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> nil)))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv 'equal) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil*
        (push-lemma '(<span class="keyword">:executable-counterpart</span> equal) nil)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp1 canonicalp1 arg1-canon ttree1)
        (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg1 type-alist)
        (declare (ignore canonicalp1))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp1 (equal arg1-canon arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree1)))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp1
             (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv 'equal)
             (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1-canon)
             (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil*
              (push-lemma '(<span class="keyword">:executable-counterpart</span> equal) ttree1)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp2 canonicalp2 arg2-canon ttree2)
              (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg2 type-alist)
              (declare (ignore canonicalp2))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp2 (equal arg1-canon arg2-canon)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 ttree2))))
                ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv 'equal)
                   occursp2
                   (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1-canon)
                   (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2-canon)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil*
                    (push-lemma '(<span class="keyword">:executable-counterpart</span> equal)
                      (cons-tag-trees ttree1 ttree2))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp-temp (<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a> equiv arg1-canon arg2-canon type-alist)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp-temp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-t*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                '<a class="sym-link local-def" href="#def-assoc-equiv_2B" data-sym="ASSOC-EQUIV+" title="(defun assoc-equiv+ (equiv arg1 arg2 type-alist)
  (cond ((equal arg1 arg2) (mv *ts-t* (puffert nil)))
        ((and (eq equiv &#39;equal) (quotep arg1) (quotep arg2))
         (mv *ts-nil* (push-lemma &#39;(:executable-counterpart equal) nil)))
        (t
...">assoc-equiv+</a>
                                <span class="string">"Please send the authors of ACL2 a replayable ~
                              transcript of this problem if possible, so that ~
                              they can see what went wrong in the function ~
                              assoc-equiv+.  The offending call was ~x0.  The ~
                              surprising type-set arose from a call of ~x1."</span>
                                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assoc-equiv_2B" data-sym="ASSOC-EQUIV+" title="(defun assoc-equiv+ (equiv arg1 arg2 type-alist)
  (cond ((equal arg1 arg2) (mv *ts-t* (puffert nil)))
        ((and (eq equiv &#39;equal) (quotep arg1) (quotep arg2))
         (mv *ts-nil* (push-lemma &#39;(:executable-counterpart equal) nil)))
        (t
...">assoc-equiv+</a>
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> equiv)
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg1)
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg2)
                                  type-alist)
                                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a>
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> equiv)
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg1-canon)
                                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg2-canon)
                                  '&lt;same_type-alist&gt;))
                              nil))
                          ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-nil*
                              (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp-temp)
                                (cons-tag-trees ttree1 ttree2))))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((erp (<a class="sym-link local-def" href="#def-assume-true-false-error" data-sym="ASSUME-TRUE-FALSE-ERROR" title="(defun assume-true-false-error (type-alist x temp-temp)
  (er hard &#39;assume-true-false-error
      &quot;It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
...">assume-true-false-error</a> type-alist
                                   (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> equiv arg1-canon arg2-canon)
                                   (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp))))
                              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp nil)))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil)))))))))))))</pre>
  </div>

<div class="form-block function" id="def-assoc-type-alist" data-defines="ASSOC-TYPE-ALIST" data-references="ASSOC-EQUAL,T,FARGN,ASSOC-EQUIV+,FFN-SYMB,EQUIVALENCE-RELATIONP,FQUOTEP,CDDR,CADR,MV,IF,ASSOC-EQ,TEMP,LET,VARIABLEP,COND,WRLD,TYPE-ALIST,TERM,DEFUN" data-used-by="RETURN-TYPE-ALIST,TYPE-SET-REC,LOOK-IN-TYPE-ALIST" data-part-name="ASSOC-TYPE-ALIST" data-part-args="WRLD,TYPE-ALIST,TERM" data-part-body="ASSOC-EQUAL,T,FARGN,ASSOC-EQUIV+,WRLD,FFN-SYMB,EQUIVALENCE-RELATIONP,FQUOTEP,CDDR,CADR,MV,IF,TYPE-ALIST,ASSOC-EQ,TEMP,LET,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-TYPE-ALIST">assoc-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assoc-type-alist" data-sym="ASSOC-TYPE-ALIST" title="(defun assoc-type-alist (term type-alist wrld)
  (cond
   ((variablep term)
    (let ((temp (assoc-eq term type-alist)))
      (if temp
...">assoc-type-alist</a>
  (term type-alist wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term type-alist)))
        (if temp
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp) (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    ((<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld) (<a class="sym-link local-def" href="#def-assoc-equiv_2B" data-sym="ASSOC-EQUIV+" title="(defun assoc-equiv+ (equiv arg1 arg2 type-alist)
  (cond ((equal arg1 arg2) (mv *ts-t* (puffert nil)))
        ((and (eq equiv &#39;equal) (quotep arg1) (quotep arg2))
         (mv *ts-nil* (push-lemma &#39;(:executable-counterpart equal) nil)))
        (t
...">assoc-equiv+</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
        type-alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> term type-alist)))
        (if temp
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp) (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))))</pre>
  </div>

<div class="form-block function" id="def-look-in-type-alist" data-defines="LOOK-IN-TYPE-ALIST" data-references="*TS-UNKNOWN*,IF,MV,ASSOC-TYPE-ALIST,TTREE,TS,MV-LET,WRLD,TYPE-ALIST,TERM,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="LOOK-IN-TYPE-ALIST" data-part-args="WRLD,TYPE-ALIST,TERM" data-part-body="*TS-UNKNOWN*,IF,MV,WRLD,TYPE-ALIST,TERM,ASSOC-TYPE-ALIST,TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOOK-IN-TYPE-ALIST">look-in-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a>
  (term type-alist wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
    (<a class="sym-link local-def" href="#def-assoc-type-alist" data-sym="ASSOC-TYPE-ALIST" title="(defun assoc-type-alist (term type-alist wrld)
  (cond
   ((variablep term)
    (let ((temp (assoc-eq term type-alist)))
      (if temp
...">assoc-type-alist</a> term type-alist wrld)
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if ts
        ts
        *ts-unknown*)
      ttree)))</pre>
  </div>

<div class="form-block function" id="def-member-char-stringp" data-defines="MEMBER-CHAR-STRINGP" data-references="1-,CHAR,EQL,OR,T,MBT,NOT,COND,+,NFIX,LENGTH,<,INTEGERP,STRINGP,AND,XARGS,DECLARE,I,STR,CHR,DEFUN" data-used-by="EVG-OCCUR" data-part-name="MEMBER-CHAR-STRINGP" data-part-args="I,STR,CHR" data-part-declare="+,NFIX,LENGTH,<,I,INTEGERP,STR,STRINGP,AND,XARGS,DECLARE" data-part-body="1-,MEMBER-CHAR-STRINGP,STR,CHAR,CHR,EQL,OR,T,<,I,INTEGERP,MBT,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-CHAR-STRINGP">member-char-stringp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-char-stringp" data-sym="MEMBER-CHAR-STRINGP" title="(defun member-char-stringp (chr str i)
  (declare
   (xargs :guard (and (stringp str) (integerp i) (&lt; i (length str))) :measure
    (nfix (+ 1 i))))
  (cond ((not (mbt (integerp i))) nil) ((&lt; i 0) nil)">member-char-stringp</a>
  (chr str i)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (stringp str) (integerp i) (&lt; i (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str)))
      <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-nfix" data-sym="NFIX">nfix</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> i))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (integerp i))) nil)
    ((&lt; i <span class="number">0</span>) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> chr (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str i))
        (<a class="sym-link local-def" href="#def-member-char-stringp" data-sym="MEMBER-CHAR-STRINGP" title="(defun member-char-stringp (chr str i)
  (declare
   (xargs :guard (and (stringp str) (integerp i) (&lt; i (length str))) :measure
    (nfix (+ 1 i))))
  (cond ((not (mbt (integerp i))) nil) ((&lt; i 0) nil)">member-char-stringp</a> chr str (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> i))))))</pre>
  </div>

<div class="form-block function" id="def-terminal-substringp1" data-defines="TERMINAL-SUBSTRINGP1" data-references="1-,CHAR,EQL,T,MBT,NOT,COND,+,NFIX,<=,LENGTH,<,INTEGERP,STRINGP,AND,XARGS,DECLARE,MAX2,MAX1,STR2,STR1,DEFUN" data-used-by="TERMINAL-SUBSTRINGP" data-part-name="TERMINAL-SUBSTRINGP1" data-part-args="MAX2,MAX1,STR2,STR1" data-part-declare="+,NFIX,<=,LENGTH,<,MAX2,MAX1,INTEGERP,STR2,STR1,STRINGP,AND,XARGS,DECLARE" data-part-body="1-,TERMINAL-SUBSTRINGP1,MAX2,STR2,STR1,CHAR,EQL,T,<,MAX1,INTEGERP,MBT,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERMINAL-SUBSTRINGP1">terminal-substringp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-terminal-substringp1" data-sym="TERMINAL-SUBSTRINGP1" title="(defun terminal-substringp1 (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)) (&lt;= max1 max2))
...">terminal-substringp1</a>
  (str1 str2 max1 max2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (stringp str1)
        (stringp str2)
        (integerp max1)
        (integerp max2)
        (&lt; max1 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str1))
        (&lt; max2 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str2))
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> max1 max2))
      <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-nfix" data-sym="NFIX">nfix</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> max1))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (integerp max1))) nil)
    ((&lt; max1 <span class="number">0</span>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str1 max1) (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str2 max2)) (<a class="sym-link local-def" href="#def-terminal-substringp1" data-sym="TERMINAL-SUBSTRINGP1" title="(defun terminal-substringp1 (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)) (&lt;= max1 max2))
...">terminal-substringp1</a> str1 str2 (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> max1) (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> max2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-terminal-substringp" data-defines="TERMINAL-SUBSTRINGP" data-references="TERMINAL-SUBSTRINGP1,T,COND,LENGTH,<,INTEGERP,STRINGP,AND,XARGS,DECLARE,MAX2,MAX1,STR2,STR1,DEFUN" data-used-by="EVG-OCCUR" data-part-name="TERMINAL-SUBSTRINGP" data-part-args="MAX2,MAX1,STR2,STR1" data-part-declare="LENGTH,<,MAX2,MAX1,INTEGERP,STR2,STR1,STRINGP,AND,XARGS,DECLARE" data-part-body="STR2,STR1,TERMINAL-SUBSTRINGP1,T,MAX1,MAX2,<,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERMINAL-SUBSTRINGP">terminal-substringp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-terminal-substringp" data-sym="TERMINAL-SUBSTRINGP" title="(defun terminal-substringp (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)))))">terminal-substringp</a>
  (str1 str2 max1 max2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (stringp str1)
        (stringp str2)
        (integerp max1)
        (integerp max2)
        (&lt; max1 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str1))
        (&lt; max2 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str2)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((&lt; max2 max1) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-terminal-substringp1" data-sym="TERMINAL-SUBSTRINGP1" title="(defun terminal-substringp1 (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)) (&lt;= max1 max2))
...">terminal-substringp1</a> str1 str2 max1 max2))))</pre>
  </div>

<div class="form-block function" id="def-evg-occur" data-defines="EVG-OCCUR" data-references="CDR,CAR,QUASIQUOTE,QUOTE,HARD?,ER,IMAGPART,REALPART,COMPLEX-RATIONALP,=,DENOMINATOR,NUMERATOR,RATIONALP,-,<,IF,<=,INT=,OR,INTEGERP,EQ,SYMBOL-NAME,SNY,LET,SYMBOLP,TERMINAL-SUBSTRINGP,LENGTH,1-,MEMBER-CHAR-STRINGP,STRINGP,EQL,AND,CHARACTERP,ATOM,COND,T,XARGS,DECLARE,Y,X,DEFUN" data-used-by="OCCUR" data-part-name="EVG-OCCUR" data-part-args="Y,X" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,CAR,QUASIQUOTE,QUOTE,HARD?,ER,IMAGPART,REALPART,COMPLEX-RATIONALP,=,DENOMINATOR,NUMERATOR,EVG-OCCUR,RATIONALP,-,<,IF,<=,INT=,OR,INTEGERP,EQ,SYMBOL-NAME,SNY,LET,SYMBOLP,T,TERMINAL-SUBSTRINGP,LENGTH,1-,MEMBER-CHAR-STRINGP,STRINGP,EQL,X,AND,CHARACTERP,Y,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EVG-OCCUR">evg-occur</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a>
  (x y)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> y) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((characterp y) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (characterp x) (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> x y)))
        ((stringp y) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((characterp x) (<a class="sym-link local-def" href="#def-member-char-stringp" data-sym="MEMBER-CHAR-STRINGP" title="(defun member-char-stringp (chr str i)
  (declare
   (xargs :guard (and (stringp str) (integerp i) (&lt; i (length str))) :measure
    (nfix (+ 1 i))))
  (cond ((not (mbt (integerp i))) nil) ((&lt; i 0) nil)">member-char-stringp</a> x y (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> y))))
            ((stringp x) (<a class="sym-link local-def" href="#def-terminal-substringp" data-sym="TERMINAL-SUBSTRINGP" title="(defun terminal-substringp (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)))))">terminal-substringp</a> x y (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> x)) (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> y))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
        ((symbolp y) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((characterp x) (let ((sny (symbol-name y)))
                (<a class="sym-link local-def" href="#def-member-char-stringp" data-sym="MEMBER-CHAR-STRINGP" title="(defun member-char-stringp (chr str i)
  (declare
   (xargs :guard (and (stringp str) (integerp i) (&lt; i (length str))) :measure
    (nfix (+ 1 i))))
  (cond ((not (mbt (integerp i))) nil) ((&lt; i 0) nil)">member-char-stringp</a> x sny (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> sny)))))
            ((stringp x) (let ((sny (symbol-name y)))
                (<a class="sym-link local-def" href="#def-terminal-substringp" data-sym="TERMINAL-SUBSTRINGP" title="(defun terminal-substringp (str1 str2 max1 max2)
  (declare
   (xargs :guard
    (and (stringp str1) (stringp str2) (integerp max1) (integerp max2)
         (&lt; max1 (length str1)) (&lt; max2 (length str2)))))">terminal-substringp</a> x
                  sny
                  (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> x))
                  (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> sny)))))
            ((symbolp x) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x y))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
        ((integerp y) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp x)
            (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> x y)
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> x)
                (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> x
                  (if (&lt; y <span class="number">0</span>)
                    (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> y)
                    y))))))
        ((rationalp y) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((integerp x) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (numerator y))
                (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (denominator y))))
            ((rationalp x) (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> x y))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
        ((complex-rationalp y) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((rationalp x) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (realpart y)) (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (imagpart y))))
            ((complex-rationalp x) (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> x y))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
            '<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a>
            <span class="string">"Surprising case:  ~x0"</span>
            `(<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> ,X ,Y)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (car y)) (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> x (cdr y))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-occur" data-defines="OCCUR" data-references="CDR,CAR,OR,ENDP,PSEUDO-TERM-LISTP,ARGS2,FARGS,OCCUR-LST,EQUAL,T,CADR,EVG-OCCUR,QUOTEP,FQUOTEP,EQ,VARIABLEP,COND,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM2,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="WORSE-THAN-BUILTIN-CLOCKED" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="OCCUR">occur</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-occur" data-sym="OCCUR" title="(mutual-recursion
 (defun occur (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term2) (eq term1 term2))
         ((fquotep term2)
...">occur</a>
    (term1 term2)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term1 term2))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term1) (<a class="sym-link local-def" href="#def-evg-occur" data-sym="EVG-OCCUR" title="(defun evg-occur (x y)
  (declare (xargs :guard t))
  (cond
   ((atom y)
    (cond ((characterp y) (and (characterp x) (eql x y)))
...">evg-occur</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> term1) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> term2)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
      ((equal term1 term2) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (occur-lst term1 (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> occur-lst
    (term1 args2)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (pseudo-term-listp args2))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> args2) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-occur" data-sym="OCCUR" title="(mutual-recursion
 (defun occur (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term2) (eq term1 term2))
         ((fquotep term2)
...">occur</a> term1 (car args2)) (occur-lst term1 (cdr args2)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-pseudo-variantp" data-defines="PSEUDO-VARIANTP" data-references="CDR,CAR,ENDP,PSEUDO-TERM-LISTP,ARGS2,ARGS1,FARGS,PSEUDO-VARIANTP-LIST,FFN-SYMB,T,OR,EQUAL,FQUOTEP,QUOTEP,NOT,VARIABLEP,COND,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM2,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="WORSE-THAN-BUILTIN-CLOCKED,WORSE-THAN-BUILTIN-CLOCKED-BODY" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PSEUDO-VARIANTP">pseudo-variantp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a>
    (term1 term2)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term2)))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) (equal term1 term2))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2)) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term2))
          (pseudo-variantp-list (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1) (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> pseudo-variantp-list
    (args1 args2)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp args1) (pseudo-term-listp args2))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> args1) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a> (car args1) (car args2))
          (pseudo-variantp-list (cdr args1) (cdr args2)))))))</pre>
  </div>

<div class="form-block macro" id="def-decrement-worse-than-clk" data-defines="DECREMENT-WORSE-THAN-CLK" data-references="1-F,<,IF,QUASIQUOTE,SYMBOLP,XARGS,DECLARE,CLK,DEFMACRO" data-used-by="WORSE-THAN-BUILTIN-CLOCKED,WITH-DECREMENT-WORSE-THAN-CLK" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECREMENT-WORSE-THAN-CLK">decrement-worse-than-clk</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-decrement-worse-than-clk" data-sym="DECREMENT-WORSE-THAN-CLK" title="(defmacro decrement-worse-than-clk (clk)
  (declare (xargs :guard (symbolp clk)))
  `(if (&lt; ,clk 2)
       ,clk
       (|1-F| ,clk)))">decrement-worse-than-clk</a>
  (clk)
  (declare (xargs <span class="keyword">:guard</span> (symbolp clk)))
  `(if (&lt; ,CLK <span class="number">2</span>)
    ,CLK
    (<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> ,CLK)))</pre>
  </div>

<div class="form-block macro" id="def-with-decrement-worse-than-clk" data-defines="WITH-DECREMENT-WORSE-THAN-CLK" data-references="UNSIGNED-BYTE,TYPE,DECREMENT-WORSE-THAN-CLK,LET,QUASIQUOTE,SYMBOLP,XARGS,DECLARE,FORM,CLK,DEFMACRO" data-used-by="WORSE-THAN-BUILTIN-CLOCKED" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WITH-DECREMENT-WORSE-THAN-CLK">with-decrement-worse-than-clk</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-with-decrement-worse-than-clk" data-sym="WITH-DECREMENT-WORSE-THAN-CLK" title="(defmacro with-decrement-worse-than-clk (clk form)
  (declare (xargs :guard (symbolp clk)))
  `(let ((,clk (decrement-worse-than-clk ,clk)))
     (declare (type (unsigned-byte 60) ,clk))
     ,form))">with-decrement-worse-than-clk</a>
  (clk form)
  (declare (xargs <span class="keyword">:guard</span> (symbolp clk)))
  `(let ((,CLK (<a class="sym-link local-def" href="#def-decrement-worse-than-clk" data-sym="DECREMENT-WORSE-THAN-CLK" title="(defmacro decrement-worse-than-clk (clk)
  (declare (xargs :guard (symbolp clk)))
  `(if (&lt; ,clk 2)
       ,clk
       (|1-F| ,clk)))">decrement-worse-than-clk</a> ,CLK)))
    (declare (type (unsigned-byte <span class="number">60</span>) ,CLK))
    ,FORM))</pre>
  </div>

<div class="form-block macro" id="def-worse-than-builtin-clocked-body" data-defines="WORSE-THAN-BUILTIN-CLOCKED-BODY" data-references="FARGS,WORSE-THAN-LST,FQUOTEP,VARIABLEP,PSEUDO-VARIANTP,T,TERM2,TERM1,BASIC-WORSE-THAN,COND,QUASIQUOTE,ATOM,XARGS,DECLARE,CLK,DEFMACRO" data-used-by="WORSE-THAN-BUILTIN-CLOCKED" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORSE-THAN-BUILTIN-CLOCKED-BODY">worse-than-builtin-clocked-body</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-worse-than-builtin-clocked-body" data-sym="WORSE-THAN-BUILTIN-CLOCKED-BODY" title="(defmacro worse-than-builtin-clocked-body (clk)
  (declare (xargs :guard (atom clk)))
  `(cond ((basic-worse-than term1 term2 ,clk) t)
         ((pseudo-variantp term1 term2) nil) ((variablep term1) nil)
         ((fquotep term1) nil) (t (worse-than-lst (fargs term1) term2 ,clk))))">worse-than-builtin-clocked-body</a>
  (clk)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> clk)))
  `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((basic-worse-than term1 term2 ,CLK) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a> term1 term2) nil)
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) nil)
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (worse-than-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1) term2 ,CLK))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-worse-than-builtin-clocked" data-defines="WORSE-THAN-BUILTIN-CLOCKED" data-references="WORSE-THAN-LST,ARGS,SOME-SUBTERM-WORSE-THAN-OR-EQUAL-LST,SOME-SUBTERM-WORSE-THAN-OR-EQUAL,FARGS,WITH-DECREMENT-WORSE-THAN-CLK,FFN-SYMB,FLAMBDA-APPLICATIONP,CADR,FN-COUNT-EVG,>,OCCUR,EQ,BASIC-WORSE-THAN,BASIC-WORSE-THAN-LST2,CDR,NOT,FQUOTEP,CAR,VARIABLEP,OR,ENDP,PSEUDO-TERM-LISTP,ARGS2,ARGS1,BASIC-WORSE-THAN-LST1,DECREMENT-WORSE-THAN-CLK,EQUAL,PSEUDO-VARIANTP,IF,WORSE-THAN-OR-EQUAL-BUILTIN-CLOCKED,WORSE-THAN-BUILTIN-CLOCKED-BODY,1-F,LET,T,ZPF,COND,O<,ACL2-COUNT,+,MAKE-ORD,PSEUDO-TERMP,AND,XARGS,UNSIGNED-BYTE,TYPE,DECLARE,CLK,TERM2,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="WORSE-THAN-BUILTIN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORSE-THAN-BUILTIN-CLOCKED">worse-than-builtin-clocked</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-worse-than-builtin-clocked" data-sym="WORSE-THAN-BUILTIN-CLOCKED" title="(mutual-recursion
 (defun worse-than-builtin-clocked (term1 term2 clk)
   (declare (type (unsigned-byte 60) clk)
            (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))
             :measure
...">worse-than-builtin-clocked</a>
    (term1 term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">2</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-zpf" data-sym="ZPF">zpf</a> clk) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((clk (<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> clk)))
          (declare (type (unsigned-byte <span class="number">60</span>) clk))
          (<a class="sym-link local-def" href="#def-worse-than-builtin-clocked-body" data-sym="WORSE-THAN-BUILTIN-CLOCKED-BODY" title="(defmacro worse-than-builtin-clocked-body (clk)
  (declare (xargs :guard (atom clk)))
  `(cond ((basic-worse-than term1 term2 ,clk) t)
         ((pseudo-variantp term1 term2) nil) ((variablep term1) nil)
         ((fquotep term1) nil) (t (worse-than-lst (fargs term1) term2 ,clk))))">worse-than-builtin-clocked-body</a> clk)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> worse-than-or-equal-builtin-clocked
    (term1 term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">3</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (if (<a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a> term1 term2)
      (equal term1 term2)
      (<a class="sym-link local-def" href="#def-worse-than-builtin-clocked" data-sym="WORSE-THAN-BUILTIN-CLOCKED" title="(mutual-recursion
 (defun worse-than-builtin-clocked (term1 term2 clk)
   (declare (type (unsigned-byte 60) clk)
            (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))
             :measure
...">worse-than-builtin-clocked</a> term1
        term2
        (<a class="sym-link local-def" href="#def-decrement-worse-than-clk" data-sym="DECREMENT-WORSE-THAN-CLK" title="(defmacro decrement-worse-than-clk (clk)
  (declare (xargs :guard (symbolp clk)))
  `(if (&lt; ,clk 2)
       ,clk
       (|1-F| ,clk)))">decrement-worse-than-clk</a> clk))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> basic-worse-than-lst1
    (args1 args2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp args1) (pseudo-term-listp args2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> args1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> args2)) <span class="number">0</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> args1) nil)
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car args1)) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> (car args1)))
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car args2)) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> (car args2)))))
         (<a class="sym-link local-def" href="#def-worse-than-builtin-clocked" data-sym="WORSE-THAN-BUILTIN-CLOCKED" title="(mutual-recursion
 (defun worse-than-builtin-clocked (term1 term2 clk)
   (declare (type (unsigned-byte 60) clk)
            (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))
             :measure
...">worse-than-builtin-clocked</a> (car args2) (car args1) clk)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (basic-worse-than-lst1 (cdr args1) (cdr args2) clk))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> basic-worse-than-lst2
    (args1 args2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp args1) (pseudo-term-listp args2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> args1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> args2)) <span class="number">0</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> args1) nil)
      ((<a class="sym-link local-def" href="#def-worse-than-builtin-clocked" data-sym="WORSE-THAN-BUILTIN-CLOCKED" title="(mutual-recursion
 (defun worse-than-builtin-clocked (term1 term2 clk)
   (declare (type (unsigned-byte 60) clk)
            (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))
             :measure
...">worse-than-builtin-clocked</a> (car args1) (car args2) clk) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (basic-worse-than-lst2 (cdr args1) (cdr args2) clk))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> basic-worse-than
    (term1 term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">0</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term1 term2) nil) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-occur" data-sym="OCCUR" title="(mutual-recursion
 (defun occur (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term2) (eq term1 term2))
         ((fquotep term2)
...">occur</a> term2 term1))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (fn-count-evg (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> term1)) (fn-count-evg (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> term2))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) nil)
      ((<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term1) (equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term2)))
         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term2)))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a> term1 term2) nil)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-with-decrement-worse-than-clk" data-sym="WITH-DECREMENT-WORSE-THAN-CLK" title="(defmacro with-decrement-worse-than-clk (clk form)
  (declare (xargs :guard (symbolp clk)))
  `(let ((,clk (decrement-worse-than-clk ,clk)))
     (declare (type (unsigned-byte 60) ,clk))
     ,form))">with-decrement-worse-than-clk</a> clk
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((basic-worse-than-lst1 (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1) (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2) clk) nil)
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (basic-worse-than-lst2 (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1) (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2) clk)))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> some-subterm-worse-than-or-equal
    (term1 term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term1) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">1</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term1 term2))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-with-decrement-worse-than-clk" data-sym="WITH-DECREMENT-WORSE-THAN-CLK" title="(defmacro with-decrement-worse-than-clk (clk form)
  (declare (xargs :guard (symbolp clk)))
  `(let ((,clk (decrement-worse-than-clk ,clk)))
     (declare (type (unsigned-byte 60) ,clk))
     ,form))">with-decrement-worse-than-clk</a> clk
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((if (<a class="sym-link local-def" href="#def-pseudo-variantp" data-sym="PSEUDO-VARIANTP" title="(mutual-recursion
 (defun pseudo-variantp (term1 term2)
   (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
   (cond ((variablep term1) (not (quotep term2)))
         ((fquotep term1) (equal term1 term2))
...">pseudo-variantp</a> term1 term2)
               (equal term1 term2)
               (basic-worse-than term1 term2 clk)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
            ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) nil)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (some-subterm-worse-than-or-equal-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1)
                term2
                clk)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> some-subterm-worse-than-or-equal-lst
    (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">0</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (some-subterm-worse-than-or-equal (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) term2 clk)
          (some-subterm-worse-than-or-equal-lst (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) term2 clk)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> worse-than-lst
    (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> term2 clk)
    (declare (type (unsigned-byte <span class="number">60</span>) clk)
      (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-make-ord" data-sym="MAKE-ORD">make-ord</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)) <span class="number">0</span>)
        <span class="keyword">:well-founded-relation</span> <a class="sym-link system" href="axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (some-subterm-worse-than-or-equal (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) term2 clk)
          (worse-than-lst (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) term2 clk))))))</pre>
  </div>

<div class="form-block encapsulate" id="form-153" typeof="Code">
    <div class="form-header"><span class="form-type">encapsulate</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> ((worse-than (term1 term2)
     <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
     <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
  (<a class="sym-link system" href="axioms.html#def-logic" data-sym="LOGIC">logic</a>)
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> worse-than
      (term1 term2)
      (declare (ignore term1 term2))
      nil)))</pre>
  </div>

<div class="form-block encapsulate" id="form-154" typeof="Code">
    <div class="form-header"><span class="form-type">encapsulate</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> ((worse-than-or-equal (term1 term2)
     <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
     <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
  (<a class="sym-link system" href="axioms.html#def-logic" data-sym="LOGIC">logic</a>)
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> worse-than-or-equal
      (term1 term2)
      (declare (ignore term1 term2))
      nil)))</pre>
  </div>

<div class="form-block macro" id="def-worse-than-clk" data-defines="WORSE-THAN-CLK" data-references="DEFMACRO" data-used-by="WORSE-THAN-OR-EQUAL-BUILTIN,WORSE-THAN-BUILTIN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORSE-THAN-CLK">worse-than-clk</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-worse-than-clk" data-sym="WORSE-THAN-CLK" title="(defmacro worse-than-clk () 15)">worse-than-clk</a> nil <span class="number">15</span>)</pre>
  </div>

<div class="form-block function" id="def-worse-than-builtin" data-defines="WORSE-THAN-BUILTIN" data-references="WORSE-THAN-CLK,WORSE-THAN-BUILTIN-CLOCKED,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM2,TERM1,DEFUN" data-part-name="WORSE-THAN-BUILTIN" data-part-args="TERM2,TERM1" data-part-declare="TERM2,TERM1,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="WORSE-THAN-CLK,TERM2,TERM1,WORSE-THAN-BUILTIN-CLOCKED" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORSE-THAN-BUILTIN">worse-than-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-worse-than-builtin" data-sym="WORSE-THAN-BUILTIN" title="(defun worse-than-builtin (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (worse-than-builtin-clocked term1 term2 (worse-than-clk)))">worse-than-builtin</a>
  (term1 term2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
  (<a class="sym-link local-def" href="#def-worse-than-builtin-clocked" data-sym="WORSE-THAN-BUILTIN-CLOCKED" title="(mutual-recursion
 (defun worse-than-builtin-clocked (term1 term2 clk)
   (declare (type (unsigned-byte 60) clk)
            (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))
             :measure
...">worse-than-builtin-clocked</a> term1 term2 (<a class="sym-link local-def" href="#def-worse-than-clk" data-sym="WORSE-THAN-CLK" title="(defmacro worse-than-clk () 15)">worse-than-clk</a>)))</pre>
  </div>

<div class="form-block function" id="def-worse-than-or-equal-builtin" data-defines="WORSE-THAN-OR-EQUAL-BUILTIN" data-references="WORSE-THAN-CLK,WORSE-THAN-OR-EQUAL-BUILTIN-CLOCKED,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM2,TERM1,DEFUN" data-part-name="WORSE-THAN-OR-EQUAL-BUILTIN" data-part-args="TERM2,TERM1" data-part-declare="TERM2,TERM1,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="WORSE-THAN-CLK,TERM2,TERM1,WORSE-THAN-OR-EQUAL-BUILTIN-CLOCKED" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORSE-THAN-OR-EQUAL-BUILTIN">worse-than-or-equal-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-worse-than-or-equal-builtin" data-sym="WORSE-THAN-OR-EQUAL-BUILTIN" title="(defun worse-than-or-equal-builtin (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (worse-than-or-equal-builtin-clocked term1 term2 (worse-than-clk)))">worse-than-or-equal-builtin</a>
  (term1 term2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term1) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2))))
  (worse-than-or-equal-builtin-clocked term1
    term2
    (<a class="sym-link local-def" href="#def-worse-than-clk" data-sym="WORSE-THAN-CLK" title="(defmacro worse-than-clk () 15)">worse-than-clk</a>)))</pre>
  </div>

<div class="form-block other" id="form-158" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (worse-than <a class="sym-link local-def" href="#def-worse-than-builtin" data-sym="WORSE-THAN-BUILTIN" title="(defun worse-than-builtin (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (worse-than-builtin-clocked term1 term2 (worse-than-clk)))">worse-than-builtin</a>) <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-159" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (worse-than-or-equal <a class="sym-link local-def" href="#def-worse-than-or-equal-builtin" data-sym="WORSE-THAN-OR-EQUAL-BUILTIN" title="(defun worse-than-or-equal-builtin (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (worse-than-or-equal-builtin-clocked term1 term2 (worse-than-clk)))">worse-than-or-equal-builtin</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-160" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> ancestor
  (lit atm var-cnt fn-cnt p-fn-cnt tokens . bkptr)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block macro" id="def-make-ancestor-binding-hyp" data-defines="MAKE-ANCESTOR-BINDING-HYP" data-references="ANCESTOR,MAKE,QUASIQUOTE,UNIFY-SUBST,HYP,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-ANCESTOR-BINDING-HYP">make-ancestor-binding-hyp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-make-ancestor-binding-hyp" data-sym="MAKE-ANCESTOR-BINDING-HYP" title="(defmacro make-ancestor-binding-hyp (hyp unify-subst)
  `(make ancestor :lit :binding-hyp :atm ,hyp :var-cnt ,unify-subst :tokens nil
         :bkptr nil))">make-ancestor-binding-hyp</a>
  (hyp unify-subst)
  `(<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> ancestor
    <span class="keyword">:lit</span> <span class="keyword">:binding-hyp</span> <span class="keyword">:atm</span> ,HYP
    <span class="keyword">:var-cnt</span> ,UNIFY-SUBST
    <span class="keyword">:tokens</span> nil
    <span class="keyword">:bkptr</span> nil))</pre>
  </div>

<div class="form-block macro" id="def-ancestor-binding-hyp-p" data-defines="ANCESTOR-BINDING-HYP-P" data-references="ANCESTOR,ACCESS,EQ,QUASIQUOTE,ANC,DEFMACRO" data-used-by="ANCESTORS-CHECK1,ANCESTOR-LISTP" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTOR-BINDING-HYP-P">ancestor-binding-hyp-p</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-ancestor-binding-hyp-p" data-sym="ANCESTOR-BINDING-HYP-P" title="(defmacro ancestor-binding-hyp-p (anc)
  `(eq (access ancestor ,anc :lit) :binding-hyp))">ancestor-binding-hyp-p</a>
  (anc)
  `(<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor ,ANC <span class="keyword">:lit</span>) <span class="keyword">:binding-hyp</span>))</pre>
  </div>

<div class="form-block macro" id="def-ancestor-binding-hyp_2Fhyp" data-defines="ANCESTOR-BINDING-HYP/HYP" data-references="ANCESTOR,ACCESS,QUASIQUOTE,ANC,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTOR-BINDING-HYP/HYP">ancestor-binding-hyp/hyp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-ancestor-binding-hyp_2Fhyp" data-sym="ANCESTOR-BINDING-HYP/HYP" title="(defmacro ancestor-binding-hyp/hyp (anc) `(access ancestor ,anc :atm))">ancestor-binding-hyp/hyp</a>
  (anc)
  `(<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor ,ANC <span class="keyword">:atm</span>))</pre>
  </div>

<div class="form-block macro" id="def-ancestor-binding-hyp_2Funify-subst" data-defines="ANCESTOR-BINDING-HYP/UNIFY-SUBST" data-references="ANCESTOR,ACCESS,QUASIQUOTE,ANC,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTOR-BINDING-HYP/UNIFY-SUBST">ancestor-binding-hyp/unify-subst</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-ancestor-binding-hyp_2Funify-subst" data-sym="ANCESTOR-BINDING-HYP/UNIFY-SUBST" title="(defmacro ancestor-binding-hyp/unify-subst (anc)
  `(access ancestor ,anc :var-cnt))">ancestor-binding-hyp/unify-subst</a>
  (anc)
  `(<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor ,ANC <span class="keyword">:var-cnt</span>))</pre>
  </div>

<div class="form-block function" id="def-push-ancestor" data-defines="PUSH-ANCESTOR" data-references="ANCESTOR,MAKE,CONS,VAR-FN-COUNT,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,IGNORE,DECLARE,STRIP-NOT,ATM,NOT-FLG,MV-LET,ALIT-ATM,ALIT,LET*,BKPTR,ANCESTORS,TOKENS,LIT,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="PUSH-ANCESTOR" data-part-args="BKPTR,ANCESTORS,TOKENS,LIT" data-part-body="ANCESTORS,BKPTR,TOKENS,ANCESTOR,MAKE,CONS,VAR-FN-COUNT,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,IGNORE,DECLARE,STRIP-NOT,ATM,NOT-FLG,MV-LET,ALIT-ATM,LIT,ALIT,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-ANCESTOR">push-ancestor</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-ancestor" data-sym="PUSH-ANCESTOR" title="(defun push-ancestor (lit tokens ancestors bkptr)
  (let* ((alit lit)
         (alit-atm
          (mv-let (not-flg atm) (strip-not alit) (declare (ignore not-flg))
                  atm)))
...">push-ancestor</a>
  (lit tokens ancestors bkptr)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((alit lit) (alit-atm (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
          (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> alit)
          (declare (ignore not-flg))
          atm)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var-cnt-alit-atm fn-cnt-alit-atm p-fn-cnt-alit-atm)
      (var-fn-count alit-atm nil)
      (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> ancestor
          <span class="keyword">:lit</span> alit
          <span class="keyword">:atm</span> alit-atm
          <span class="keyword">:var-cnt</span> var-cnt-alit-atm
          <span class="keyword">:fn-cnt</span> fn-cnt-alit-atm
          <span class="keyword">:p-fn-cnt</span> p-fn-cnt-alit-atm
          <span class="keyword">:tokens</span> tokens
          <span class="keyword">:bkptr</span> bkptr)
        ancestors))))</pre>
  </div>

<div class="form-block function" id="def-ancestor-listp" data-defines="ANCESTOR-LISTP" data-references="TRUE-LISTP,INTEGERP,PSEUDO-TERMP,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,ALIT-ATM,ALIT,ANC,LET*,CDR,ANCESTOR,ACCESS,AND,ANCESTOR-BINDING-HYP-P,CAR,WEAK-ANCESTOR-P,NOT,NULL,ATOM,COND,T,XARGS,DECLARE,X,DEFUN" data-used-by="ANCESTORS-CHECK-BUILTIN,ANCESTORS-CHECK1,EARLIER-ANCESTOR-BIGGERP" data-part-name="ANCESTOR-LISTP" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="TRUE-LISTP,INTEGERP,PSEUDO-TERMP,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,ALIT-ATM,ALIT,ANC,LET*,T,CDR,ANCESTOR-LISTP,ANCESTOR,ACCESS,AND,ANCESTOR-BINDING-HYP-P,CAR,WEAK-ANCESTOR-P,NOT,NULL,X,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTOR-LISTP">ancestor-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (weak-ancestor-p (car x))) nil)
    ((<a class="sym-link local-def" href="#def-ancestor-binding-hyp-p" data-sym="ANCESTOR-BINDING-HYP-P" title="(defmacro ancestor-binding-hyp-p (anc)
  `(eq (access ancestor ,anc :lit) :binding-hyp))">ancestor-binding-hyp-p</a> (car x)) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car x) <span class="keyword">:tokens</span>))
        (<a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a> (cdr x))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((anc (car x)) (alit (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:lit</span>))
          (alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:atm</span>))
          (var-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:var-cnt</span>))
          (fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:fn-cnt</span>))
          (p-fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:p-fn-cnt</span>))
          (atokens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:tokens</span>)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> alit)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> alit-atm)
          (integerp var-cnt-alit-atm)
          (integerp fn-cnt-alit-atm)
          (integerp p-fn-cnt-alit-atm)
          (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> atokens)
          (<a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a> (cdr x)))))))</pre>
  </div>

<div class="form-block function" id="def-earlier-ancestor-biggerp" data-defines="EARLIER-ANCESTOR-BIGGERP" data-references="CDR,VAR-OR-FN-COUNT-<,INTERSECTP-EQUAL,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,ANCESTOR,ACCESS,VAR-CNT-ALIT-ATM,CAR,ANC,LET*,T,ENDP,COND,ANCESTOR-LISTP,TRUE-LISTP,INTEGERP,AND,XARGS,DECLARE,ANCESTORS,TOKENS,P-FN-CNT,FN-CNT,VAR-CNT,DEFUN" data-used-by="ANCESTORS-CHECK1" data-part-name="EARLIER-ANCESTOR-BIGGERP" data-part-args="ANCESTORS,TOKENS,P-FN-CNT,FN-CNT,VAR-CNT" data-part-declare="ANCESTORS,ANCESTOR-LISTP,TOKENS,TRUE-LISTP,P-FN-CNT,FN-CNT,VAR-CNT,INTEGERP,AND,XARGS,DECLARE" data-part-body="CDR,EARLIER-ANCESTOR-BIGGERP,P-FN-CNT,FN-CNT,VAR-CNT,VAR-OR-FN-COUNT-<,TOKENS,INTERSECTP-EQUAL,AND,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,ANCESTOR,ACCESS,VAR-CNT-ALIT-ATM,CAR,ANC,LET*,T,ANCESTORS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EARLIER-ANCESTOR-BIGGERP">earlier-ancestor-biggerp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-earlier-ancestor-biggerp" data-sym="EARLIER-ANCESTOR-BIGGERP" title="(defun earlier-ancestor-biggerp (var-cnt fn-cnt p-fn-cnt tokens ancestors)
  (declare
   (xargs :guard
    (and (integerp var-cnt) (integerp fn-cnt) (integerp p-fn-cnt)
         (true-listp tokens) (ancestor-listp ancestors))))
...">earlier-ancestor-biggerp</a>
  (var-cnt fn-cnt p-fn-cnt tokens ancestors)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp var-cnt)
        (integerp fn-cnt)
        (integerp p-fn-cnt)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> tokens)
        (<a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a> ancestors))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> ancestors) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((anc (car ancestors)) (var-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:var-cnt</span>))
          (fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:fn-cnt</span>))
          (p-fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:p-fn-cnt</span>))
          (atokens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor anc <span class="keyword">:tokens</span>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-intersectp-equal" data-sym="INTERSECTP-EQUAL">intersectp-equal</a> tokens atokens)
             (var-or-fn-count-&lt; var-cnt
               var-cnt-alit-atm
               fn-cnt
               fn-cnt-alit-atm
               p-fn-cnt
               p-fn-cnt-alit-atm)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-earlier-ancestor-biggerp" data-sym="EARLIER-ANCESTOR-BIGGERP" title="(defun earlier-ancestor-biggerp (var-cnt fn-cnt p-fn-cnt tokens ancestors)
  (declare
   (xargs :guard
    (and (integerp var-cnt) (integerp fn-cnt) (integerp p-fn-cnt)
         (true-listp tokens) (ancestor-listp ancestors))))
...">earlier-ancestor-biggerp</a> var-cnt
              fn-cnt
              p-fn-cnt
              tokens
              (cdr ancestors))))))))</pre>
  </div>

<div class="form-block function" id="def-equal-mod-commuting" data-defines="EQUAL-MOD-COMMUTING" data-references="FARGN,EQUIVALENCE-RELATIONP,IFF,QUOTE,MEMBER-EQ,IF,FNX,LET,FFN-SYMB,FLAMBDAP,T,EQUAL,FQUOTEP,OR,EQ,VARIABLEP,COND,PLIST-WORLDP,PSEUDO-TERMP,AND,XARGS,DECLARE,WRLD,Y,X,DEFUN" data-used-by="ANCESTORS-CHECK1" data-part-name="EQUAL-MOD-COMMUTING" data-part-args="WRLD,Y,X" data-part-declare="WRLD,PLIST-WORLDP,Y,X,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="FARGN,EQUIVALENCE-RELATIONP,WRLD,IFF,QUOTE,MEMBER-EQ,IF,AND,FNX,LET,FFN-SYMB,FLAMBDAP,T,EQUAL,FQUOTEP,OR,Y,EQ,X,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-MOD-COMMUTING">equal-mod-commuting</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-equal-mod-commuting" data-sym="EQUAL-MOD-COMMUTING" title="(defun equal-mod-commuting (x y wrld)
  (declare
   (xargs :guard (and (pseudo-termp x) (pseudo-termp y) (plist-worldp wrld))))
  (cond ((variablep x) (eq x y)) ((variablep y) nil)
        ((or (fquotep x) (fquotep y)) nil) ((equal x y) t)
...">equal-mod-commuting</a>
  (x y wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> x) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> y) (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> x) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x y))
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> y) nil)
    ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> x) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> y)) nil)
    ((equal x y) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((fnx (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fnx (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> y))
          (if (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> fnx '(equal <a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>))
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> wrld (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> fnx wrld)))
          (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> y <span class="number">2</span>))
          (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> y <span class="number">1</span>)))))))</pre>
  </div>

<div class="form-block function" id="def-ancestors-check1" data-defines="ANCESTORS-CHECK1" data-references="EARLIER-ANCESTOR-BIGGERP,WORSE-THAN-OR-EQUAL,VAR-OR-FN-COUNT-<,FFN-SYMB,EQUAL,FQUOTEP,NOT,NVARIABLEP,INTERSECTP-EQUAL,EQUAL-MOD-COMMUTING,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,ALIT-ATM,ANCESTOR,ACCESS,ALIT,LET,T,CDR,CAR,ANCESTOR-BINDING-HYP-P,MV,ENDP,COND,TRUE-LISTP,ANCESTOR-LISTP,INTEGERP,PSEUDO-TERMP,AND,XARGS,DECLARE,TOKENS,ANCESTORS,P-FN-CNT,FN-CNT,VAR-CNT,LIT,LIT-ATM,DEFUN" data-used-by="ANCESTORS-CHECK-BUILTIN" data-part-name="ANCESTORS-CHECK1" data-part-args="TOKENS,ANCESTORS,P-FN-CNT,FN-CNT,VAR-CNT,LIT,LIT-ATM" data-part-declare="TOKENS,TRUE-LISTP,ANCESTORS,ANCESTOR-LISTP,P-FN-CNT,FN-CNT,VAR-CNT,INTEGERP,LIT,LIT-ATM,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="EARLIER-ANCESTOR-BIGGERP,WORSE-THAN-OR-EQUAL,VAR-OR-FN-COUNT-<,FFN-SYMB,EQUAL,FQUOTEP,NOT,NVARIABLEP,AND,INTERSECTP-EQUAL,EQUAL-MOD-COMMUTING,ATOKENS,P-FN-CNT-ALIT-ATM,FN-CNT-ALIT-ATM,VAR-CNT-ALIT-ATM,ALIT-ATM,ANCESTOR,ACCESS,ALIT,LET,T,TOKENS,CDR,P-FN-CNT,FN-CNT,VAR-CNT,LIT,LIT-ATM,ANCESTORS-CHECK1,CAR,ANCESTOR-BINDING-HYP-P,MV,ANCESTORS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTORS-CHECK1">ancestors-check1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a>
  (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> lit-atm)
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> lit)
        (integerp var-cnt)
        (integerp fn-cnt)
        (integerp p-fn-cnt)
        (<a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a> ancestors)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> tokens))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> ancestors) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    ((<a class="sym-link local-def" href="#def-ancestor-binding-hyp-p" data-sym="ANCESTOR-BINDING-HYP-P" title="(defmacro ancestor-binding-hyp-p (anc)
  `(eq (access ancestor ,anc :lit) :binding-hyp))">ancestor-binding-hyp-p</a> (car ancestors)) (<a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a> lit-atm
        lit
        var-cnt
        fn-cnt
        p-fn-cnt
        (cdr ancestors)
        tokens))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((alit (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:lit</span>)) (alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:atm</span>))
          (var-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:var-cnt</span>))
          (fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:fn-cnt</span>))
          (p-fn-cnt-alit-atm (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:p-fn-cnt</span>))
          (atokens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:tokens</span>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-equal-mod-commuting" data-sym="EQUAL-MOD-COMMUTING" title="(defun equal-mod-commuting (x y wrld)
  (declare
   (xargs :guard (and (pseudo-termp x) (pseudo-termp y) (plist-worldp wrld))))
  (cond ((variablep x) (eq x y)) ((variablep y) nil)
        ((or (fquotep x) (fquotep y)) nil) ((equal x y) t)
...">equal-mod-commuting</a> alit lit nil) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
          ((<a class="sym-link local-def" href="#def-equal-mod-commuting" data-sym="EQUAL-MOD-COMMUTING" title="(defun equal-mod-commuting (x y wrld)
  (declare
   (xargs :guard (and (pseudo-termp x) (pseudo-termp y) (plist-worldp wrld))))
  (cond ((variablep x) (eq x y)) ((variablep y) nil)
        ((or (fquotep x) (fquotep y)) nil) ((equal x y) t)
...">equal-mod-commuting</a> lit-atm alit-atm nil) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))
          ((<a class="sym-link system" href="axioms.html#def-intersectp-equal" data-sym="INTERSECTP-EQUAL">intersectp-equal</a> tokens atokens) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> alit-atm)
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> alit-atm))
                 (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> lit-atm)
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> lit-atm))
                 (equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit-atm) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> alit-atm))
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (var-or-fn-count-&lt; var-cnt
                     var-cnt-alit-atm
                     fn-cnt
                     fn-cnt-alit-atm
                     p-fn-cnt
                     p-fn-cnt-alit-atm))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a> lit-atm
                  lit
                  var-cnt
                  fn-cnt
                  p-fn-cnt
                  (cdr ancestors)
                  tokens))))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (var-or-fn-count-&lt; var-cnt
                 var-cnt-alit-atm
                 fn-cnt
                 fn-cnt-alit-atm
                 p-fn-cnt
                 p-fn-cnt-alit-atm))
             (worse-than-or-equal lit-atm alit-atm)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-earlier-ancestor-biggerp" data-sym="EARLIER-ANCESTOR-BIGGERP" title="(defun earlier-ancestor-biggerp (var-cnt fn-cnt p-fn-cnt tokens ancestors)
  (declare
   (xargs :guard
    (and (integerp var-cnt) (integerp fn-cnt) (integerp p-fn-cnt)
         (true-listp tokens) (ancestor-listp ancestors))))
...">earlier-ancestor-biggerp</a> var-cnt
                 fn-cnt
                 p-fn-cnt
                 atokens
                 (cdr ancestors)) (<a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a> lit-atm
                  lit
                  var-cnt
                  fn-cnt
                  p-fn-cnt
                  (cdr ancestors)
                  tokens))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a> lit-atm
              lit
              var-cnt
              fn-cnt
              p-fn-cnt
              (cdr ancestors)
              tokens)))))))</pre>
  </div>

<div class="form-block function" id="def-ancestors-check-builtin" data-defines="ANCESTORS-CHECK-BUILTIN" data-references="ANCESTORS-CHECK1,VAR-FN-COUNT,P-FN-CNT,FN-CNT,VAR-CNT,IGNORE,STRIP-NOT,LIT-ATM,NOT-FLG,MV-LET,T,MV,ENDP,COND,TRUE-LISTP,ANCESTOR-LISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,TOKENS,ANCESTORS,LIT,DEFUN" data-part-name="ANCESTORS-CHECK-BUILTIN" data-part-args="TOKENS,ANCESTORS,LIT" data-part-declare="TOKENS,TRUE-LISTP,ANCESTORS,ANCESTOR-LISTP,LIT,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="TOKENS,ANCESTORS-CHECK1,VAR-FN-COUNT,P-FN-CNT,FN-CNT,VAR-CNT,IGNORE,DECLARE,LIT,STRIP-NOT,LIT-ATM,NOT-FLG,MV-LET,T,MV,ANCESTORS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTORS-CHECK-BUILTIN">ancestors-check-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ancestors-check-builtin" data-sym="ANCESTORS-CHECK-BUILTIN" title="(defun ancestors-check-builtin (lit ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit) (ancestor-listp ancestors) (true-listp tokens))))
  (cond ((endp ancestors) (mv nil nil))
...">ancestors-check-builtin</a>
  (lit ancestors tokens)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> lit)
        (<a class="sym-link local-def" href="#def-ancestor-listp" data-sym="ANCESTOR-LISTP" title="(defun ancestor-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (null x)) ((not (weak-ancestor-p (car x))) nil)
        ((ancestor-binding-hyp-p (car x))
         (and (null (access ancestor (car x) :tokens))
...">ancestor-listp</a> ancestors)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> tokens))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> ancestors) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg lit-atm)
        (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> lit)
        (declare (ignore not-flg))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var-cnt fn-cnt p-fn-cnt)
          (var-fn-count lit-atm nil)
          (<a class="sym-link local-def" href="#def-ancestors-check1" data-sym="ANCESTORS-CHECK1" title="(defun ancestors-check1 (lit-atm lit var-cnt fn-cnt p-fn-cnt ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit-atm) (pseudo-termp lit) (integerp var-cnt)
         (integerp fn-cnt) (integerp p-fn-cnt) (ancestor-listp ancestors)
...">ancestors-check1</a> lit-atm
            lit
            var-cnt
            fn-cnt
            p-fn-cnt
            ancestors
            tokens))))))</pre>
  </div>

<div class="form-block other" id="form-171" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> ancestors-check (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>))</pre>
  </div>

<div class="form-block other" id="form-172" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (ancestors-check <a class="sym-link local-def" href="#def-ancestors-check-builtin" data-sym="ANCESTORS-CHECK-BUILTIN" title="(defun ancestors-check-builtin (lit ancestors tokens)
  (declare
   (xargs :guard
    (and (pseudo-termp lit) (ancestor-listp ancestors) (true-listp tokens))))
  (cond ((endp ancestors) (mv nil nil))
...">ancestors-check-builtin</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-map-multiply-car" data-defines="MAP-MULTIPLY-CAR" data-references="CDR,CAR,*,CONS,T,ENDP,COND,X,MULTIPLICATIVE-CONSTANT,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM-1" data-part-name="MAP-MULTIPLY-CAR" data-part-args="X,MULTIPLICATIVE-CONSTANT" data-part-body="MAP-MULTIPLY-CAR,CDR,CAR,MULTIPLICATIVE-CONSTANT,*,CONS,T,X,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAP-MULTIPLY-CAR">map-multiply-car</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-map-multiply-car" data-sym="MAP-MULTIPLY-CAR" title="(defun map-multiply-car (multiplicative-constant x)
  (cond ((endp x) nil)
        (t
         (cons (cons (* multiplicative-constant (car (car x))) (cdr (car x)))
               (map-multiply-car multiplicative-constant (cdr x))))))">map-multiply-car</a>
  (multiplicative-constant x)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> multiplicative-constant (car (car x)))
          (cdr (car x)))
        (<a class="sym-link local-def" href="#def-map-multiply-car" data-sym="MAP-MULTIPLY-CAR" title="(defun map-multiply-car (multiplicative-constant x)
  (cond ((endp x) nil)
        (t
         (cons (cons (* multiplicative-constant (car (car x))) (cdr (car x)))
               (map-multiply-car multiplicative-constant (cdr x))))))">map-multiply-car</a> multiplicative-constant (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-normalize-addend" data-defines="NORMALIZE-ADDEND" data-references="T,UNQUOTE,RATIONALP,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,FQUOTEP,CONS,VARIABLEP,COND,ADDEND,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM-2" data-part-name="NORMALIZE-ADDEND" data-part-args="ADDEND" data-part-body="T,UNQUOTE,RATIONALP,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,FQUOTEP,CONS,ADDEND,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-ADDEND">normalize-addend</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-addend" data-sym="NORMALIZE-ADDEND" title="(defun normalize-addend (addend)
  (cond ((variablep addend) (cons 1 addend)) ((fquotep addend) (cons 1 addend))
        ((flambda-applicationp addend) (cons 1 addend))
        ((eq (ffn-symb addend) &#39;unary--) (cons -1 (fargn addend 1)))
        ((eq (ffn-symb addend) &#39;binary-*)
...">normalize-addend</a>
  (addend)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> addend) (cons <span class="number">1</span> addend))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> addend) (cons <span class="number">1</span> addend))
    ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> addend) (cons <span class="number">1</span> addend))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> addend) 'unary--) (cons <span class="number">-1</span> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> addend <span class="number">1</span>)))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> addend) 'binary-*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> addend <span class="number">1</span>))
           (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> addend <span class="number">1</span>)))) (cons (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> addend <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> addend <span class="number">2</span>)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons <span class="number">1</span> addend))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons <span class="number">1</span> addend))))</pre>
  </div>

<div class="form-block function" id="def-insert-cdr-term-order" data-defines="INSERT-CDR-TERM-ORDER" data-references="T,CONS,CAR,CDR,TERM-ORDER,ENDP,COND,LIST,ITEM,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM-2" data-part-name="INSERT-CDR-TERM-ORDER" data-part-args="LIST,ITEM" data-part-body="T,INSERT-CDR-TERM-ORDER,CONS,CAR,CDR,TERM-ORDER,ITEM,LIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INSERT-CDR-TERM-ORDER">insert-cdr-term-order</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-insert-cdr-term-order" data-sym="INSERT-CDR-TERM-ORDER" title="(defun insert-cdr-term-order (item list)
  (cond ((endp list) (list item))
        ((term-order (cdr (car list)) (cdr item))
         (cons (car list) (insert-cdr-term-order item (cdr list))))
        (t (cons item list))))">insert-cdr-term-order</a>
  (item <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> item))
    ((<a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a> (cdr (car <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>)) (cdr item)) (cons (car <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>) (<a class="sym-link local-def" href="#def-insert-cdr-term-order" data-sym="INSERT-CDR-TERM-ORDER" title="(defun insert-cdr-term-order (item list)
  (cond ((endp list) (list item))
        ((term-order (cdr (car list)) (cdr item))
         (cons (car list) (insert-cdr-term-order item (cdr list))))
        (t (cons item list))))">insert-cdr-term-order</a> item (cdr <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons item <a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>))))</pre>
  </div>

<div class="form-block function" id="def-normalize-linear-sum-2" data-defines="NORMALIZE-LINEAR-SUM-2" data-references="LIST,T,FARGN,NORMALIZE-ADDEND,INSERT-CDR-TERM-ORDER,BINARY-+,QUOTE,FN-SYMB,EQ,COND,TERM,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM-1" data-part-name="NORMALIZE-LINEAR-SUM-2" data-part-args="TERM" data-part-body="LIST,T,NORMALIZE-LINEAR-SUM-2,FARGN,NORMALIZE-ADDEND,INSERT-CDR-TERM-ORDER,BINARY-+,QUOTE,TERM,FN-SYMB,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-LINEAR-SUM-2">normalize-linear-sum-2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-linear-sum-2" data-sym="NORMALIZE-LINEAR-SUM-2" title="(defun normalize-linear-sum-2 (term)
  (cond
   ((eq (fn-symb term) &#39;binary-+)
    (insert-cdr-term-order (normalize-addend (fargn term 1))
                           (normalize-linear-sum-2 (fargn term 2))))">normalize-linear-sum-2</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-fn-symb" data-sym="FN-SYMB">fn-symb</a> term) 'binary-+) (<a class="sym-link local-def" href="#def-insert-cdr-term-order" data-sym="INSERT-CDR-TERM-ORDER" title="(defun insert-cdr-term-order (item list)
  (cond ((endp list) (list item))
        ((term-order (cdr (car list)) (cdr item))
         (cons (car list) (insert-cdr-term-order item (cdr list))))
        (t (cons item list))))">insert-cdr-term-order</a> (<a class="sym-link local-def" href="#def-normalize-addend" data-sym="NORMALIZE-ADDEND" title="(defun normalize-addend (addend)
  (cond ((variablep addend) (cons 1 addend)) ((fquotep addend) (cons 1 addend))
        ((flambda-applicationp addend) (cons 1 addend))
        ((eq (ffn-symb addend) &#39;unary--) (cons -1 (fargn addend 1)))
        ((eq (ffn-symb addend) &#39;binary-*)
...">normalize-addend</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
        (<a class="sym-link local-def" href="#def-normalize-linear-sum-2" data-sym="NORMALIZE-LINEAR-SUM-2" title="(defun normalize-linear-sum-2 (term)
  (cond
   ((eq (fn-symb term) &#39;binary-+)
    (insert-cdr-term-order (normalize-addend (fargn term 1))
                           (normalize-linear-sum-2 (fargn term 2))))">normalize-linear-sum-2</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link local-def" href="#def-normalize-addend" data-sym="NORMALIZE-ADDEND" title="(defun normalize-addend (addend)
  (cond ((variablep addend) (cons 1 addend)) ((fquotep addend) (cons 1 addend))
        ((flambda-applicationp addend) (cons 1 addend))
        ((eq (ffn-symb addend) &#39;unary--) (cons -1 (fargn addend 1)))
        ((eq (ffn-symb addend) &#39;binary-*)
...">normalize-addend</a> term)))))</pre>
  </div>

<div class="form-block function" id="def-normalize-linear-sum-1" data-defines="NORMALIZE-LINEAR-SUM-1" data-references="/,MAP-MULTIPLY-CAR,TEMP-2,LET,EQL,OR,CAR,MULTIPLICATIVE-CONSTANT,NORMALIZE-LINEAR-SUM-2,TEMP-1,LET*,BINARY-+,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,T,*0*,+,UNQUOTE,RATIONALP,FQUOTEP,MV,VARIABLEP,COND,TERM,ADDITIVE-CONSTANT,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM" data-part-name="NORMALIZE-LINEAR-SUM-1" data-part-args="TERM,ADDITIVE-CONSTANT" data-part-body="/,MAP-MULTIPLY-CAR,TEMP-2,LET,EQL,OR,CAR,MULTIPLICATIVE-CONSTANT,NORMALIZE-LINEAR-SUM-2,TEMP-1,LET*,BINARY-+,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,T,*0*,+,UNQUOTE,RATIONALP,FQUOTEP,ADDITIVE-CONSTANT,MV,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-LINEAR-SUM-1">normalize-linear-sum-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-linear-sum-1" data-sym="NORMALIZE-LINEAR-SUM-1" title="(defun normalize-linear-sum-1 (additive-constant term)
  (cond ((variablep term) (mv additive-constant 1 term))
        ((fquotep term)
         (cond
          ((rationalp (unquote term))
...">normalize-linear-sum-1</a>
  (additive-constant term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> term))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> term)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> additive-constant (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> term)) <span class="number">1</span> <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> term))))
    ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> term))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'unary--) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">-1</span> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'binary-*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
           (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant
            (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> term))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'binary-+) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((temp-1 (<a class="sym-link local-def" href="#def-normalize-linear-sum-2" data-sym="NORMALIZE-LINEAR-SUM-2" title="(defun normalize-linear-sum-2 (term)
  (cond
   ((eq (fn-symb term) &#39;binary-+)
    (insert-cdr-term-order (normalize-addend (fargn term 1))
                           (normalize-linear-sum-2 (fargn term 2))))">normalize-linear-sum-2</a> term)) (multiplicative-constant (car (car temp-1))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> multiplicative-constant <span class="number">0</span>)
             (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> multiplicative-constant <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> temp-1))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp-2 (<a class="sym-link local-def" href="#def-map-multiply-car" data-sym="MAP-MULTIPLY-CAR" title="(defun map-multiply-car (multiplicative-constant x)
  (cond ((endp x) nil)
        (t
         (cons (cons (* multiplicative-constant (car (car x))) (cdr (car x)))
               (map-multiply-car multiplicative-constant (cdr x))))))">map-multiply-car</a> (<a class="sym-link system" href="axioms.html#def-_2F" data-sym="/">/</a> multiplicative-constant) temp-1)))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant multiplicative-constant temp-2))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> additive-constant <span class="number">1</span> term))))</pre>
  </div>

<div class="form-block function" id="def-normalize-linear-sum" data-defines="NORMALIZE-LINEAR-SUM" data-references="NORMALIZE-LINEAR-SUM-1,BINARY-+,T,UNQUOTE,RATIONALP,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,FQUOTEP,MV,VARIABLEP,COND,TERM,DEFUN" data-used-by="TYPE-SET-FINISH,TYPE-SET-FINISH-1" data-part-name="NORMALIZE-LINEAR-SUM" data-part-args="TERM" data-part-body="NORMALIZE-LINEAR-SUM-1,BINARY-+,T,UNQUOTE,RATIONALP,QUOTEP,AND,BINARY-*,FARGN,UNARY--,QUOTE,FFN-SYMB,EQ,FLAMBDA-APPLICATIONP,FQUOTEP,MV,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-LINEAR-SUM">normalize-linear-sum</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-linear-sum" data-sym="NORMALIZE-LINEAR-SUM" title="(defun normalize-linear-sum (term)
  (cond ((variablep term) (mv 0 1 term)) ((fquotep term) (mv 0 1 term))
        ((flambda-applicationp term) (mv 0 1 term))
        ((eq (ffn-symb term) &#39;unary--) (mv 0 -1 (fargn term 1)))
        ((eq (ffn-symb term) &#39;binary-*)
...">normalize-linear-sum</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">1</span> term))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">1</span> term))
    ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">1</span> term))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'unary--) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">-1</span> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'binary-*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
           (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">1</span> term))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'binary-+) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
           (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))) (<a class="sym-link local-def" href="#def-normalize-linear-sum-1" data-sym="NORMALIZE-LINEAR-SUM-1" title="(defun normalize-linear-sum-1 (additive-constant term)
  (cond ((variablep term) (mv additive-constant 1 term))
        ((fquotep term)
         (cond
          ((rationalp (unquote term))
...">normalize-linear-sum-1</a> (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-normalize-linear-sum-1" data-sym="NORMALIZE-LINEAR-SUM-1" title="(defun normalize-linear-sum-1 (additive-constant term)
  (cond ((variablep term) (mv additive-constant 1 term))
        ((fquotep term)
         (cond
          ((rationalp (unquote term))
...">normalize-linear-sum-1</a> <span class="number">0</span> term))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> <span class="number">1</span> term))))</pre>
  </div>

<div class="form-block function" id="def-normalize-linear-sum-p1" data-defines="NORMALIZE-LINEAR-SUM-P1" data-references="T,FARGN,CDR,BINARY-+,QUOTE,FFN-SYMB-P,NULL,COND,TERM-TO-MATCH,STRIPPED-TERM,DEFUN" data-used-by="NORMALIZE-LINEAR-SUM-P" data-part-name="NORMALIZE-LINEAR-SUM-P1" data-part-args="TERM-TO-MATCH,STRIPPED-TERM" data-part-body="T,FARGN,CDR,NORMALIZE-LINEAR-SUM-P1,BINARY-+,QUOTE,TERM-TO-MATCH,FFN-SYMB-P,STRIPPED-TERM,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-LINEAR-SUM-P1">normalize-linear-sum-p1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-linear-sum-p1" data-sym="NORMALIZE-LINEAR-SUM-P1" title="(defun normalize-linear-sum-p1 (stripped-term term-to-match)
  (cond ((null stripped-term) nil)
        ((ffn-symb-p term-to-match &#39;binary-+)
         (normalize-linear-sum-p1 (cdr stripped-term) (fargn term-to-match 2)))
        (t (null (cdr stripped-term)))))">normalize-linear-sum-p1</a>
  (stripped-term term-to-match)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> stripped-term) nil)
    ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term-to-match 'binary-+) (<a class="sym-link local-def" href="#def-normalize-linear-sum-p1" data-sym="NORMALIZE-LINEAR-SUM-P1" title="(defun normalize-linear-sum-p1 (stripped-term term-to-match)
  (cond ((null stripped-term) nil)
        ((ffn-symb-p term-to-match &#39;binary-+)
         (normalize-linear-sum-p1 (cdr stripped-term) (fargn term-to-match 2)))
        (t (null (cdr stripped-term)))))">normalize-linear-sum-p1</a> (cdr stripped-term)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term-to-match <span class="number">2</span>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr stripped-term)))))</pre>
  </div>

<div class="form-block function" id="def-normalize-linear-sum-p" data-defines="NORMALIZE-LINEAR-SUM-P" data-references="NOT,NORMALIZE-LINEAR-SUM-P1,CAAR,ACL2-NUMBERP,CAR,CONSP,T,FARGN,QUOTEP,BINARY-+,QUOTE,FFN-SYMB-P,AND,COND,TERM,LET,TERM-TO-MATCH,STRIPPED-TERM,DEFUN" data-used-by="TYPE-SET-FINISH-1" data-part-name="NORMALIZE-LINEAR-SUM-P" data-part-args="TERM-TO-MATCH,STRIPPED-TERM" data-part-body="NOT,NORMALIZE-LINEAR-SUM-P1,CAAR,ACL2-NUMBERP,CAR,STRIPPED-TERM,CONSP,T,FARGN,QUOTEP,BINARY-+,QUOTE,TERM-TO-MATCH,FFN-SYMB-P,AND,COND,TERM,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-LINEAR-SUM-P">normalize-linear-sum-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-linear-sum-p" data-sym="NORMALIZE-LINEAR-SUM-P" title="(defun normalize-linear-sum-p (stripped-term term-to-match)
  (let ((term
         (cond
          ((and (ffn-symb-p term-to-match &#39;binary-+)
                (quotep (fargn term-to-match 1)))
...">normalize-linear-sum-p</a>
  (stripped-term term-to-match)
  (let ((term (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term-to-match 'binary-+)
            (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term-to-match <span class="number">1</span>))) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term-to-match <span class="number">2</span>))
         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term-to-match))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp stripped-term)
         (consp (car stripped-term))
         (acl2-numberp (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> stripped-term))) (<a class="sym-link local-def" href="#def-normalize-linear-sum-p1" data-sym="NORMALIZE-LINEAR-SUM-P1" title="(defun normalize-linear-sum-p1 (stripped-term term-to-match)
  (cond ((null stripped-term) nil)
        ((ffn-symb-p term-to-match &#39;binary-+)
         (normalize-linear-sum-p1 (cdr stripped-term) (fargn term-to-match 2)))
        (t (null (cdr stripped-term)))))">normalize-linear-sum-p1</a> stripped-term term))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'binary-+))))))</pre>
  </div>

<div class="form-block function" id="def-type-set-finish-1" data-defines="TYPE-SET-FINISH-1" data-references="T,CDR,CONS-TAG-TREES,PUFFERT,IF,TS-INTERSECTION,NEW-TS3,*TYPE-SET-BINARY-+-TABLE*,TYPE-SET-BINARY-+-TABLE,NEW-TS2,*TYPE-SET-BINARY-*-TABLE*,TYPE-SET-BINARY-*-TABLE,QUOTE,AREF2,NEW-TS1,MERGED-ADDITIVE-CONST-TS,TYPE-SET-QUOTE,MERGED-MULTIPLICATIVE-CONST-TS,-,MERGED-ADDITIVE-CONST,/,*,MERGED-MULTIPLICATIVE-CONST,LET*,EQL,NOT,EQUAL,NORMALIZE-LINEAR-SUM,STRIPPED-TERM-TO-MATCH,TYPED-MULTIPLICATIVE-CONST,TYPED-ADDITIVE-CONST,MV-LET,CDDR,TTREE-TO-MATCH,TYPE-TO-MATCH,TERM-TO-MATCH,LET,NORMALIZE-LINEAR-SUM-P,*TS-RATIO*,*TS-INTEGER*,CAR,CADR,TS-SUBSETP,OR,AND,MV,NULL,COND,TYPE-ALIST,TTREE,TS,STRIPPED-TERM,MULTIPLICATIVE-CONST,ADDITIVE-CONST,DEFUN" data-used-by="TYPE-SET-FINISH" data-part-name="TYPE-SET-FINISH-1" data-part-args="TYPE-ALIST,TTREE,TS,STRIPPED-TERM,MULTIPLICATIVE-CONST,ADDITIVE-CONST" data-part-body="T,CDR,TYPE-SET-FINISH-1,CONS-TAG-TREES,PUFFERT,IF,TS-INTERSECTION,NEW-TS3,*TYPE-SET-BINARY-+-TABLE*,TYPE-SET-BINARY-+-TABLE,NEW-TS2,*TYPE-SET-BINARY-*-TABLE*,TYPE-SET-BINARY-*-TABLE,QUOTE,AREF2,NEW-TS1,MERGED-ADDITIVE-CONST-TS,TYPE-SET-QUOTE,MERGED-MULTIPLICATIVE-CONST-TS,ADDITIVE-CONST,-,MERGED-ADDITIVE-CONST,/,MULTIPLICATIVE-CONST,*,MERGED-MULTIPLICATIVE-CONST,LET*,EQL,NOT,EQUAL,NORMALIZE-LINEAR-SUM,STRIPPED-TERM-TO-MATCH,TYPED-MULTIPLICATIVE-CONST,TYPED-ADDITIVE-CONST,MV-LET,CDDR,TTREE-TO-MATCH,TYPE-TO-MATCH,TERM-TO-MATCH,LET,STRIPPED-TERM,NORMALIZE-LINEAR-SUM-P,*TS-RATIO*,*TS-INTEGER*,CAR,CADR,TS-SUBSETP,OR,AND,TTREE,TS,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-FINISH-1">type-set-finish-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a>
  (additive-const multiplicative-const
    stripped-term
    ts
    ttree
    type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts ttree))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ts-subsetp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car type-alist)) *ts-integer*)
         (ts-subsetp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car type-alist)) *ts-ratio*))
       (<a class="sym-link local-def" href="#def-normalize-linear-sum-p" data-sym="NORMALIZE-LINEAR-SUM-P" title="(defun normalize-linear-sum-p (stripped-term term-to-match)
  (let ((term
         (cond
          ((and (ffn-symb-p term-to-match &#39;binary-+)
                (quotep (fargn term-to-match 1)))
...">normalize-linear-sum-p</a> stripped-term
         (car (car type-alist)))) (let ((term-to-match (car (car type-alist))) (type-to-match (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car type-alist)))
          (ttree-to-match (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car type-alist))))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (typed-additive-const typed-multiplicative-const
            stripped-term-to-match)
          (<a class="sym-link local-def" href="#def-normalize-linear-sum" data-sym="NORMALIZE-LINEAR-SUM" title="(defun normalize-linear-sum (term)
  (cond ((variablep term) (mv 0 1 term)) ((fquotep term) (mv 0 1 term))
        ((flambda-applicationp term) (mv 0 1 term))
        ((eq (ffn-symb term) &#39;unary--) (mv 0 -1 (fargn term 1)))
        ((eq (ffn-symb term) &#39;binary-*)
...">normalize-linear-sum</a> term-to-match)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal stripped-term stripped-term-to-match)
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> typed-multiplicative-const <span class="number">0</span>))) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((merged-multiplicative-const (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> multiplicative-const (<a class="sym-link system" href="axioms.html#def-_2F" data-sym="/">/</a> typed-multiplicative-const))) (merged-additive-const (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> additive-const
                      (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> merged-multiplicative-const typed-additive-const))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> merged-additive-const <span class="number">0</span>))
                     (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> merged-multiplicative-const <span class="number">1</span>))) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((merged-multiplicative-const-ts (<a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a> merged-multiplicative-const)) (merged-additive-const-ts (<a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a> merged-additive-const))
                        (new-ts1 (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-*-table
                            <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table_2A" data-sym="*TYPE-SET-BINARY-*-TABLE*" title="(defconst *type-set-binary-*-table*
          (compress2 &#39;type-set-binary-*-table *type-set-binary-*-table-list*))">*type-set-binary-*-table*</a>
                            merged-multiplicative-const-ts
                            type-to-match))
                        (new-ts2 (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-+-table
                            <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table_2A" data-sym="*TYPE-SET-BINARY-+-TABLE*" title="(defconst *type-set-binary-+-table*
          (compress2 &#39;type-set-binary-+-table *type-set-binary-+-table-list*))">*type-set-binary-+-table*</a>
                            merged-additive-const-ts
                            new-ts1))
                        (new-ts3 (ts-intersection ts new-ts2)))
                      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ts-subsetp new-ts3 *ts-integer*)
                          (ts-subsetp new-ts3 *ts-ratio*))
                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-ts3 (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree ttree-to-match)))
                        (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
                          multiplicative-const
                          stripped-term
                          ts
                          ttree
                          (cdr type-alist)))))
                  ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> merged-additive-const <span class="number">0</span>)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((merged-additive-const-ts (<a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a> merged-additive-const)) (new-ts1 (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-+-table
                            <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2B-table_2A" data-sym="*TYPE-SET-BINARY-+-TABLE*" title="(defconst *type-set-binary-+-table*
          (compress2 &#39;type-set-binary-+-table *type-set-binary-+-table-list*))">*type-set-binary-+-table*</a>
                            merged-additive-const-ts
                            type-to-match))
                        (new-ts2 (ts-intersection ts new-ts1)))
                      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ts-subsetp new-ts2 *ts-integer*)
                          (ts-subsetp new-ts2 *ts-ratio*))
                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-ts2 (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree ttree-to-match)))
                        (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
                          multiplicative-const
                          stripped-term
                          ts
                          ttree
                          (cdr type-alist)))))
                  ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> merged-multiplicative-const <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((merged-multiplicative-const-ts (<a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a> merged-multiplicative-const)) (new-ts1 (<a class="sym-link system" href="axioms.html#def-aref2" data-sym="AREF2">aref2</a> 'type-set-binary-*-table
                            <a class="sym-link local-def" href="#def-_2Atype-set-binary-_2A-table_2A" data-sym="*TYPE-SET-BINARY-*-TABLE*" title="(defconst *type-set-binary-*-table*
          (compress2 &#39;type-set-binary-*-table *type-set-binary-*-table-list*))">*type-set-binary-*-table*</a>
                            merged-multiplicative-const-ts
                            type-to-match))
                        (new-ts2 (ts-intersection ts new-ts1)))
                      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ts-subsetp new-ts2 *ts-integer*)
                          (ts-subsetp new-ts2 *ts-ratio*))
                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-ts2 (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree ttree-to-match)))
                        (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
                          multiplicative-const
                          stripped-term
                          ts
                          ttree
                          (cdr type-alist)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
                      multiplicative-const
                      stripped-term
                      ts
                      ttree
                      (cdr type-alist))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
                multiplicative-const
                stripped-term
                ts
                ttree
                (cdr type-alist)))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
        multiplicative-const
        stripped-term
        ts
        ttree
        (cdr type-alist)))))</pre>
  </div>

<div class="form-block function" id="def-type-set-finish" data-defines="TYPE-SET-FINISH" data-references="TYPE-SET-FINISH-1,NORMALIZE-LINEAR-SUM,STRIPPED-TERM,MULTIPLICATIVE-CONST,ADDITIVE-CONST,*TS-RATIO*,*TS-INTEGER*,TS-INTERSECTP,*TS-RATIONAL*,AND,CONS-TAG-TREES,TS-INTERSECTION,T,TS-SUBSETP,MV,NULL,COND,TTREE,TS,MV-LET,TYPE-ALIST,TTREE1,TS1,TTREE0,TS0,X,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="TYPE-SET-FINISH" data-part-args="TYPE-ALIST,TTREE1,TS1,TTREE0,TS0,X" data-part-body="TYPE-ALIST,TYPE-SET-FINISH-1,X,NORMALIZE-LINEAR-SUM,STRIPPED-TERM,MULTIPLICATIVE-CONST,ADDITIVE-CONST,*TS-RATIO*,*TS-INTEGER*,TS-INTERSECTP,*TS-RATIONAL*,AND,TTREE0,CONS-TAG-TREES,TS-INTERSECTION,T,TS-SUBSETP,TTREE1,TS1,MV,TS0,NULL,COND,TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-FINISH">type-set-finish</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a>
  (x ts0 ttree0 ts1 ttree1 type-alist)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ts0) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts1 ttree1))
      ((ts-subsetp ts1 ts0) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts1 ttree1))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-intersection ts0 ts1)
          (cons-tag-trees ttree0 ttree1))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts *ts-rational*)
         (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-integer*)
         (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-ratio*)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (additive-const multiplicative-const stripped-term)
          (<a class="sym-link local-def" href="#def-normalize-linear-sum" data-sym="NORMALIZE-LINEAR-SUM" title="(defun normalize-linear-sum (term)
  (cond ((variablep term) (mv 0 1 term)) ((fquotep term) (mv 0 1 term))
        ((flambda-applicationp term) (mv 0 1 term))
        ((eq (ffn-symb term) &#39;unary--) (mv 0 -1 (fargn term 1)))
        ((eq (ffn-symb term) &#39;binary-*)
...">normalize-linear-sum</a> x)
          (<a class="sym-link local-def" href="#def-type-set-finish-1" data-sym="TYPE-SET-FINISH-1" title="(defun type-set-finish-1
       (additive-const multiplicative-const stripped-term ts ttree type-alist)
  (cond ((null type-alist) (mv ts ttree))
        ((and
          (or (ts-subsetp (cadr (car type-alist)) *ts-integer*)
...">type-set-finish-1</a> additive-const
            multiplicative-const
            stripped-term
            ts
            ttree
            type-alist)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts ttree)))))</pre>
  </div>

<div class="form-block function" id="def-search-type-alist-rec" data-defines="SEARCH-TYPE-ALIST-REC" data-references="CDR,CDDR,CONS-TAG-TREES,T,ONE-WAY-UNIFY1,ANS,MV-LET,CAR,CADR,TS-SUBSETP,MV,NULL,COND,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,ALT-TERM,TERM,DEFUN" data-used-by="SEARCH-TYPE-ALIST-WITH-REST" data-part-name="SEARCH-TYPE-ALIST-REC" data-part-args="TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,ALT-TERM,TERM" data-part-body="SEARCH-TYPE-ALIST-REC,ALT-TERM,CDR,CDDR,CONS-TAG-TREES,T,TERM,ONE-WAY-UNIFY1,ANS,MV-LET,TYP,CAR,CADR,TS-SUBSETP,TTREE,UNIFY-SUBST,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-TYPE-ALIST-REC">search-type-alist-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-type-alist-rec" data-sym="SEARCH-TYPE-ALIST-REC" title="(defun search-type-alist-rec (term alt-term typ type-alist unify-subst ttree)
  (cond ((null type-alist) (mv nil unify-subst ttree nil))
        ((ts-subsetp (cadr (car type-alist)) typ)
         (mv-let (ans unify-subst)
                 (one-way-unify1 term (car (car type-alist)) unify-subst)
...">search-type-alist-rec</a>
  (term alt-term typ type-alist unify-subst ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil unify-subst ttree nil))
    ((ts-subsetp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car type-alist)) typ) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans unify-subst)
        (one-way-unify1 term (car (car type-alist)) unify-subst)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
              unify-subst
              (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car type-alist)) ttree)
              (cdr type-alist)))
          (alt-term (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans unify-subst)
              (one-way-unify1 alt-term (car (car type-alist)) unify-subst)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    unify-subst
                    (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car type-alist)) ttree)
                    (cdr type-alist)))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-type-alist-rec" data-sym="SEARCH-TYPE-ALIST-REC" title="(defun search-type-alist-rec (term alt-term typ type-alist unify-subst ttree)
  (cond ((null type-alist) (mv nil unify-subst ttree nil))
        ((ts-subsetp (cadr (car type-alist)) typ)
         (mv-let (ans unify-subst)
                 (one-way-unify1 term (car (car type-alist)) unify-subst)
...">search-type-alist-rec</a> term
                    alt-term
                    typ
                    (cdr type-alist)
                    unify-subst
                    ttree)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-type-alist-rec" data-sym="SEARCH-TYPE-ALIST-REC" title="(defun search-type-alist-rec (term alt-term typ type-alist unify-subst ttree)
  (cond ((null type-alist) (mv nil unify-subst ttree nil))
        ((ts-subsetp (cadr (car type-alist)) typ)
         (mv-let (ans unify-subst)
                 (one-way-unify1 term (car (car type-alist)) unify-subst)
...">search-type-alist-rec</a> term
              alt-term
              typ
              (cdr type-alist)
              unify-subst
              ttree)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-type-alist-rec" data-sym="SEARCH-TYPE-ALIST-REC" title="(defun search-type-alist-rec (term alt-term typ type-alist unify-subst ttree)
  (cond ((null type-alist) (mv nil unify-subst ttree nil))
        ((ts-subsetp (cadr (car type-alist)) typ)
         (mv-let (ans unify-subst)
                 (one-way-unify1 term (car (car type-alist)) unify-subst)
...">search-type-alist-rec</a> term
        alt-term
        typ
        (cdr type-alist)
        unify-subst
        ttree))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-free-varsp" data-defines="FREE-VARSP" data-references="CDR,CAR,OR,NULL,ARGS,FARGS,FREE-VARSP-LST,T,FQUOTEP,ASSOC-EQ,NOT,VARIABLEP,COND,ALIST,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="TYPE-SET-REC,BINDING-HYP-P,SEARCH-TYPE-ALIST-WITH-REST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FREE-VARSP">free-varsp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a>
    (term alist)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term alist)))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (free-varsp-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) alist))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> free-varsp-lst
    (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> alist)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) alist)
          (free-varsp-lst (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) alist))))))</pre>
  </div>

<div class="form-block function" id="def-search-type-alist-with-rest" data-defines="SEARCH-TYPE-ALIST-WITH-REST" data-references="SEARCH-TYPE-ALIST-REC,TERM-ORDER,ARG2,ARG1,LET,T,FARGN,FCONS-TERM*,FREE-VARSP,MV,FFN-SYMB,EQUIVALENCE-RELATIONP,NOT,FQUOTEP,VARIABLEP,OR,COND,ALT-TERM,MV-LET,WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM,DEFUN" data-used-by="TYPE-SET-REC,SEARCH-TYPE-ALIST" data-part-name="SEARCH-TYPE-ALIST-WITH-REST" data-part-args="WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM" data-part-body="TTREE,TYPE-ALIST,TYP,SEARCH-TYPE-ALIST-REC,TERM-ORDER,ARG2,ARG1,LET,T,FARGN,FCONS-TERM*,UNIFY-SUBST,FREE-VARSP,MV,WRLD,FFN-SYMB,EQUIVALENCE-RELATIONP,NOT,FQUOTEP,VARIABLEP,OR,COND,ALT-TERM,TERM,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-TYPE-ALIST-WITH-REST">search-type-alist-with-rest</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-type-alist-with-rest" data-sym="SEARCH-TYPE-ALIST-WITH-REST" title="(defun search-type-alist-with-rest (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist-with-rest</a>
  (term typ type-alist unify-subst ttree wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term alt-term)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term)
         (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)
         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term nil))
      ((<a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a> term unify-subst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term
          (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a> arg1 arg2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term nil))))))
    (<a class="sym-link local-def" href="#def-search-type-alist-rec" data-sym="SEARCH-TYPE-ALIST-REC" title="(defun search-type-alist-rec (term alt-term typ type-alist unify-subst ttree)
  (cond ((null type-alist) (mv nil unify-subst ttree nil))
        ((ts-subsetp (cadr (car type-alist)) typ)
         (mv-let (ans unify-subst)
                 (one-way-unify1 term (car (car type-alist)) unify-subst)
...">search-type-alist-rec</a> term
      alt-term
      typ
      type-alist
      unify-subst
      ttree)))</pre>
  </div>

<div class="form-block function" id="def-search-type-alist" data-defines="SEARCH-TYPE-ALIST" data-references="MV,IGNORE,DECLARE,SEARCH-TYPE-ALIST-WITH-REST,REST-TYPE-ALIST,ANS,MV-LET,WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM,DEFUN" data-used-by="LOOKUP-HYP" data-part-name="SEARCH-TYPE-ALIST" data-part-args="WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM" data-part-body="MV,IGNORE,DECLARE,WRLD,TYPE-ALIST,TYP,TERM,SEARCH-TYPE-ALIST-WITH-REST,REST-TYPE-ALIST,TTREE,UNIFY-SUBST,ANS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-TYPE-ALIST">search-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-type-alist" data-sym="SEARCH-TYPE-ALIST" title="(defun search-type-alist (term typ type-alist unify-subst ttree wrld)
  (mv-let (ans unify-subst ttree rest-type-alist)
          (search-type-alist-with-rest term typ type-alist unify-subst ttree
                                       wrld)
          (declare (ignore rest-type-alist)) (mv ans unify-subst ttree)))">search-type-alist</a>
  (term typ type-alist unify-subst ttree wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans unify-subst ttree rest-type-alist)
    (<a class="sym-link local-def" href="#def-search-type-alist-with-rest" data-sym="SEARCH-TYPE-ALIST-WITH-REST" title="(defun search-type-alist-with-rest (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist-with-rest</a> term
      typ
      type-alist
      unify-subst
      ttree
      wrld)
    (declare (ignore rest-type-alist))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans unify-subst ttree)))</pre>
  </div>

<div class="form-block function" id="def-term-and-typ-to-lookup" data-defines="TERM-AND-TYP-TO-LOOKUP" data-references="*TS-NON-NIL*,*TS-NIL*,T,IF,FARGN,MV,RECOGNIZER-TUPLE,ACCESS,COND,FFN-SYMB,MOST-RECENT-ENABLED-RECOG-TUPLE,FLAMBDA-APPLICATIONP,FQUOTEP,NOT,NVARIABLEP,AND,RECOG-TUPLE,LET,STRIP-NOT,TERM,NOT-FLG,MV-LET,ENS,WRLD,HYP,DEFUN" data-used-by="TYPE-SET-REC,LOOKUP-HYP" data-part-name="TERM-AND-TYP-TO-LOOKUP" data-part-args="ENS,WRLD,HYP" data-part-body="*TS-NON-NIL*,*TS-NIL*,T,IF,FARGN,MV,RECOGNIZER-TUPLE,ACCESS,COND,ENS,WRLD,FFN-SYMB,MOST-RECENT-ENABLED-RECOG-TUPLE,FLAMBDA-APPLICATIONP,FQUOTEP,NOT,NVARIABLEP,AND,RECOG-TUPLE,LET,HYP,STRIP-NOT,TERM,NOT-FLG,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERM-AND-TYP-TO-LOOKUP">term-and-typ-to-lookup</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-term-and-typ-to-lookup" data-sym="TERM-AND-TYP-TO-LOOKUP" title="(defun term-and-typ-to-lookup (hyp wrld ens)
  (mv-let (not-flg term) (strip-not hyp)
          (let ((recog-tuple
                 (and (nvariablep term) (not (fquotep term))
                      (not (flambda-applicationp term))
...">term-and-typ-to-lookup</a>
  (hyp wrld <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg term)
    (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> hyp)
    (let ((recog-tuple (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> term)
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term))
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term))
           (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE" title="(defun most-recent-enabled-recog-tuple (fn wrld ens)
  (let ((lst (getpropc fn &#39;recognizer-alist nil wrld)))
    (and lst (most-recent-enabled-recog-tuple1 lst ens))))">most-recent-enabled-recog-tuple</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> recog-tuple
           (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:strongp</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            (if not-flg
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:false-ts</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:true-ts</span>))
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:rune</span>)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term
            (if not-flg
              *ts-nil*
              *ts-non-nil*)
            nil))))))</pre>
  </div>

<div class="form-block function" id="def-lookup-hyp" data-defines="LOOKUP-HYP" data-references="PUSH-LEMMA,AND,IF,MV,SEARCH-TYPE-ALIST,ANS,TERM-AND-TYP-TO-LOOKUP,RUNE,TYP,TERM,MV-LET,ENS,TTREE,UNIFY-SUBST,WRLD,TYPE-ALIST,HYP,DEFUN" data-part-name="LOOKUP-HYP" data-part-args="ENS,TTREE,UNIFY-SUBST,WRLD,TYPE-ALIST,HYP" data-part-body="PUSH-LEMMA,AND,IF,MV,TYPE-ALIST,SEARCH-TYPE-ALIST,TTREE,UNIFY-SUBST,ANS,ENS,WRLD,HYP,TERM-AND-TYP-TO-LOOKUP,RUNE,TYP,TERM,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOOKUP-HYP">lookup-hyp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lookup-hyp" data-sym="LOOKUP-HYP" title="(defun lookup-hyp (hyp type-alist wrld unify-subst ttree ens)
  (mv-let (term typ rune) (term-and-typ-to-lookup hyp wrld ens)
          (mv-let (ans unify-subst ttree)
                  (search-type-alist term typ type-alist unify-subst ttree
                                     wrld)
...">lookup-hyp</a>
  (hyp type-alist wrld unify-subst ttree <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term typ rune)
    (<a class="sym-link local-def" href="#def-term-and-typ-to-lookup" data-sym="TERM-AND-TYP-TO-LOOKUP" title="(defun term-and-typ-to-lookup (hyp wrld ens)
  (mv-let (not-flg term) (strip-not hyp)
          (let ((recog-tuple
                 (and (nvariablep term) (not (fquotep term))
                      (not (flambda-applicationp term))
...">term-and-typ-to-lookup</a> hyp wrld <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans unify-subst ttree)
      (<a class="sym-link local-def" href="#def-search-type-alist" data-sym="SEARCH-TYPE-ALIST" title="(defun search-type-alist (term typ type-alist unify-subst ttree wrld)
  (mv-let (ans unify-subst ttree rest-type-alist)
          (search-type-alist-with-rest term typ type-alist unify-subst ttree
                                       wrld)
          (declare (ignore rest-type-alist)) (mv ans unify-subst ttree)))">search-type-alist</a> term
        typ
        type-alist
        unify-subst
        ttree
        wrld)
      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans
        unify-subst
        (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ans rune)
          (push-lemma rune ttree)
          ttree)))))</pre>
  </div>

<div class="form-block function" id="def-bind-free-vars-to-unbound-free-vars" data-defines="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" data-references="UNBOUND-FREE-,QUOTE,LIST,PACKN,CONS,T,CDR,CAR,ASSOC-EQ,ENDP,COND,ALIST,VARS,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" data-part-args="ALIST,VARS" data-part-body="UNBOUND-FREE-,QUOTE,LIST,PACKN,CONS,T,CDR,BIND-FREE-VARS-TO-UNBOUND-FREE-VARS,CAR,ASSOC-EQ,ALIST,VARS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS">bind-free-vars-to-unbound-free-vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bind-free-vars-to-unbound-free-vars" data-sym="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" title="(defun bind-free-vars-to-unbound-free-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (bind-free-vars-to-unbound-free-vars (cdr vars) alist))
        (t
...">bind-free-vars-to-unbound-free-vars</a>
  (vars alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> vars) alist)
    ((<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car vars) alist) (<a class="sym-link local-def" href="#def-bind-free-vars-to-unbound-free-vars" data-sym="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" title="(defun bind-free-vars-to-unbound-free-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (bind-free-vars-to-unbound-free-vars (cdr vars) alist))
        (t
...">bind-free-vars-to-unbound-free-vars</a> (cdr vars) alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bind-free-vars-to-unbound-free-vars" data-sym="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" title="(defun bind-free-vars-to-unbound-free-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (bind-free-vars-to-unbound-free-vars (cdr vars) alist))
        (t
...">bind-free-vars-to-unbound-free-vars</a> (cdr vars)
        (cons (cons (car vars) (<a class="sym-link system" href="basis-a.html#def-packn" data-sym="PACKN">packn</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'unbound-free- (car vars))))
          alist)))))</pre>
  </div>

<div class="form-block other" id="def-x-xrunep" data-defines="X-XRUNEP" data-references="CAR,EQ,OR,XRUNE,DEFABBREV" data-used-by="POP-ACCP-FN,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE,XRUNE-RUNE,CONC-XRUNE-RUNE,CONC-XRUNE,HYP-XRUNE-RUNE,HYP-XRUNE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="X-XRUNEP">x-xrunep</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a>
  (xrune)
  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:hyp</span>) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:conc</span>)))</pre>
  </div>

<div class="form-block other" id="def-hyp-xrune" data-defines="HYP-XRUNE" data-references="LIST*,X-XRUNEP,NOT,ASSERT$,RUNE,N,DEFABBREV" data-used-by="PUSH-ACCP-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="HYP-XRUNE">hyp-xrune</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-hyp-xrune" data-sym="HYP-XRUNE" title="(defabbrev hyp-xrune (n rune)
           (assert$ (not (x-xrunep rune)) (list* :hyp rune n)))">hyp-xrune</a>
  (n rune)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> rune)) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:hyp</span> rune n)))</pre>
  </div>

<div class="form-block other" id="def-hyp-xrune-rune" data-defines="HYP-XRUNE-RUNE" data-references="CADR,CAR,EQ,X-XRUNEP,AND,ASSERT$,XRUNE,DEFABBREV" data-used-by="SORT-XRUNE-ALIST-BY-RUNE1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="HYP-XRUNE-RUNE">hyp-xrune-rune</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-hyp-xrune-rune" data-sym="HYP-XRUNE-RUNE" title="(defabbrev hyp-xrune-rune (xrune)
           (assert$ (and (x-xrunep xrune) (eq (car xrune) :hyp)) (cadr xrune)))">hyp-xrune-rune</a>
  (xrune)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> xrune) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:hyp</span>))
    (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> xrune)))</pre>
  </div>

<div class="form-block other" id="def-conc-xrune" data-defines="CONC-XRUNE" data-references="LIST*,X-XRUNEP,NOT,ASSERT$,RUNE,DEFABBREV" data-used-by="PUSH-ACCP-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONC-XRUNE">conc-xrune</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-conc-xrune" data-sym="CONC-XRUNE" title="(defabbrev conc-xrune (rune) (assert$ (not (x-xrunep rune)) (list* :conc rune)))">conc-xrune</a>
  (rune)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> rune)) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:conc</span> rune)))</pre>
  </div>

<div class="form-block other" id="def-conc-xrune-rune" data-defines="CONC-XRUNE-RUNE" data-references="CDR,CAR,EQ,X-XRUNEP,AND,ASSERT$,XRUNE,DEFABBREV" data-used-by="SORT-XRUNE-ALIST-BY-RUNE1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONC-XRUNE-RUNE">conc-xrune-rune</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-conc-xrune-rune" data-sym="CONC-XRUNE-RUNE" title="(defabbrev conc-xrune-rune (xrune)
           (assert$ (and (x-xrunep xrune) (eq (car xrune) :conc)) (cdr xrune)))">conc-xrune-rune</a>
  (xrune)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> xrune) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:conc</span>))
    (cdr xrune)))</pre>
  </div>

<div class="form-block other" id="def-xrune-rune" data-defines="XRUNE-RUNE" data-references="T,CDR,CADR,CAR,EQ,IF,X-XRUNEP,COND,XRUNE,DEFABBREV" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1,ADD-ACCUMULATED-PERSISTENCE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="XRUNE-RUNE">xrune-rune</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-xrune-rune" data-sym="XRUNE-RUNE" title="(defabbrev xrune-rune (xrune)
           (cond
            ((x-xrunep xrune)
             (if (eq (car xrune) :hyp)
                 (cadr xrune)
...">xrune-rune</a>
  (xrune)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> xrune) (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:hyp</span>)
        (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> xrune)
        (cdr xrune)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> xrune)))</pre>
  </div>

<div class="form-block other" id="def-rune_3D" data-defines="RUNE=" data-references="CDR,EQUAL,CAR,EQ,AND,RUNE2,RUNE1,DEFABBREV" data-used-by="XRUNE=" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="RUNE=">rune=</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-rune_3D" data-sym="RUNE=" title="(defabbrev rune= (rune1 rune2)
           (and (eq (car rune1) (car rune2)) (equal (cdr rune1) (cdr rune2))))">rune=</a>
  (rune1 rune2)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car rune1) (car rune2))
    (equal (cdr rune1) (cdr rune2))))</pre>
  </div>

<div class="form-block other" id="def-xrune_3D" data-defines="XRUNE=" data-references="T,CDR,CDDR,EQL,CADR,RUNE=,AND,CAR,EQ,COND,XRUNE2,XRUNE1,DEFABBREV" data-used-by="ADD-ACCUMULATED-PERSISTENCE-F,ADD-ACCUMULATED-PERSISTENCE-S,MERGE-ACCUMULATED-PERSISTENCE-AUX" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="XRUNE=">xrune=</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-xrune_3D" data-sym="XRUNE=" title="(defabbrev xrune= (xrune1 xrune2)
           (cond
            ((eq (car xrune1) :hyp)
             (and (eq (car xrune2) :hyp) (rune= (cadr xrune1) (cadr xrune2))
                  (eql (cddr xrune1) (cddr xrune2))))
...">xrune=</a>
  (xrune1 xrune2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune1) <span class="keyword">:hyp</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune2) <span class="keyword">:hyp</span>)
        (<a class="sym-link local-def" href="#def-rune_3D" data-sym="RUNE=" title="(defabbrev rune= (rune1 rune2)
           (and (eq (car rune1) (car rune2)) (equal (cdr rune1) (cdr rune2))))">rune=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> xrune1) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> xrune2))
        (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> xrune1) (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> xrune2))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune1) <span class="keyword">:conc</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune2) <span class="keyword">:conc</span>)
        (<a class="sym-link local-def" href="#def-rune_3D" data-sym="RUNE=" title="(defabbrev rune= (rune1 rune2)
           (and (eq (car rune1) (car rune2)) (equal (cdr rune1) (cdr rune2))))">rune=</a> (cdr xrune1) (cdr xrune2))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rune_3D" data-sym="RUNE=" title="(defabbrev rune= (rune1 rune2)
           (and (eq (car rune1) (car rune2)) (equal (cdr rune1) (cdr rune2))))">rune=</a> xrune1 xrune2))))</pre>
  </div>

<div class="form-block function" id="def-prettyify-xrune" data-defines="PRETTYIFY-XRUNE" data-references="T,CADR,CDDR,LIST*,CAR,EQ,COND,XRUNE,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-LIST,SHOW-ACCUMULATED-PERSISTENCE-PHRASE0" data-part-name="PRETTYIFY-XRUNE" data-part-args="XRUNE" data-part-body="T,CADR,CDDR,LIST*,XRUNE,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PRETTYIFY-XRUNE">prettyify-xrune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-prettyify-xrune" data-sym="PRETTYIFY-XRUNE" title="(defun prettyify-xrune (xrune)
  (cond ((eq (car xrune) :hyp) (list* :hyp (cddr xrune) (cadr xrune)))
        (t xrune)))">prettyify-xrune</a>
  (xrune)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xrune) <span class="keyword">:hyp</span>) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:hyp</span> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> xrune) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> xrune)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> xrune)))</pre>
  </div>

<div class="form-block other" id="form-199" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
  (((cnt-s . cnt-f) stack-s . stack-f) xrune-stack
    xrunep
    totals . old-accp-info)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-200" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> accp-entry (xrune (n-s . ap-s) n-f . ap-f) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-merge-accumulated-persistence-aux" data-defines="MERGE-ACCUMULATED-PERSISTENCE-AUX" data-references="T,CDR,+,MAKE,CONS,CAR,ACCP-ENTRY,ACCESS,XRUNE=,LIST,ENDP,COND,ALIST,ENTRY,XRUNE,DEFUN" data-used-by="MERGE-ACCUMULATED-PERSISTENCE-REC" data-part-name="MERGE-ACCUMULATED-PERSISTENCE-AUX" data-part-args="ALIST,ENTRY,XRUNE" data-part-body="MERGE-ACCUMULATED-PERSISTENCE-AUX,T,CDR,+,MAKE,CONS,CAR,ACCP-ENTRY,ACCESS,XRUNE,XRUNE=,ENTRY,LIST,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-ACCUMULATED-PERSISTENCE-AUX">merge-accumulated-persistence-aux</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-accumulated-persistence-aux" data-sym="MERGE-ACCUMULATED-PERSISTENCE-AUX" title="(defun merge-accumulated-persistence-aux (xrune entry alist)
  (cond ((endp alist) (list entry))
        ((xrune= xrune (access accp-entry (car alist) :xrune))
         (cons
          (make accp-entry :xrune xrune :n-s
...">merge-accumulated-persistence-aux</a>
  (xrune entry alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> entry))
    ((<a class="sym-link local-def" href="#def-xrune_3D" data-sym="XRUNE=" title="(defabbrev xrune= (xrune1 xrune2)
           (cond
            ((eq (car xrune1) :hyp)
             (and (eq (car xrune2) :hyp) (rune= (cadr xrune1) (cadr xrune2))
                  (eql (cddr xrune1) (cddr xrune2))))
...">xrune=</a> xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)) (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> accp-entry
          <span class="keyword">:xrune</span> xrune
          <span class="keyword">:n-s</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-s</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-s</span>))
          <span class="keyword">:ap-s</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-s</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-s</span>))
          <span class="keyword">:n-f</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-f</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-f</span>))
          <span class="keyword">:ap-f</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-f</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>)))
        (cdr alist)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car alist)
        (<a class="sym-link local-def" href="#def-merge-accumulated-persistence-aux" data-sym="MERGE-ACCUMULATED-PERSISTENCE-AUX" title="(defun merge-accumulated-persistence-aux (xrune entry alist)
  (cond ((endp alist) (list entry))
        ((xrune= xrune (access accp-entry (car alist) :xrune))
         (cons
          (make accp-entry :xrune xrune :n-s
...">merge-accumulated-persistence-aux</a> xrune entry (cdr alist))))))</pre>
  </div>

<div class="form-block function" id="def-merge-accumulated-persistence-rec" data-defines="MERGE-ACCUMULATED-PERSISTENCE-REC" data-references="CAR,ACCP-ENTRY,ACCESS,MERGE-ACCUMULATED-PERSISTENCE-AUX,CDR,T,ENDP,COND,OLD-ALIST,NEW-ALIST,DEFUN" data-used-by="MERGE-ACCUMULATED-PERSISTENCE" data-part-name="MERGE-ACCUMULATED-PERSISTENCE-REC" data-part-args="OLD-ALIST,NEW-ALIST" data-part-body="CAR,ACCP-ENTRY,ACCESS,MERGE-ACCUMULATED-PERSISTENCE-AUX,CDR,MERGE-ACCUMULATED-PERSISTENCE-REC,T,OLD-ALIST,NEW-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-ACCUMULATED-PERSISTENCE-REC">merge-accumulated-persistence-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-accumulated-persistence-rec" data-sym="MERGE-ACCUMULATED-PERSISTENCE-REC" title="(defun merge-accumulated-persistence-rec (new-alist old-alist)
  (cond ((endp new-alist) old-alist)
        (t
         (merge-accumulated-persistence-rec (cdr new-alist)
                                            (merge-accumulated-persistence-aux
...">merge-accumulated-persistence-rec</a>
  (new-alist old-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> new-alist) old-alist)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-accumulated-persistence-rec" data-sym="MERGE-ACCUMULATED-PERSISTENCE-REC" title="(defun merge-accumulated-persistence-rec (new-alist old-alist)
  (cond ((endp new-alist) old-alist)
        (t
         (merge-accumulated-persistence-rec (cdr new-alist)
                                            (merge-accumulated-persistence-aux
...">merge-accumulated-persistence-rec</a> (cdr new-alist)
        (<a class="sym-link local-def" href="#def-merge-accumulated-persistence-aux" data-sym="MERGE-ACCUMULATED-PERSISTENCE-AUX" title="(defun merge-accumulated-persistence-aux (xrune entry alist)
  (cond ((endp alist) (list entry))
        ((xrune= xrune (access accp-entry (car alist) :xrune))
         (cons
          (make accp-entry :xrune xrune :n-s
...">merge-accumulated-persistence-aux</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car new-alist) <span class="keyword">:xrune</span>)
          (car new-alist)
          old-alist)))))</pre>
  </div>

<div class="form-block function" id="def-merge-accumulated-persistence" data-defines="MERGE-ACCUMULATED-PERSISTENCE" data-references="MERGE-ACCUMULATED-PERSISTENCE-REC,T,NULL,COND,OLD-ALIST,NEW-ALIST,DEFUN" data-used-by="ADD-ACCUMULATED-PERSISTENCE" data-part-name="MERGE-ACCUMULATED-PERSISTENCE" data-part-args="OLD-ALIST,NEW-ALIST" data-part-body="MERGE-ACCUMULATED-PERSISTENCE-REC,T,NEW-ALIST,OLD-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-ACCUMULATED-PERSISTENCE">merge-accumulated-persistence</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-accumulated-persistence" data-sym="MERGE-ACCUMULATED-PERSISTENCE" title="(defun merge-accumulated-persistence (new-alist old-alist)
  (cond ((null old-alist) new-alist)
        (t (merge-accumulated-persistence-rec new-alist old-alist))))">merge-accumulated-persistence</a>
  (new-alist old-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> old-alist) new-alist)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-accumulated-persistence-rec" data-sym="MERGE-ACCUMULATED-PERSISTENCE-REC" title="(defun merge-accumulated-persistence-rec (new-alist old-alist)
  (cond ((endp new-alist) old-alist)
        (t
         (merge-accumulated-persistence-rec (cdr new-alist)
                                            (merge-accumulated-persistence-aux
...">merge-accumulated-persistence-rec</a> new-alist old-alist))))</pre>
  </div>

<div class="form-block function" id="def-add-accumulated-persistence-s" data-defines="ADD-ACCUMULATED-PERSISTENCE-S" data-references="CDR,REVAPPEND,INT=,AND,ASSERT$,T,+,1+,CHANGE,CAR,ACCESS,XRUNE=,OR,ACCP-ENTRY,MAKE,CONS,NULL,COND,ACC,ORIGINAL-ALIST,ALIST,DELTA,XRUNE,DEFUN" data-used-by="ADD-ACCUMULATED-PERSISTENCE" data-part-name="ADD-ACCUMULATED-PERSISTENCE-S" data-part-args="ACC,ORIGINAL-ALIST,ALIST,DELTA,XRUNE" data-part-body="ADD-ACCUMULATED-PERSISTENCE-S,CDR,ACC,REVAPPEND,INT=,AND,ASSERT$,T,+,1+,CHANGE,CAR,ACCESS,XRUNE=,ORIGINAL-ALIST,DELTA,OR,XRUNE,ACCP-ENTRY,MAKE,CONS,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-ACCUMULATED-PERSISTENCE-S">add-accumulated-persistence-s</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-accumulated-persistence-s" data-sym="ADD-ACCUMULATED-PERSISTENCE-S" title="(defun add-accumulated-persistence-s (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 1 :ap-s (or delta 0) :n-f 0 :ap-f 0)
...">add-accumulated-persistence-s</a>
  (xrune delta alist original-alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> accp-entry
          <span class="keyword">:xrune</span> xrune
          <span class="keyword">:n-s</span> <span class="number">1</span>
          <span class="keyword">:ap-s</span> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> delta <span class="number">0</span>)
          <span class="keyword">:n-f</span> <span class="number">0</span>
          <span class="keyword">:ap-f</span> <span class="number">0</span>)
        original-alist))
    ((<a class="sym-link local-def" href="#def-xrune_3D" data-sym="XRUNE=" title="(defabbrev xrune= (xrune1 xrune2)
           (cond
            ((eq (car xrune1) :hyp)
             (and (eq (car xrune2) :hyp) (rune= (cadr xrune1) (cadr xrune2))
                  (eql (cddr xrune1) (cddr xrune2))))
...">xrune=</a> xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)) (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (delta (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> accp-entry
              (car alist)
              <span class="keyword">:ap-f</span> <span class="number">0</span>
              <span class="keyword">:n-s</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-s</span>))
              <span class="keyword">:ap-s</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> delta
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-s</span>)
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-s</span>) <span class="number">0</span>)
                (<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>) <span class="number">0</span>))
              (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> accp-entry
                (car alist)
                <span class="keyword">:ap-f</span> <span class="number">0</span>
                <span class="keyword">:n-s</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-s</span>))))))
        (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> acc (cdr alist))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-add-accumulated-persistence-s" data-sym="ADD-ACCUMULATED-PERSISTENCE-S" title="(defun add-accumulated-persistence-s (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 1 :ap-s (or delta 0) :n-f 0 :ap-f 0)
...">add-accumulated-persistence-s</a> xrune
        delta
        (cdr alist)
        original-alist
        (cons (car alist) acc)))))</pre>
  </div>

<div class="form-block function" id="def-add-accumulated-persistence-f" data-defines="ADD-ACCUMULATED-PERSISTENCE-F" data-references="CDR,REVAPPEND,T,+,1+,CHANGE,EQL,ASSERT$,CAR,ACCESS,XRUNE=,OR,ACCP-ENTRY,MAKE,CONS,NULL,COND,ACC,ORIGINAL-ALIST,ALIST,DELTA,XRUNE,DEFUN" data-used-by="ADD-ACCUMULATED-PERSISTENCE" data-part-name="ADD-ACCUMULATED-PERSISTENCE-F" data-part-args="ACC,ORIGINAL-ALIST,ALIST,DELTA,XRUNE" data-part-body="ADD-ACCUMULATED-PERSISTENCE-F,CDR,ACC,REVAPPEND,T,+,1+,CHANGE,EQL,ASSERT$,CAR,ACCESS,XRUNE=,ORIGINAL-ALIST,DELTA,OR,XRUNE,ACCP-ENTRY,MAKE,CONS,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-ACCUMULATED-PERSISTENCE-F">add-accumulated-persistence-f</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-accumulated-persistence-f" data-sym="ADD-ACCUMULATED-PERSISTENCE-F" title="(defun add-accumulated-persistence-f (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 0 :ap-s 0 :n-f 1 :ap-f (or delta 0))
...">add-accumulated-persistence-f</a>
  (xrune delta alist original-alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> accp-entry
          <span class="keyword">:xrune</span> xrune
          <span class="keyword">:n-s</span> <span class="number">0</span>
          <span class="keyword">:ap-s</span> <span class="number">0</span>
          <span class="keyword">:n-f</span> <span class="number">1</span>
          <span class="keyword">:ap-f</span> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> delta <span class="number">0</span>))
        original-alist))
    ((<a class="sym-link local-def" href="#def-xrune_3D" data-sym="XRUNE=" title="(defabbrev xrune= (xrune1 xrune2)
           (cond
            ((eq (car xrune1) :hyp)
             (and (eq (car xrune2) :hyp) (rune= (cadr xrune1) (cadr xrune2))
                  (eql (cddr xrune1) (cddr xrune2))))
...">xrune=</a> xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)) (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-s</span>) <span class="number">0</span>)
        (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (delta (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> accp-entry
                (car alist)
                <span class="keyword">:n-f</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-f</span>))
                <span class="keyword">:ap-f</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> delta (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>) <span class="number">0</span>)
                (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> accp-entry
                  (car alist)
                  <span class="keyword">:n-f</span> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-f</span>))))))
          (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> acc (cdr alist)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-add-accumulated-persistence-f" data-sym="ADD-ACCUMULATED-PERSISTENCE-F" title="(defun add-accumulated-persistence-f (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 0 :ap-s 0 :n-f 1 :ap-f (or delta 0))
...">add-accumulated-persistence-f</a> xrune
        delta
        (cdr alist)
        original-alist
        (cons (car alist) acc)))))</pre>
  </div>

<div class="form-block function" id="def-accumulated-persistence-make-failures" data-defines="ACCUMULATED-PERSISTENCE-MAKE-FAILURES" data-references="CDR,ACCESS,+,CAR,ACCP-ENTRY,CHANGE,CONS,T,NULL,COND,ALIST,DEFUN" data-used-by="ADD-ACCUMULATED-PERSISTENCE" data-part-name="ACCUMULATED-PERSISTENCE-MAKE-FAILURES" data-part-args="ALIST" data-part-body="CDR,ACCUMULATED-PERSISTENCE-MAKE-FAILURES,ACCESS,+,CAR,ACCP-ENTRY,CHANGE,CONS,T,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATED-PERSISTENCE-MAKE-FAILURES">accumulated-persistence-make-failures</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulated-persistence-make-failures" data-sym="ACCUMULATED-PERSISTENCE-MAKE-FAILURES" title="(defun accumulated-persistence-make-failures (alist)
  (cond ((null alist) nil)
        (t
         (cons
          (change accp-entry (car alist) :n-f
...">accumulated-persistence-make-failures</a>
  (alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> accp-entry
          (car alist)
          <span class="keyword">:n-f</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-f</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:n-s</span>))
          <span class="keyword">:n-s</span> <span class="number">0</span>
          <span class="keyword">:ap-f</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-f</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:ap-s</span>))
          <span class="keyword">:ap-s</span> <span class="number">0</span>)
        (<a class="sym-link local-def" href="#def-accumulated-persistence-make-failures" data-sym="ACCUMULATED-PERSISTENCE-MAKE-FAILURES" title="(defun accumulated-persistence-make-failures (alist)
  (cond ((null alist) nil)
        (t
         (cons
          (change accp-entry (car alist) :n-f
...">accumulated-persistence-make-failures</a> (cdr alist))))))</pre>
  </div>

<div class="form-block function" id="def-add-accumulated-persistence" data-defines="ADD-ACCUMULATED-PERSISTENCE" data-references="CDDR,CADR,MERGE-ACCUMULATED-PERSISTENCE,CONS,ADD-ACCUMULATED-PERSISTENCE-F,T,ADD-ACCUMULATED-PERSISTENCE-S,XRUNE-RUNE,FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE-P,COND,NEW-ALIST,ACCUMULATED-PERSISTENCE-MAKE-FAILURES,CAR,IF,ALIST,LET*,CDR,ASSERT$,ALIST-STACK,DELTA,SUCCESS-P,XRUNE,DEFUN" data-used-by="POP-ACCP-FN" data-part-name="ADD-ACCUMULATED-PERSISTENCE" data-part-args="ALIST-STACK,DELTA,SUCCESS-P,XRUNE" data-part-body="CDDR,CADR,MERGE-ACCUMULATED-PERSISTENCE,CONS,ADD-ACCUMULATED-PERSISTENCE-F,T,DELTA,ADD-ACCUMULATED-PERSISTENCE-S,XRUNE,XRUNE-RUNE,FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE-P,COND,NEW-ALIST,ACCUMULATED-PERSISTENCE-MAKE-FAILURES,CAR,SUCCESS-P,IF,ALIST,LET*,ALIST-STACK,CDR,ASSERT$" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-ACCUMULATED-PERSISTENCE">add-accumulated-persistence</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-accumulated-persistence" data-sym="ADD-ACCUMULATED-PERSISTENCE" title="(defun add-accumulated-persistence (xrune success-p delta alist-stack)
  (assert$ (cdr alist-stack)
           (let* ((alist
                   (if success-p
                       (car alist-stack)
...">add-accumulated-persistence</a>
  (xrune success-p delta alist-stack)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (cdr alist-stack)
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((alist (if success-p
           (car alist-stack)
           (<a class="sym-link local-def" href="#def-accumulated-persistence-make-failures" data-sym="ACCUMULATED-PERSISTENCE-MAKE-FAILURES" title="(defun accumulated-persistence-make-failures (alist)
  (cond ((null alist) nil)
        (t
         (cons
          (change accp-entry (car alist) :n-f
...">accumulated-persistence-make-failures</a> (car alist-stack)))) (new-alist (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((fake-rune-for-anonymous-enabled-rule-p (<a class="sym-link local-def" href="#def-xrune-rune" data-sym="XRUNE-RUNE" title="(defabbrev xrune-rune (xrune)
           (cond
            ((x-xrunep xrune)
             (if (eq (car xrune) :hyp)
                 (cadr xrune)
...">xrune-rune</a> xrune)) alist)
            (success-p (<a class="sym-link local-def" href="#def-add-accumulated-persistence-s" data-sym="ADD-ACCUMULATED-PERSISTENCE-S" title="(defun add-accumulated-persistence-s (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 1 :ap-s (or delta 0) :n-f 0 :ap-f 0)
...">add-accumulated-persistence-s</a> xrune delta alist alist nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-add-accumulated-persistence-f" data-sym="ADD-ACCUMULATED-PERSISTENCE-F" title="(defun add-accumulated-persistence-f (xrune delta alist original-alist acc)
  (cond
   ((null alist)
    (cons
     (make accp-entry :xrune xrune :n-s 0 :ap-s 0 :n-f 1 :ap-f (or delta 0))
...">add-accumulated-persistence-f</a> xrune delta alist alist nil)))))
      (cons (<a class="sym-link local-def" href="#def-merge-accumulated-persistence" data-sym="MERGE-ACCUMULATED-PERSISTENCE" title="(defun merge-accumulated-persistence (new-alist old-alist)
  (cond ((null old-alist) new-alist)
        (t (merge-accumulated-persistence-rec new-alist old-alist))))">merge-accumulated-persistence</a> new-alist (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> alist-stack))
        (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> alist-stack)))))</pre>
  </div>

<div class="form-block function" id="def-accumulated-persistence-fn" data-defines="ACCUMULATED-PERSISTENCE-FN" data-references="CHANGE,WORMHOLE-DATA,INFO,LET,EQ,ACCP-INFO,MAKE,IF,SET-WORMHOLE-DATA,WHS,LAMBDA,WORMHOLE-EVAL,ACCUMULATED-PERSISTENCE,HARD,ER,T,QUOTE,MEMBER,NOT,COND,IGNORABLE,DECLARE,STATE,FLG,DEFUN" data-used-by="ACCUMULATED-PERSISTENCE" data-part-name="ACCUMULATED-PERSISTENCE-FN" data-part-args="STATE,FLG" data-part-declare="STATE,IGNORABLE,DECLARE" data-part-body="CHANGE,WORMHOLE-DATA,INFO,LET,EQ,ACCP-INFO,MAKE,IF,SET-WORMHOLE-DATA,WHS,LAMBDA,WORMHOLE-EVAL,ACCUMULATED-PERSISTENCE,HARD,ER,T,QUOTE,FLG,MEMBER,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATED-PERSISTENCE-FN">accumulated-persistence-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulated-persistence-fn" data-sym="ACCUMULATED-PERSISTENCE-FN" title="(defun accumulated-persistence-fn (flg state)
  (declare (ignorable state))
  (cond
   ((not (member flg &#39;(t nil :all)))
    (er hard &#39;accumulated-persistence &quot;Unrecognized flg argument ~x0.&quot; flg))
...">accumulated-persistence-fn</a>
  (flg state)
  (declare (ignorable state))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member" data-sym="MEMBER">member</a> flg '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil <span class="keyword">:all</span>))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
        <span class="string">"Unrecognized flg argument ~x0."</span>
        flg))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
        '(lambda (whs)
          (<a class="sym-link system" href="basis-a.html#def-set-wormhole-data" data-sym="SET-WORMHOLE-DATA">set-wormhole-data</a> whs
            (if flg
              (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
                <span class="keyword">:cnt-s</span> <span class="number">0</span>
                <span class="keyword">:cnt-f</span> <span class="number">0</span>
                <span class="keyword">:stack-s</span> nil
                <span class="keyword">:stack-f</span> nil
                <span class="keyword">:xrunep</span> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> flg <span class="keyword">:all</span>)
                <span class="keyword">:totals</span> '(nil)
                <span class="keyword">:old-accp-info</span> (let ((info (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (info (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:old-accp-info</span> nil))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))
              nil)))
        nil))))</pre>
  </div>

<div class="form-block macro" id="def-accumulated-persistence" data-defines="ACCUMULATED-PERSISTENCE" data-references="STATE,ACCUMULATED-PERSISTENCE-FN,QUASIQUOTE,T,QUOTE,MEMBER-EQUAL,XARGS,DECLARE,FLG,DEFMACRO" data-used-by="POP-ACCP,PUSH-ACCP,SHOW-ACCUMULATED-PERSISTENCE-FN,SHOW-ACCUMULATED-PERSISTENCE-PHRASE,SET-ACCUMULATED-PERSISTENCE,ACCUMULATED-PERSISTENCE-OOPS-FN,ACCUMULATED-PERSISTENCE-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATED-PERSISTENCE">accumulated-persistence</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
  (flg)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> flg '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil 'nil <span class="keyword">:all</span> '<span class="keyword">:all</span>))))
  `(<a class="sym-link local-def" href="#def-accumulated-persistence-fn" data-sym="ACCUMULATED-PERSISTENCE-FN" title="(defun accumulated-persistence-fn (flg state)
  (declare (ignorable state))
  (cond
   ((not (member flg &#39;(t nil :all)))
    (er hard &#39;accumulated-persistence &quot;Unrecognized flg argument ~x0.&quot; flg))
...">accumulated-persistence-fn</a> ,FLG state))</pre>
  </div>

<div class="form-block function" id="def-accumulated-persistence-oops-fn" data-defines="ACCUMULATED-PERSISTENCE-OOPS-FN" data-references="CW,PROG2$,T,SET-WORMHOLE-DATA,COND,ACCP-INFO,ACCESS,AND,OLD,WORMHOLE-DATA,INFO,LET*,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL,DEFUN" data-used-by="ACCUMULATED-PERSISTENCE-OOPS" data-part-name="ACCUMULATED-PERSISTENCE-OOPS-FN" data-part-body="CW,PROG2$,T,SET-WORMHOLE-DATA,COND,ACCP-INFO,ACCESS,AND,OLD,WORMHOLE-DATA,INFO,LET*,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATED-PERSISTENCE-OOPS-FN">accumulated-persistence-oops-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulated-persistence-oops-fn" data-sym="ACCUMULATED-PERSISTENCE-OOPS-FN" title="(defun accumulated-persistence-oops-fn ()
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let* ((info (wormhole-data whs))
                           (old
...">accumulated-persistence-oops-fn</a>
  nil
  (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
    '(lambda (whs)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((info (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs)) (old (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> info (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:old-accp-info</span>))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (old (<a class="sym-link system" href="basis-a.html#def-set-wormhole-data" data-sym="SET-WORMHOLE-DATA">set-wormhole-data</a> whs old))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"No change: Unable to apply ~
                              accumulated-persistence-oops.~|"</span>)
              whs)))))
    nil))</pre>
  </div>

<div class="form-block macro" id="def-accumulated-persistence-oops" data-defines="ACCUMULATED-PERSISTENCE-OOPS" data-references="ACCUMULATED-PERSISTENCE-OOPS-FN,QUOTE,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATED-PERSISTENCE-OOPS">accumulated-persistence-oops</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-accumulated-persistence-oops" data-sym="ACCUMULATED-PERSISTENCE-OOPS" title="(defmacro accumulated-persistence-oops () &#39;(accumulated-persistence-oops-fn))">accumulated-persistence-oops</a>
  nil
  '(<a class="sym-link local-def" href="#def-accumulated-persistence-oops-fn" data-sym="ACCUMULATED-PERSISTENCE-OOPS-FN" title="(defun accumulated-persistence-oops-fn ()
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let* ((info (wormhole-data whs))
                           (old
...">accumulated-persistence-oops-fn</a>))</pre>
  </div>

<div class="form-block macro" id="def-set-accumulated-persistence" data-defines="SET-ACCUMULATED-PERSISTENCE" data-references="ACCUMULATED-PERSISTENCE,QUASIQUOTE,FLG,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-ACCUMULATED-PERSISTENCE">set-accumulated-persistence</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-accumulated-persistence" data-sym="SET-ACCUMULATED-PERSISTENCE" title="(defmacro set-accumulated-persistence (flg) `(accumulated-persistence ,flg))">set-accumulated-persistence</a>
  (flg)
  `(<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a> ,FLG))</pre>
  </div>

<div class="form-block function" id="def-merge-car-_3E" data-defines="MERGE-CAR->" data-references="T,CDR,CONS,CAR,>,NULL,COND,L2,L1,DEFUN" data-used-by="MERGE-SORT-CAR->" data-part-name="MERGE-CAR->" data-part-args="L2,L1" data-part-body="T,CDR,MERGE-CAR->,CONS,CAR,>,L2,L1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-CAR->">merge-car-&gt;</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-car-_3E" data-sym="MERGE-CAR-&gt;" title="(defun merge-car-&gt; (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((&gt; (car (car l1)) (car (car l2)))
         (cons (car l1) (merge-car-&gt; (cdr l1) l2)))
        (t (cons (car l2) (merge-car-&gt; l1 (cdr l2))))))">merge-car-&gt;</a>
  (l1 l2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l1) l2)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l2) l1)
    ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (car (car l1)) (car (car l2))) (cons (car l1) (<a class="sym-link local-def" href="#def-merge-car-_3E" data-sym="MERGE-CAR-&gt;" title="(defun merge-car-&gt; (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((&gt; (car (car l1)) (car (car l2)))
         (cons (car l1) (merge-car-&gt; (cdr l1) l2)))
        (t (cons (car l2) (merge-car-&gt; l1 (cdr l2))))))">merge-car-&gt;</a> (cdr l1) l2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car l2) (<a class="sym-link local-def" href="#def-merge-car-_3E" data-sym="MERGE-CAR-&gt;" title="(defun merge-car-&gt; (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((&gt; (car (car l1)) (car (car l2)))
         (cons (car l1) (merge-car-&gt; (cdr l1) l2)))
        (t (cons (car l2) (merge-car-&gt; l1 (cdr l2))))))">merge-car-&gt;</a> l1 (cdr l2))))))</pre>
  </div>

<div class="form-block function" id="def-merge-sort-car-_3E" data-defines="MERGE-SORT-CAR->" data-references="ODDS,EVENS,MERGE-CAR->,T,CDR,NULL,COND,L,DEFUN" data-part-name="MERGE-SORT-CAR->" data-part-args="L" data-part-body="ODDS,EVENS,MERGE-SORT-CAR->,MERGE-CAR->,T,L,CDR,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-SORT-CAR->">merge-sort-car-&gt;</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-sort-car-_3E" data-sym="MERGE-SORT-CAR-&gt;" title="(defun merge-sort-car-&gt; (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-car-&gt; (merge-sort-car-&gt; (evens l))
                      (merge-sort-car-&gt; (odds l))))))">merge-sort-car-&gt;</a>
  (l)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr l)) l)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-car-_3E" data-sym="MERGE-CAR-&gt;" title="(defun merge-car-&gt; (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((&gt; (car (car l1)) (car (car l2)))
         (cons (car l1) (merge-car-&gt; (cdr l1) l2)))
        (t (cons (car l2) (merge-car-&gt; l1 (cdr l2))))))">merge-car-&gt;</a> (<a class="sym-link local-def" href="#def-merge-sort-car-_3E" data-sym="MERGE-SORT-CAR-&gt;" title="(defun merge-sort-car-&gt; (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-car-&gt; (merge-sort-car-&gt; (evens l))
                      (merge-sort-car-&gt; (odds l))))))">merge-sort-car-&gt;</a> (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> l))
        (<a class="sym-link local-def" href="#def-merge-sort-car-_3E" data-sym="MERGE-SORT-CAR-&gt;" title="(defun merge-sort-car-&gt; (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-car-&gt; (merge-sort-car-&gt; (evens l))
                      (merge-sort-car-&gt; (odds l))))))">merge-sort-car-&gt;</a> (<a class="sym-link system" href="axioms.html#def-odds" data-sym="ODDS">odds</a> l))))))</pre>
  </div>

<div class="form-block constant" id="def-_2Aaccp-major-separator_2A" data-defines="*ACCP-MAJOR-SEPARATOR*" data-references="DEFCONST" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE,SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*ACCP-MAJOR-SEPARATOR*">*accp-major-separator*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aaccp-major-separator_2A" data-sym="*ACCP-MAJOR-SEPARATOR*" title="(defconst *accp-major-separator* &quot;   --------------------------------~%&quot;)">*accp-major-separator*</a>
  <span class="string">"   --------------------------------~%"</span>)</pre>
  </div>

<div class="form-block constant" id="def-_2Aaccp-minor-separator_2A" data-defines="*ACCP-MINOR-SEPARATOR*" data-references="DEFCONST" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*ACCP-MINOR-SEPARATOR*">*accp-minor-separator*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aaccp-minor-separator_2A" data-sym="*ACCP-MINOR-SEPARATOR*" title="(defconst *accp-minor-separator* &quot;      .............................~%&quot;)">*accp-minor-separator*</a>
  <span class="string">"      .............................~%"</span>)</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase0" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0" data-references="OTHERWISE,LIST,CASE,PRETTYIFY-XRUNE,*,MOD,FLOOR,CONS,MSG,MAIN-MSG,LET,AP,AP-F,AP-S,+,N,N-F,N-S,ACCP-ENTRY,ACCESS,XRUNE,LET*,KEY,ENTRY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0" data-part-args="KEY,ENTRY" data-part-body="OTHERWISE,LIST,KEY,CASE,PRETTYIFY-XRUNE,*,MOD,FLOOR,CONS,MSG,MAIN-MSG,LET,AP,AP-F,AP-S,+,N,N-F,N-S,ENTRY,ACCP-ENTRY,ACCESS,XRUNE,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0">show-accumulated-persistence-phrase0</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase0" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0" title="(defun show-accumulated-persistence-phrase0 (entry key)
  (let* ((xrune (access accp-entry entry :xrune))
         (n-s (access accp-entry entry :n-s))
         (n-f (access accp-entry entry :n-f))
         (n (+ n-s n-f))
...">show-accumulated-persistence-phrase0</a>
  (entry key)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:xrune</span>)) (n-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-s</span>))
      (n-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-f</span>))
      (n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> n-s n-f))
      (ap-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-s</span>))
      (ap-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-f</span>))
      (ap (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> ap-s ap-f)))
    (let ((main-msg (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~c0 ~c1 (~c2.~f3~f4) ~y5"</span>
           (cons ap <span class="number">10</span>)
           (cons n <span class="number">8</span>)
           (cons (floor ap n) <span class="number">5</span>)
           (mod (floor (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">10</span> ap) n) <span class="number">10</span>)
           (mod (floor (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">100</span> ap) n) <span class="number">10</span>)
           (<a class="sym-link local-def" href="#def-prettyify-xrune" data-sym="PRETTYIFY-XRUNE" title="(defun prettyify-xrune (xrune)
  (cond ((eq (car xrune) :hyp) (list* :hyp (cddr xrune) (cadr xrune)))
        (t xrune)))">prettyify-xrune</a> xrune))))
      (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> key
        ((<span class="keyword">:useless</span> <span class="keyword">:ratio-a</span> <span class="keyword">:frames-a</span> <span class="keyword">:tries-a</span>) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> main-msg))
        (otherwise (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> main-msg
            (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~c0 ~c1    [useful]~%"</span> (cons ap-s <span class="number">10</span>) (cons n-s <span class="number">8</span>))
            (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~c0 ~c1    [useless]~%"</span> (cons ap-f <span class="number">10</span>) (cons n-f <span class="number">8</span>))))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase1" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" data-references="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0,APPEND,*ACCP-MAJOR-SEPARATOR*,*ACCP-MINOR-SEPARATOR*,CAR,ACCP-ENTRY,ACCESS,XRUNE-RUNE,EQUAL,AND,CONS,CDR,T,NULL,COND,ACC,MERGEP,ALIST,KEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" data-part-args="ACC,MERGEP,ALIST,KEY" data-part-body="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0,APPEND,*ACCP-MAJOR-SEPARATOR*,*ACCP-MINOR-SEPARATOR*,CAR,ACCP-ENTRY,ACCESS,XRUNE-RUNE,EQUAL,AND,CONS,MERGEP,CDR,KEY,SHOW-ACCUMULATED-PERSISTENCE-PHRASE1,T,ACC,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1">show-accumulated-persistence-phrase1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase1" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" title="(defun show-accumulated-persistence-phrase1 (key alist mergep acc)
  (cond ((null alist) acc)
        (t
         (show-accumulated-persistence-phrase1 key (cdr alist) mergep
                                               (cons
...">show-accumulated-persistence-phrase1</a>
  (key alist mergep acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase1" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" title="(defun show-accumulated-persistence-phrase1 (key alist mergep acc)
  (cond ((null alist) acc)
        (t
         (show-accumulated-persistence-phrase1 key (cdr alist) mergep
                                               (cons
...">show-accumulated-persistence-phrase1</a> key
        (cdr alist)
        mergep
        (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> mergep
               (cdr alist)
               (equal (<a class="sym-link local-def" href="#def-xrune-rune" data-sym="XRUNE-RUNE" title="(defabbrev xrune-rune (xrune)
           (cond
            ((x-xrunep xrune)
             (if (eq (car xrune) :hyp)
                 (cadr xrune)
...">xrune-rune</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (cdr (car (cdr alist))) <span class="keyword">:xrune</span>))
                 (<a class="sym-link local-def" href="#def-xrune-rune" data-sym="XRUNE-RUNE" title="(defabbrev xrune-rune (xrune)
           (cond
            ((x-xrunep xrune)
             (if (eq (car xrune) :hyp)
                 (cadr xrune)
...">xrune-rune</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (cdr (car alist)) <span class="keyword">:xrune</span>)))) <a class="sym-link local-def" href="#def-_2Aaccp-minor-separator_2A" data-sym="*ACCP-MINOR-SEPARATOR*" title="(defconst *accp-minor-separator* &quot;      .............................~%&quot;)">*accp-minor-separator*</a>)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link local-def" href="#def-_2Aaccp-major-separator_2A" data-sym="*ACCP-MAJOR-SEPARATOR*" title="(defconst *accp-major-separator* &quot;   --------------------------------~%&quot;)">*accp-major-separator*</a>))
          (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase0" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE0" title="(defun show-accumulated-persistence-phrase0 (entry key)
  (let* ((xrune (access accp-entry entry :xrune))
         (n-s (access accp-entry entry :n-s))
         (n-f (access accp-entry entry :n-f))
         (n (+ n-s n-f))
...">show-accumulated-persistence-phrase0</a> (cdr (car alist)) key)
            acc))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-remove-useless" data-defines="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" data-references="CONS,T,CAR,CDR,ACCP-ENTRY,ACCESS,EQL,NOT,REVERSE,NULL,COND,ACC,ALIST,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" data-part-args="ACC,ALIST" data-part-body="CONS,T,SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS,CAR,CDR,ACCP-ENTRY,ACCESS,EQL,NOT,ACC,REVERSE,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS">show-accumulated-persistence-remove-useless</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-remove-useless" data-sym="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" title="(defun show-accumulated-persistence-remove-useless (alist acc)
  (cond ((null alist) (reverse acc))
        ((not (eql (access accp-entry (cdr (car alist)) :n-s) 0))
         (show-accumulated-persistence-remove-useless (cdr alist) acc))
        (t
...">show-accumulated-persistence-remove-useless</a>
  (alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> acc))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (cdr (car alist)) <span class="keyword">:n-s</span>) <span class="number">0</span>)) (<a class="sym-link local-def" href="#def-show-accumulated-persistence-remove-useless" data-sym="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" title="(defun show-accumulated-persistence-remove-useless (alist acc)
  (cond ((null alist) (reverse acc))
        ((not (eql (access accp-entry (cdr (car alist)) :n-s) 0))
         (show-accumulated-persistence-remove-useless (cdr alist) acc))
        (t
...">show-accumulated-persistence-remove-useless</a> (cdr alist)
        acc))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-show-accumulated-persistence-remove-useless" data-sym="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" title="(defun show-accumulated-persistence-remove-useless (alist acc)
  (cond ((null alist) (reverse acc))
        ((not (eql (access accp-entry (cdr (car alist)) :n-s) 0))
         (show-accumulated-persistence-remove-useless (cdr alist) acc))
        (t
...">show-accumulated-persistence-remove-useless</a> (cdr alist)
        (cons (car alist) acc)))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase-key" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" data-references="/,OTHERWISE,LIST*,CASE,N,N-F,N-S,+,AP,AP-F,ACCP-ENTRY,ACCESS,AP-S,LET*,LASTCDR,ENTRY,KEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" data-part-args="LASTCDR,ENTRY,KEY" data-part-body="/,OTHERWISE,LASTCDR,LIST*,KEY,CASE,N,N-F,N-S,+,AP,AP-F,ENTRY,ACCP-ENTRY,ACCESS,AP-S,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY">show-accumulated-persistence-phrase-key</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase-key" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" title="(defun show-accumulated-persistence-phrase-key (key entry lastcdr)
  (let* ((ap-s (access accp-entry entry :ap-s))
         (ap-f (access accp-entry entry :ap-f))
         (ap (+ ap-s ap-f))
         (n-s (access accp-entry entry :n-s))
...">show-accumulated-persistence-phrase-key</a>
  (key entry lastcdr)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ap-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-s</span>)) (ap-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-f</span>))
      (ap (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> ap-s ap-f))
      (n-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-s</span>))
      (n-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-f</span>))
      (n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> n-s n-f)))
    (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> key
      ((<span class="keyword">:frames</span> <span class="keyword">:frames-a</span>) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> ap ap-s n n-s lastcdr))
      (<span class="keyword">:frames-s</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> ap-s ap n-s n lastcdr))
      (<span class="keyword">:frames-f</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> ap-f ap n-f n lastcdr))
      ((<span class="keyword">:tries</span> <span class="keyword">:tries-a</span>) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> n n-s ap ap-s lastcdr))
      (<span class="keyword">:tries-s</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> n-s n ap-s ap lastcdr))
      (<span class="keyword">:tries-f</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> n-f n ap-f ap lastcdr))
      (<span class="keyword">:useless</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> ap n lastcdr))
      (otherwise (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> (<a class="sym-link system" href="axioms.html#def-_2F" data-sym="/">/</a> ap n) lastcdr)))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase2-merge" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" data-references="QUOTE,LIST,NEXT-KEY-INFO,LET,T,CDR,SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY,APPEND,CONS,CAR,ACCP-ENTRY,ACCESS,X-XRUNEP,NULL,COND,LAST-KEY-INFO,ALIST,KEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" data-part-args="LAST-KEY-INFO,ALIST,KEY" data-part-body="QUOTE,LIST,NEXT-KEY-INFO,LET,T,CDR,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE,KEY,SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY,LAST-KEY-INFO,APPEND,CONS,CAR,ACCP-ENTRY,ACCESS,X-XRUNEP,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE">show-accumulated-persistence-phrase2-merge</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" title="(defun show-accumulated-persistence-phrase2-merge (key alist last-key-info)
  (cond ((null alist) nil)
        ((x-xrunep (access accp-entry (car alist) :xrune))
         (cons
          (cons
...">show-accumulated-persistence-phrase2-merge</a>
  (key alist last-key-info)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) nil)
    ((<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)) (cons (cons (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> last-key-info
            (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase-key" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" title="(defun show-accumulated-persistence-phrase-key (key entry lastcdr)
  (let* ((ap-s (access accp-entry entry :ap-s))
         (ap-f (access accp-entry entry :ap-f))
         (ap (+ ap-s ap-f))
         (n-s (access accp-entry entry :n-s))
...">show-accumulated-persistence-phrase-key</a> key
              (car alist)
              nil))
          (car alist))
        (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" title="(defun show-accumulated-persistence-phrase2-merge (key alist last-key-info)
  (cond ((null alist) nil)
        ((x-xrunep (access accp-entry (car alist) :xrune))
         (cons
          (cons
...">show-accumulated-persistence-phrase2-merge</a> key
          (cdr alist)
          last-key-info)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((next-key-info (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase-key" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" title="(defun show-accumulated-persistence-phrase-key (key entry lastcdr)
  (let* ((ap-s (access accp-entry entry :ap-s))
         (ap-f (access accp-entry entry :ap-f))
         (ap (+ ap-s ap-f))
         (n-s (access accp-entry entry :n-s))
...">show-accumulated-persistence-phrase-key</a> key
             (car alist)
             (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)))))
        (cons (cons (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> next-key-info '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)) (car alist))
          (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" title="(defun show-accumulated-persistence-phrase2-merge (key alist last-key-info)
  (cond ((null alist) nil)
        ((x-xrunep (access accp-entry (car alist) :xrune))
         (cons
          (cons
...">show-accumulated-persistence-phrase2-merge</a> key
            (cdr alist)
            next-key-info))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase2-not-merge" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE" data-references="CDR,CAR,SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY,CONS,T,NULL,COND,ALIST,KEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE" data-part-args="ALIST,KEY" data-part-body="CDR,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE,CAR,KEY,SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY,CONS,T,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE">show-accumulated-persistence-phrase2-not-merge</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-not-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE" title="(defun show-accumulated-persistence-phrase2-not-merge (key alist)
  (cond ((null alist) nil)
        (t
         (cons
          (cons (show-accumulated-persistence-phrase-key key (car alist) nil)
...">show-accumulated-persistence-phrase2-not-merge</a>
  (key alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase-key" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE-KEY" title="(defun show-accumulated-persistence-phrase-key (key entry lastcdr)
  (let* ((ap-s (access accp-entry entry :ap-s))
         (ap-f (access accp-entry entry :ap-f))
         (ap (+ ap-s ap-f))
         (n-s (access accp-entry entry :n-s))
...">show-accumulated-persistence-phrase-key</a> key
            (car alist)
            nil)
          (car alist))
        (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-not-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE" title="(defun show-accumulated-persistence-phrase2-not-merge (key alist)
  (cond ((null alist) nil)
        (t
         (cons
          (cons (show-accumulated-persistence-phrase-key key (car alist) nil)
...">show-accumulated-persistence-phrase2-not-merge</a> key
          (cdr alist))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase2" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" data-references="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE,T,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE,COND,MERGEP,ALIST,KEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" data-part-args="MERGEP,ALIST,KEY" data-part-body="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE,T,ALIST,KEY,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE,MERGEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2">show-accumulated-persistence-phrase2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" title="(defun show-accumulated-persistence-phrase2 (key alist mergep)
  (cond (mergep (show-accumulated-persistence-phrase2-merge key alist nil))
        (t (show-accumulated-persistence-phrase2-not-merge key alist))))">show-accumulated-persistence-phrase2</a>
  (key alist mergep)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (mergep (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-MERGE" title="(defun show-accumulated-persistence-phrase2-merge (key alist last-key-info)
  (cond ((null alist) nil)
        ((x-xrunep (access accp-entry (car alist) :xrune))
         (cons
          (cons
...">show-accumulated-persistence-phrase2-merge</a> key alist nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2-not-merge" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2-NOT-MERGE" title="(defun show-accumulated-persistence-phrase2-not-merge (key alist)
  (cond ((null alist) nil)
        (t
         (cons
          (cons (show-accumulated-persistence-phrase-key key (car alist) nil)
...">show-accumulated-persistence-phrase2-not-merge</a> key alist))))</pre>
  </div>

<div class="form-block function" id="def-split-xrune-alist" data-defines="SPLIT-XRUNE-ALIST" data-references="CONS,CDR,CASE,CAR,ACCP-ENTRY,ACCESS,XRUNE,LET,T,MV,ENDP,COND,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,ALIST,DEFUN" data-used-by="SORT-XRUNE-ALIST-BY-RUNE" data-part-name="SPLIT-XRUNE-ALIST" data-part-args="CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,ALIST" data-part-body="CONS,CDR,SPLIT-XRUNE-ALIST,CASE,CAR,ACCP-ENTRY,ACCESS,XRUNE,LET,T,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,MV,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLIT-XRUNE-ALIST">split-xrune-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-split-xrune-alist" data-sym="SPLIT-XRUNE-ALIST" title="(defun split-xrune-alist (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (cond ((endp alist) (mv rune-alist hyp-xrune-alist conc-xrune-alist))
        (t
         (let ((xrune (access accp-entry (car alist) :xrune)))
           (case (car xrune)
...">split-xrune-alist</a>
  (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> rune-alist hyp-xrune-alist conc-xrune-alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry (car alist) <span class="keyword">:xrune</span>)))
        (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (car xrune)
          (<span class="keyword">:hyp</span> (<a class="sym-link local-def" href="#def-split-xrune-alist" data-sym="SPLIT-XRUNE-ALIST" title="(defun split-xrune-alist (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (cond ((endp alist) (mv rune-alist hyp-xrune-alist conc-xrune-alist))
        (t
         (let ((xrune (access accp-entry (car alist) :xrune)))
           (case (car xrune)
...">split-xrune-alist</a> (cdr alist)
              rune-alist
              (cons (car alist) hyp-xrune-alist)
              conc-xrune-alist))
          (<span class="keyword">:conc</span> (<a class="sym-link local-def" href="#def-split-xrune-alist" data-sym="SPLIT-XRUNE-ALIST" title="(defun split-xrune-alist (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (cond ((endp alist) (mv rune-alist hyp-xrune-alist conc-xrune-alist))
        (t
         (let ((xrune (access accp-entry (car alist) :xrune)))
           (case (car xrune)
...">split-xrune-alist</a> (cdr alist)
              rune-alist
              hyp-xrune-alist
              (cons (car alist) conc-xrune-alist)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-split-xrune-alist" data-sym="SPLIT-XRUNE-ALIST" title="(defun split-xrune-alist (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (cond ((endp alist) (mv rune-alist hyp-xrune-alist conc-xrune-alist))
        (t
         (let ((xrune (access accp-entry (car alist) :xrune)))
           (case (car xrune)
...">split-xrune-alist</a> (cdr alist)
              (cons (car alist) rune-alist)
              hyp-xrune-alist
              conc-xrune-alist)))))))</pre>
  </div>

<div class="form-block function" id="def-sort-xrune-alist-by-rune1" data-defines="SORT-XRUNE-ALIST-BY-RUNE1" data-references="T,CONC-XRUNE-RUNE,CAR,CONS,CDR,CAAR,HYP-XRUNE-RUNE,EQUAL,NULL,AND,ASSERT$,ENDP,COND,ACC,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,DEFUN" data-used-by="SORT-XRUNE-ALIST-BY-RUNE" data-part-name="SORT-XRUNE-ALIST-BY-RUNE1" data-part-args="ACC,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST" data-part-body="T,CONC-XRUNE-RUNE,CAR,CONS,CDR,SORT-XRUNE-ALIST-BY-RUNE1,CAAR,HYP-XRUNE-RUNE,EQUAL,ACC,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,NULL,AND,ASSERT$,RUNE-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-XRUNE-ALIST-BY-RUNE1">sort-xrune-alist-by-rune1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune1" data-sym="SORT-XRUNE-ALIST-BY-RUNE1" title="(defun sort-xrune-alist-by-rune1
       (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (cond
   ((endp rune-alist)
    (assert$ (and (null hyp-xrune-alist) (null conc-xrune-alist)) acc))
...">sort-xrune-alist-by-rune1</a>
  (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> rune-alist) (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyp-xrune-alist) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> conc-xrune-alist))
        acc))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyp-xrune-alist
       (equal (<a class="sym-link local-def" href="#def-hyp-xrune-rune" data-sym="HYP-XRUNE-RUNE" title="(defabbrev hyp-xrune-rune (xrune)
           (assert$ (and (x-xrunep xrune) (eq (car xrune) :hyp)) (cadr xrune)))">hyp-xrune-rune</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> hyp-xrune-alist))
         (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> rune-alist))) (<a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune1" data-sym="SORT-XRUNE-ALIST-BY-RUNE1" title="(defun sort-xrune-alist-by-rune1
       (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (cond
   ((endp rune-alist)
    (assert$ (and (null hyp-xrune-alist) (null conc-xrune-alist)) acc))
...">sort-xrune-alist-by-rune1</a> rune-alist
        (cdr hyp-xrune-alist)
        conc-xrune-alist
        (cons (car hyp-xrune-alist) acc)))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> conc-xrune-alist
       (equal (<a class="sym-link local-def" href="#def-conc-xrune-rune" data-sym="CONC-XRUNE-RUNE" title="(defabbrev conc-xrune-rune (xrune)
           (assert$ (and (x-xrunep xrune) (eq (car xrune) :conc)) (cdr xrune)))">conc-xrune-rune</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> conc-xrune-alist))
         (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> rune-alist))) (<a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune1" data-sym="SORT-XRUNE-ALIST-BY-RUNE1" title="(defun sort-xrune-alist-by-rune1
       (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (cond
   ((endp rune-alist)
    (assert$ (and (null hyp-xrune-alist) (null conc-xrune-alist)) acc))
...">sort-xrune-alist-by-rune1</a> rune-alist
        hyp-xrune-alist
        (cdr conc-xrune-alist)
        (cons (car conc-xrune-alist) acc)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune1" data-sym="SORT-XRUNE-ALIST-BY-RUNE1" title="(defun sort-xrune-alist-by-rune1
       (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (cond
   ((endp rune-alist)
    (assert$ (and (null hyp-xrune-alist) (null conc-xrune-alist)) acc))
...">sort-xrune-alist-by-rune1</a> (cdr rune-alist)
        hyp-xrune-alist
        conc-xrune-alist
        (cons (car rune-alist) acc)))))</pre>
  </div>

<div class="form-block function" id="def-sort-xrune-alist-by-rune" data-defines="SORT-XRUNE-ALIST-BY-RUNE" data-references="MERGE-SORT-LEXORDER,SORT-XRUNE-ALIST-BY-RUNE1,EQ,SPLIT-XRUNE-ALIST,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,MV-LET,T,QUOTE,MEMBER-EQ,NOT,COND,DISPLAY,ALIST,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="SORT-XRUNE-ALIST-BY-RUNE" data-part-args="DISPLAY,ALIST" data-part-body="MERGE-SORT-LEXORDER,SORT-XRUNE-ALIST-BY-RUNE1,EQ,SPLIT-XRUNE-ALIST,CONC-XRUNE-ALIST,HYP-XRUNE-ALIST,RUNE-ALIST,MV-LET,T,ALIST,QUOTE,DISPLAY,MEMBER-EQ,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-XRUNE-ALIST-BY-RUNE">sort-xrune-alist-by-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune" data-sym="SORT-XRUNE-ALIST-BY-RUNE" title="(defun sort-xrune-alist-by-rune (alist display)
  (cond ((not (member-eq display &#39;(nil :merge))) alist)
        (t
         (mv-let (rune-alist hyp-xrune-alist conc-xrune-alist)
                 (split-xrune-alist alist nil nil nil)
...">sort-xrune-alist-by-rune</a>
  (alist display)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> display '(nil <span class="keyword">:merge</span>))) alist)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rune-alist hyp-xrune-alist conc-xrune-alist)
        (<a class="sym-link local-def" href="#def-split-xrune-alist" data-sym="SPLIT-XRUNE-ALIST" title="(defun split-xrune-alist (alist rune-alist hyp-xrune-alist conc-xrune-alist)
  (cond ((endp alist) (mv rune-alist hyp-xrune-alist conc-xrune-alist))
        (t
         (let ((xrune (access accp-entry (car alist) :xrune)))
           (case (car xrune)
...">split-xrune-alist</a> alist nil nil nil)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> display nil) rune-alist)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune1" data-sym="SORT-XRUNE-ALIST-BY-RUNE1" title="(defun sort-xrune-alist-by-rune1
       (rune-alist hyp-xrune-alist conc-xrune-alist acc)
  (cond
   ((endp rune-alist)
    (assert$ (and (null hyp-xrune-alist) (null conc-xrune-alist)) acc))
...">sort-xrune-alist-by-rune1</a> (<a class="sym-link system" href="axioms.html#def-merge-sort-lexorder" data-sym="MERGE-SORT-LEXORDER">merge-sort-lexorder</a> rune-alist)
              (<a class="sym-link system" href="axioms.html#def-merge-sort-lexorder" data-sym="MERGE-SORT-LEXORDER">merge-sort-lexorder</a> hyp-xrune-alist)
              (<a class="sym-link system" href="axioms.html#def-merge-sort-lexorder" data-sym="MERGE-SORT-LEXORDER">merge-sort-lexorder</a> conc-xrune-alist)
              nil)))))))</pre>
  </div>

<div class="form-block function" id="def-pop-accp-fn" data-defines="POP-ACCP-FN" data-references="-,+,ADD-ACCUMULATED-PERSISTENCE,CHANGE,CDR,MEMBER-EQUAL,TOP-LEVEL-P,T,1+,FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE-P,IF,COND,NOT,AND,NEW-CNT,X-XRUNEP,XP,CAR,XRUNE,ACCP-INFO,ACCESS,XRUNE-STACK,LET*,SUCCESS-P,INFO,DEFUN" data-used-by="POP-ACCP,POP-ACCP-FN-ITERATE" data-part-name="POP-ACCP-FN" data-part-args="SUCCESS-P,INFO" data-part-body="-,+,ADD-ACCUMULATED-PERSISTENCE,CHANGE,CDR,MEMBER-EQUAL,TOP-LEVEL-P,T,1+,FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE-P,IF,SUCCESS-P,COND,NOT,AND,NEW-CNT,X-XRUNEP,XP,CAR,XRUNE,INFO,ACCP-INFO,ACCESS,XRUNE-STACK,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-ACCP-FN">pop-accp-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pop-accp-fn" data-sym="POP-ACCP-FN" title="(defun pop-accp-fn (info success-p)
  (let* ((xrune-stack (access accp-info info :xrune-stack))
         (xrune (car xrune-stack))
         (xp (x-xrunep xrune))
         (new-cnt
...">pop-accp-fn</a>
  (info success-p)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((xrune-stack (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:xrune-stack</span>)) (xrune (car xrune-stack))
      (xp (<a class="sym-link local-def" href="#def-x-xrunep" data-sym="X-XRUNEP" title="(defabbrev x-xrunep (xrune) (or (eq (car xrune) :hyp) (eq (car xrune) :conc)))">x-xrunep</a> xrune))
      (new-cnt (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> xp)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (success-p (if (fake-rune-for-anonymous-enabled-rule-p xrune)
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-s</span>)
                (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-s</span>))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (if (fake-rune-for-anonymous-enabled-rule-p xrune)
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-f</span>)
                (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-f</span>)))))))
      (top-level-p (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> xrune (cdr xrune-stack)))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (xp (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
          info
          <span class="keyword">:stack-s</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>))
          <span class="keyword">:stack-f</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>))
          <span class="keyword">:xrune-stack</span> (cdr xrune-stack)
          <span class="keyword">:totals</span> (<a class="sym-link local-def" href="#def-add-accumulated-persistence" data-sym="ADD-ACCUMULATED-PERSISTENCE" title="(defun add-accumulated-persistence (xrune success-p delta alist-stack)
  (assert$ (cdr alist-stack)
           (let* ((alist
                   (if success-p
                       (car alist-stack)
...">add-accumulated-persistence</a> xrune
            success-p
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> top-level-p
              (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-s</span>)
                  (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>)))
                (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-f</span>)
                  (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>)))))
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:totals</span>))))
      (success-p (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
          info
          <span class="keyword">:cnt-s</span> new-cnt
          <span class="keyword">:stack-s</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>))
          <span class="keyword">:stack-f</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>))
          <span class="keyword">:xrune-stack</span> (cdr xrune-stack)
          <span class="keyword">:totals</span> (<a class="sym-link local-def" href="#def-add-accumulated-persistence" data-sym="ADD-ACCUMULATED-PERSISTENCE" title="(defun add-accumulated-persistence (xrune success-p delta alist-stack)
  (assert$ (cdr alist-stack)
           (let* ((alist
                   (if success-p
                       (car alist-stack)
...">add-accumulated-persistence</a> xrune
            success-p
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> top-level-p
              (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> new-cnt (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>)))
                (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-f</span>)
                  (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>)))))
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:totals</span>))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
          info
          <span class="keyword">:cnt-f</span> new-cnt
          <span class="keyword">:stack-s</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>))
          <span class="keyword">:stack-f</span> (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>))
          <span class="keyword">:xrune-stack</span> (cdr xrune-stack)
          <span class="keyword">:totals</span> (<a class="sym-link local-def" href="#def-add-accumulated-persistence" data-sym="ADD-ACCUMULATED-PERSISTENCE" title="(defun add-accumulated-persistence (xrune success-p delta alist-stack)
  (assert$ (cdr alist-stack)
           (let* ((alist
                   (if success-p
                       (car alist-stack)
...">add-accumulated-persistence</a> xrune
            success-p
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> top-level-p
              (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-s</span>)
                  (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>)))
                (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> new-cnt (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>)))))
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:totals</span>)))))))</pre>
  </div>

<div class="form-block function" id="def-pop-accp-fn-iterate" data-defines="POP-ACCP-FN-ITERATE" data-references="1-,T,POP-ACCP-FN,ZP,IF,N,INFO,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="POP-ACCP-FN-ITERATE" data-part-args="N,INFO" data-part-body="1-,T,POP-ACCP-FN,POP-ACCP-FN-ITERATE,INFO,N,ZP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-ACCP-FN-ITERATE">pop-accp-fn-iterate</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pop-accp-fn-iterate" data-sym="POP-ACCP-FN-ITERATE" title="(defun pop-accp-fn-iterate (info n)
  (if (zp n)
      info
      (pop-accp-fn-iterate (pop-accp-fn info t) (1- n))))">pop-accp-fn-iterate</a>
  (info n)
  (if (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> n)
    info
    (<a class="sym-link local-def" href="#def-pop-accp-fn-iterate" data-sym="POP-ACCP-FN-ITERATE" title="(defun pop-accp-fn-iterate (info n)
  (if (zp n)
      info
      (pop-accp-fn-iterate (pop-accp-fn info t) (1- n))))">pop-accp-fn-iterate</a> (<a class="sym-link local-def" href="#def-pop-accp-fn" data-sym="POP-ACCP-FN" title="(defun pop-accp-fn (info success-p)
  (let* ((xrune-stack (access accp-info info :xrune-stack))
         (xrune (car xrune-stack))
         (xp (x-xrunep xrune))
         (new-cnt
...">pop-accp-fn</a> info <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-list" data-defines="SHOW-ACCUMULATED-PERSISTENCE-LIST" data-references="PRETTYIFY-XRUNE,LIST,CONS,CDR,AP,AP-F,AP-S,+,N,N-F,N-S,ACCP-ENTRY,ACCESS,XRUNE,CDAR,ENTRY,LET*,T,ENDP,COND,ACC,ALIST,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-LIST" data-part-args="ACC,ALIST" data-part-body="PRETTYIFY-XRUNE,LIST,CONS,CDR,SHOW-ACCUMULATED-PERSISTENCE-LIST,AP,AP-F,AP-S,+,N,N-F,N-S,ACCP-ENTRY,ACCESS,XRUNE,CDAR,ENTRY,LET*,T,ACC,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-LIST">show-accumulated-persistence-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-list" data-sym="SHOW-ACCUMULATED-PERSISTENCE-LIST" title="(defun show-accumulated-persistence-list (alist acc)
  (cond ((endp alist) acc)
        (t
         (let* ((entry (cdar alist))
                (xrune (access accp-entry entry :xrune))
...">show-accumulated-persistence-list</a>
  (alist acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((entry (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)) (xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:xrune</span>))
          (n-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-s</span>))
          (n-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:n-f</span>))
          (n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> n-s n-f))
          (ap-s (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-s</span>))
          (ap-f (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> accp-entry entry <span class="keyword">:ap-f</span>))
          (ap (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> ap-s ap-f)))
        (<a class="sym-link local-def" href="#def-show-accumulated-persistence-list" data-sym="SHOW-ACCUMULATED-PERSISTENCE-LIST" title="(defun show-accumulated-persistence-list (alist acc)
  (cond ((endp alist) acc)
        (t
         (let* ((entry (cdar alist))
                (xrune (access accp-entry entry :xrune))
...">show-accumulated-persistence-list</a> (cdr alist)
          (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> ap n (<a class="sym-link local-def" href="#def-prettyify-xrune" data-sym="PRETTYIFY-XRUNE" title="(defun prettyify-xrune (xrune)
  (cond ((eq (car xrune) :hyp) (list* :hyp (cddr xrune) (cadr xrune)))
        (t xrune)))">prettyify-xrune</a> xrune)) acc))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-phrase" data-defines="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-references="+,-,*ACCP-MAJOR-SEPARATOR*,SHOW-ACCUMULATED-PERSISTENCE-PHRASE1,LIST,SHOW-ACCUMULATED-PERSISTENCE-LIST,MSG-FOR-RESULTS,HEADER-FOR-RESULTS,SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS,IF,SORT-XRUNE-ALIST-BY-RUNE,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2,ALIST,MERGEP,LAST,STRIP-CARS,MERGE-SORT-LEXORDER,EQ,ACCUMULATED-PERSISTENCE,MSG,NULL,TOTALS,T,LENGTH,POP-ACCP-FN-ITERATE,QUOTE,MEMBER-EQ,AND,COND,ACCESS,XRUNE-STACK,CDR,DISPLAY,CAR,KEY,LET*,ACCP-INFO,KEY/DISPLAY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-FN" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" data-part-args="ACCP-INFO,KEY/DISPLAY" data-part-body="+,-,*ACCP-MAJOR-SEPARATOR*,SHOW-ACCUMULATED-PERSISTENCE-PHRASE1,LIST,SHOW-ACCUMULATED-PERSISTENCE-LIST,MSG-FOR-RESULTS,HEADER-FOR-RESULTS,SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS,IF,SORT-XRUNE-ALIST-BY-RUNE,SHOW-ACCUMULATED-PERSISTENCE-PHRASE2,ALIST,MERGEP,LAST,STRIP-CARS,MERGE-SORT-LEXORDER,EQ,ACCUMULATED-PERSISTENCE,MSG,NULL,TOTALS,T,LENGTH,POP-ACCP-FN-ITERATE,QUOTE,MEMBER-EQ,AND,COND,ACCP-INFO,ACCESS,XRUNE-STACK,CDR,DISPLAY,KEY/DISPLAY,CAR,KEY,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE">show-accumulated-persistence-phrase</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" title="(defun show-accumulated-persistence-phrase (key/display accp-info)
  (let* ((key (car key/display))
         (display (cdr key/display))
         (xrune-stack (access accp-info accp-info :xrune-stack))
         (accp-info
...">show-accumulated-persistence-phrase</a>
  (key/display <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((key (car key/display)) (display (cdr key/display))
      (xrune-stack (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:xrune-stack</span>))
      (<a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> xrune-stack (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> key '(<span class="keyword">:frames-a</span> <span class="keyword">:tries-a</span>))) (<a class="sym-link local-def" href="#def-pop-accp-fn-iterate" data-sym="POP-ACCP-FN-ITERATE" title="(defun pop-accp-fn-iterate (info n)
  (if (zp n)
      info
      (pop-accp-fn-iterate (pop-accp-fn info t) (1- n))))">pop-accp-fn-iterate</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> xrune-stack)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>)))
      (totals (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:totals</span>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> totals) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"There is no accumulated persistence to show.  Evaluate ~x0 to ~
            activate gathering of accumulated-persistence statistics.~|"</span>
          '(<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> key <span class="keyword">:runes</span>) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~x0"</span>
          (<a class="sym-link system" href="axioms.html#def-merge-sort-lexorder" data-sym="MERGE-SORT-LEXORDER">merge-sort-lexorder</a> (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> (car (<a class="sym-link system" href="axioms.html#def-last" data-sym="LAST">last</a> totals))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((mergep (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> display <span class="keyword">:merge</span>)) (alist (<a class="sym-link system" href="axioms.html#def-merge-sort-lexorder" data-sym="MERGE-SORT-LEXORDER">merge-sort-lexorder</a> (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase2" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE2" title="(defun show-accumulated-persistence-phrase2 (key alist mergep)
  (cond (mergep (show-accumulated-persistence-phrase2-merge key alist nil))
        (t (show-accumulated-persistence-phrase2-not-merge key alist))))">show-accumulated-persistence-phrase2</a> key
                  (<a class="sym-link local-def" href="#def-sort-xrune-alist-by-rune" data-sym="SORT-XRUNE-ALIST-BY-RUNE" title="(defun sort-xrune-alist-by-rune (alist display)
  (cond ((not (member-eq display &#39;(nil :merge))) alist)
        (t
         (mv-let (rune-alist hyp-xrune-alist conc-xrune-alist)
                 (split-xrune-alist alist nil nil nil)
...">sort-xrune-alist-by-rune</a> (car (<a class="sym-link system" href="axioms.html#def-last" data-sym="LAST">last</a> totals)) display)
                  mergep)))
            (alist (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> key <span class="keyword">:useless</span>)
                (<a class="sym-link local-def" href="#def-show-accumulated-persistence-remove-useless" data-sym="SHOW-ACCUMULATED-PERSISTENCE-REMOVE-USELESS" title="(defun show-accumulated-persistence-remove-useless (alist acc)
  (cond ((null alist) (reverse acc))
        ((not (eql (access accp-entry (cdr (car alist)) :n-s) 0))
         (show-accumulated-persistence-remove-useless (cdr alist) acc))
        (t
...">show-accumulated-persistence-remove-useless</a> alist nil)
                alist))
            (header-for-results (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> display <span class="keyword">:list</span>)
                <span class="string">"List of entries (:frames :tries rune):~|"</span>
                <span class="string">"   :frames   :tries    :ratio  rune"</span>))
            (msg-for-results (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> display <span class="keyword">:list</span>)
                (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~|~x0~|"</span>
                  (<a class="sym-link local-def" href="#def-show-accumulated-persistence-list" data-sym="SHOW-ACCUMULATED-PERSISTENCE-LIST" title="(defun show-accumulated-persistence-list (alist acc)
  (cond ((endp alist) acc)
        (t
         (let* ((entry (cdar alist))
                (xrune (access accp-entry entry :xrune))
...">show-accumulated-persistence-list</a> alist nil))
                (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~*0~@1"</span>
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="string">""</span>
                    <span class="string">"~@*"</span>
                    <span class="string">"~@*"</span>
                    <span class="string">"~@*"</span>
                    (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase1" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE1" title="(defun show-accumulated-persistence-phrase1 (key alist mergep acc)
  (cond ((null alist) acc)
        (t
         (show-accumulated-persistence-phrase1 key (cdr alist) mergep
                                               (cons
...">show-accumulated-persistence-phrase1</a> key alist mergep nil))
                  <a class="sym-link local-def" href="#def-_2Aaccp-major-separator_2A" data-sym="*ACCP-MAJOR-SEPARATOR*" title="(defconst *accp-major-separator* &quot;   --------------------------------~%&quot;)">*accp-major-separator*</a>))))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr totals)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Accumulated Persistence~@0~|~%~@1~%~@2"</span>
                (if xrune-stack
                  <span class="string">""</span>
                  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">" (~x0 :tries useful, ~x1 :tries not useful)"</span>
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:cnt-s</span>)
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:cnt-f</span>)))
                header-for-results
                msg-for-results))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Accumulated Persistence~|~%~
                       ***************************************~|~
                       *** NOTE: INCOMPLETE!!!~|~
                       *** ~x0 rule attempts are not considered below.~|~
                       *** Use :frames-a or :tries-a to get more complete ~
                           totals.~|~
                       ***************************************~|~
                       ~%~@1~%~@2"</span>
                (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:cnt-s</span>)
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:cnt-f</span>)
                    (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> xrune-stack))
                  (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (car (<a class="sym-link system" href="axioms.html#def-last" data-sym="LAST">last</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:stack-s</span>)))
                    (car (<a class="sym-link system" href="axioms.html#def-last" data-sym="LAST">last</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> <span class="keyword">:stack-f</span>)))))
                header-for-results
                msg-for-results))))))))</pre>
  </div>

<div class="form-block function" id="def-show-accumulated-persistence-fn" data-defines="SHOW-ACCUMULATED-PERSISTENCE-FN" data-references="VALUE,*STANDARD-CO*,WORMHOLE-STATUS,WORMHOLE-DATA,WORMHOLE-INPUT,F-GET-GLOBAL,SHOW-ACCUMULATED-PERSISTENCE-PHRASE,LIST,FMS,STATE,TEMPORARY,IO?,PPROGN,SET-PRINT-RADIX,PRINT-RADIX,SET-PRINT-BASE,PRINT-BASE,STATE-GLOBAL-LET*,CONS,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,WORMHOLE,T,SHOW-ACCUMULATED-PERSISTENCE,HARD,ER,QUOTE,MEMBER-EQ,NOT,COND,DISPLAY,SORTKEY,DEFUN" data-used-by="SHOW-ACCUMULATED-PERSISTENCE" data-part-name="SHOW-ACCUMULATED-PERSISTENCE-FN" data-part-args="DISPLAY,SORTKEY" data-part-body="VALUE,*STANDARD-CO*,WORMHOLE-STATUS,WORMHOLE-DATA,WORMHOLE-INPUT,F-GET-GLOBAL,SHOW-ACCUMULATED-PERSISTENCE-PHRASE,LIST,FMS,STATE,TEMPORARY,IO?,PPROGN,SET-PRINT-RADIX,PRINT-RADIX,SET-PRINT-BASE,PRINT-BASE,STATE-GLOBAL-LET*,CONS,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,WORMHOLE,T,DISPLAY,SHOW-ACCUMULATED-PERSISTENCE,HARD,ER,QUOTE,SORTKEY,MEMBER-EQ,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE-FN">show-accumulated-persistence-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence-fn" data-sym="SHOW-ACCUMULATED-PERSISTENCE-FN" title="(defun show-accumulated-persistence-fn (sortkey display)
  (cond
   ((not
     (member-eq sortkey
                &#39;(:ratio :frames :frames-s :frames-f :frames-a :tries :tries-s
...">show-accumulated-persistence-fn</a>
  (sortkey display)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> sortkey
         '(<span class="keyword">:ratio</span> <span class="keyword">:frames</span> <span class="keyword">:frames-s</span> <span class="keyword">:frames-f</span> <span class="keyword">:frames-a</span> <span class="keyword">:tries</span> <span class="keyword">:tries-s</span> <span class="keyword">:tries-f</span> <span class="keyword">:tries-a</span> <span class="keyword">:useless</span> <span class="keyword">:runes</span>))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-show-accumulated-persistence" data-sym="SHOW-ACCUMULATED-PERSISTENCE" title="(defmacro show-accumulated-persistence
          (&amp;optional (sortkey &#39;:frames) (display &#39;t))
  (declare
   (xargs :guard
    (and
...">show-accumulated-persistence</a>
        <span class="string">"Unrecognized sortkey argument ~x0."</span>
        sortkey))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> display '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil <span class="keyword">:raw</span> <span class="keyword">:merge</span> <span class="keyword">:list</span>))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-show-accumulated-persistence" data-sym="SHOW-ACCUMULATED-PERSISTENCE" title="(defmacro show-accumulated-persistence
          (&amp;optional (sortkey &#39;:frames) (display &#39;t))
  (declare
   (xargs :guard
    (and
...">show-accumulated-persistence</a>
        <span class="string">"Unrecognized display argument ~x0."</span>
        display))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-wormhole" data-sym="WORMHOLE">wormhole</a> '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
        '(lambda (whs) (<a class="sym-link system" href="basis-a.html#def-set-wormhole-entry-code" data-sym="SET-WORMHOLE-ENTRY-CODE">set-wormhole-entry-code</a> whs <span class="keyword">:enter</span>))
        (cons sortkey display)
        '(<a class="sym-link system" href="axioms.html#def-state-global-let_2A" data-sym="STATE-GLOBAL-LET*">state-global-let*</a> ((<a class="sym-link system" href="axioms.html#def-print-base" data-sym="PRINT-BASE">print-base</a> <span class="number">10</span> <a class="sym-link system" href="axioms.html#def-set-print-base" data-sym="SET-PRINT-BASE">set-print-base</a>) (<a class="sym-link system" href="axioms.html#def-print-radix" data-sym="PRINT-RADIX">print-radix</a> nil <a class="sym-link system" href="axioms.html#def-set-print-radix" data-sym="SET-PRINT-RADIX">set-print-radix</a>))
          (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="basis-a.html#def-io_3F" data-sym="IO?">io?</a> temporary
              nil
              state
              nil
              (<a class="sym-link system" href="basis-a.html#def-fms" data-sym="FMS">fms</a> <span class="string">"~@0"</span>
                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0
                    (<a class="sym-link local-def" href="#def-show-accumulated-persistence-phrase" data-sym="SHOW-ACCUMULATED-PERSISTENCE-PHRASE" title="(defun show-accumulated-persistence-phrase (key/display accp-info)
  (let* ((key (car key/display))
         (display (cdr key/display))
         (xrune-stack (access accp-info accp-info :xrune-stack))
         (accp-info
...">show-accumulated-persistence-phrase</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-input state)
                      (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)))))
                <a class="sym-link system" href="axioms.html#def-_2Astandard-co_2A" data-sym="*STANDARD-CO*">*standard-co*</a>
                state
                nil))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:q</span>)))
        <span class="keyword">:ld-prompt</span> nil
        <span class="keyword">:ld-missing-input-ok</span> nil
        <span class="keyword">:ld-pre-eval-filter</span> <span class="keyword">:all</span> <span class="keyword">:ld-pre-eval-print</span> nil
        <span class="keyword">:ld-post-eval-print</span> <span class="keyword">:command-conventions</span> <span class="keyword">:ld-evisc-tuple</span> nil
        <span class="keyword">:ld-error-triples</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
        <span class="keyword">:ld-error-action</span> <span class="keyword">:error</span> <span class="keyword">:ld-query-control-alist</span> nil
        <span class="keyword">:ld-verbose</span> nil))))</pre>
  </div>

<div class="form-block macro" id="def-show-accumulated-persistence" data-defines="SHOW-ACCUMULATED-PERSISTENCE" data-references="SHOW-ACCUMULATED-PERSISTENCE-FN,MEMBER-EQ,AND,XARGS,DECLARE,T,DISPLAY,QUOTE,SORTKEY,&OPTIONAL,DEFMACRO" data-used-by="SHOW-ACCUMULATED-PERSISTENCE-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ACCUMULATED-PERSISTENCE">show-accumulated-persistence</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-show-accumulated-persistence" data-sym="SHOW-ACCUMULATED-PERSISTENCE" title="(defmacro show-accumulated-persistence
          (&amp;optional (sortkey &#39;:frames) (display &#39;t))
  (declare
   (xargs :guard
    (and
...">show-accumulated-persistence</a>
  (&amp;optional (sortkey '<span class="keyword">:frames</span>) (display '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> sortkey
          '(<span class="keyword">:ratio</span> <span class="keyword">:frames</span> <span class="keyword">:frames-s</span> <span class="keyword">:frames-f</span> <span class="keyword">:frames-a</span> <span class="keyword">:tries</span> <span class="keyword">:tries-s</span> <span class="keyword">:tries-f</span> <span class="keyword">:tries-a</span> <span class="keyword">:useless</span> <span class="keyword">:runes</span>))
        (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> display '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil <span class="keyword">:raw</span> <span class="keyword">:merge</span> <span class="keyword">:list</span>)))))
  (<a class="sym-link local-def" href="#def-show-accumulated-persistence-fn" data-sym="SHOW-ACCUMULATED-PERSISTENCE-FN" title="(defun show-accumulated-persistence-fn (sortkey display)
  (cond
   ((not
     (member-eq sortkey
                &#39;(:ratio :frames :frames-s :frames-f :frames-a :tries :tries-s
...">show-accumulated-persistence-fn</a> sortkey display))</pre>
  </div>

<div class="form-block function" id="def-push-accp-fn" data-defines="PUSH-ACCP-FN" data-references="ACCESS,CONS,ACCP-INFO,CHANGE,PUSH-ACCP,QUOTE,HARD,ER,T,NULL,CONC-XRUNE,EQ,HYP-XRUNE,NATP,COND,XRUNE,LET,INFO,X-INFO,RUNE,DEFUN" data-used-by="PUSH-ACCP" data-part-name="PUSH-ACCP-FN" data-part-args="INFO,X-INFO,RUNE" data-part-body="ACCESS,CONS,INFO,ACCP-INFO,CHANGE,PUSH-ACCP,QUOTE,HARD,ER,T,NULL,CONC-XRUNE,EQ,RUNE,HYP-XRUNE,X-INFO,NATP,COND,XRUNE,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-ACCP-FN">push-accp-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-accp-fn" data-sym="PUSH-ACCP-FN" title="(defun push-accp-fn (rune x-info info)
  (let ((xrune
         (cond ((natp x-info) (hyp-xrune x-info rune))
               ((eq x-info :conc) (conc-xrune rune)) ((null x-info) rune)
               (t
...">push-accp-fn</a>
  (rune x-info info)
  (let ((xrune (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> x-info) (<a class="sym-link local-def" href="#def-hyp-xrune" data-sym="HYP-XRUNE" title="(defabbrev hyp-xrune (n rune)
           (assert$ (not (x-xrunep rune)) (list* :hyp rune n)))">hyp-xrune</a> x-info rune))
         ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x-info <span class="keyword">:conc</span>) (<a class="sym-link local-def" href="#def-conc-xrune" data-sym="CONC-XRUNE" title="(defabbrev conc-xrune (rune) (assert$ (not (x-xrunep rune)) (list* :conc rune)))">conc-xrune</a> rune))
         ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x-info) rune)
         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
             '<a class="sym-link local-def" href="#def-push-accp" data-sym="PUSH-ACCP" title="(defun push-accp (rune x-info)
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let ((info (wormhole-data whs)))
                      (cond ((null info) whs)
...">push-accp</a>
             <span class="string">"Implementation error: Bad value of x-info, ~x0."</span>
             x-info)))))
    (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a>
      info
      <span class="keyword">:xrune-stack</span> (cons xrune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:xrune-stack</span>))
      <span class="keyword">:stack-s</span> (cons (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-s</span>)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-s</span>))
      <span class="keyword">:stack-f</span> (cons (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:cnt-f</span>)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:stack-f</span>))
      <span class="keyword">:totals</span> (cons nil (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:totals</span>)))))</pre>
  </div>

<div class="form-block function" id="def-push-accp" data-defines="PUSH-ACCP" data-references="CONS,T,PUSH-ACCP-FN,SET-WORMHOLE-DATA,ACCP-INFO,ACCESS,OR,NULL,COND,WORMHOLE-DATA,INFO,LET,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL,X-INFO,RUNE,DEFUN" data-used-by="WITH-ACCUMULATED-PERSISTENCE,PUSH-ACCP-FN" data-part-name="PUSH-ACCP" data-part-args="X-INFO,RUNE" data-part-body="CONS,T,RUNE,PUSH-ACCP-FN,SET-WORMHOLE-DATA,ACCP-INFO,ACCESS,X-INFO,OR,NULL,COND,WORMHOLE-DATA,INFO,LET,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-ACCP">push-accp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-accp" data-sym="PUSH-ACCP" title="(defun push-accp (rune x-info)
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let ((info (wormhole-data whs)))
                      (cond ((null info) whs)
...">push-accp</a>
  (rune x-info)
  (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
    '(lambda (whs)
      (let ((info (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> info) whs)
          ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x-info) (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:xrunep</span>)) (<a class="sym-link system" href="basis-a.html#def-set-wormhole-data" data-sym="SET-WORMHOLE-DATA">set-wormhole-data</a> whs (<a class="sym-link local-def" href="#def-push-accp-fn" data-sym="PUSH-ACCP-FN" title="(defun push-accp-fn (rune x-info info)
  (let ((xrune
         (cond ((natp x-info) (hyp-xrune x-info rune))
               ((eq x-info :conc) (conc-xrune rune)) ((null x-info) rune)
               (t
...">push-accp-fn</a> rune x-info info)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> whs))))
    (cons <span class="keyword">:no-wormhole-lock</span> rune)))</pre>
  </div>

<div class="form-block function" id="def-pop-accp" data-defines="POP-ACCP" data-references="CONS,T,POP-ACCP-FN,SET-WORMHOLE-DATA,ACCP-INFO,ACCESS,OR,NULL,COND,WORMHOLE-DATA,INFO,LET,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL,X-INFO,SUCCESS-P,DEFUN" data-part-name="POP-ACCP" data-part-args="X-INFO,SUCCESS-P" data-part-body="CONS,T,SUCCESS-P,POP-ACCP-FN,SET-WORMHOLE-DATA,ACCP-INFO,ACCESS,X-INFO,OR,NULL,COND,WORMHOLE-DATA,INFO,LET,WHS,LAMBDA,ACCUMULATED-PERSISTENCE,QUOTE,WORMHOLE-EVAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-ACCP">pop-accp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pop-accp" data-sym="POP-ACCP" title="(defun pop-accp (success-p x-info)
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let ((info (wormhole-data whs)))
                      (cond ((null info) whs)
...">pop-accp</a>
  (success-p x-info)
  (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> '<a class="sym-link local-def" href="#def-accumulated-persistence" data-sym="ACCUMULATED-PERSISTENCE" title="(defmacro accumulated-persistence (flg)
  (declare
   (xargs :guard
    (member-equal flg
                  (quote (t (quote t) nil (quote nil) :all (quote :all))))))">accumulated-persistence</a>
    '(lambda (whs)
      (let ((info (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> info) whs)
          ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x-info) (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> <a class="sym-link system" href="defuns.html#def-accp-info" data-sym="ACCP-INFO">accp-info</a> info <span class="keyword">:xrunep</span>)) (<a class="sym-link system" href="basis-a.html#def-set-wormhole-data" data-sym="SET-WORMHOLE-DATA">set-wormhole-data</a> whs (<a class="sym-link local-def" href="#def-pop-accp-fn" data-sym="POP-ACCP-FN" title="(defun pop-accp-fn (info success-p)
  (let* ((xrune-stack (access accp-info info :xrune-stack))
         (xrune (car xrune-stack))
         (xp (x-xrunep xrune))
         (new-cnt
...">pop-accp-fn</a> info success-p)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> whs))))
    (cons <span class="keyword">:no-wormhole-lock</span> success-p)))</pre>
  </div>

<div class="form-block macro" id="def-with-accumulated-persistence" data-defines="WITH-ACCUMULATED-PERSISTENCE" data-references="T,COND,PUSH-ACCP,PROG2$,FORM,LET,CDR,CAR,CONS,FIX-VARS,TYPE,DECLARE,QUASIQUOTE,AND,FIX-VAR-DECLARES,CADDR,CONSP,IF,VAR,FIX-VAR,FLET,CONDITION-P,QUOTE,CONDITION,X-INFO,&OPTIONAL,BODY,SUCCESS-P,VARS,RUNE,DEFMACRO" data-used-by="TYPE-SET-REC" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WITH-ACCUMULATED-PERSISTENCE">with-accumulated-persistence</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-with-accumulated-persistence" data-sym="WITH-ACCUMULATED-PERSISTENCE" title="(defmacro with-accumulated-persistence
          (rune vars success-p body
           &amp;optional x-info (condition &#39;nil condition-p))
  (flet ((fix-var (var)
           (if (consp var)
...">with-accumulated-persistence</a>
  (rune vars
    success-p
    <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
    &amp;optional
    x-info
    (condition 'nil condition-p))
  (flet ((fix-var (var)
       (if (consp var)
         (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> var)
         var)) (fix-var-declares (var)
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp var)
          `((declare (type ,(CADR VAR) ,(CADDR VAR)))))))
    (flet ((fix-vars (vars)
         (if (consp vars)
           (cons (fix-var (car vars)) (cdr vars))
           vars)))
      (let ((form `(<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-push-accp" data-sym="PUSH-ACCP" title="(defun push-accp (rune x-info)
  (wormhole-eval &#39;accumulated-persistence
                 &#39;(lambda (whs)
                    (let ((info (wormhole-data whs)))
                      (cond ((null info) whs)
...">push-accp</a> ,RUNE ,X-INFO)
             ,(COND
  ((AND (TRUE-LISTP VARS) (= (LENGTH VARS) 1))
   `(LET ((,(FIX-VAR (CAR VARS)) ,BODY))
      ,@(FIX-VAR-DECLARES (CAR VARS))
      (PROG2$ (POP-ACCP ,SUCCESS-P ,X-INFO) ,(FIX-VAR (CAR VARS)))))
  (T
   `(MV-LET ,(FIX-VARS VARS) ,BODY ,@(FIX-VAR-DECLARES (CAR VARS))
            (PROG2$ (POP-ACCP ,SUCCESS-P ,X-INFO) (MV ,@(FIX-VARS VARS)))))))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (condition-p `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (,CONDITION ,FORM) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ,BODY)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> form))))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false-_3C" data-defines="ASSUME-TRUE-FALSE-<" data-references="T,*TS-NEGATIVE-RATIONAL*,*TS-NON-POSITIVE-RATIONAL*,*TS-ACL2-NUMBER*,*TS-NON-NEGATIVE-RATIONAL*,CONS-TAG-TREES,*TS-COMPLEX-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-UNION,TS-COMPLEMENT,TS-INTERSECTION,EXTEND-TYPE-ALIST,*TS-ONE*,TS-INTERSECTP,<=,UNQUOTE,RATIONALP,QUOTEP,*TS-POSITIVE-INTEGER*,TS-SUBSETP,OR,AND,STRONGP,LET,NOT,COND,W,XTTREE,TTREE,TYPE-ALIST,TS2,TS1,ARG2,ARG1,NOT-FLG,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="ASSUME-TRUE-FALSE-<" data-part-args="W,XTTREE,TTREE,TYPE-ALIST,TS2,TS1,ARG2,ARG1,NOT-FLG" data-part-body="T,*TS-NEGATIVE-RATIONAL*,*TS-NON-POSITIVE-RATIONAL*,*TS-ACL2-NUMBER*,*TS-NON-NEGATIVE-RATIONAL*,W,TYPE-ALIST,XTTREE,TTREE,CONS-TAG-TREES,*TS-COMPLEX-RATIONAL*,*TS-POSITIVE-RATIONAL*,TS-UNION,TS-COMPLEMENT,TS-INTERSECTION,ARG2,EXTEND-TYPE-ALIST,*TS-ONE*,TS2,TS-INTERSECTP,<=,UNQUOTE,RATIONALP,ARG1,QUOTEP,*TS-POSITIVE-INTEGER*,TS1,TS-SUBSETP,OR,AND,STRONGP,LET,NOT-FLG,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE-<">assume-true-false-&lt;</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false-_3C" data-sym="ASSUME-TRUE-FALSE-&lt;" title="(defun assume-true-false-&lt;
       (not-flg arg1 arg2 ts1 ts2 type-alist ttree xttree w)
  (cond
   ((not not-flg)
    (let ((strongp
...">assume-true-false-&lt;</a>
  (not-flg arg1 arg2 ts1 ts2 type-alist ttree xttree <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg) (let ((strongp (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ts-subsetp ts1 *ts-positive-integer*)
               (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1)
                 (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> arg1))
                 (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">1</span> (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> arg1))))
             (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts2 *ts-one*))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (strongp (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
              (ts-intersection ts2
                (ts-complement *ts-one*)
                (ts-union *ts-positive-rational* *ts-complex-rational*))
              (cons-tag-trees ttree xttree)
              type-alist
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts1
               (ts-union *ts-non-negative-rational*
                 (ts-complement *ts-acl2-number*)))
             (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts2
               (ts-complement (ts-union *ts-positive-rational* *ts-complex-rational*)))) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
              (ts-intersection ts2
                (ts-union *ts-positive-rational* *ts-complex-rational*))
              (cons-tag-trees ttree xttree)
              type-alist
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts2
               (ts-union *ts-non-positive-rational*
                 (ts-complement *ts-acl2-number*)))
             (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1
               (ts-complement (ts-union *ts-negative-rational* *ts-complex-rational*)))) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg1
              (ts-intersection ts1
                (ts-union *ts-negative-rational* *ts-complex-rational*))
              (cons-tag-trees ttree xttree)
              type-alist
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts1 *ts-negative-rational*)
       (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts2
         (ts-complement (ts-union *ts-complex-rational* *ts-negative-rational*)))) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
        (ts-intersection ts2
          (ts-union *ts-complex-rational* *ts-negative-rational*))
        (cons-tag-trees ttree xttree)
        type-alist
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts1
         (ts-union *ts-non-positive-rational*
           (ts-complement *ts-acl2-number*)))
       (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts2 *ts-positive-rational*)) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
        (ts-intersection ts2 (ts-complement *ts-positive-rational*))
        (cons-tag-trees ttree xttree)
        type-alist
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts2 *ts-positive-rational*)
       (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1
         (ts-complement (ts-union *ts-complex-rational* *ts-positive-rational*)))) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg1
        (ts-intersection ts1
          (ts-union *ts-complex-rational* *ts-positive-rational*))
        (cons-tag-trees ttree xttree)
        type-alist
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts2
         (ts-complement (ts-union *ts-complex-rational* *ts-negative-rational*)))
       (<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 *ts-negative-rational*)) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg1
        (ts-intersection ts1 (ts-complement *ts-negative-rational*))
        (cons-tag-trees ttree xttree)
        type-alist
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist)))</pre>
  </div>

<div class="form-block function" id="def-mv-atf-2" data-defines="MV-ATF-2" data-references="FTA1,IF,TTA1,MV-ATF,DUMB-NEGATE-LIT,T,EQUAL,COND,SAME-PARITY,*TS-NIL*,FTA0,*TS-T*,EXTEND-TYPE-ALIST-SIMPLE,EQ,NOT,AND,TTA0,LET,IGNORE,XTTREE,SHARED-TTREE,X,XNOT-FLG,NEW-TERM,FALSE-TYPE-ALIST,TRUE-TYPE-ALIST,NOT-FLG,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="MV-ATF-2" data-part-args="IGNORE,XTTREE,SHARED-TTREE,X,XNOT-FLG,NEW-TERM,FALSE-TYPE-ALIST,TRUE-TYPE-ALIST,NOT-FLG" data-part-body="FTA1,XTTREE,IF,TTA1,MV-ATF,DUMB-NEGATE-LIT,T,X,EQUAL,COND,XNOT-FLG,NOT-FLG,SAME-PARITY,FALSE-TYPE-ALIST,*TS-NIL*,FTA0,TRUE-TYPE-ALIST,SHARED-TTREE,*TS-T*,NEW-TERM,EXTEND-TYPE-ALIST-SIMPLE,IGNORE,EQ,NOT,AND,TTA0,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MV-ATF-2">mv-atf-2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-mv-atf-2" data-sym="MV-ATF-2" title="(defun mv-atf-2
       (not-flg true-type-alist false-type-alist new-term xnot-flg x
        shared-ttree xttree ignore)
  (let ((tta0
         (and (not (eq ignore :tta))
...">mv-atf-2</a>
  (not-flg true-type-alist
    false-type-alist
    new-term
    xnot-flg
    x
    shared-ttree
    xttree
    ignore)
  (let ((tta0 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
         (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> new-term
           *ts-t*
           shared-ttree
           true-type-alist))) (fta0 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
          (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> new-term
            *ts-nil*
            shared-ttree
            false-type-alist)))
      (same-parity (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> not-flg xnot-flg)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal new-term
         (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (same-parity x) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> x)))) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil nil tta0 fta0 nil nil))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((tta1 (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
               (if same-parity
                 *ts-t*
                 *ts-nil*)
               xttree
               tta0)) (fta1 (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                (if same-parity
                  *ts-nil*
                  *ts-t*)
                xttree
                fta0)))
          (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil nil tta1 fta1 nil nil))))))</pre>
  </div>

<div class="form-block function" id="def-binding-hyp-p" data-defines="BINDING-HYP-P" data-references="DOUBLE-REWRITE,FFN-SYMB-P,ARG2,LET,EQUIVALENCE-RELATIONP,FARGS,T,FREE-VARSP,ASSOC-EQ,VARIABLEP,COND,MV,EQUALITYP,EQP,FARGN,IF,CASE-SPLIT,FORCE,QUOTE,FFN-SYMB,EQ,OR,FQUOTEP,NOT,NVARIABLEP,AND,FORCEP,LET*,WRLD,ALIST,HYP,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="BINDING-HYP-P" data-part-args="WRLD,ALIST,HYP" data-part-body="DOUBLE-REWRITE,FFN-SYMB-P,ARG2,LET,WRLD,EQUIVALENCE-RELATIONP,FARGS,T,FREE-VARSP,ALIST,ASSOC-EQ,VARIABLEP,COND,MV,EQUALITYP,EQP,FARGN,IF,CASE-SPLIT,FORCE,QUOTE,FFN-SYMB,EQ,OR,FQUOTEP,NOT,HYP,NVARIABLEP,AND,FORCEP,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BINDING-HYP-P">binding-hyp-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-binding-hyp-p" data-sym="BINDING-HYP-P" title="(defun binding-hyp-p (hyp alist wrld)
  (let* ((forcep
          (and (nvariablep hyp) (not (fquotep hyp))
               (or (eq (ffn-symb hyp) &#39;force)
                   (eq (ffn-symb hyp) &#39;case-split))))
...">binding-hyp-p</a>
  (hyp alist wrld)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((forcep (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> hyp)
         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> hyp))
         (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) '<a class="sym-link system" href="axioms.html#def-force" data-sym="FORCE">force</a>)
           (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) '<a class="sym-link system" href="axioms.html#def-case-split" data-sym="CASE-SPLIT">case-split</a>)))) (hyp (if forcep
          (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>)
          hyp))
      (eqp (<a class="sym-link system" href="basis-b.html#def-equalityp" data-sym="EQUALITYP">equalityp</a> hyp)))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> forcep
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (eqp (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>))
            (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>) alist))
            (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>) alist))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> hyp)
            (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> hyp))
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> hyp)
            (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>))
            (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) wrld)
            (let ((arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>)))
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>) alist))
                (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg2 '<a class="sym-link system" href="axioms.html#def-double-rewrite" data-sym="DOUBLE-REWRITE">double-rewrite</a>)
                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a> arg2 alist))))))))))</pre>
  </div>

<div class="form-block macro" id="def-adjust-ignore-for-atf" data-defines="ADJUST-IGNORE-FOR-ATF" data-references="T,EQ,AND,COND,QUASIQUOTE,IGNORE,NOT-FLG,DEFMACRO" data-used-by="TYPE-SET-REC" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADJUST-IGNORE-FOR-ATF">adjust-ignore-for-atf</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-adjust-ignore-for-atf" data-sym="ADJUST-IGNORE-FOR-ATF" title="(defmacro adjust-ignore-for-atf (not-flg ignore)
  `(cond ((and ,not-flg (eq ,ignore :fta)) :tta)
         ((and ,not-flg (eq ,ignore :tta)) :fta) (t ,ignore)))">adjust-ignore-for-atf</a>
  (not-flg ignore)
  `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,NOT-FLG (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ,IGNORE <span class="keyword">:fta</span>)) <span class="keyword">:tta</span>)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,NOT-FLG (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ,IGNORE <span class="keyword">:tta</span>)) <span class="keyword">:fta</span>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ,IGNORE)))</pre>
  </div>

<div class="form-block function" id="def-backchain-limit-reachedp1" data-defines="BACKCHAIN-LIMIT-REACHEDP1" data-references="CDR,1-,NULL,T,INT=,COND,ANCESTORS,N,DEFUN" data-used-by="BACKCHAIN-LIMIT-REACHEDP" data-part-name="BACKCHAIN-LIMIT-REACHEDP1" data-part-args="ANCESTORS,N" data-part-body="CDR,1-,BACKCHAIN-LIMIT-REACHEDP1,ANCESTORS,NULL,T,N,INT=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BACKCHAIN-LIMIT-REACHEDP1">backchain-limit-reachedp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-backchain-limit-reachedp1" data-sym="BACKCHAIN-LIMIT-REACHEDP1" title="(defun backchain-limit-reachedp1 (n ancestors)
  (cond ((int= n 0) t) ((null ancestors) nil)
        (t (backchain-limit-reachedp1 (1- n) (cdr ancestors)))))">backchain-limit-reachedp1</a>
  (n ancestors)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> n <span class="number">0</span>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ancestors) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-backchain-limit-reachedp1" data-sym="BACKCHAIN-LIMIT-REACHEDP1" title="(defun backchain-limit-reachedp1 (n ancestors)
  (cond ((int= n 0) t) ((null ancestors) nil)
        (t (backchain-limit-reachedp1 (1- n) (cdr ancestors)))))">backchain-limit-reachedp1</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n) (cdr ancestors)))))</pre>
  </div>

<div class="form-block function" id="def-backchain-limit-reachedp" data-defines="BACKCHAIN-LIMIT-REACHEDP" data-references="BACKCHAIN-LIMIT-REACHEDP1,AND,ANCESTORS,N,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="BACKCHAIN-LIMIT-REACHEDP" data-part-args="ANCESTORS,N" data-part-body="ANCESTORS,BACKCHAIN-LIMIT-REACHEDP1,N,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BACKCHAIN-LIMIT-REACHEDP">backchain-limit-reachedp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-backchain-limit-reachedp" data-sym="BACKCHAIN-LIMIT-REACHEDP" title="(defun backchain-limit-reachedp (n ancestors)
  (and n (backchain-limit-reachedp1 n ancestors)))">backchain-limit-reachedp</a>
  (n ancestors)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> n (<a class="sym-link local-def" href="#def-backchain-limit-reachedp1" data-sym="BACKCHAIN-LIMIT-REACHEDP1" title="(defun backchain-limit-reachedp1 (n ancestors)
  (cond ((int= n 0) t) ((null ancestors) nil)
        (t (backchain-limit-reachedp1 (1- n) (cdr ancestors)))))">backchain-limit-reachedp1</a> n ancestors)))</pre>
  </div>

<div class="form-block function" id="def-new-backchain-limit" data-defines="NEW-BACKCHAIN-LIMIT" data-references="MIN,T,LENGTH,+,NULL,COND,ANCESTORS,OLD-LIMIT,NEW-OFFSET,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="NEW-BACKCHAIN-LIMIT" data-part-args="ANCESTORS,OLD-LIMIT,NEW-OFFSET" data-part-body="MIN,T,ANCESTORS,LENGTH,+,OLD-LIMIT,NEW-OFFSET,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEW-BACKCHAIN-LIMIT">new-backchain-limit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-new-backchain-limit" data-sym="NEW-BACKCHAIN-LIMIT" title="(defun new-backchain-limit (new-offset old-limit ancestors)
  (cond ((null new-offset) old-limit)
        ((null old-limit) (+ (length ancestors) new-offset))
        (t (min (+ (length ancestors) new-offset) old-limit))))">new-backchain-limit</a>
  (new-offset old-limit ancestors)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-offset) old-limit)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> old-limit) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> ancestors) new-offset))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (min (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> ancestors) new-offset) old-limit))))</pre>
  </div>

<div class="form-block other" id="form-244" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> oncep-tp (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block function" id="def-oncep-tp-builtin" data-defines="ONCEP-TP-BUILTIN" data-references="T,XARGS,IGNORE,DECLARE,WRLD,RUNE,DEFUN" data-part-name="ONCEP-TP-BUILTIN" data-part-args="WRLD,RUNE" data-part-declare="T,XARGS,WRLD,RUNE,IGNORE,DECLARE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ONCEP-TP-BUILTIN">oncep-tp-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-oncep-tp-builtin" data-sym="ONCEP-TP-BUILTIN" title="(defun oncep-tp-builtin (rune wrld)
  (declare (ignore rune wrld)
           (xargs :mode :logic :guard t))
  nil)">oncep-tp-builtin</a>
  (rune wrld)
  (declare (ignore rune wrld)
    (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  nil)</pre>
  </div>

<div class="form-block other" id="form-246" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (oncep-tp <a class="sym-link local-def" href="#def-oncep-tp-builtin" data-sym="ONCEP-TP-BUILTIN" title="(defun oncep-tp-builtin (rune wrld)
  (declare (ignore rune wrld)
           (xargs :mode :logic :guard t))
  nil)">oncep-tp-builtin</a>) <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-strengthen-recog-call" data-defines="STRENGTHEN-RECOG-CALL" data-references="OTHERWISE,EQL,NOT,BINARY-*,RATIONALP,T,*TS-ACL2-NUMBER*,TS-COMPLEMENT,MV,UNQUOTE,QUOTEP,AND,BINARY-+,QUOTE,FFN-SYMB-P,COND,INTEGERP,FFN-SYMB,CASE,FARGN,ARG,LET,X,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="STRENGTHEN-RECOG-CALL" data-part-args="X" data-part-body="OTHERWISE,EQL,NOT,BINARY-*,RATIONALP,T,*TS-ACL2-NUMBER*,TS-COMPLEMENT,MV,UNQUOTE,QUOTEP,AND,BINARY-+,QUOTE,FFN-SYMB-P,COND,INTEGERP,FFN-SYMB,CASE,X,FARGN,ARG,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STRENGTHEN-RECOG-CALL">strengthen-recog-call</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-strengthen-recog-call" data-sym="STRENGTHEN-RECOG-CALL" title="(defun strengthen-recog-call (x)
  (let ((arg (fargn x 1)))
    (case (ffn-symb x)
      (integerp
       (cond
...">strengthen-recog-call</a>
  (x)
  (let ((arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)))
    (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)
      (integerp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg 'binary-+) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>))
                 (integerp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-complement *ts-acl2-number*) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">2</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg))))
      (rationalp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg 'binary-+) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>))
                 (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-complement *ts-acl2-number*) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">2</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg))))
          ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg 'binary-*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>))
                 (rationalp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>)))
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">1</span>))))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-complement *ts-acl2-number*) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg <span class="number">2</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg))))
      (otherwise (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil arg)))))</pre>
  </div>

<div class="form-block function" id="def-push-lemma_3F" data-defines="PUSH-LEMMA?" data-references="PUSH-LEMMA,IF,TTREE,RUNE,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="PUSH-LEMMA?" data-part-args="TTREE,RUNE" data-part-body="TTREE,PUSH-LEMMA,RUNE,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-LEMMA?">push-lemma?</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-lemma_3F" data-sym="PUSH-LEMMA?" title="(defun push-lemma? (rune ttree)
  (if rune
      (push-lemma rune ttree)
      ttree))">push-lemma?</a>
  (rune ttree)
  (if rune
    (push-lemma rune ttree)
    ttree))</pre>
  </div>

<div class="form-block other" id="form-249" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> use-enhanced-recognizer nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-250" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> use-enhanced-recognizer
  <a class="sym-link system" href="axioms.html#def-constant-t-function-arity-0" data-sym="CONSTANT-T-FUNCTION-ARITY-0">constant-t-function-arity-0</a>)</pre>
  </div>

<div class="form-block function" id="def-strong-recognizer-expr-p" data-defines="STRONG-RECOGNIZER-EXPR-P" data-references="*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,TS-COMPLEMENT,OTHERWISE,*TS-ONE*,*TS-ZERO*,*TS-NIL*,*TS-T*,CASE,TS,NULL,UNQUOTE,QUOTEP,EVG,ARG,USE-ENHANCED-RECOGNIZER,LIST,RECOGNIZER-TUPLE,ACCESS,MOST-RECENT-ENABLED-RECOG-TUPLE,R,LET,CDR,FARGS,ADD-TO-SET-EQUAL,RUNES,NOT-FALSE-TS,NOT-TRUE-TS,FFN-SYMB,FLAMBDA-APPLICATIONP,FQUOTEP,*NIL*,*TS-EMPTY*,*TS-UNKNOWN*,OR,*T*,EQUAL,VARIABLEP,T,UNION-EQUAL,TS-INTERSECTION,TS-UNION,MV,FBR-RUNES,FBR-FALSE-TS,FBR-TRUE-TS,EQ,NOT,AND,TBR-RUNES,TBR-FALSE-TS,TBR-TRUE-TS,FARGN,TEST-RUNES,TEST-FALSE-TS,TEST-TRUE-TS,MV-LET,IF,QUOTE,FFN-SYMB-P,COND,W,ENS,X,VAR,DEFUN" data-used-by="RECOGNIZER-EXPR-P" data-part-name="STRONG-RECOGNIZER-EXPR-P" data-part-args="W,ENS,X,VAR" data-part-body="*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,TS-COMPLEMENT,OTHERWISE,*TS-ONE*,*TS-ZERO*,*TS-NIL*,*TS-T*,CASE,TS,NULL,UNQUOTE,QUOTEP,EVG,ARG,USE-ENHANCED-RECOGNIZER,LIST,RECOGNIZER-TUPLE,ACCESS,MOST-RECENT-ENABLED-RECOG-TUPLE,R,LET,CDR,FARGS,ADD-TO-SET-EQUAL,RUNES,NOT-FALSE-TS,NOT-TRUE-TS,FFN-SYMB,FLAMBDA-APPLICATIONP,FQUOTEP,*NIL*,*TS-EMPTY*,*TS-UNKNOWN*,OR,*T*,EQUAL,VARIABLEP,T,UNION-EQUAL,TS-INTERSECTION,TS-UNION,MV,FBR-RUNES,FBR-FALSE-TS,FBR-TRUE-TS,EQ,NOT,AND,TBR-RUNES,TBR-FALSE-TS,TBR-TRUE-TS,W,ENS,FARGN,STRONG-RECOGNIZER-EXPR-P,TEST-RUNES,TEST-FALSE-TS,TEST-TRUE-TS,VAR,MV-LET,IF,QUOTE,X,FFN-SYMB-P,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STRONG-RECOGNIZER-EXPR-P">strong-recognizer-expr-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a>
  (var x <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> x 'if) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var test-true-ts test-false-ts test-runes)
        (<a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a> var (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (var (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var tbr-true-ts tbr-false-ts tbr-runes)
              (<a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>)) var)
                (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (var (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var fbr-true-ts fbr-false-ts fbr-runes)
                    (<a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>)) var)
                      (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">3</span>)
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (var (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> var
                          (ts-union (ts-intersection test-true-ts tbr-true-ts)
                            (ts-intersection test-false-ts fbr-true-ts))
                          (ts-union (ts-intersection test-true-ts tbr-false-ts)
                            (ts-intersection test-false-ts fbr-false-ts))
                          (<a class="sym-link system" href="axioms.html#def-union-equal" data-sym="UNION-EQUAL">union-equal</a> test-runes (<a class="sym-link system" href="axioms.html#def-union-equal" data-sym="UNION-EQUAL">union-equal</a> tbr-runes fbr-runes))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)))))
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
    ((equal x <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> var <span class="keyword">:empty</span>) *ts-unknown* *ts-empty* nil))
    ((equal x <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> var <span class="keyword">:empty</span>) *ts-empty* *ts-unknown* nil))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
    ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var not-true-ts not-false-ts runes)
        (<a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a> var (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> var
          not-false-ts
          not-true-ts
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> var (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>)))
            (<a class="sym-link system" href="axioms.html#def-add-to-set-equal" data-sym="ADD-TO-SET-EQUAL">add-to-set-equal</a> '(<span class="keyword">:definition</span> <a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) runes)
            runes))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x)
       (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (cdr (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x)))
       (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var nil) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>) (equal var (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)))) (let ((r (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE" title="(defun most-recent-enabled-recog-tuple (fn wrld ens)
  (let ((lst (getpropc fn &#39;recognizer-alist nil wrld)))
    (and lst (most-recent-enabled-recog-tuple1 lst ens))))">most-recent-enabled-recog-tuple</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> r (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:strongp</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:true-ts</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:false-ts</span>)
              (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:rune</span>))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'equal) (use-enhanced-recognizer)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (arg evg)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>))))
          ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> arg)
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var nil) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>) (equal var arg)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ts (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> evg
                   ((<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) *ts-t*)
                   ((nil) *ts-nil*)
                   (<span class="number">0</span> *ts-zero*)
                   (<span class="number">1</span> *ts-one*)
                   (otherwise nil))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ts) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> arg
                    ts
                    (ts-complement ts)
                    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> *fake-rune-for-anonymous-enabled-rule*)))))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))))</pre>
  </div>

<div class="form-block function" id="def-recognizer-expr-p" data-defines="RECOGNIZER-EXPR-P" data-references="RECOGNIZER-TUPLE,ACCESS,MOST-RECENT-ENABLED-RECOG-TUPLE,R,LET,CDR,FARGS,T,MV,TS-COMPLEMENT,TS=,ASSERT$,NOT,AND,STRONG-RECOGNIZER-EXPR-P,RUNES,FALSE-TS,TRUE-TS,VAR,MV-LET,IF,QUOTE,FFN-SYMB,EQ,COND,W,ENS,X,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="RECOGNIZER-EXPR-P" data-part-args="W,ENS,X" data-part-body="RECOGNIZER-TUPLE,ACCESS,MOST-RECENT-ENABLED-RECOG-TUPLE,R,LET,CDR,FARGS,T,MV,TS-COMPLEMENT,TS=,ASSERT$,NOT,AND,W,ENS,STRONG-RECOGNIZER-EXPR-P,RUNES,FALSE-TS,TRUE-TS,VAR,MV-LET,IF,QUOTE,X,FFN-SYMB,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECOGNIZER-EXPR-P">recognizer-expr-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-recognizer-expr-p" data-sym="RECOGNIZER-EXPR-P" title="(defun recognizer-expr-p (x ens w)
  (cond
   ((eq (ffn-symb x) &#39;if)
    (mv-let (var true-ts false-ts runes) (strong-recognizer-expr-p nil x ens w)
            (cond
...">recognizer-expr-p</a>
  (x <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'if) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var true-ts false-ts runes)
        (<a class="sym-link local-def" href="#def-strong-recognizer-expr-p" data-sym="STRONG-RECOGNIZER-EXPR-P" title="(defun strong-recognizer-expr-p (var x ens w)
  (cond
   ((ffn-symb-p x &#39;if)
    (mv-let (var test-true-ts test-false-ts test-runes)
            (strong-recognizer-expr-p var (fargn x 1) ens w)
...">strong-recognizer-expr-p</a> nil x <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> var (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:empty</span>))) (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> false-ts (ts-complement true-ts))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> var <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> true-ts false-ts runes)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil nil)))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (cdr (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x)))) (let ((r (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE" title="(defun most-recent-enabled-recog-tuple (fn wrld ens)
  (let ((lst (getpropc fn &#39;recognizer-alist nil wrld)))
    (and lst (most-recent-enabled-recog-tuple1 lst ens))))">most-recent-enabled-recog-tuple</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (r (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:one</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:strongp</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:true-ts</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:false-ts</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple r <span class="keyword">:rune</span>)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil nil)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil nil))))</pre>
  </div>

<div class="form-block function" id="def-push-lemma_5Bs_5D" data-defines="PUSH-LEMMA[S]" data-references="REMOVE-TAG-FROM-TAG-TREE!,CDR,UNION-EQUAL,ACONS,REMOVE1-EQUAL,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,MEMBER-EQUAL,IF,RUNES,LEMMA,QUOTE,ASSOC-EQ,PAIR,LET,T,PUSH-LEMMA,EQ,COND,TTREE,RUNE[S],FLG,DEFUN" data-used-by="TYPE-SET-REC" data-part-name="PUSH-LEMMA[S]" data-part-args="TTREE,RUNE[S],FLG" data-part-body="REMOVE-TAG-FROM-TAG-TREE!,CDR,UNION-EQUAL,ACONS,REMOVE1-EQUAL,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,MEMBER-EQUAL,IF,RUNES,LEMMA,QUOTE,ASSOC-EQ,PAIR,LET,T,TTREE,RUNE[S],PUSH-LEMMA,FLG,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-LEMMA[S]">|PUSH-LEMMA[S]|</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a>
  (flg |RUNE[S]| ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> flg <span class="keyword">:one</span>) (push-lemma |RUNE[S]| ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'lemma ttree)) (runes (if (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> *fake-rune-for-anonymous-enabled-rule*
                |RUNE[S]|)
              (<a class="sym-link system" href="axioms.html#def-remove1-equal" data-sym="REMOVE1-EQUAL">remove1-equal</a> *fake-rune-for-anonymous-enabled-rule*
                |RUNE[S]|)
              |RUNE[S]|)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> 'lemma
              (<a class="sym-link system" href="axioms.html#def-union-equal" data-sym="UNION-EQUAL">union-equal</a> runes (cdr pair))
              (remove-tag-from-tag-tree! 'lemma ttree)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> 'lemma runes ttree)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-type-set-rec" data-defines="TYPE-SET-REC" data-references="TYPE-ALIST-TO-BE-EXTENDED,*TS-TRUE-LIST*,TTREEX,NON-CONS-CDR,*TS-IMPROPER-CONS*,*TS-PROPER-CONS*,PROPER/IMPROPER-CONS-TS-TUPLE,FTA1,TTA1,MBT1,EQUIV,EQUIVALENCE-RELATIONP,ASSUME-TRUE-FALSE-<,DTTREE,*TS-NON-NEGATIVE-RATIONAL*,*TS-NEGATIVE-RATIONAL*,*TS-POSITIVE-RATIO*,*TS-INTEGER>1*,MV-ATF-2,THE-TYPE-SET,*TS-COMPLEX-RATIONAL*,*TS-NON-POSITIVE-RATIONAL*,*TS-POSITIVE-RATIONAL*,TSX,FFN-SYMB-P,*-1*,*2*,*0*,*TS-INTEGER*,*TS-ACL2-NUMBER*,*1*,FALSE-TYPE-ALIST3,TS-COMPLEMENT,*TS-ONE*,*TS-ZERO*,FALSE-TYPE-ALIST2,FALSE-TYPE-ALIST1,TRUE-TYPE-ALIST3,TRUE-TYPE-ALIST2,EXTEND-TYPE-ALIST1,TRUE-TYPE-ALIST1,XTTREE+,SHARED-TTREE-TTA-P,TERM-ORDER,SWAP-FLG,*SINGLETON-TYPE-SETS*,MEMBER,INT,ASSUME-TRUE-FALSE-ERROR,ERP,<SAME_TYPE-ALIST>,<W>,<ENS>,<XTTREE>,KWOTE,ASSUME-TRUE-FALSE,HARD,ER,ASSOC-EQUIV,TEMP-TEMP,ARG2-CANON,CANONICALP2,OCCURSP2,CANONICAL-REPRESENTATIVE,ARG1-CANON,CANONICALP1,OCCURSP1,QUOTEP,ARG2,ARG1,EXTEND-WITH-PROPER/IMPROPER-CONS-TS-TUPLE,TYPE-ALIST0,SHARED-TTREE,PUSH-LEMMA[S],F-INT,T-INT,STRENGTHEN-RECOG-CALL,ARG,ADJUST-IGNORE-FOR-ATF,RECOGNIZER-EXPR-P,RUNE[S],FALSE-TS,TRUE-TS,STRONGP,VAR,ASSUME-TRUE-FALSE1,*T*,NVARIABLEP,XNOT-FLG,IGNORE0,INFECT-NEW-TYPE-ALIST-ENTRIES,*TS-NON-NIL*,EXTEND-TYPE-ALIST-SIMPLE,LOOK-IN-TYPE-ALIST,X-TS-TTREE,X-TS,FB-TTREE,FB-FTA,FB-TTA,FB-MBF,FB-MBT,TB-TTREE,TB-FTA,TB-TTA,TB-MBF,TB-MBT,MV-ATF,FTA,TTA,MBF,MBT,TEST-TTREE,TEST-FTA,TEST-TTA,TEST-MBF,TEST-MBT,FALSE-BRANCH,TRUE-BRANCH,TEST,XTTREE,ASSUME-TRUE-FALSE-IF,OTHERWISE,TYPE-SET-CHAR-CODE,CHAR-CODE,TYPE-SET-COMPLEX,COMPLEX,TYPE-SET-IMAGPART,IMAGPART,TYPE-SET-REALPART,REALPART,TYPE-SET-<,<,TYPE-SET-BINARY-*,BINARY-*,TYPE-SET-BINARY-+,BINARY-+,TYPE-SET-LENGTH,LENGTH,TYPE-SET-COERCE,COERCE,*TS-SYMBOL*,PKG-WITNESS,TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL,INTERN-IN-PACKAGE-OF-SYMBOL,SYMBOL-PACKAGE-NAME,PUFFERT,*TS-STRING*,SYMBOL-NAME,TYPE-SET-CDR,TYPE-SET-CAR,TYPE-SET-NUMERATOR,NUMERATOR,TYPE-SET-DENOMINATOR,DENOMINATOR,TYPE-SET-UNARY-/,UNARY-/,TYPE-SET-UNARY--,UNARY--,TYPE-SET-EQUAL,TYPE-SET-CONS,CASE,TYPE-ALIST1,TS-SUBSETP,TYPE-SET-PRIMITIVE,TP-LST,CDAR,BASIC-TS,VARS,PUSH-LEMMA,TYPE-SET-WITH-RULE1,EXTENDED-P-OUT,TTREE-OUT,TYPE-ALIST-OUT,ONE-WAY-UNIFY,UNIFY-SUBST,UNIFY-ANS,TYPE-PRESCRIPTION,ENABLED-NUMEP,TP,TYPE-SET-WITH-RULE,EXTEND-TYPE-ALIST,ASSOC-EQUAL,EXTEND-TYPE-ALIST-WITH-BINDINGS,SUBLIS-VAR,ALL-VARS,BIND-FREE-VARS-TO-UNBOUND-FREE-VARS,FULLY-BOUND-ALIST,FREE-VARSP,ONCEP-TP,CAAR,PUSH-LEMMA?,TERM-AND-TYP-TO-LOOKUP,COMPOUND-REC-RUNE?,BINDING-HYP-P,BIND-FLG,*TS-BOOLEAN*,TS-INTERSECTP,LET,NEW-BACKCHAIN-LIMIT,PUSH-ANCESTOR,WITH-ACCUMULATED-PERSISTENCE,FLG,IMMEDIATE-FORCEP,FORCE-ASSUMPTION,BACKCHAIN-LIMIT-REACHEDP,LIST,MCONS-TERM*,ANCESTORS-CHECK,ASSUMED-TRUE,ON-ANCESTORSP,1+,*NIL*,EQUAL,SUBLIS-VAR!,QUOTEP-ATM1,ATM1,STRIP-NOT,ATM,NOT-FLG,BKPTR,FORCEP,HYP,TYPE-SET-RELIEVE-HYPS1,RELIEVE-HYPS-ANS,TYPE-SET-RELIEVE-HYPS,SEARCH-TYPE-ALIST-WITH-REST,ALIST+,LOOKUP-HYP-ANS,ASSERT$,BKPTR+1,WRLD,ALIST,BACKCHAIN-LIMIT-LST,HYPS,TARGET,RUNE,REST-TYPE-ALIST,TYP,TERM,TYPE-SET-RELIEVE-HYPS-FREE,CDR,CONS,NULL,BBODY,FORMALS,SUBCOR-VAR,*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*,MEMBER-EQ,TS-UNION,*TS-EMPTY*,ASSUME-TRUE-FALSE-REC,FALSE-TYPE-ALIST,TRUE-TYPE-ALIST,MUST-BE-FALSE,MUST-BE-TRUE,TS-INTERSECTION,IGNORE,DECLARE,TYPE-PRESCRIPTIONS,GETPROPC,TYPE-SET-WITH-RULES,EXTENDED-P,TTREE2,TS2,*TS-NIL*,*TS-T*,TS=,TS,TYPE-SET-RECOGNIZER,IF,MOST-RECENT-ENABLED-RECOG-TUPLE,RECOG-TUPLE,FN,LET*,TYPE-SET-NOT,FARGN,QUOTE,FARGS,TYPE-SET-LST,LAMBDA-FORMALS,ZIP-VARIABLE-TYPE-ALIST,FFN-SYMB,LAMBDA-BODY,TTREE1,TS1,FLAMBDA-APPLICATIONP,TYPE-SET-QUOTE,FQUOTEP,*TS-UNKNOWN*,TYPE-SET-FINISH,VARIABLEP,CONS-TAG-TREES,RECOGNIZER-TUPLE,ACCESS,TS-DISJOINTP,NOT,OR,ASSOC-TYPE-ALIST,T,CDDR,CADR,MV,CAR,EQ,CONSP,AND,COND,TTREE0,TS0,MV-LET,BACKCHAIN-LIMIT,PT,POT-LST,TTREE,W,ENS,ANCESTORS,TYPE-ALIST,DWP,FORCE-FLG,X,DEFUN,MUTUAL-RECURSION" data-used-by="TYPE-SET-BC,TYPE-SET" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-REC">type-set-rec</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a>
    (x force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts0 ttree0)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp dwp) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car dwp) <span class="keyword">:skip-lookup</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> dwp) (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> dwp)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assoc-type-alist" data-sym="ASSOC-TYPE-ALIST" title="(defun assoc-type-alist (term type-alist wrld)
  (cond
   ((variablep term)
    (let ((temp (assoc-eq term type-alist)))
      (if temp
...">assoc-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ts0
           (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> dwp)
             (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp dwp)
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car dwp) <span class="keyword">:skip-lookup</span>))
               (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts0 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple dwp <span class="keyword">:true-ts</span>))
                 (<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts0 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple dwp <span class="keyword">:false-ts</span>)))))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts0 (cons-tag-trees ttree ttree0)))
        ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> x) (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 *ts-unknown* ttree type-alist))
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> x) (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x
            ts0
            ttree0
            (<a class="sym-link local-def" href="#def-type-set-quote" data-sym="TYPE-SET-QUOTE" title="(defun type-set-quote (evg)
  (cond
   ((atom evg)
    (cond
     ((rationalp evg)
...">type-set-quote</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
            ttree
            type-alist))
        ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> x) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x))
              nil
              nil
              (<a class="sym-link local-def" href="#def-zip-variable-type-alist" data-sym="ZIP-VARIABLE-TYPE-ALIST" title="(defun zip-variable-type-alist (vars pairs)
  (cond ((null vars) nil)
        ((ts= (caar pairs) *ts-unknown*)
         (zip-variable-type-alist (cdr vars) (cdr pairs)))
        (t
...">zip-variable-type-alist</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x))
                (type-set-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x)
                  force-flg
                  nil
                  type-alist
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                  pot-lst
                  pt
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              nil
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist)))
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
              force-flg
              nil
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
              (<a class="sym-link local-def" href="#def-type-set-not" data-sym="TYPE-SET-NOT" title="(defun type-set-not (ts ttree ttree0)
  (cond ((ts= ts *ts-nil*) (mv *ts-t* (puffert ttree)))
        ((ts-subsetp *ts-nil* ts) (mv *ts-boolean* ttree0))
        (t (mv *ts-nil* (puffert ttree)))))">type-set-not</a> ts1 ttree1 ttree)
              (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)) (recog-tuple (<a class="sym-link local-def" href="#def-most-recent-enabled-recog-tuple" data-sym="MOST-RECENT-ENABLED-RECOG-TUPLE" title="(defun most-recent-enabled-recog-tuple (fn wrld ens)
  (let ((lst (getpropc fn &#39;recognizer-alist nil wrld)))
    (and lst (most-recent-enabled-recog-tuple1 lst ens))))">most-recent-enabled-recog-tuple</a> fn <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>))
              (dwp (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp dwp) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car dwp) <span class="keyword">:skip-lookup</span>))
                  nil
                  dwp)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (recog-tuple (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                  (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
                    force-flg
                    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> force-flg dwp) recog-tuple)
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    ttree
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                    (<a class="sym-link local-def" href="#def-type-set-recognizer" data-sym="TYPE-SET-RECOGNIZER" title="(defun type-set-recognizer (recog-tuple arg-ts ttree ttree0)
  (let ((ts
         (ts-builder arg-ts
                     ((access recognizer-tuple recog-tuple :true-ts) *ts-t*)
                     ((access recognizer-tuple recog-tuple :false-ts)
...">type-set-recognizer</a> recog-tuple ts1 ttree1 ttree)
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
                      (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-t*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree2 extended-p)
                            (type-set-with-rules (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'type-prescriptions nil <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                              x
                              force-flg
                              dwp
                              type-alist
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              *ts-unknown*
                              ttree
                              pot-lst
                              pt
                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                              nil)
                            (declare (ignore extended-p))
                            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-intersection ts ts2) ttree2))))))))
              ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'if) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (must-be-true must-be-false
                      true-type-alist
                      false-type-alist
                      ttree1)
                    (assume-true-false-rec (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
                      nil
                      force-flg
                      nil
                      type-alist
                      ancestors
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                      pot-lst
                      pt
                      nil
                      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (must-be-true (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (must-be-false (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-empty* (cons-tag-trees ttree1 ttree)))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)
                              force-flg
                              nil
                              true-type-alist
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              (cons-tag-trees ttree1 ttree)
                              pot-lst
                              pt
                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))))
                      (must-be-false (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">3</span>)
                          force-flg
                          nil
                          false-type-alist
                          ancestors
                          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                          (cons-tag-trees ttree1 ttree)
                          pot-lst
                          pt
                          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
                          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)
                            force-flg
                            nil
                            true-type-alist
                            ancestors
                            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                            ttree
                            pot-lst
                            pt
                            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
                            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">3</span>)
                              force-flg
                              nil
                              false-type-alist
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              ttree
                              pot-lst
                              pt
                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (ts-union ts1 ts2) ttree))))))
                  (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist)))
              ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> fn <a class="sym-link system" href="axioms.html#def-_2Aexpandable-boot-strap-non-rec-fns_2A" data-sym="*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*">*expandable-boot-strap-non-rec-fns*</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                  (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="basis-b.html#def-subcor-var" data-sym="SUBCOR-VAR">subcor-var</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> fn <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>) (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x) (<a class="sym-link system" href="axioms.html#def-bbody" data-sym="BBODY">bbody</a> fn))
                    force-flg
                    nil
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    ttree
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                  (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1 extended-p)
                  (type-set-with-rules (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'type-prescriptions nil <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                    x
                    force-flg
                    dwp
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    *ts-unknown*
                    ttree
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                    nil)
                  (declare (ignore extended-p))
                  (<a class="sym-link local-def" href="#def-type-set-finish" data-sym="TYPE-SET-FINISH" title="(defun type-set-finish (x ts0 ttree0 ts1 ttree1 type-alist)
  (mv-let (ts ttree)
          (cond ((null ts0) (mv ts1 ttree1))
                ((ts-subsetp ts1 ts0) (mv ts1 ttree1))
                (t
...">type-set-finish</a> x ts0 ttree0 ts1 ttree1 type-alist)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-lst
    (x force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (car x)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            nil
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (cons (cons ts ttree)
            (type-set-lst (cdr x)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-relieve-hyps-free
    (term typ
      rest-type-alist
      rune
      target
      hyps
      backchain-limit-lst
      force-flg
      dwp
      alist
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      ttree
      ttree0
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      bkptr+1)
    (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> rest-type-alist
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (lookup-hyp-ans alist+ ttree rest-type-alist)
        (<a class="sym-link local-def" href="#def-search-type-alist-with-rest" data-sym="SEARCH-TYPE-ALIST-WITH-REST" title="(defun search-type-alist-with-rest (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist-with-rest</a> term
          typ
          rest-type-alist
          alist
          ttree
          wrld)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lookup-hyp-ans) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))
          ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> rest-type-alist) (type-set-relieve-hyps rune
              target
              (cdr hyps)
              (cdr backchain-limit-lst)
              force-flg
              dwp
              alist+
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld
              ttree
              ttree0
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
              bkptr+1))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (relieve-hyps-ans type-alist ttree)
              (type-set-relieve-hyps rune
                target
                (cdr hyps)
                (cdr backchain-limit-lst)
                force-flg
                dwp
                alist+
                type-alist
                ancestors
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                ttree
                ttree0
                pot-lst
                pt
                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                bkptr+1)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> relieve-hyps-ans type-alist ttree))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (type-set-relieve-hyps-free term
                    typ
                    rest-type-alist
                    rune
                    target
                    hyps
                    backchain-limit-lst
                    force-flg
                    dwp
                    alist
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    ttree
                    ttree0
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                    bkptr+1)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-relieve-hyps1
    (hyp forcep
      rune
      target
      hyps
      backchain-limit-lst
      force-flg
      dwp
      alist
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      ttree
      ttree0
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      bkptr)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
      (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> hyp)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (atm1 quotep-atm1 ttree)
        (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist atm <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (quotep-atm1 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> not-flg (equal atm1 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (type-set-relieve-hyps rune
                  target
                  (cdr hyps)
                  (cdr backchain-limit-lst)
                  force-flg
                  dwp
                  alist
                  type-alist
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  wrld
                  ttree
                  ttree0
                  pot-lst
                  pt
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                  (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (on-ancestorsp assumed-true)
              (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ancestors <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)
                (ancestors-check (if not-flg
                    (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                    atm1)
                  ancestors
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (on-ancestorsp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (assumed-true (type-set-relieve-hyps rune
                        target
                        (cdr hyps)
                        (cdr backchain-limit-lst)
                        force-flg
                        dwp
                        alist
                        type-alist
                        ancestors
                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                        wrld
                        ttree
                        ttree0
                        pot-lst
                        pt
                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                        (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))))
                ((<a class="sym-link local-def" href="#def-backchain-limit-reachedp" data-sym="BACKCHAIN-LIMIT-REACHEDP" title="(defun backchain-limit-reachedp (n ancestors)
  (and n (backchain-limit-reachedp1 n ancestors)))">backchain-limit-reachedp</a> <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> ancestors) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> force-flg forcep)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                          target
                          (if not-flg
                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                            atm1)
                          type-alist
                          nil
                          (<a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car hyps)) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                          force-flg
                          ttree)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (type-set-relieve-hyps rune
                          target
                          (cdr hyps)
                          (cdr backchain-limit-lst)
                          force-flg
                          dwp
                          alist
                          type-alist
                          ancestors
                          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                          wrld
                          ttree
                          ttree0
                          pot-lst
                          pt
                          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                          (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg type-alist ttree2)
                    (<a class="sym-link local-def" href="#def-with-accumulated-persistence" data-sym="WITH-ACCUMULATED-PERSISTENCE" title="(defmacro with-accumulated-persistence
          (rune vars success-p body
           &amp;optional x-info (condition &#39;nil condition-p))
  (flet ((fix-var (var)
           (if (consp var)
...">with-accumulated-persistence</a> rune
                      (flg type-alist ttree2)
                      flg
                      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                        (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> atm1
                          force-flg
                          dwp
                          type-alist
                          (<a class="sym-link local-def" href="#def-push-ancestor" data-sym="PUSH-ANCESTOR" title="(defun push-ancestor (lit tokens ancestors bkptr)
  (let* ((alit lit)
         (alit-atm
          (mv-let (not-flg atm) (strip-not alit) (declare (ignore not-flg))
                  atm)))
...">push-ancestor</a> (if not-flg
                              atm1
                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1))
                            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune)
                            ancestors
                            nil)
                          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                          wrld
                          ttree
                          pot-lst
                          pt
                          (<a class="sym-link local-def" href="#def-new-backchain-limit" data-sym="NEW-BACKCHAIN-LIMIT" title="(defun new-backchain-limit (new-offset old-limit ancestors)
  (cond ((null new-offset) old-limit)
        ((null old-limit) (+ (length ancestors) new-offset))
        (t (min (+ (length ancestors) new-offset) old-limit))))">new-backchain-limit</a> (car backchain-limit-lst)
                            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                            ancestors))
                        (let ((ts (if not-flg
                               (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-nil*) *ts-t*)
                                 ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 *ts-nil*) *ts-boolean*)
                                 (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-nil*))
                               ts1)))
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))
                            ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> *ts-nil* ts) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> force-flg forcep)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                                      target
                                      (if not-flg
                                        (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                                        atm1)
                                      type-alist
                                      nil
                                      (<a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car hyps)) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                                      force-flg
                                      ttree)))
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist ttree))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0)))))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist ttree1)))))
                      bkptr)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (type-set-relieve-hyps rune
                          target
                          (cdr hyps)
                          (cdr backchain-limit-lst)
                          force-flg
                          dwp
                          alist
                          type-alist
                          ancestors
                          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                          wrld
                          ttree2
                          ttree0
                          pot-lst
                          pt
                          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                          (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree2))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-relieve-hyps
    (rune target
      hyps
      backchain-limit-lst
      force-flg
      dwp
      alist
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      ttree
      ttree0
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      bkptr)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyps) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist (cons-tag-trees ttree ttree0)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (forcep bind-flg)
          (<a class="sym-link local-def" href="#def-binding-hyp-p" data-sym="BINDING-HYP-P" title="(defun binding-hyp-p (hyp alist wrld)
  (let* ((forcep
          (and (nvariablep hyp) (not (fquotep hyp))
               (or (eq (ffn-symb hyp) &#39;force)
                   (eq (ffn-symb hyp) &#39;case-split))))
...">binding-hyp-p</a> (car hyps) alist wrld)
          (let ((hyp (if forcep
                 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car hyps) <span class="number">1</span>)
                 (car hyps))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bind-flg (type-set-relieve-hyps rune
                  target
                  (cdr hyps)
                  (cdr backchain-limit-lst)
                  force-flg
                  dwp
                  (cons (cons (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>)) alist)
                  type-alist
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  wrld
                  ttree
                  ttree0
                  pot-lst
                  pt
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                  (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term typ compound-rec-rune?)
                  (<a class="sym-link local-def" href="#def-term-and-typ-to-lookup" data-sym="TERM-AND-TYP-TO-LOOKUP" title="(defun term-and-typ-to-lookup (hyp wrld ens)
  (mv-let (not-flg term) (strip-not hyp)
          (let ((recog-tuple
                 (and (nvariablep term) (not (fquotep term))
                      (not (flambda-applicationp term))
...">term-and-typ-to-lookup</a> hyp wrld <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (lookup-hyp-ans alist+ ttree rest-type-alist)
                    (<a class="sym-link local-def" href="#def-search-type-alist-with-rest" data-sym="SEARCH-TYPE-ALIST-WITH-REST" title="(defun search-type-alist-with-rest (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist-with-rest</a> term
                      typ
                      type-alist
                      alist
                      ttree
                      wrld)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (lookup-hyp-ans (let ((ttree (<a class="sym-link local-def" href="#def-push-lemma_3F" data-sym="PUSH-LEMMA?" title="(defun push-lemma? (rune ttree)
  (if rune
      (push-lemma rune ttree)
      ttree))">push-lemma?</a> compound-rec-rune? ttree)))
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rest-type-alist
                               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist+)))
                               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (oncep-tp rune wrld))) (let ((bkptr+1 (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (relieve-hyps-ans type-alist ttree)
                                  (type-set-relieve-hyps rune
                                    target
                                    (cdr hyps)
                                    (cdr backchain-limit-lst)
                                    force-flg
                                    dwp
                                    alist+
                                    type-alist
                                    ancestors
                                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                    wrld
                                    ttree
                                    ttree0
                                    pot-lst
                                    pt
                                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                    bkptr+1)
                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> relieve-hyps-ans type-alist ttree))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (type-set-relieve-hyps-free term
                                        typ
                                        rest-type-alist
                                        rune
                                        target
                                        hyps
                                        backchain-limit-lst
                                        force-flg
                                        dwp
                                        alist
                                        type-alist
                                        ancestors
                                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                        wrld
                                        ttree
                                        ttree0
                                        pot-lst
                                        pt
                                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                        bkptr+1))))))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (type-set-relieve-hyps rune
                                target
                                (cdr hyps)
                                (cdr backchain-limit-lst)
                                force-flg
                                dwp
                                alist+
                                type-alist
                                ancestors
                                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                wrld
                                ttree
                                ttree0
                                pot-lst
                                pt
                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr))))))
                      ((<a class="sym-link local-def" href="#def-free-varsp" data-sym="FREE-VARSP" title="(mutual-recursion
 (defun free-varsp (term alist)
   (cond ((variablep term) (not (assoc-eq term alist))) ((fquotep term) nil)
         (t (free-varsp-lst (fargs term) alist))))
 (defun free-varsp-lst (args alist)
...">free-varsp</a> hyp alist) (let ((fully-bound-alist (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep force-flg)
                               (<a class="sym-link local-def" href="#def-bind-free-vars-to-unbound-free-vars" data-sym="BIND-FREE-VARS-TO-UNBOUND-FREE-VARS" title="(defun bind-free-vars-to-unbound-free-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (bind-free-vars-to-unbound-free-vars (cdr vars) alist))
        (t
...">bind-free-vars-to-unbound-free-vars</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> hyp) alist)
                               alist)))
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep force-flg)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                                  target
                                  (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> fully-bound-alist hyp)
                                  type-alist
                                  nil
                                  (<a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car hyps)) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                                  force-flg
                                  ttree)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (type-set-relieve-hyps rune
                                  target
                                  (cdr hyps)
                                  (cdr backchain-limit-lst)
                                  force-flg
                                  dwp
                                  fully-bound-alist
                                  type-alist
                                  ancestors
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  wrld
                                  ttree
                                  ttree0
                                  pot-lst
                                  pt
                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                  (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
                          (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> hyp)
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (atm1 quotep-atm1 ttree)
                            (<a class="sym-link local-def" href="#def-sublis-var_21" data-sym="SUBLIS-VAR!" title="(mutual-recursion
 (defun sublis-var! (alist term ens wrld ttree)
   (cond
    ((variablep term)
     (let ((a (assoc-eq term alist)))
...">sublis-var!</a> alist atm <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (quotep-atm1 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> not-flg (equal atm1 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (type-set-relieve-hyps rune
                                      target
                                      (cdr hyps)
                                      (cdr backchain-limit-lst)
                                      force-flg
                                      dwp
                                      alist
                                      type-alist
                                      ancestors
                                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                      wrld
                                      ttree
                                      ttree0
                                      pot-lst
                                      pt
                                      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                      (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (on-ancestorsp assumed-true)
                                  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ancestors <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)
                                    (ancestors-check (if not-flg
                                        (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                                        atm1)
                                      ancestors
                                      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune)))
                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (on-ancestorsp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (assumed-true (type-set-relieve-hyps rune
                                            target
                                            (cdr hyps)
                                            (cdr backchain-limit-lst)
                                            force-flg
                                            dwp
                                            alist
                                            type-alist
                                            ancestors
                                            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                            wrld
                                            ttree
                                            ttree0
                                            pot-lst
                                            pt
                                            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                            (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))))
                                    ((<a class="sym-link local-def" href="#def-backchain-limit-reachedp" data-sym="BACKCHAIN-LIMIT-REACHEDP" title="(defun backchain-limit-reachedp (n ancestors)
  (and n (backchain-limit-reachedp1 n ancestors)))">backchain-limit-reachedp</a> <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> ancestors) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> force-flg forcep)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                                              target
                                              (if not-flg
                                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                                                atm1)
                                              type-alist
                                              nil
                                              (<a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car hyps)) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                                              force-flg
                                              ttree)))
                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (type-set-relieve-hyps rune
                                              target
                                              (cdr hyps)
                                              (cdr backchain-limit-lst)
                                              force-flg
                                              dwp
                                              alist
                                              type-alist
                                              ancestors
                                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                              wrld
                                              ttree
                                              ttree0
                                              pot-lst
                                              pt
                                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                              (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0)))))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg type-alist ttree2)
                                        (<a class="sym-link local-def" href="#def-with-accumulated-persistence" data-sym="WITH-ACCUMULATED-PERSISTENCE" title="(defmacro with-accumulated-persistence
          (rune vars success-p body
           &amp;optional x-info (condition &#39;nil condition-p))
  (flet ((fix-var (var)
           (if (consp var)
...">with-accumulated-persistence</a> rune
                                          (flg type-alist ttree2)
                                          flg
                                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                                            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> atm1
                                              force-flg
                                              dwp
                                              type-alist
                                              (<a class="sym-link local-def" href="#def-push-ancestor" data-sym="PUSH-ANCESTOR" title="(defun push-ancestor (lit tokens ancestors bkptr)
  (let* ((alit lit)
         (alit-atm
          (mv-let (not-flg atm) (strip-not alit) (declare (ignore not-flg))
                  atm)))
...">push-ancestor</a> (if not-flg
                                                  atm1
                                                  (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1))
                                                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune)
                                                ancestors
                                                nil)
                                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                              wrld
                                              ttree
                                              pot-lst
                                              pt
                                              (<a class="sym-link local-def" href="#def-new-backchain-limit" data-sym="NEW-BACKCHAIN-LIMIT" title="(defun new-backchain-limit (new-offset old-limit ancestors)
  (cond ((null new-offset) old-limit)
        ((null old-limit) (+ (length ancestors) new-offset))
        (t (min (+ (length ancestors) new-offset) old-limit))))">new-backchain-limit</a> (car backchain-limit-lst)
                                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                                ancestors))
                                            (let ((ts (if not-flg
                                                   (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-nil*) *ts-t*)
                                                     ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts1 *ts-nil*) *ts-boolean*)
                                                     (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> *ts-nil*))
                                                   ts1)))
                                              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0))
                                                ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> *ts-nil* ts) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> force-flg forcep)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                                                          target
                                                          (if not-flg
                                                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> atm1)
                                                            atm1)
                                                          type-alist
                                                          nil
                                                          (<a class="sym-link local-def" href="#def-immediate-forcep" data-sym="IMMEDIATE-FORCEP" title="(defun immediate-forcep (fn ens)
  (cond ((eq fn &#39;case-split) &#39;case-split)
        ((enabled-numep *immediate-force-modep-xnume* ens) t) (t nil)))">immediate-forcep</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car hyps)) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
                                                          force-flg
                                                          ttree)))
                                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist ttree))
                                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree0)))))
                                                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist ttree1)))))
                                          bkptr)
                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (type-set-relieve-hyps rune
                                              target
                                              (cdr hyps)
                                              (cdr backchain-limit-lst)
                                              force-flg
                                              dwp
                                              alist
                                              type-alist
                                              ancestors
                                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                              wrld
                                              ttree2
                                              ttree0
                                              pot-lst
                                              pt
                                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                                              (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)))
                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist ttree2))))))))))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> extend-type-alist-with-bindings
    (alist force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) type-alist)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-type-alist-with-bindings (cdr alist)
          force-flg
          dwp
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (cdr (car alist)) type-alist) type-alist)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree1)
                (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (cdr (car alist))
                  force-flg
                  dwp
                  type-alist
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                  ttree
                  pot-lst
                  pt
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> (cdr (car alist)) ts ttree1 type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))))
          ancestors
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          ttree
          pot-lst
          pt
          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-with-rule
    (tp term
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      extended-p)
    (declare (ignore dwp))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:nume</span>) <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
          (one-way-unify (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:term</span>) term)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (unify-ans (<a class="sym-link local-def" href="#def-with-accumulated-persistence" data-sym="WITH-ACCUMULATED-PERSISTENCE" title="(defmacro with-accumulated-persistence
          (rune vars success-p body
           &amp;optional x-info (condition &#39;nil condition-p))
  (flet ((fix-var (var)
           (if (consp var)
...">with-accumulated-persistence</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:rune</span>)
                (ts type-alist-out ttree-out extended-p-out)
                (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> *ts-unknown* ts))
                  (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> type-alist type-alist-out)))
                (let ((hyps (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:hyps</span>)))
                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (type-alist extended-p)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyps) extended-p) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> type-alist extended-p))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (extend-type-alist-with-bindings unify-subst
                            force-flg
                            nil
                            type-alist
                            ancestors
                            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                            nil
                            pot-lst
                            pt
                            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (relieve-hyps-ans type-alist ttree)
                      (type-set-relieve-hyps (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:rune</span>)
                        term
                        hyps
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:backchain-limit-lst</span>)
                        force-flg
                        nil
                        unify-subst
                        type-alist
                        ancestors
                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                        nil
                        ttree
                        pot-lst
                        pt
                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                        <span class="number">1</span>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts type-alist ttree)
                            (<a class="sym-link local-def" href="#def-with-accumulated-persistence" data-sym="WITH-ACCUMULATED-PERSISTENCE" title="(defmacro with-accumulated-persistence
          (rune vars success-p body
           &amp;optional x-info (condition &#39;nil condition-p))
  (flet ((fix-var (var)
           (if (consp var)
...">with-accumulated-persistence</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:rune</span>)
                              (ts type-alist-out ttree)
                              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> *ts-unknown* ts))
                                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> type-alist type-alist-out)))
                              (type-set-with-rule1 unify-subst
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:vars</span>)
                                force-flg
                                nil
                                type-alist
                                ancestors
                                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:basic-ts</span>)
                                (push-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription tp <span class="keyword">:rune</span>) ttree)
                                pot-lst
                                pt
                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                              <span class="keyword">:conc</span> hyps)
                            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts type-alist ttree extended-p)))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-unknown* type-alist ttree extended-p))))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-unknown* type-alist ttree nil)))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-unknown* type-alist ttree nil))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-with-rule1
    (alist vars
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      basic-ts
      ttree
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> basic-ts type-alist ttree))
      ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) vars) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (type-set-with-rule1 (cdr alist)
            vars
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            (ts-union ts basic-ts)
            ttree
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (type-set-with-rule1 (cdr alist)
          vars
          force-flg
          dwp
          type-alist
          ancestors
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          basic-ts
          ttree
          pot-lst
          pt
          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-with-rules
    (tp-lst term
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ts
      ttree
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      extended-p)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> tp-lst) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
          (type-set-primitive term
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (let ((ts2 (ts-intersection ts1 ts)))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ts2
              (if (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts)
                ttree
                ttree1)
              extended-p))))
      ((ts-subsetp ts
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription (car tp-lst) <span class="keyword">:basic-ts</span>)) (type-set-with-rules (cdr tp-lst)
          term
          force-flg
          dwp
          type-alist
          ancestors
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          ts
          ttree
          pot-lst
          pt
          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
          extended-p))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 type-alist1 ttree1 extended-p)
          (type-set-with-rule (car tp-lst)
            term
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
            extended-p)
          (let ((ts2 (ts-intersection ts1 ts)))
            (type-set-with-rules (cdr tp-lst)
              term
              force-flg
              dwp
              type-alist1
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ts2
              (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts) (equal type-alist type-alist1))
                ttree
                ttree1)
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
              extended-p))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> type-set-primitive
    (term force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree0
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
      (cons (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-cons" data-sym="TYPE-SET-CONS" title="(defun type-set-cons (ts2 ttree ttree0)
  (let ((ts
         (ts-builder ts2 (*ts-true-list* *ts-proper-cons*)
                     (otherwise *ts-improper-cons*))))
    (cond ((ts= ts *ts-cons*) (mv ts (puffert ttree0)))">type-set-cons</a> ts2 ttree ttree0)))
      (equal (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-t* ttree0))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
              (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                force-flg
                dwp
                type-alist
                ancestors
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                ttree0
                pot-lst
                pt
                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
                (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                  force-flg
                  dwp
                  type-alist
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                  ttree
                  pot-lst
                  pt
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                (<a class="sym-link local-def" href="#def-type-set-equal" data-sym="TYPE-SET-EQUAL" title="(defun type-set-equal (ts1 ts2 ttree ttree0)
  (cond
   ((member ts1 *singleton-type-sets*)
    (cond ((ts= ts1 ts2) (mv *ts-t* (puffert ttree)))
          ((ts-intersectp ts1 ts2) (mv *ts-boolean* (puffert ttree0)))
...">type-set-equal</a> ts1 ts2 ttree ttree0))))))
      (unary-- (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-unary--" data-sym="TYPE-SET-UNARY--" title="(defun type-set-unary-- (ts ttree ttree0)
  (let ((ts1 (numeric-type-set ts)))
    (cond ((ts= ts1 *ts-acl2-number*) (mv *ts-acl2-number* ttree0))
          (t
           (mv
...">type-set-unary--</a> ts1 ttree ttree0)))
      (unary-/ (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-unary-_2F" data-sym="TYPE-SET-UNARY-/" title="(defun type-set-unary-/ (ts ttree ttree0)
  (let* ((ts1 (numeric-type-set ts))
         (ans
          (ts-builder ts1 (*ts-zero* *ts-zero*) (*ts-one* *ts-one*)
                      (*ts-integer&gt;1*
...">type-set-unary-/</a> ts1 ttree ttree0)))
      (denominator (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-denominator" data-sym="TYPE-SET-DENOMINATOR" title="(defun type-set-denominator (ts ttree ttree0)
  (let* ((ts1 (rational-type-set ts))
         (ans
          (ts-builder ts1 (*ts-integer* *ts-one*) (*ts-ratio* *ts-integer&gt;1*))))
    (cond
...">type-set-denominator</a> ts1 ttree ttree0)))
      (numerator (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-numerator" data-sym="TYPE-SET-NUMERATOR" title="(defun type-set-numerator (ts ttree ttree0)
  (let* ((ts1 (rational-type-set ts))
         (ans
          (ts-builder ts1 (*ts-zero* *ts-zero*) (*ts-one* *ts-one*)
                      (*ts-integer&gt;1* *ts-integer&gt;1*)
...">type-set-numerator</a> ts1 ttree ttree0)))
      (car (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-car" data-sym="TYPE-SET-CAR" title="(defun type-set-car (ts ttree ttree0)
  (cond ((ts-intersectp ts *ts-cons*) (mv *ts-unknown* ttree0))
        (t (mv *ts-nil* ttree))))">type-set-car</a> ts1 ttree ttree0)))
      (cdr (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-cdr" data-sym="TYPE-SET-CDR" title="(defun type-set-cdr (ts ttree ttree0)
  (let ((cdr-ts
         (ts-builder ts (*ts-proper-cons* *ts-true-list*)
                     (*ts-improper-cons* (ts-complement *ts-true-list*))
                     (otherwise *ts-nil*))))
...">type-set-cdr</a> ts1 ttree ttree0)))
      (symbol-name (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-string* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (symbol-package-name (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-string* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (intern-in-package-of-symbol (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree2)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree0
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-intern-in-package-of-symbol" data-sym="TYPE-SET-INTERN-IN-PACKAGE-OF-SYMBOL" title="(defun type-set-intern-in-package-of-symbol (ts1 ts2 ttree1 ttree2 ttree0)
  (cond ((ts-disjointp ts1 *ts-string*) (mv *ts-nil* (puffert ttree1)))
        ((ts-disjointp ts2 *ts-symbol*) (mv *ts-nil* (puffert ttree2)))
        (t (mv *ts-symbol* (puffert ttree0)))))">type-set-intern-in-package-of-symbol</a> ts1
              ts2
              ttree1
              ttree2
              ttree0))))
      (pkg-witness (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-symbol* (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree0)))
      (coerce (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree2)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree0
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-coerce" data-sym="TYPE-SET-COERCE" title="(defun type-set-coerce (term ts1 ts2 ttree1 ttree2 ttree0)
  (cond
   ((equal (fargn term 2) &#39;&#39;list)
    (cond
     ((ts-intersectp *ts-string* ts1) (mv *ts-true-list* (puffert ttree0)))
...">type-set-coerce</a> term ts1 ts2 ttree1 ttree2 ttree0))))
      (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-length" data-sym="TYPE-SET-LENGTH" title="(defun type-set-length (ts ttree ttree0)
  (let ((ans
         (ts-builder ts (*ts-string* *ts-non-negative-integer*)
                     (*ts-cons* *ts-positive-integer*) (otherwise *ts-zero*))))
    (cond ((ts= ans *ts-integer*) (mv *ts-integer* (puffert ttree0)))">type-set-length</a> ts1 ttree ttree0)))
      (binary-+ (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-binary-_2B" data-sym="TYPE-SET-BINARY-+" title="(defun type-set-binary-+ (term ts1 ts2 ttree ttree0)
  (let ((arg1 (fargn term 1)) (arg2 (fargn term 2)))
    (cond
     ((or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) (mv *ts-empty* ttree))
     ((and (equal arg2 &#39;&#39;-1) (ts-subsetp ts1 *ts-positive-integer*))
...">type-set-binary-+</a> term ts1 ts2 ttree ttree0))))
      (binary-* (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-binary-_2A" data-sym="TYPE-SET-BINARY-*" title="(defun type-set-binary-* (ts1 ts2 ttree ttree0)
  (cond ((or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) (mv *ts-empty* ttree))
        (t
         (let ((ans
                (aref2 &#39;type-set-binary-*-table *type-set-binary-*-table*
...">type-set-binary-*</a> ts1 ts2 ttree ttree0))))
      (&lt; (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-_3C" data-sym="TYPE-SET-&lt;" title="(defun type-set-&lt; (arg1 arg2 ts1 ts2 type-alist ttree ttree0 pot-lst pt)
  (let* ((nts1 (numeric-type-set ts1)) (nts2 (numeric-type-set ts2)))
    (cond
     ((and (equal arg2 *1*) (ts-subsetp nts1 *ts-integer*))
      (mv-let (ts ttree)
...">type-set-&lt;</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
              (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              ts1
              ts2
              type-alist
              ttree
              ttree0
              pot-lst
              pt))))
      (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-not" data-sym="TYPE-SET-NOT" title="(defun type-set-not (ts ttree ttree0)
  (cond ((ts= ts *ts-nil*) (mv *ts-t* (puffert ttree)))
        ((ts-subsetp *ts-nil* ts) (mv *ts-boolean* ttree0))
        (t (mv *ts-nil* (puffert ttree)))))">type-set-not</a> ts1 ttree ttree0)))
      (realpart (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-realpart" data-sym="TYPE-SET-REALPART" title="(defun type-set-realpart (ts ttree ttree0)
  (cond
   ((ts-intersectp ts *ts-complex-rational*)
    (mv *ts-rational* (puffert ttree0)))
   (t (mv (numeric-type-set ts) (puffert ttree)))))">type-set-realpart</a> ts1 ttree ttree0)))
      (imagpart (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-imagpart" data-sym="TYPE-SET-IMAGPART" title="(defun type-set-imagpart (ts ttree ttree0)
  (cond
   ((ts-subsetp ts *ts-complex-rational*)
    (mv (ts-union *ts-positive-rational* *ts-negative-rational*)
        (puffert ttree)))
...">type-set-imagpart</a> ts1 ttree ttree0)))
      (complex (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-type-set-complex" data-sym="TYPE-SET-COMPLEX" title="(defun type-set-complex (ts1 ts2 ttree ttree0)
  (let ((ts1 (rational-type-set ts1)) (ts2 (rational-type-set ts2)))
    (cond ((ts= ts2 *ts-zero*) (mv ts1 (puffert ttree)))
          ((ts= (ts-intersection ts2 *ts-zero*) *ts-empty*)
           (mv *ts-complex-rational* (puffert ttree)))
...">type-set-complex</a> ts1 ts2 ttree ttree0))))
      (char-code (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            ttree0
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
          (<a class="sym-link local-def" href="#def-type-set-char-code" data-sym="TYPE-SET-CHAR-CODE" title="(defun type-set-char-code (ts ttree ttree0)
  (cond ((ts-disjointp ts *ts-character*) (mv *ts-zero* (puffert ttree)))
        (t (mv *ts-non-negative-integer* (puffert ttree0)))))">type-set-char-code</a> ts1 ttree ttree0)))
      (otherwise (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> *ts-unknown* ttree0))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> assume-true-false-if
    (not-flg x
      xttree
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (let ((test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)) (true-branch (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>))
        (false-branch (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">3</span>)))
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (test-mbt test-mbf test-tta test-fta test-ttree)
        (assume-true-false-rec test
          xttree
          force-flg
          dwp
          type-alist
          ancestors
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          pot-lst
          pt
          nil
          <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (test-mbt (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
              (assume-true-false-rec true-branch
                test-ttree
                force-flg
                dwp
                test-tta
                ancestors
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                pot-lst
                pt
                nil
                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
              (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree nil)))
          (test-mbf (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
              (assume-true-false-rec false-branch
                test-ttree
                force-flg
                dwp
                test-fta
                ancestors
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                pot-lst
                pt
                nil
                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
              (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree nil)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (tb-mbt tb-mbf tb-tta tb-fta tb-ttree)
              (assume-true-false-rec true-branch
                xttree
                force-flg
                dwp
                test-tta
                ancestors
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                pot-lst
                pt
                nil
                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (fb-mbt fb-mbf fb-tta fb-fta fb-ttree)
                (assume-true-false-rec false-branch
                  xttree
                  force-flg
                  dwp
                  test-fta
                  ancestors
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                  pot-lst
                  pt
                  nil
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> tb-mbf fb-mbf) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist xttree x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                              *ts-nil*
                              (cons-tag-trees tb-ttree fb-ttree)
                              type-alist)
                            tb-ttree
                            fb-ttree)))))
                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> tb-mbt fb-mbt) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil xttree x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                              (ts-intersection x-ts *ts-non-nil*)
                              (cons-tag-trees x-ts-ttree
                                (cons-tag-trees tb-ttree fb-ttree))
                              type-alist)
                            nil
                            tb-ttree
                            fb-ttree)))))
                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> tb-mbt fb-mbf) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                      nil
                      nil
                      (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-tta
                        type-alist
                        (cons-tag-trees tb-ttree fb-ttree))
                      (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-fta
                        type-alist
                        (cons-tag-trees tb-ttree fb-ttree))
                      nil
                      nil))
                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> tb-mbf fb-mbt) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                      nil
                      nil
                      (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-tta
                        type-alist
                        (cons-tag-trees tb-ttree fb-ttree))
                      (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-fta
                        type-alist
                        (cons-tag-trees tb-ttree fb-ttree))
                      nil
                      nil))
                  (tb-mbt (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-fta type-alist tb-ttree)
                            xttree
                            x-ts-ttree))
                        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil xttree x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            nil
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                              (ts-intersection x-ts *ts-non-nil*)
                              (cons-tag-trees x-ts-ttree xttree)
                              type-alist)
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-fta type-alist tb-ttree)
                            nil
                            nil)))))
                  (tb-mbf (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist xttree x-ts-ttree))
                        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-tta type-alist tb-ttree)
                            nil
                            xttree
                            x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> fb-tta type-alist tb-ttree)
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x *ts-nil* xttree type-alist)
                            nil
                            nil)))))
                  (fb-mbt (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-fta type-alist fb-ttree)
                            xttree
                            x-ts-ttree))
                        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil xttree x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            nil
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                              (ts-intersection x-ts *ts-non-nil*)
                              (cons-tag-trees x-ts-ttree xttree)
                              type-alist)
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-fta type-alist fb-ttree)
                            nil
                            nil)))))
                  (fb-mbf (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist xttree x-ts-ttree))
                        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-tta type-alist fb-ttree)
                            nil
                            xttree
                            x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            nil
                            (<a class="sym-link local-def" href="#def-infect-new-type-alist-entries" data-sym="INFECT-NEW-TYPE-ALIST-ENTRIES" title="(defun infect-new-type-alist-entries (new-type-alist old-type-alist ttree)
  (if (null ttree)
      new-type-alist
      (infect-new-type-alist-entries1 new-type-alist old-type-alist ttree
                                      (- (length new-type-alist)">infect-new-type-alist-entries</a> tb-tta type-alist fb-ttree)
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x *ts-nil* xttree type-alist)
                            nil
                            nil)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x-ts x-ts-ttree)
                      (<a class="sym-link local-def" href="#def-look-in-type-alist" data-sym="LOOK-IN-TYPE-ALIST" title="(defun look-in-type-alist (term type-alist wrld)
  (mv-let (ts ttree) (assoc-type-alist term type-alist wrld)
          (mv
           (if ts
               ts
...">look-in-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist xttree x-ts-ttree))
                        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> x-ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil xttree x-ts-ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
                            nil
                            nil
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                              (ts-intersection x-ts *ts-non-nil*)
                              (cons-tag-trees x-ts-ttree xttree)
                              type-alist)
                            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x *ts-nil* xttree type-alist)
                            nil
                            nil)))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> assume-true-false-rec
    (x xttree
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      pot-lst
      pt
      ignore0
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (xnot-flg x)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> x) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)))
            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'if)
               (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
               (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">3</span>) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil x))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil x)))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> x) (assume-true-false1 xnot-flg
            x
            xttree
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> x) (if (equal x <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
            (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil xttree)
            (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil nil xttree)))
        ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> x) (assume-true-false1 xnot-flg
            x
            xttree
            force-flg
            dwp
            type-alist
            ancestors
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
            pot-lst
            pt
            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (var strongp true-ts false-ts |RUNE[S]|)
            (<a class="sym-link local-def" href="#def-recognizer-expr-p" data-sym="RECOGNIZER-EXPR-P" title="(defun recognizer-expr-p (x ens w)
  (cond
   ((eq (ffn-symb x) &#39;if)
    (mv-let (var true-ts false-ts runes) (strong-recognizer-expr-p nil x ens w)
            (cond
...">recognizer-expr-p</a> x <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
            (let ((ignore (<a class="sym-link local-def" href="#def-adjust-ignore-for-atf" data-sym="ADJUST-IGNORE-FOR-ATF" title="(defmacro adjust-ignore-for-atf (not-flg ignore)
  `(cond ((and ,not-flg (eq ,ignore :fta)) :tta)
         ((and ,not-flg (eq ,ignore :tta)) :fta) (t ,ignore)))">adjust-ignore-for-atf</a> xnot-flg ignore0)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (var (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (strongp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assoc-type-alist" data-sym="ASSOC-TYPE-ALIST" title="(defun assoc-type-alist (term type-alist wrld)
  (cond
   ((variablep term)
    (let ((temp (assoc-eq term type-alist)))
      (if temp
...">assoc-type-alist</a> x type-alist <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ts (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
                      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ts (<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts *ts-nil*)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts0 arg)
                          (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var <span class="keyword">:one</span>)
                            (<a class="sym-link local-def" href="#def-strengthen-recog-call" data-sym="STRENGTHEN-RECOG-CALL" title="(defun strengthen-recog-call (x)
  (let ((arg (fargn x 1)))
    (case (ffn-symb x)
      (integerp
       (cond
...">strengthen-recog-call</a> x)
                            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil var))
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
                            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> arg
                              force-flg
                              dwp
                              type-alist
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              nil
                              pot-lst
                              pt
                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                            (let ((t-int (ts-intersection ts
                                   (if ts0
                                     (ts-union ts0 true-ts)
                                     true-ts))) (f-int (ts-intersection ts false-ts)))
                              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> t-int *ts-empty*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> f-int *ts-empty*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                        type-alist
                                        type-alist
                                        (<a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a> var
                                          |RUNE[S]|
                                          (if ts0
                                            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)
                                            ttree))
                                        xttree))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                        nil
                                        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                        nil
                                        type-alist
                                        (<a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a> var
                                          |RUNE[S]|
                                          (if ts0
                                            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)
                                            ttree))
                                        xttree))))
                                ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> f-int *ts-empty*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                    nil
                                    type-alist
                                    nil
                                    (<a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a> var |RUNE[S]| ttree)
                                    xttree))
                                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((shared-ttree (<a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a> var
                                         |RUNE[S]|
                                         (if ts0
                                           (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree xttree))
                                           (cons-tag-trees ttree xttree)))))
                                    (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                      nil
                                      nil
                                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                        (let ((type-alist0 (if strongp
                                               type-alist
                                               (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x
                                                 *ts-t*
                                                 (<a class="sym-link local-def" href="#def-push-lemma_5Bs_5D" data-sym="PUSH-LEMMA[S]" title="(defun push-lemma[s] (flg rune[s] ttree)
  (cond ((eq flg :one) (push-lemma rune[s] ttree))
        (t
         (let ((pair (assoc-eq &#39;lemma ttree))
               (runes
...">|PUSH-LEMMA[S]|</a> var |RUNE[S]| xttree)
                                                 type-alist))))
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> t-int ts) type-alist0)
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-with-proper/improper-cons-ts-tuple arg
                                                t-int
                                                shared-ttree
                                                force-flg
                                                dwp
                                                type-alist
                                                ancestors
                                                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                type-alist0
                                                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                pot-lst
                                                pt
                                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))))
                                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                        (let ((type-alist0 (if strongp
                                               type-alist
                                               (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x *ts-nil* xttree type-alist))))
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> f-int ts) type-alist0)
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-with-proper/improper-cons-ts-tuple arg
                                                f-int
                                                shared-ttree
                                                force-flg
                                                dwp
                                                type-alist
                                                ancestors
                                                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                type-alist0
                                                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                pot-lst
                                                pt
                                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))))
                                      nil
                                      nil)))))))))))
                ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) <a class="sym-link system" href="axioms.html#def-_2Aexpandable-boot-strap-non-rec-fns_2A" data-sym="*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*">*expandable-boot-strap-non-rec-fns*</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
                    (assume-true-false-rec (<a class="sym-link system" href="basis-b.html#def-subcor-var" data-sym="SUBCOR-VAR">subcor-var</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                        (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> x)
                        (<a class="sym-link system" href="axioms.html#def-bbody" data-sym="BBODY">bbody</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)))
                      xttree
                      force-flg
                      dwp
                      type-alist
                      ancestors
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                      pot-lst
                      pt
                      ignore
                      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                    (if xnot-flg
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> mbf <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> fta tta ttree)
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree))))
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'equal) (let ((arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)) (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1 arg2) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil nil (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> xttree)))
                      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                          nil
                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                          nil
                          type-alist
                          nil
                          (push-lemma '(<span class="keyword">:executable-counterpart</span> equal) xttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp1 canonicalp1 arg1-canon ttree1)
                          (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> 'equal arg1 type-alist)
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp1 (equal arg1-canon arg2)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                nil
                                type-alist
                                nil
                                nil
                                (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 xttree))))
                            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp1 (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1-canon) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                nil
                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                nil
                                type-alist
                                nil
                                (push-lemma '(<span class="keyword">:executable-counterpart</span> equal)
                                  (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 xttree)))))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp2 canonicalp2 arg2-canon ttree2)
                                (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> 'equal arg2 type-alist)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp2 (equal arg1-canon arg2-canon)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                      nil
                                      type-alist
                                      nil
                                      nil
                                      (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees xttree (cons-tag-trees ttree1 ttree2)))))
                                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp2 (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1-canon) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2-canon)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                      nil
                                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                      nil
                                      type-alist
                                      nil
                                      (push-lemma '(<span class="keyword">:executable-counterpart</span> equal)
                                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees xttree (cons-tag-trees ttree1 ttree2))))))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp-temp (<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a> 'equal arg1-canon arg2-canon type-alist)))
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp-temp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-t*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                  '<a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a>
                                                  <span class="string">"Please send the authors of ACL2 a ~
                                           replayable transcript of this ~
                                           problem if possible, so that they ~
                                           can see what went wrong in the ~
                                           function assume-true-false.  The ~
                                           offending call was ~x0.  The ~
                                           surprising type-set arose from a ~
                                           call of ~x1."</span>
                                                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a>
                                                    (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> x)
                                                    '&lt;xttree&gt;
                                                    force-flg
                                                    (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> type-alist)
                                                    '&lt;ens&gt;
                                                    '&lt;w&gt;)
                                                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a>
                                                    ''equal
                                                    (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg1-canon)
                                                    (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg2-canon)
                                                    '&lt;same_type-alist&gt;))
                                                nil
                                                nil
                                                nil
                                                nil
                                                nil
                                                nil))
                                            ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                nil
                                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                nil
                                                type-alist
                                                nil
                                                (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                  (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp-temp) xttree)
                                                  (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp-temp)
                                                      (cons-tag-trees ttree1 (cons-tag-trees ttree2 xttree)))))))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((erp (<a class="sym-link local-def" href="#def-assume-true-false-error" data-sym="ASSUME-TRUE-FALSE-ERROR" title="(defun assume-true-false-error (type-alist x temp-temp)
  (er hard &#39;assume-true-false-error
      &quot;It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
...">assume-true-false-error</a> type-alist x (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp))))
                                                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp nil nil nil nil)))))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
                                            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> arg1
                                              force-flg
                                              dwp
                                              type-alist
                                              ancestors
                                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                              nil
                                              pot-lst
                                              pt
                                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
                                              (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> arg2
                                                force-flg
                                                dwp
                                                type-alist
                                                ancestors
                                                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                ttree
                                                pot-lst
                                                pt
                                                <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                              (let ((int (ts-intersection ts1 ts2)))
                                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> int *ts-empty*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                      nil
                                                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                      nil
                                                      type-alist
                                                      nil
                                                      (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree xttree))))
                                                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-member" data-sym="MEMBER">member</a> ts1 <a class="sym-link local-def" href="#def-_2Asingleton-type-sets_2A" data-sym="*SINGLETON-TYPE-SETS*" title="(defconst *singleton-type-sets* (list *ts-t* *ts-nil* *ts-zero* *ts-one*))">*singleton-type-sets*</a>)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                      nil
                                                      type-alist
                                                      nil
                                                      nil
                                                      (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree xttree))))
                                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((swap-flg (<a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a> arg1-canon arg2-canon)) (shared-ttree-tta-p (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                            (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 int)) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 int)))))
                                                        (shared-ttree (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (shared-ttree-tta-p (cons-tag-trees ttree xttree))
                                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
                                                        (xttree+ (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                            xttree
                                                            (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 (cons-tag-trees ttree2 xttree)))))
                                                        (true-type-alist1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                            (<a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a> 'equal
                                                              occursp1
                                                              occursp2
                                                              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                              arg1-canon
                                                              arg2-canon
                                                              swap-flg
                                                              x
                                                              *ts-t*
                                                              xttree+
                                                              type-alist)))
                                                        (true-type-alist2 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 int) true-type-alist1)
                                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-with-proper/improper-cons-ts-tuple arg1
                                                                  int
                                                                  shared-ttree
                                                                  force-flg
                                                                  dwp
                                                                  type-alist
                                                                  ancestors
                                                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                                  true-type-alist1
                                                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                                  pot-lst
                                                                  pt
                                                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))))
                                                        (true-type-alist3 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 int) true-type-alist2)
                                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-with-proper/improper-cons-ts-tuple arg2
                                                                  int
                                                                  shared-ttree
                                                                  force-flg
                                                                  dwp
                                                                  type-alist
                                                                  ancestors
                                                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                                  true-type-alist2
                                                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                                  pot-lst
                                                                  pt
                                                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))))
                                                        (false-type-alist1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                            (<a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a> 'equal
                                                              occursp1
                                                              occursp2
                                                              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                              arg1-canon
                                                              arg2-canon
                                                              swap-flg
                                                              x
                                                              *ts-nil*
                                                              xttree+
                                                              type-alist)))
                                                        (false-type-alist2 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-t*)
                                                                 (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-nil*)
                                                                 (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-zero*)
                                                                 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 *ts-one*)
                                                                   (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> arg1) (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> arg1 type-alist)))) (extend-with-proper/improper-cons-ts-tuple arg1
                                                                  (ts-intersection ts1 (ts-complement ts2))
                                                                  (if shared-ttree-tta-p
                                                                    shared-ttree
                                                                    (cons-tag-trees ttree xttree))
                                                                  force-flg
                                                                  dwp
                                                                  type-alist
                                                                  ancestors
                                                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                                  false-type-alist1
                                                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                                  pot-lst
                                                                  pt
                                                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> false-type-alist1))))
                                                        (false-type-alist3 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-t*)
                                                                 (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-nil*)
                                                                 (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-zero*)
                                                                 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 *ts-one*)
                                                                   (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> arg2) (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> arg2 type-alist)))) (extend-with-proper/improper-cons-ts-tuple arg2
                                                                  (ts-intersection ts2 (ts-complement ts1))
                                                                  (if shared-ttree-tta-p
                                                                    shared-ttree
                                                                    (cons-tag-trees ttree xttree))
                                                                  force-flg
                                                                  dwp
                                                                  type-alist
                                                                  ancestors
                                                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                                                  false-type-alist2
                                                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                                                  pot-lst
                                                                  pt
                                                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> false-type-alist2)))))
                                                      (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                        nil
                                                        nil
                                                        true-type-alist3
                                                        false-type-alist3
                                                        nil
                                                        nil))))))))))))))))))))
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) '&lt;) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts0 ttree)
                    (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> x
                      force-flg
                      dwp
                      type-alist
                      ancestors
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                      nil
                      pot-lst
                      pt
                      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts0 *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
                      ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts0 *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
                          (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
                            force-flg
                            dwp
                            type-alist
                            ancestors
                            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                            nil
                            pot-lst
                            pt
                            <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
                            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)
                              force-flg
                              dwp
                              type-alist
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              ttree
                              pot-lst
                              pt
                              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg arg1 arg2 ts1 ts2)
                              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>)
                                   (ts-subsetp ts1
                                     (ts-union (ts-complement *ts-acl2-number*) *ts-integer*))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> xnot-flg) <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) *ts-zero* ts1))
                                ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2A2_2A" data-sym="*2*">*2*</a>)
                                   (ts-subsetp ts1
                                     (ts-union (ts-complement *ts-acl2-number*) *ts-integer*))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> xnot-flg) <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) *ts-one* ts1))
                                ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) <a class="sym-link system" href="axioms.html#def-_2A-1_2A" data-sym="*-1*">*-1*</a>)
                                   (ts-subsetp ts2
                                     (ts-union (ts-complement *ts-acl2-number*) *ts-integer*))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> xnot-flg) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> ts2 *ts-zero*))
                                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> xnot-flg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>) ts1 ts2)))
                              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg arg1 arg2 ts1 ts2 ttree)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>)
                                     (ts-subsetp ts2 *ts-integer*)
                                     (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg2 'binary-+)
                                     (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg2 <span class="number">1</span>) <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (tsx ttree)
                                      (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg2 <span class="number">2</span>)
                                        force-flg
                                        dwp
                                        type-alist
                                        ancestors
                                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                        ttree
                                        pot-lst
                                        pt
                                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg2 <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> tsx *ts-zero* ttree)))
                                  ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg2 <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>)
                                     (ts-subsetp ts1 *ts-integer*)
                                     (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> arg1 'binary-+)
                                     (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg1 <span class="number">1</span>) <a class="sym-link system" href="axioms.html#def-_2A-1_2A" data-sym="*-1*">*-1*</a>)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (tsx ttree)
                                      (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg1 <span class="number">2</span>)
                                        force-flg
                                        dwp
                                        type-alist
                                        ancestors
                                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                        ttree
                                        pot-lst
                                        pt
                                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg) <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> arg1 <span class="number">2</span>) *ts-zero* tsx ttree)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> not-flg arg1 arg2 ts1 ts2 ttree)))
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1 <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts2 *ts-positive-rational*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
                                      ((ts-subsetp ts2
                                         (ts-union (ts-complement *ts-acl2-number*)
                                           *ts-non-positive-rational*)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((shared-ttree (cons-tag-trees ttree xttree)) (ignore (<a class="sym-link local-def" href="#def-adjust-ignore-for-atf" data-sym="ADJUST-IGNORE-FOR-ATF" title="(defmacro adjust-ignore-for-atf (not-flg ignore)
  `(cond ((and ,not-flg (eq ,ignore :fta)) :tta)
         ((and ,not-flg (eq ,ignore :tta)) :fta) (t ,ignore)))">adjust-ignore-for-atf</a> not-flg ignore0))
                                            (true-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                (let ((ts (ts-intersection ts2
                                                       (ts-union *ts-positive-rational* *ts-complex-rational*))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts) type-alist)
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
                                                        (the-type-set ts)
                                                        shared-ttree
                                                        type-alist
                                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))))))
                                            (false-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                (let ((ts (ts-intersection ts2 (ts-complement *ts-positive-rational*))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts) type-alist)
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
                                                        (the-type-set ts)
                                                        shared-ttree
                                                        type-alist
                                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))))))
                                          (<a class="sym-link local-def" href="#def-mv-atf-2" data-sym="MV-ATF-2" title="(defun mv-atf-2
       (not-flg true-type-alist false-type-alist new-term xnot-flg x
        shared-ttree xttree ignore)
  (let ((tta0
         (and (not (eq ignore :tta))
...">mv-atf-2</a> not-flg
                                            true-type-alist
                                            false-type-alist
                                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '&lt; <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> arg2)
                                            xnot-flg
                                            x
                                            shared-ttree
                                            xttree
                                            ignore)))))
                                  ((equal arg1 <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts2 *ts-integer&gt;1*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
                                      ((ts-subsetp ts2
                                         (ts-union (ts-complement *ts-acl2-number*)
                                           *ts-one*
                                           *ts-non-positive-rational*)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((shared-ttree (cons-tag-trees ttree xttree)) (ignore (<a class="sym-link local-def" href="#def-adjust-ignore-for-atf" data-sym="ADJUST-IGNORE-FOR-ATF" title="(defmacro adjust-ignore-for-atf (not-flg ignore)
  `(cond ((and ,not-flg (eq ,ignore :fta)) :tta)
         ((and ,not-flg (eq ,ignore :tta)) :fta) (t ,ignore)))">adjust-ignore-for-atf</a> not-flg ignore0))
                                            (true-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                (let ((ts (ts-intersection ts2
                                                       (ts-union *ts-integer&gt;1*
                                                         *ts-positive-ratio*
                                                         *ts-complex-rational*))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts) type-alist)
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
                                                        (the-type-set ts)
                                                        shared-ttree
                                                        type-alist
                                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))))))
                                            (false-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> arg2) (let ((ts (ts-intersection ts2 (ts-complement *ts-integer&gt;1*))))
                                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 ts) type-alist)
                                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg2
                                                            (the-type-set ts)
                                                            shared-ttree
                                                            type-alist
                                                            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))))
                                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist)))))
                                          (<a class="sym-link local-def" href="#def-mv-atf-2" data-sym="MV-ATF-2" title="(defun mv-atf-2
       (not-flg true-type-alist false-type-alist new-term xnot-flg x
        shared-ttree xttree ignore)
  (let ((tta0
         (and (not (eq ignore :tta))
...">mv-atf-2</a> not-flg
                                            true-type-alist
                                            false-type-alist
                                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '&lt; <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a> arg2)
                                            xnot-flg
                                            x
                                            shared-ttree
                                            xttree
                                            ignore)))))
                                  ((equal arg2 <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts1 *ts-negative-rational*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
                                      ((ts-subsetp ts1
                                         (ts-union (ts-complement *ts-acl2-number*)
                                           *ts-non-negative-rational*)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((shared-ttree (cons-tag-trees ttree xttree)) (ignore (<a class="sym-link local-def" href="#def-adjust-ignore-for-atf" data-sym="ADJUST-IGNORE-FOR-ATF" title="(defmacro adjust-ignore-for-atf (not-flg ignore)
  `(cond ((and ,not-flg (eq ,ignore :fta)) :tta)
         ((and ,not-flg (eq ,ignore :tta)) :fta) (t ,ignore)))">adjust-ignore-for-atf</a> not-flg ignore0))
                                            (true-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                (let ((ts (ts-intersection ts1
                                                       (ts-union *ts-negative-rational* *ts-complex-rational*))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 ts) type-alist)
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg1
                                                        (the-type-set ts)
                                                        shared-ttree
                                                        type-alist
                                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))))))
                                            (false-type-alist (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                (let ((ts (ts-intersection ts1 (ts-complement *ts-negative-rational*))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 ts) type-alist)
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> arg1
                                                        (the-type-set ts)
                                                        shared-ttree
                                                        type-alist
                                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))))))
                                          (<a class="sym-link local-def" href="#def-mv-atf-2" data-sym="MV-ATF-2" title="(defun mv-atf-2
       (not-flg true-type-alist false-type-alist new-term xnot-flg x
        shared-ttree xttree ignore)
  (let ((tta0
         (and (not (eq ignore :tta))
...">mv-atf-2</a> not-flg
                                            true-type-alist
                                            false-type-alist
                                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '&lt; arg1 <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>)
                                            xnot-flg
                                            x
                                            shared-ttree
                                            xttree
                                            ignore)))))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta dttree)
                                      (assume-true-false1 xnot-flg
                                        x
                                        xttree
                                        force-flg
                                        dwp
                                        type-alist
                                        ancestors
                                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                        pot-lst
                                        pt
                                        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta dttree))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((tta (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore0 <span class="keyword">:tta</span>))
                                                 (<a class="sym-link local-def" href="#def-assume-true-false-_3C" data-sym="ASSUME-TRUE-FALSE-&lt;" title="(defun assume-true-false-&lt;
       (not-flg arg1 arg2 ts1 ts2 type-alist ttree xttree w)
  (cond
   ((not not-flg)
    (let ((strongp
...">assume-true-false-&lt;</a> not-flg
                                                   arg1
                                                   arg2
                                                   ts1
                                                   ts2
                                                   tta
                                                   ttree
                                                   xttree
                                                   <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))) (fta (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore0 <span class="keyword">:fta</span>))
                                                  (<a class="sym-link local-def" href="#def-assume-true-false-_3C" data-sym="ASSUME-TRUE-FALSE-&lt;" title="(defun assume-true-false-&lt;
       (not-flg arg1 arg2 ts1 ts2 type-alist ttree xttree w)
  (cond
   ((not not-flg)
    (let ((strongp
...">assume-true-false-&lt;</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg)
                                                    arg1
                                                    arg2
                                                    ts1
                                                    ts2
                                                    fta
                                                    ttree
                                                    xttree
                                                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))))
                                            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil tta fta nil)))))))))))))))
                ((<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>) (let ((arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)) (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">2</span>)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1 arg2) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil nil (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> xttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((equiv (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x)))
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp1 canonicalp1 arg1-canon ttree1)
                            (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg1 type-alist)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp1 (equal arg1-canon arg2)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                  nil
                                  type-alist
                                  nil
                                  nil
                                  (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 xttree))))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (occursp2 canonicalp2 arg2-canon ttree2)
                                  (<a class="sym-link local-def" href="#def-canonical-representative" data-sym="CANONICAL-REPRESENTATIVE" title="(defun canonical-representative (equiv term type-alist)
  (declare (xargs :guard (symbolp equiv)))
  (cond ((null type-alist) (mv nil t term nil))
        (t
         (let ((first-term (caar type-alist)) (ts (cadar type-alist)))
...">canonical-representative</a> equiv arg2 type-alist)
                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> occursp2 (equal arg1-canon arg2-canon)) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                        nil
                                        type-alist
                                        nil
                                        nil
                                        (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees xttree (cons-tag-trees ttree1 ttree2)))))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp-temp (<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a> equiv arg1-canon arg2-canon type-alist)))
                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp-temp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-t*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                    '<a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a>
                                                    <span class="string">"Please send the authors of ~
                                               ACL2 a replayable transcript ~
                                               of this problem if possible, ~
                                               so that they can see what went ~
                                               wrong in the function ~
                                               assume-true-false.  The ~
                                               offending call was ~x0.  The ~
                                               surprising type-set arose from ~
                                               a call of ~x1."</span>
                                                    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a>
                                                      (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> x)
                                                      '&lt;xttree&gt;
                                                      force-flg
                                                      (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> type-alist)
                                                      '&lt;ens&gt;
                                                      '&lt;w&gt;)
                                                    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-assoc-equiv" data-sym="ASSOC-EQUIV" title="(defun assoc-equiv (fn arg1 arg2 alist)
  (cond ((eq alist nil) nil)
        ((and (ffn-symb-p (caar alist) fn)
              (if (equal (fargn (caar alist) 2) arg2)
                  (equal (fargn (caar alist) 1) arg1)
...">assoc-equiv</a>
                                                      (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> equiv)
                                                      (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg1-canon)
                                                      (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> arg2-canon)
                                                      '&lt;same_type-alist&gt;))
                                                  nil
                                                  nil
                                                  nil
                                                  nil
                                                  nil
                                                  nil))
                                              ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp) *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                  nil
                                                  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                  nil
                                                  type-alist
                                                  nil
                                                  (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                    (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp-temp) xttree)
                                                    (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> temp-temp)
                                                        (cons-tag-trees ttree1 (cons-tag-trees ttree2 xttree)))))))
                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((erp (<a class="sym-link local-def" href="#def-assume-true-false-error" data-sym="ASSUME-TRUE-FALSE-ERROR" title="(defun assume-true-false-error (type-alist x temp-temp)
  (er hard &#39;assume-true-false-error
      &quot;It was thought impossible for an equivalence relation, e.g., ~x0, ~
    to have anything besides a non-empty proper subset of ~
    *ts-boolean* on the type-alist!  But in the type-alist ~x1 the ~
...">assume-true-false-error</a> type-alist x (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp-temp))))
                                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp nil nil nil nil)))))
                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((swap-flg (<a class="sym-link local-def" href="#def-term-order" data-sym="TERM-ORDER" title="(defun term-order (term1 term2)
  (declare (xargs :guard (and (pseudo-termp term1) (pseudo-termp term2))))
  (term-order1 term1 term2 nil))">term-order</a> arg1-canon arg2-canon)) (xttree+ (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                    xttree
                                                    (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree1 (cons-tag-trees ttree2 xttree))))))
                                              (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg
                                                nil
                                                nil
                                                (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:tta</span>))
                                                  (<a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a> equiv
                                                    occursp1
                                                    occursp2
                                                    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                    arg1-canon
                                                    arg2-canon
                                                    swap-flg
                                                    x
                                                    *ts-t*
                                                    xttree+
                                                    type-alist))
                                                (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore <span class="keyword">:fta</span>))
                                                  (<a class="sym-link local-def" href="#def-extend-type-alist1" data-sym="EXTEND-TYPE-ALIST1" title="(defun extend-type-alist1
       (equiv occursp1 occursp2 both-canonicalp arg1-canon arg2-canon swap-flg
        term ts ttree type-alist)
  (cons
   (cond ((and (not swap-flg) both-canonicalp) (list* term ts ttree))
...">extend-type-alist1</a> equiv
                                                    occursp1
                                                    occursp2
                                                    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> canonicalp1 canonicalp2)
                                                    arg1-canon
                                                    arg2-canon
                                                    swap-flg
                                                    x
                                                    *ts-nil*
                                                    xttree+
                                                    type-alist))
                                                nil
                                                nil))))))))))))))))
                ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'car) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'cdr)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
                    (assume-true-false1 xnot-flg
                      x
                      xttree
                      force-flg
                      dwp
                      type-alist
                      ancestors
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                      pot-lst
                      pt
                      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((tta (if xnot-flg
                               fta
                               tta)) (fta (if xnot-flg
                                tta
                                fta)))
                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (mbt1 mbf tta1 fta1 ttree)
                            (assume-true-false-rec (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> x <span class="number">1</span>)
                              xttree
                              force-flg
                              dwp
                              tta
                              ancestors
                              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                              pot-lst
                              pt
                              <span class="keyword">:fta</span> <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                            (declare (ignore mbt1 fta1))
                            (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> xnot-flg <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta1 fta ttree nil)))))))
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> x) 'if) (assume-true-false-if xnot-flg
                    x
                    xttree
                    force-flg
                    dwp
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (assume-true-false1 xnot-flg
                    x
                    xttree
                    force-flg
                    dwp
                    type-alist
                    ancestors
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    pot-lst
                    pt
                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> assume-true-false1
    (not-flg x
      xttree
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
      (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> x
        force-flg
        dwp
        type-alist
        ancestors
        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
        nil
        pot-lst
        pt
        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist ttree xttree))
        ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts *ts-nil*) (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil type-alist nil ttree xttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-mv-atf" data-sym="MV-ATF" title="(defun mv-atf (not-flg mbt mbf tta fta ttree1 ttree2)
  (if not-flg
      (mv mbf mbt fta tta
          (if (or mbt mbf)
              (cons-tag-trees ttree1 ttree2)
...">mv-atf</a> not-flg
            nil
            nil
            (extend-with-proper/improper-cons-ts-tuple x
              (ts-intersection ts *ts-non-nil*)
              (cons-tag-trees ttree xttree)
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              type-alist
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link local-def" href="#def-extend-type-alist-simple" data-sym="EXTEND-TYPE-ALIST-SIMPLE" title="(defun extend-type-alist-simple (term ts ttree type-alist)
  (cond ((ts= ts *ts-unknown*) type-alist)
        ((variablep term) (cons (list* term ts ttree) type-alist))
        ((fquotep term) type-alist)
        (t (cons (list* term ts ttree) type-alist))))">extend-type-alist-simple</a> x *ts-nil* xttree type-alist)
            nil
            nil)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> proper/improper-cons-ts-tuple
    (term ts
      ttree
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'cons)
         (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-proper-cons*) (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-improper-cons*))) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((x (<a class="sym-link local-def" href="#def-non-cons-cdr" data-sym="NON-CONS-CDR" title="(defun non-cons-cdr (term)
  (cond ((variablep term) term) ((fquotep term) term)
        ((eq (ffn-symb term) &#39;cons) (non-cons-cdr (fargn term 2))) (t term)))">non-cons-cdr</a> term)))
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (tsx ttreex)
            (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> x
              force-flg
              dwp
              type-alist
              ancestors
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld
              ttree
              pot-lst
              pt
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-proper-cons*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> x (ts-intersection tsx *ts-true-list*) ttreex))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> x
                  (ts-intersection tsx (ts-complement *ts-true-list*))
                  ttreex))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ts ttree))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> extend-with-proper/improper-cons-ts-tuple
    (term ts
      ttree
      force-flg
      dwp
      type-alist
      ancestors
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      type-alist-to-be-extended
      wrld
      pot-lst
      pt
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term ts ttree)
      (proper/improper-cons-ts-tuple term
        ts
        ttree
        force-flg
        dwp
        type-alist
        ancestors
        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
        wrld
        pot-lst
        pt
        <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
      (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> term
        ts
        ttree
        type-alist-to-be-extended
        wrld))))</pre>
  </div>

<div class="form-block function" id="def-type-set" data-defines="TYPE-SET" data-references="BACKCHAIN-LIMIT,TYPE-SET-REC,GET-DWP,LET,PT,POT-LST,TTREE,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,X,DEFUN" data-used-by="DTS,NOT-IDENT,TS-BOOLEANP,KNOWN-WHETHER-NIL,RECONSIDER-TYPE-ALIST,TYPE-ALIST-EQUALITY-LOOP1,ADD-LINEAR-ASSUMPTION" data-part-name="TYPE-SET" data-part-args="PT,POT-LST,TTREE,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,X" data-part-body="BACKCHAIN-LIMIT,PT,POT-LST,TTREE,ENS,TYPE-ALIST,FORCE-FLG,X,TYPE-SET-REC,W,GET-DWP,DWP,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET">type-set</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a>
  (x force-flg dwp type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> ttree pot-lst pt)
  (let ((dwp (<a class="sym-link system" href="axioms.html#def-get-dwp" data-sym="GET-DWP">get-dwp</a> dwp <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
    (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> x
      force-flg
      dwp
      type-alist
      nil
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree
      pot-lst
      pt
      (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <span class="keyword">:ts</span>))))</pre>
  </div>

<div class="form-block function" id="def-type-set-bc" data-defines="TYPE-SET-BC" data-references="TYPE-SET-REC,GET-DWP,LET,TS-BACKCHAIN-LIMIT,PT,POT-LST,TTREE,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,X,DEFUN" data-used-by="NORMALIZE,NORMALIZE-WITH-TYPE-SET" data-part-name="TYPE-SET-BC" data-part-args="TS-BACKCHAIN-LIMIT,PT,POT-LST,TTREE,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,X" data-part-body="TS-BACKCHAIN-LIMIT,PT,POT-LST,TTREE,ENS,TYPE-ALIST,FORCE-FLG,X,TYPE-SET-REC,W,GET-DWP,DWP,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-SET-BC">type-set-bc</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-set-bc" data-sym="TYPE-SET-BC" title="(defun type-set-bc
       (x force-flg dwp type-alist ens w ttree pot-lst pt ts-backchain-limit)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  ts-backchain-limit)))">type-set-bc</a>
  (x force-flg
    dwp
    type-alist
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
    ttree
    pot-lst
    pt
    ts-backchain-limit)
  (let ((dwp (<a class="sym-link system" href="axioms.html#def-get-dwp" data-sym="GET-DWP">get-dwp</a> dwp <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
    (<a class="sym-link local-def" href="#def-type-set-rec" data-sym="TYPE-SET-REC" title="(mutual-recursion
 (defun type-set-rec
        (x force-flg dwp type-alist ancestors ens w ttree pot-lst pt
         backchain-limit)
   (mv-let (ts0 ttree0)
...">type-set-rec</a> x
      force-flg
      dwp
      type-alist
      nil
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      ttree
      pot-lst
      pt
      ts-backchain-limit)))</pre>
  </div>

<div class="form-block other" id="form-257" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> assume-true-false-aggressive-p nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-258" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> assume-true-false-aggressive-p
  <a class="sym-link system" href="axioms.html#def-constant-nil-function-arity-0" data-sym="CONSTANT-NIL-FUNCTION-ARITY-0">constant-nil-function-arity-0</a>)</pre>
  </div>

<div class="form-block function" id="def-top-level-if-reduce-rec" data-defines="TOP-LEVEL-IF-REDUCE-REC" data-references="FCONS-TERM*,*TS-NIL*,TS-COMPLEMENT,TS=,*NIL*,*T*,OR,FBR,CHANGEDP-FBR,TBR,CHANGEDP-TBR,MV-LET,NOT,AND,T,MV,FARGN,EQUAL,IF,QUOTE,FFN-SYMB-P,COND,TS,NOT-FLG,TERM,TEST,DEFUN" data-used-by="TOP-LEVEL-IF-REDUCE" data-part-name="TOP-LEVEL-IF-REDUCE-REC" data-part-args="TS,NOT-FLG,TERM,TEST" data-part-body="FCONS-TERM*,*TS-NIL*,TS-COMPLEMENT,TS=,*NIL*,*T*,OR,FBR,CHANGEDP-FBR,TS,TOP-LEVEL-IF-REDUCE-REC,TBR,CHANGEDP-TBR,MV-LET,NOT,AND,NOT-FLG,T,MV,FARGN,TEST,EQUAL,IF,QUOTE,TERM,FFN-SYMB-P,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOP-LEVEL-IF-REDUCE-REC">top-level-if-reduce-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-top-level-if-reduce-rec" data-sym="TOP-LEVEL-IF-REDUCE-REC" title="(defun top-level-if-reduce-rec (test term not-flg ts)
  (cond
   ((ffn-symb-p term &#39;if)
    (cond
     ((equal test (fargn term 1))
...">top-level-if-reduce-rec</a>
  (test term not-flg ts)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'if) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            (if not-flg
              (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)
              (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))))
        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
           (equal test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) <span class="number">1</span>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            (if not-flg
              (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
              (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp-tbr tbr)
            (<a class="sym-link local-def" href="#def-top-level-if-reduce-rec" data-sym="TOP-LEVEL-IF-REDUCE-REC" title="(defun top-level-if-reduce-rec (test term not-flg ts)
  (cond
   ((ffn-symb-p term &#39;if)
    (cond
     ((equal test (fargn term 1))
...">top-level-if-reduce-rec</a> test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) not-flg ts)
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp-fbr fbr)
              (<a class="sym-link local-def" href="#def-top-level-if-reduce-rec" data-sym="TOP-LEVEL-IF-REDUCE-REC" title="(defun top-level-if-reduce-rec (test term not-flg ts)
  (cond
   ((ffn-symb-p term &#39;if)
    (cond
     ((equal test (fargn term 1))
...">top-level-if-reduce-rec</a> test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>) not-flg ts)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> changedp-tbr changedp-fbr) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal tbr fbr) tbr)
                      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal tbr <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                         (equal fbr <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                         (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts (ts-complement *ts-nil*))) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal tbr <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                         (equal fbr <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                         (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                         (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) <span class="number">1</span>))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> 'if (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) tbr fbr)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil term))))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil term))))</pre>
  </div>

<div class="form-block function" id="def-top-level-if-reduce" data-defines="TOP-LEVEL-IF-REDUCE" data-references="IGNORE,DECLARE,TOP-LEVEL-IF-REDUCE-REC,VAL,CHANGEDP,MV-LET,TS,NOT-FLG,TERM,TEST,DEFUN" data-used-by="ASSUME-TRUE-FALSE-AGGRESSIVE-1" data-part-name="TOP-LEVEL-IF-REDUCE" data-part-args="TS,NOT-FLG,TERM,TEST" data-part-body="IGNORE,DECLARE,TS,NOT-FLG,TERM,TEST,TOP-LEVEL-IF-REDUCE-REC,VAL,CHANGEDP,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOP-LEVEL-IF-REDUCE">top-level-if-reduce</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-top-level-if-reduce" data-sym="TOP-LEVEL-IF-REDUCE" title="(defun top-level-if-reduce (test term not-flg ts)
  (mv-let (changedp val) (top-level-if-reduce-rec test term not-flg ts)
          (declare (ignore changedp)) val))">top-level-if-reduce</a>
  (test term not-flg ts)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp val)
    (<a class="sym-link local-def" href="#def-top-level-if-reduce-rec" data-sym="TOP-LEVEL-IF-REDUCE-REC" title="(defun top-level-if-reduce-rec (test term not-flg ts)
  (cond
   ((ffn-symb-p term &#39;if)
    (cond
     ((equal test (fargn term 1))
...">top-level-if-reduce-rec</a> test term not-flg ts)
    (declare (ignore changedp))
    val))</pre>
  </div>

<div class="form-block function" id="def-top-level-if-p" data-defines="TOP-LEVEL-IF-P" data-references="T,NOT,AND,FARGN,EQUAL,OR,IF,QUOTE,FFN-SYMB-P,COND,TERM,TEST,DEFUN" data-used-by="TYPE-ALIST-REDUCIBLE-ENTRIES" data-part-name="TOP-LEVEL-IF-P" data-part-args="TERM,TEST" data-part-body="T,TOP-LEVEL-IF-P,NOT,AND,FARGN,TEST,EQUAL,OR,IF,QUOTE,TERM,FFN-SYMB-P,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOP-LEVEL-IF-P">top-level-if-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-top-level-if-p" data-sym="TOP-LEVEL-IF-P" title="(defun top-level-if-p (test term)
  (cond
   ((ffn-symb-p term &#39;if)
    (or (equal test (fargn term 1))
        (and (ffn-symb-p (fargn term 1) &#39;not)
...">top-level-if-p</a>
  (test term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'if) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (equal test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
          (equal test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) <span class="number">1</span>)))
        (<a class="sym-link local-def" href="#def-top-level-if-p" data-sym="TOP-LEVEL-IF-P" title="(defun top-level-if-p (test term)
  (cond
   ((ffn-symb-p term &#39;if)
    (or (equal test (fargn term 1))
        (and (ffn-symb-p (fargn term 1) &#39;not)
...">top-level-if-p</a> test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
        (<a class="sym-link local-def" href="#def-top-level-if-p" data-sym="TOP-LEVEL-IF-P" title="(defun top-level-if-p (test term)
  (cond
   ((ffn-symb-p term &#39;if)
    (or (equal test (fargn term 1))
        (and (ffn-symb-p (fargn term 1) &#39;not)
...">top-level-if-p</a> test (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-type-alist-reducible-entries" data-defines="TYPE-ALIST-REDUCIBLE-ENTRIES" data-references="CONS,TOP-LEVEL-IF-P,TERM2,CAR,ENTRY,1-,BOUND-1,CDR,REST-TYPE-ALIST,LET*,T,ZP,AND,ENDP,OR,COND,BOUND,TYPE-ALIST,TERM,DEFUN" data-used-by="ASSUME-TRUE-FALSE-AGGRESSIVE" data-part-name="TYPE-ALIST-REDUCIBLE-ENTRIES" data-part-args="BOUND,TYPE-ALIST,TERM" data-part-body="TYPE-ALIST-REDUCIBLE-ENTRIES,CONS,TERM,TOP-LEVEL-IF-P,TERM2,CAR,ENTRY,1-,BOUND-1,CDR,REST-TYPE-ALIST,LET*,T,ZP,BOUND,AND,TYPE-ALIST,ENDP,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-REDUCIBLE-ENTRIES">type-alist-reducible-entries</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-reducible-entries" data-sym="TYPE-ALIST-REDUCIBLE-ENTRIES" title="(defun type-alist-reducible-entries (term type-alist bound)
  (cond ((or (endp type-alist) (and bound (zp bound))) nil)
        (t
         (let* ((rest-type-alist (cdr type-alist))
                (bound-1 (and bound (1- bound)))
...">type-alist-reducible-entries</a>
  (term type-alist bound)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> type-alist) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> bound (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> bound))) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rest-type-alist (cdr type-alist)) (bound-1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> bound (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> bound)))
          (entry (car type-alist))
          (term2 (car entry)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-top-level-if-p" data-sym="TOP-LEVEL-IF-P" title="(defun top-level-if-p (test term)
  (cond
   ((ffn-symb-p term &#39;if)
    (or (equal test (fargn term 1))
        (and (ffn-symb-p (fargn term 1) &#39;not)
...">top-level-if-p</a> term term2) (cons entry
              (<a class="sym-link local-def" href="#def-type-alist-reducible-entries" data-sym="TYPE-ALIST-REDUCIBLE-ENTRIES" title="(defun type-alist-reducible-entries (term type-alist bound)
  (cond ((or (endp type-alist) (and bound (zp bound))) nil)
        (t
         (let* ((rest-type-alist (cdr type-alist))
                (bound-1 (and bound (1- bound)))
...">type-alist-reducible-entries</a> term rest-type-alist bound-1)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-alist-reducible-entries" data-sym="TYPE-ALIST-REDUCIBLE-ENTRIES" title="(defun type-alist-reducible-entries (term type-alist bound)
  (cond ((or (endp type-alist) (and bound (zp bound))) nil)
        (t
         (let* ((rest-type-alist (cdr type-alist))
                (bound-1 (and bound (1- bound)))
...">type-alist-reducible-entries</a> term rest-type-alist bound-1)))))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false-aggressive-1" data-defines="ASSUME-TRUE-FALSE-AGGRESSIVE-1" data-references="CDR,NOT,NEW-FTA,TOP-LEVEL-IF-REDUCE,EXTEND-TYPE-ALIST,EQ,IF,NEW-TTA,CDDR,CONS-TAG-TREES,NEW-TTREE,CADR,TS,TERM,CAR,ENTRY,LET*,T,MV,ENDP,COND,NOT-FLG,IGNORE0,WRLD,XTTREE,X,FTA,TTA,ENTRIES,DEFUN" data-used-by="ASSUME-TRUE-FALSE-AGGRESSIVE" data-part-name="ASSUME-TRUE-FALSE-AGGRESSIVE-1" data-part-args="NOT-FLG,IGNORE0,WRLD,XTTREE,X,FTA,TTA,ENTRIES" data-part-body="CDR,ASSUME-TRUE-FALSE-AGGRESSIVE-1,NOT,NEW-FTA,WRLD,NOT-FLG,X,TOP-LEVEL-IF-REDUCE,EXTEND-TYPE-ALIST,IGNORE0,EQ,IF,NEW-TTA,CDDR,XTTREE,CONS-TAG-TREES,NEW-TTREE,CADR,TS,TERM,CAR,ENTRY,LET*,T,FTA,TTA,MV,ENTRIES,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE-1">assume-true-false-aggressive-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false-aggressive-1" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE-1" title="(defun assume-true-false-aggressive-1
       (entries tta fta x xttree wrld ignore0 not-flg)
  (cond ((endp entries) (mv nil nil tta fta nil))
        (t
         (let* ((entry (car entries))
...">assume-true-false-aggressive-1</a>
  (entries tta fta x xttree wrld ignore0 not-flg)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> entries) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil tta fta nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((entry (car entries)) (term (car entry))
          (ts (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> entry))
          (new-ttree (cons-tag-trees xttree (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> entry)))
          (new-tta (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore0 <span class="keyword">:tta</span>)
              tta
              (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> (<a class="sym-link local-def" href="#def-top-level-if-reduce" data-sym="TOP-LEVEL-IF-REDUCE" title="(defun top-level-if-reduce (test term not-flg ts)
  (mv-let (changedp val) (top-level-if-reduce-rec test term not-flg ts)
          (declare (ignore changedp)) val))">top-level-if-reduce</a> x term not-flg ts)
                ts
                new-ttree
                tta
                wrld)))
          (new-fta (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ignore0 <span class="keyword">:fta</span>)
              fta
              (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> (<a class="sym-link local-def" href="#def-top-level-if-reduce" data-sym="TOP-LEVEL-IF-REDUCE" title="(defun top-level-if-reduce (test term not-flg ts)
  (mv-let (changedp val) (top-level-if-reduce-rec test term not-flg ts)
          (declare (ignore changedp)) val))">top-level-if-reduce</a> x term (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg) ts)
                ts
                new-ttree
                fta
                wrld))))
        (<a class="sym-link local-def" href="#def-assume-true-false-aggressive-1" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE-1" title="(defun assume-true-false-aggressive-1
       (entries tta fta x xttree wrld ignore0 not-flg)
  (cond ((endp entries) (mv nil nil tta fta nil))
        (t
         (let* ((entry (car entries))
...">assume-true-false-aggressive-1</a> (cdr entries)
          new-tta
          new-fta
          x
          xttree
          wrld
          ignore0
          not-flg)))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false-aggressive" data-defines="ASSUME-TRUE-FALSE-AGGRESSIVE" data-references="SET-DIFFERENCE-EQUAL,ASSUME-TRUE-FALSE-AGGRESSIVE-1,NATP,AND,TYPE-ALIST-REDUCIBLE-ENTRIES,ENTRIES,LET,STRIP-NOT,ATM,NOT-FLG,T,MV,OR,COND,ASSUME-TRUE-FALSE-REC,TTREE,FTA,TTA,MBF,MBT,MV-LET,BOUND,TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X,DEFUN" data-used-by="ASSUME-TRUE-FALSE-BC,ASSUME-TRUE-FALSE" data-part-name="ASSUME-TRUE-FALSE-AGGRESSIVE" data-part-args="BOUND,TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X" data-part-body="SET-DIFFERENCE-EQUAL,ASSUME-TRUE-FALSE-AGGRESSIVE-1,BOUND,NATP,AND,TYPE-ALIST-REDUCIBLE-ENTRIES,ENTRIES,LET,STRIP-NOT,ATM,NOT-FLG,T,MV,OR,COND,TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X,ASSUME-TRUE-FALSE-REC,TTREE,FTA,TTA,MBF,MBT,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE">assume-true-false-aggressive</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false-aggressive" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE" title="(defun assume-true-false-aggressive
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit bound)
  (mv-let (mbt mbf tta fta ttree)
          (assume-true-false-rec x xttree force-flg dwp type-alist nil ens w
...">assume-true-false-aggressive</a>
  (x xttree
    force-flg
    dwp
    type-alist
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
    pot-lst
    pt
    ignore0
    ts-backchain-limit
    bound)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
    (assume-true-false-rec x
      xttree
      force-flg
      dwp
      type-alist
      nil
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
      pot-lst
      pt
      ignore0
      ts-backchain-limit)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
          (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> x)
          (let ((entries (<a class="sym-link local-def" href="#def-type-alist-reducible-entries" data-sym="TYPE-ALIST-REDUCIBLE-ENTRIES" title="(defun type-alist-reducible-entries (term type-alist bound)
  (cond ((or (endp type-alist) (and bound (zp bound))) nil)
        (t
         (let* ((rest-type-alist (cdr type-alist))
                (bound-1 (and bound (1- bound)))
...">type-alist-reducible-entries</a> atm
                 type-alist
                 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> bound) bound))))
            (<a class="sym-link local-def" href="#def-assume-true-false-aggressive-1" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE-1" title="(defun assume-true-false-aggressive-1
       (entries tta fta x xttree wrld ignore0 not-flg)
  (cond ((endp entries) (mv nil nil tta fta nil))
        (t
         (let* ((entry (car entries))
...">assume-true-false-aggressive-1</a> entries
              (<a class="sym-link system" href="axioms.html#def-set-difference-equal" data-sym="SET-DIFFERENCE-EQUAL">set-difference-equal</a> tta entries)
              (<a class="sym-link system" href="axioms.html#def-set-difference-equal" data-sym="SET-DIFFERENCE-EQUAL">set-difference-equal</a> fta entries)
              atm
              xttree
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              ignore0
              not-flg)))))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false" data-defines="ASSUME-TRUE-FALSE" data-references="ASSUME-TRUE-FALSE-REC,T,BACKCHAIN-LIMIT,ASSUME-TRUE-FALSE-AGGRESSIVE,COND,GET-DWP,ASSUME-TRUE-FALSE-AGGRESSIVE-P,BOUND,LET,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X,DEFUN" data-used-by="TYPE-ALIST-CLAUSE-FINISH1,TYPE-SET-REC" data-part-name="ASSUME-TRUE-FALSE" data-part-args="IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X" data-part-body="ASSUME-TRUE-FALSE-REC,T,BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,ENS,TYPE-ALIST,FORCE-FLG,XTTREE,X,ASSUME-TRUE-FALSE-AGGRESSIVE,COND,W,GET-DWP,DWP,ASSUME-TRUE-FALSE-AGGRESSIVE-P,BOUND,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE">assume-true-false</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a>
  (x xttree force-flg dwp type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (<a class="sym-link system" href="axioms.html#def-get-dwp" data-sym="GET-DWP">get-dwp</a> dwp <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bound (<a class="sym-link local-def" href="#def-assume-true-false-aggressive" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE" title="(defun assume-true-false-aggressive
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit bound)
  (mv-let (mbt mbf tta fta ttree)
          (assume-true-false-rec x xttree force-flg dwp type-alist nil ens w
...">assume-true-false-aggressive</a> x
          xttree
          force-flg
          dwp
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          pot-lst
          pt
          ignore0
          (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <span class="keyword">:ts</span>)
          bound))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (assume-true-false-rec x
          xttree
          force-flg
          dwp
          type-alist
          nil
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          pot-lst
          pt
          ignore0
          (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <span class="keyword">:ts</span>))))))</pre>
  </div>

<div class="form-block function" id="def-assume-true-false-bc" data-defines="ASSUME-TRUE-FALSE-BC" data-references="ASSUME-TRUE-FALSE-REC,T,ASSUME-TRUE-FALSE-AGGRESSIVE,COND,GET-DWP,ASSUME-TRUE-FALSE-AGGRESSIVE-P,BOUND,LET,TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X,DEFUN" data-used-by="NORMALIZE" data-part-name="ASSUME-TRUE-FALSE-BC" data-part-args="TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,W,ENS,TYPE-ALIST,DWP,FORCE-FLG,XTTREE,X" data-part-body="ASSUME-TRUE-FALSE-REC,T,TS-BACKCHAIN-LIMIT,IGNORE0,PT,POT-LST,ENS,TYPE-ALIST,FORCE-FLG,XTTREE,X,ASSUME-TRUE-FALSE-AGGRESSIVE,COND,W,GET-DWP,DWP,ASSUME-TRUE-FALSE-AGGRESSIVE-P,BOUND,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSUME-TRUE-FALSE-BC">assume-true-false-bc</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assume-true-false-bc" data-sym="ASSUME-TRUE-FALSE-BC" title="(defun assume-true-false-bc
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
...">assume-true-false-bc</a>
  (x xttree
    force-flg
    dwp
    type-alist
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
    pot-lst
    pt
    ignore0
    ts-backchain-limit)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (<a class="sym-link system" href="axioms.html#def-get-dwp" data-sym="GET-DWP">get-dwp</a> dwp <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bound (<a class="sym-link local-def" href="#def-assume-true-false-aggressive" data-sym="ASSUME-TRUE-FALSE-AGGRESSIVE" title="(defun assume-true-false-aggressive
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit bound)
  (mv-let (mbt mbf tta fta ttree)
          (assume-true-false-rec x xttree force-flg dwp type-alist nil ens w
...">assume-true-false-aggressive</a> x
          xttree
          force-flg
          dwp
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          pot-lst
          pt
          ignore0
          ts-backchain-limit
          bound))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (assume-true-false-rec x
          xttree
          force-flg
          dwp
          type-alist
          nil
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          pot-lst
          pt
          ignore0
          ts-backchain-limit)))))</pre>
  </div>

<div class="form-block function" id="def-ok-to-force-ens" data-defines="OK-TO-FORCE-ENS" data-references="T,*FORCE-XNUME*,ENABLED-NUMEP,AND,ENS,DEFUN" data-part-name="OK-TO-FORCE-ENS" data-part-args="ENS" data-part-body="T,ENS,*FORCE-XNUME*,ENABLED-NUMEP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="OK-TO-FORCE-ENS">ok-to-force-ens</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ok-to-force-ens" data-sym="OK-TO-FORCE-ENS" title="(defun ok-to-force-ens (ens) (and (enabled-numep *force-xnume* ens) t))">ok-to-force-ens</a>
  (<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-enabled-numep" data-sym="ENABLED-NUMEP" title="(defun enabled-numep (nume ens)
  (declare (type (or null (unsigned-byte 60)) nume)
           (xargs :guard (enabled-structure-p ens)))
  (cond ((null nume) t)
        ((&gt; nume
...">enabled-numep</a> <a class="sym-link system" href="axioms.html#def-_2Aforce-xnume_2A" data-sym="*FORCE-XNUME*">*force-xnume*</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))</pre>
  </div>

<div class="form-block function" id="def-add-linear-assumption" data-defines="ADD-LINEAR-ASSUMPTION" data-references="EQUAL,QUOTE,FORCE-ASSUMPTION,NOT,FORCED,T,TS-DISJOINTP,CONS-TAG-TREES,MV,*TS-NIL*,TS=,COND,TYPE-SET,TTREE,TS,MV-LET,TAG-TREE,WRLD,FORCE-FLG,IMMEDIATEP,ENS,TYPE-ALIST,TERM,TARGET,DEFUN" data-part-name="ADD-LINEAR-ASSUMPTION" data-part-args="TAG-TREE,WRLD,FORCE-FLG,IMMEDIATEP,ENS,TYPE-ALIST,TERM,TARGET" data-part-body="IMMEDIATEP,TARGET,EQUAL,QUOTE,FORCE-ASSUMPTION,NOT,FORCED,T,TS-DISJOINTP,TAG-TREE,CONS-TAG-TREES,MV,*TS-NIL*,TS=,COND,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TERM,TYPE-SET,TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-LINEAR-ASSUMPTION">add-linear-assumption</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-linear-assumption" data-sym="ADD-LINEAR-ASSUMPTION" title="(defun add-linear-assumption
       (target term type-alist ens immediatep force-flg wrld tag-tree)
  (mv-let (ts ttree)
          (type-set term force-flg nil type-alist ens wrld nil nil nil)
          (cond
...">add-linear-assumption</a>
  (target term
    type-alist
    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
    immediatep
    force-flg
    wrld
    tag-tree)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
    (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> term
      force-flg
      nil
      type-alist
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      nil
      nil
      nil)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:known-false</span> (cons-tag-trees ttree tag-tree)))
      ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:known-true</span> (cons-tag-trees ttree tag-tree)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (forced tag-tree)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> force-flg) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil tag-tree))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption 'equal
                target
                term
                type-alist
                nil
                immediatep
                force-flg
                tag-tree)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> forced) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:failed</span> tag-tree))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:added</span> tag-tree))))))))</pre>
  </div>

<div class="form-block function" id="def-return-type-alist" data-defines="RETURN-TYPE-ALIST" data-references="CONS-TAG-TREES,T,CDDR,EXTEND-TYPE-ALIST,TS=,COND,CADR,TS-INTERSECTION,INT,*TS-UNKNOWN*,OR,LET*,CAR,ASSOC-TYPE-ALIST,TTREE,TS,MV-LET,IF,WRLD,ORIGINAL-TYPE-ALIST,REST-TYPE-ALIST,CAR-TYPE-ALIST,HITP,DEFUN" data-used-by="TYPE-ALIST-EQUALITY-LOOP1" data-part-name="RETURN-TYPE-ALIST" data-part-args="WRLD,ORIGINAL-TYPE-ALIST,REST-TYPE-ALIST,CAR-TYPE-ALIST,HITP" data-part-body="ORIGINAL-TYPE-ALIST,CONS-TAG-TREES,T,CDDR,EXTEND-TYPE-ALIST,TS=,COND,CADR,TS-INTERSECTION,INT,*TS-UNKNOWN*,OR,LET*,WRLD,REST-TYPE-ALIST,CAR-TYPE-ALIST,CAR,ASSOC-TYPE-ALIST,TTREE,TS,MV-LET,HITP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RETURN-TYPE-ALIST">return-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-return-type-alist" data-sym="RETURN-TYPE-ALIST" title="(defun return-type-alist
       (hitp car-type-alist rest-type-alist original-type-alist wrld)
  (if hitp
      (mv-let (ts ttree)
              (assoc-type-alist (car car-type-alist) rest-type-alist wrld)
...">return-type-alist</a>
  (<a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> car-type-alist
    rest-type-alist
    original-type-alist
    wrld)
  (if <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
      (<a class="sym-link local-def" href="#def-assoc-type-alist" data-sym="ASSOC-TYPE-ALIST" title="(defun assoc-type-alist (term type-alist wrld)
  (cond
   ((variablep term)
    (let ((temp (assoc-eq term type-alist)))
      (if temp
...">assoc-type-alist</a> (car car-type-alist) rest-type-alist wrld)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ts (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> ts *ts-unknown*)) (int (ts-intersection ts (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> car-type-alist))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> int ts) rest-type-alist)
          ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> int (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> car-type-alist)) (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> (car car-type-alist)
              (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> car-type-alist)
              (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> car-type-alist)
              rest-type-alist
              wrld))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-type-alist" data-sym="EXTEND-TYPE-ALIST" title="(defun extend-type-alist (term ts ttree type-alist wrld)
  (declare (xargs :guard (and (pseudo-termp term) (not (quotep term)))))
  (cond
   ((and (nvariablep term) (not (fquotep term))
         (equivalence-relationp (ffn-symb term) wrld))
...">extend-type-alist</a> (car car-type-alist)
              int
              (cons-tag-trees ttree (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> car-type-alist))
              rest-type-alist
              wrld)))))
    original-type-alist))</pre>
  </div>

<div class="form-block function" id="def-type-alist-equality-loop1" data-defines="TYPE-ALIST-EQUALITY-LOOP1" data-references="EXTEND-WITH-PROPER/IMPROPER-CONS-TS-TUPLE,BACKCHAIN-LIMIT,CONS-TAG-TREES,SHARED-TTREE,CAR,RETURN-TYPE-ALIST,PUFFERT,*TS-EMPTY*,TS-INTERSECTION,INT,TS2,TYPE-SET,TTREE,TS1,CDDAR,TTREE0,ARG2,FARGN,ARG1,LET,*TS-T*,CADAR,TS=,EQUAL,CAAR,FFN-SYMB-P,AND,CONTRADICTION,QUOTE,EQ,CDR,REST-TTREE,REST-TYPE-ALIST,HITP,MV-LET,T,MV,NULL,COND,W,ENS,TOP-LEVEL-TYPE-ALIST,TYPE-ALIST,DEFUN" data-used-by="TYPE-ALIST-EQUALITY-LOOP" data-part-name="TYPE-ALIST-EQUALITY-LOOP1" data-part-args="W,ENS,TOP-LEVEL-TYPE-ALIST,TYPE-ALIST" data-part-body="EXTEND-WITH-PROPER/IMPROPER-CONS-TS-TUPLE,BACKCHAIN-LIMIT,CONS-TAG-TREES,SHARED-TTREE,CAR,RETURN-TYPE-ALIST,PUFFERT,*TS-EMPTY*,TS-INTERSECTION,INT,TS2,TYPE-SET,TTREE,TS1,CDDAR,TTREE0,ARG2,FARGN,ARG1,LET,*TS-T*,CADAR,TS=,EQUAL,CAAR,FFN-SYMB-P,AND,CONTRADICTION,QUOTE,EQ,W,ENS,TOP-LEVEL-TYPE-ALIST,CDR,TYPE-ALIST-EQUALITY-LOOP1,REST-TTREE,REST-TYPE-ALIST,HITP,MV-LET,T,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-EQUALITY-LOOP1">type-alist-equality-loop1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-equality-loop1" data-sym="TYPE-ALIST-EQUALITY-LOOP1" title="(defun type-alist-equality-loop1 (type-alist top-level-type-alist ens w)
  (cond ((null type-alist) (mv nil nil nil))
        (t
         (mv-let (hitp rest-type-alist rest-ttree)
                 (type-alist-equality-loop1 (cdr type-alist)
...">type-alist-equality-loop1</a>
  (type-alist top-level-type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> rest-type-alist rest-ttree)
        (<a class="sym-link local-def" href="#def-type-alist-equality-loop1" data-sym="TYPE-ALIST-EQUALITY-LOOP1" title="(defun type-alist-equality-loop1 (type-alist top-level-type-alist ens w)
  (cond ((null type-alist) (mv nil nil nil))
        (t
         (mv-let (hitp rest-type-alist rest-ttree)
                 (type-alist-equality-loop1 (cdr type-alist)
...">type-alist-equality-loop1</a> (cdr type-alist)
          top-level-type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> 'contradiction) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> rest-type-alist rest-ttree))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist) 'equal)
             (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist) *ts-t*)) (let ((arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist) <span class="number">1</span>)) (arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist) <span class="number">2</span>))
                (ttree0 (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> type-alist)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
                (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> arg1
                  nil
                  nil
                  top-level-type-alist
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                  nil
                  nil
                  nil)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
                  (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> arg2
                    nil
                    nil
                    top-level-type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                    ttree
                    nil
                    nil)
                  (let ((int (ts-intersection ts1 ts2)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> int *ts-empty*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> 'contradiction nil (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> ttree)))
                      ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
                          (<a class="sym-link local-def" href="#def-return-type-alist" data-sym="RETURN-TYPE-ALIST" title="(defun return-type-alist
       (hitp car-type-alist rest-type-alist original-type-alist wrld)
  (if hitp
      (mv-let (ts ttree)
              (assoc-type-alist (car car-type-alist) rest-type-alist wrld)
...">return-type-alist</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
                            (car type-alist)
                            rest-type-alist
                            type-alist
                            <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
                          nil))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                          (let ((shared-ttree (<a class="sym-link local-def" href="#def-puffert" data-sym="PUFFERT" title="(defun puffert (ttree) (push-lemma *fake-rune-for-type-set* ttree))">puffert</a> (cons-tag-trees ttree0 ttree))) (type-alist (<a class="sym-link local-def" href="#def-return-type-alist" data-sym="RETURN-TYPE-ALIST" title="(defun return-type-alist
       (hitp car-type-alist rest-type-alist original-type-alist wrld)
  (if hitp
      (mv-let (ts ttree)
              (assoc-type-alist (car car-type-alist) rest-type-alist wrld)
...">return-type-alist</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
                                  (car type-alist)
                                  rest-type-alist
                                  type-alist
                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>))
                              (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> <span class="keyword">:ts</span>)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 int) (extend-with-proper/improper-cons-ts-tuple arg2
                                  int
                                  shared-ttree
                                  nil
                                  nil
                                  top-level-type-alist
                                  nil
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  type-alist
                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                  nil
                                  nil
                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                              ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts2 int) (extend-with-proper/improper-cons-ts-tuple arg1
                                  int
                                  shared-ttree
                                  nil
                                  nil
                                  top-level-type-alist
                                  nil
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  type-alist
                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                  nil
                                  nil
                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-with-proper/improper-cons-ts-tuple arg2
                                  int
                                  shared-ttree
                                  nil
                                  nil
                                  top-level-type-alist
                                  nil
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  (extend-with-proper/improper-cons-ts-tuple arg1
                                    int
                                    shared-ttree
                                    nil
                                    nil
                                    top-level-type-alist
                                    nil
                                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                    type-alist
                                    <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                    nil
                                    nil
                                    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>)
                                  <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
                                  nil
                                  nil
                                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>))))
                          nil))))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
              (<a class="sym-link local-def" href="#def-return-type-alist" data-sym="RETURN-TYPE-ALIST" title="(defun return-type-alist
       (hitp car-type-alist rest-type-alist original-type-alist wrld)
  (if hitp
      (mv-let (ts ttree)
              (assoc-type-alist (car car-type-alist) rest-type-alist wrld)
...">return-type-alist</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>
                (car type-alist)
                rest-type-alist
                type-alist
                <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
              nil)))))))</pre>
  </div>

<div class="form-block function" id="def-clean-up-alist" data-defines="CLEAN-UP-ALIST" data-references="CAR,CONS,T,CDR,CAAR,ASSOC-EQUAL,NULL,COND,ANS,ALIST,DEFUN" data-part-name="CLEAN-UP-ALIST" data-part-args="ANS,ALIST" data-part-body="CAR,CONS,T,CDR,CLEAN-UP-ALIST,CAAR,ASSOC-EQUAL,ANS,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CLEAN-UP-ALIST">clean-up-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-clean-up-alist" data-sym="CLEAN-UP-ALIST" title="(defun clean-up-alist (alist ans)
  (cond ((null alist) ans)
        ((assoc-equal (caar alist) ans) (clean-up-alist (cdr alist) ans))
        (t (clean-up-alist (cdr alist) (cons (car alist) ans)))))">clean-up-alist</a>
  (alist ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) ans)
    ((<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) ans) (<a class="sym-link local-def" href="#def-clean-up-alist" data-sym="CLEAN-UP-ALIST" title="(defun clean-up-alist (alist ans)
  (cond ((null alist) ans)
        ((assoc-equal (caar alist) ans) (clean-up-alist (cdr alist) ans))
        (t (clean-up-alist (cdr alist) (cons (car alist) ans)))))">clean-up-alist</a> (cdr alist) ans))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-clean-up-alist" data-sym="CLEAN-UP-ALIST" title="(defun clean-up-alist (alist ans)
  (cond ((null alist) ans)
        ((assoc-equal (caar alist) ans) (clean-up-alist (cdr alist) ans))
        (t (clean-up-alist (cdr alist) (cons (car alist) ans)))))">clean-up-alist</a> (cdr alist) (cons (car alist) ans)))))</pre>
  </div>

<div class="form-block function" id="def-duplicate-keysp" data-defines="DUPLICATE-KEYSP" data-references="T,CAR,CDR,CAAR,ASSOC-EQUAL,NULL,COND,ALIST,DEFUN" data-part-name="DUPLICATE-KEYSP" data-part-args="ALIST" data-part-body="DUPLICATE-KEYSP,T,CAR,CDR,CAAR,ASSOC-EQUAL,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICATE-KEYSP">duplicate-keysp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicate-keysp" data-sym="DUPLICATE-KEYSP" title="(defun duplicate-keysp (alist)
  (cond ((null alist) nil) ((assoc-equal (caar alist) (cdr alist)) (car alist))
        (t (duplicate-keysp (cdr alist)))))">duplicate-keysp</a>
  (alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) nil)
    ((<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) (cdr alist)) (car alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicate-keysp" data-sym="DUPLICATE-KEYSP" title="(defun duplicate-keysp (alist)
  (cond ((null alist) nil) ((assoc-equal (caar alist) (cdr alist)) (car alist))
        (t (duplicate-keysp (cdr alist)))))">duplicate-keysp</a> (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-clean-type-alist" data-defines="CLEAN-TYPE-ALIST" data-references="TYPE-ALIST,DEFUN" data-used-by="TYPE-ALIST-EQUALITY-LOOP" data-part-name="CLEAN-TYPE-ALIST" data-part-args="TYPE-ALIST" data-part-body="TYPE-ALIST" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CLEAN-TYPE-ALIST">clean-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-clean-type-alist" data-sym="CLEAN-TYPE-ALIST" title="(defun clean-type-alist (type-alist) type-alist)">clean-type-alist</a> (type-alist) type-alist)</pre>
  </div>

<div class="form-block function" id="def-type-alist-equality-loop-exit" data-defines="TYPE-ALIST-EQUALITY-LOOP-EXIT" data-references="QUOTE,HARD,ER,TYPE-ALIST,DEFUN" data-used-by="TYPE-ALIST-EQUALITY-LOOP" data-part-name="TYPE-ALIST-EQUALITY-LOOP-EXIT" data-part-args="TYPE-ALIST" data-part-body="TYPE-ALIST,TYPE-ALIST-EQUALITY-LOOP-EXIT,QUOTE,HARD,ER" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-EQUALITY-LOOP-EXIT">type-alist-equality-loop-exit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-equality-loop-exit" data-sym="TYPE-ALIST-EQUALITY-LOOP-EXIT" title="(defun type-alist-equality-loop-exit (type-alist)
  (er hard &#39;type-alist-equality-loop-exit
      &quot;We&#39;re apparently in an infinite type-alist-equality-loop!  The ~
       offending type-alist is:~%~x0&quot;
      type-alist))">type-alist-equality-loop-exit</a>
  (type-alist)
  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
    '<a class="sym-link local-def" href="#def-type-alist-equality-loop-exit" data-sym="TYPE-ALIST-EQUALITY-LOOP-EXIT" title="(defun type-alist-equality-loop-exit (type-alist)
  (er hard &#39;type-alist-equality-loop-exit
      &quot;We&#39;re apparently in an infinite type-alist-equality-loop!  The ~
       offending type-alist is:~%~x0&quot;
      type-alist))">type-alist-equality-loop-exit</a>
    <span class="string">"We&#39;re apparently in an infinite type-alist-equality-loop!  The ~
       offending type-alist is:~%~x0"</span>
    type-alist))</pre>
  </div>

<div class="form-block constant" id="def-_2Atype-alist-equality-loop-max-depth_2A" data-defines="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*" data-references="DEFCONST" data-used-by="TYPE-ALIST-CLAUSE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*">*type-alist-equality-loop-max-depth*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Atype-alist-equality-loop-max-depth_2A" data-sym="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*" title="(defconst *type-alist-equality-loop-max-depth* 10)">*type-alist-equality-loop-max-depth*</a> <span class="number">10</span>)</pre>
  </div>

<div class="form-block function" id="def-type-alist-equality-loop" data-defines="TYPE-ALIST-EQUALITY-LOOP" data-references="1-,TYPE-ALIST-EQUALITY-LOOP-EXIT,EQUAL,NOT,OR,IF,=,T,MV,CONTRADICTION,QUOTE,EQ,COND,TYPE-ALIST-EQUALITY-LOOP1,TTREE,HITP,MV-LET,CLEAN-TYPE-ALIST,TYPE-ALIST,LET,N,W,ENS,TYPE-ALIST0,DEFUN" data-used-by="TYPE-ALIST-CLAUSE" data-part-name="TYPE-ALIST-EQUALITY-LOOP" data-part-args="N,W,ENS,TYPE-ALIST0" data-part-body="1-,TYPE-ALIST-EQUALITY-LOOP,TYPE-ALIST-EQUALITY-LOOP-EXIT,EQUAL,NOT,OR,IF,N,=,T,MV,CONTRADICTION,QUOTE,EQ,COND,W,ENS,TYPE-ALIST-EQUALITY-LOOP1,TTREE,HITP,MV-LET,TYPE-ALIST0,CLEAN-TYPE-ALIST,TYPE-ALIST,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-EQUALITY-LOOP">type-alist-equality-loop</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-equality-loop" data-sym="TYPE-ALIST-EQUALITY-LOOP" title="(defun type-alist-equality-loop (type-alist0 ens w n)
  (let ((type-alist (clean-type-alist type-alist0)))
    (mv-let (hitp type-alist ttree)
            (type-alist-equality-loop1 type-alist type-alist ens w)
            (cond ((eq hitp &#39;contradiction) (mv t nil ttree))
...">type-alist-equality-loop</a>
  (type-alist0 <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> n)
  (let ((type-alist (<a class="sym-link local-def" href="#def-clean-type-alist" data-sym="CLEAN-TYPE-ALIST" title="(defun clean-type-alist (type-alist) type-alist)">clean-type-alist</a> type-alist0)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> type-alist ttree)
      (<a class="sym-link local-def" href="#def-type-alist-equality-loop1" data-sym="TYPE-ALIST-EQUALITY-LOOP1" title="(defun type-alist-equality-loop1 (type-alist top-level-type-alist ens w)
  (cond ((null type-alist) (mv nil nil nil))
        (t
         (mv-let (hitp rest-type-alist rest-ttree)
                 (type-alist-equality-loop1 (cdr type-alist)
...">type-alist-equality-loop1</a> type-alist type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> 'contradiction) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil ttree))
        ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>) (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a>) (equal type-alist type-alist0))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist nil)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link local-def" href="#def-type-alist-equality-loop-exit" data-sym="TYPE-ALIST-EQUALITY-LOOP-EXIT" title="(defun type-alist-equality-loop-exit (type-alist)
  (er hard &#39;type-alist-equality-loop-exit
      &quot;We&#39;re apparently in an infinite type-alist-equality-loop!  The ~
       offending type-alist is:~%~x0&quot;
      type-alist))">type-alist-equality-loop-exit</a> type-alist) nil)))
        (<a class="sym-link system" href="history-management.html#def-hitp" data-sym="HITP">hitp</a> (<a class="sym-link local-def" href="#def-type-alist-equality-loop" data-sym="TYPE-ALIST-EQUALITY-LOOP" title="(defun type-alist-equality-loop (type-alist0 ens w n)
  (let ((type-alist (clean-type-alist type-alist0)))
    (mv-let (hitp type-alist ttree)
            (type-alist-equality-loop1 type-alist type-alist ens w)
            (cond ((eq hitp &#39;contradiction) (mv t nil ttree))
...">type-alist-equality-loop</a> type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist nil))))))</pre>
  </div>

<div class="form-block function" id="def-put-assoc-equal-ts" data-defines="PUT-ASSOC-EQUAL-TS" data-references="CAR,CDR,CONS,T,TS=,CADAR,TS-INTERSECTION,TS1,LET,CAAR,EQUAL,LIST*,LIST,ENDP,COND,ALISTP,XARGS,DECLARE,TYPE-ALIST,TTREE,TS,TERM,DEFUN" data-used-by="RECONSIDER-TYPE-ALIST" data-part-name="PUT-ASSOC-EQUAL-TS" data-part-args="TYPE-ALIST,TTREE,TS,TERM" data-part-declare="TYPE-ALIST,ALISTP,XARGS,DECLARE" data-part-body="PUT-ASSOC-EQUAL-TS,CAR,CDR,CONS,T,TS=,CADAR,TS-INTERSECTION,TS1,LET,CAAR,EQUAL,TTREE,TS,TERM,LIST*,LIST,TYPE-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-ASSOC-EQUAL-TS">put-assoc-equal-ts</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-assoc-equal-ts" data-sym="PUT-ASSOC-EQUAL-TS" title="(defun put-assoc-equal-ts (term ts ttree type-alist)
  (declare (xargs :guard (alistp type-alist)))
  (cond ((endp type-alist) (list (list* term ts ttree)))
        ((equal term (caar type-alist))
         (let ((ts1 (ts-intersection ts (cadar type-alist))))
...">put-assoc-equal-ts</a>
  (term ts ttree type-alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> type-alist)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> type-alist) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> term ts ttree)))
    ((equal term (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)) (let ((ts1 (ts-intersection ts (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts1 (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist)) type-alist)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> term ts ttree) (cdr type-alist))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car type-alist)
        (<a class="sym-link local-def" href="#def-put-assoc-equal-ts" data-sym="PUT-ASSOC-EQUAL-TS" title="(defun put-assoc-equal-ts (term ts ttree type-alist)
  (declare (xargs :guard (alistp type-alist)))
  (cond ((endp type-alist) (list (list* term ts ttree)))
        ((equal term (caar type-alist))
         (let ((ts1 (ts-intersection ts (cadar type-alist))))
...">put-assoc-equal-ts</a> term ts ttree (cdr type-alist))))))</pre>
  </div>

<div class="form-block function" id="def-reconsider-type-alist" data-defines="RECONSIDER-TYPE-ALIST" data-references="PUT-ASSOC-EQUAL-TS,CADAR,TS-SUBSETP,*TS-EMPTY*,TS=,CDAR,CONS,TYPE-SET,TTREE,TS,MV-LET,T,CDR,IF,QUOTE,CAAR,FFN-SYMB-P,MV,NULL,COND,PT,POT-LST,W,ENS,FORCE-FLG,XTYPE-ALIST,TYPE-ALIST,DEFUN" data-used-by="TYPE-ALIST-CLAUSE-FINISH" data-part-name="RECONSIDER-TYPE-ALIST" data-part-args="PT,POT-LST,W,ENS,FORCE-FLG,XTYPE-ALIST,TYPE-ALIST" data-part-body="PUT-ASSOC-EQUAL-TS,CADAR,TS-SUBSETP,*TS-EMPTY*,TS=,CDAR,CONS,TYPE-SET,TTREE,TS,MV-LET,T,PT,POT-LST,W,ENS,FORCE-FLG,CDR,RECONSIDER-TYPE-ALIST,IF,QUOTE,CAAR,FFN-SYMB-P,XTYPE-ALIST,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECONSIDER-TYPE-ALIST">reconsider-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-reconsider-type-alist" data-sym="RECONSIDER-TYPE-ALIST" title="(defun reconsider-type-alist
       (type-alist xtype-alist force-flg ens w pot-lst pt)
  (cond ((null type-alist) (mv nil xtype-alist nil))
        ((ffn-symb-p (caar type-alist) &#39;if)
         (reconsider-type-alist (cdr type-alist) xtype-alist force-flg ens w
...">reconsider-type-alist</a>
  (type-alist xtype-alist force-flg <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> pot-lst pt)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil xtype-alist nil))
    ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist) 'if) (<a class="sym-link local-def" href="#def-reconsider-type-alist" data-sym="RECONSIDER-TYPE-ALIST" title="(defun reconsider-type-alist
       (type-alist xtype-alist force-flg ens w pot-lst pt)
  (cond ((null type-alist) (mv nil xtype-alist nil))
        ((ffn-symb-p (caar type-alist) &#39;if)
         (reconsider-type-alist (cdr type-alist) xtype-alist force-flg ens w
...">reconsider-type-alist</a> (cdr type-alist)
        xtype-alist
        force-flg
        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
        pot-lst
        pt))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
        (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)
          force-flg
          (cons <span class="keyword">:skip-lookup</span> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> type-alist))
          xtype-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
          nil
          pot-lst
          pt)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-empty*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-reconsider-type-alist" data-sym="RECONSIDER-TYPE-ALIST" title="(defun reconsider-type-alist
       (type-alist xtype-alist force-flg ens w pot-lst pt)
  (cond ((null type-alist) (mv nil xtype-alist nil))
        ((ffn-symb-p (caar type-alist) &#39;if)
         (reconsider-type-alist (cdr type-alist) xtype-alist force-flg ens w
...">reconsider-type-alist</a> (cdr type-alist)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist) ts) xtype-alist)
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-put-assoc-equal-ts" data-sym="PUT-ASSOC-EQUAL-TS" title="(defun put-assoc-equal-ts (term ts ttree type-alist)
  (declare (xargs :guard (alistp type-alist)))
  (cond ((endp type-alist) (list (list* term ts ttree)))
        ((equal term (caar type-alist))
         (let ((ts1 (ts-intersection ts (cadar type-alist))))
...">put-assoc-equal-ts</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist) ts ttree xtype-alist)))
              force-flg
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
              pot-lst
              pt)))))))</pre>
  </div>

<div class="form-block function" id="def-type-alist-clause-finish1" data-defines="TYPE-ALIST-CLAUSE-FINISH1" data-references="CDR,IGNORE,DECLARE,CAR,ASSUME-TRUE-FALSE,TTREE,FTA,TTA,MBF,MBT,MV-LET,T,MV,NULL,COND,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,LITS,DEFUN" data-used-by="TYPE-ALIST-CLAUSE-FINISH" data-part-name="TYPE-ALIST-CLAUSE-FINISH1" data-part-args="WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,LITS" data-part-body="CDR,TYPE-ALIST-CLAUSE-FINISH1,IGNORE,DECLARE,WRLD,ENS,FORCE-FLG,TTREE-LST,CAR,ASSUME-TRUE-FALSE,TTREE,FTA,TTA,MBF,MBT,MV-LET,T,TYPE-ALIST,MV,LITS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-CLAUSE-FINISH1">type-alist-clause-finish1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-clause-finish1" data-sym="TYPE-ALIST-CLAUSE-FINISH1" title="(defun type-alist-clause-finish1 (lits ttree-lst force-flg type-alist ens wrld)
  (cond ((null lits) (mv nil type-alist nil))
        (t
         (mv-let (mbt mbf tta fta ttree)
                 (assume-true-false (car lits) (car ttree-lst) force-flg nil
...">type-alist-clause-finish1</a>
  (lits ttree-lst force-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lits) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil type-alist nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree)
        (<a class="sym-link local-def" href="#def-assume-true-false" data-sym="ASSUME-TRUE-FALSE" title="(defun assume-true-false
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
     (bound
...">assume-true-false</a> (car lits)
          (car ttree-lst)
          force-flg
          nil
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          wrld
          nil
          nil
          <span class="keyword">:tta</span>)
        (declare (ignore tta))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil ttree))
          (mbf (<a class="sym-link local-def" href="#def-type-alist-clause-finish1" data-sym="TYPE-ALIST-CLAUSE-FINISH1" title="(defun type-alist-clause-finish1 (lits ttree-lst force-flg type-alist ens wrld)
  (cond ((null lits) (mv nil type-alist nil))
        (t
         (mv-let (mbt mbf tta fta ttree)
                 (assume-true-false (car lits) (car ttree-lst) force-flg nil
...">type-alist-clause-finish1</a> (cdr lits)
              (cdr ttree-lst)
              force-flg
              type-alist
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-alist-clause-finish1" data-sym="TYPE-ALIST-CLAUSE-FINISH1" title="(defun type-alist-clause-finish1 (lits ttree-lst force-flg type-alist ens wrld)
  (cond ((null lits) (mv nil type-alist nil))
        (t
         (mv-let (mbt mbf tta fta ttree)
                 (assume-true-false (car lits) (car ttree-lst) force-flg nil
...">type-alist-clause-finish1</a> (cdr lits)
              (cdr ttree-lst)
              force-flg
              fta
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld)))))))</pre>
  </div>

<div class="form-block function" id="def-type-alist-clause-finish" data-defines="TYPE-ALIST-CLAUSE-FINISH" data-references="NULL,EQUAL,OR,RECONSIDER-TYPE-ALIST,NEW-TYPE-ALIST,T,MV,COND,TYPE-ALIST-CLAUSE-FINISH1,TTREE,CONTRADICTIONP,MV-LET,PT,POT-LST,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,LITS,DEFUN" data-used-by="TYPE-ALIST-CLAUSE" data-part-name="TYPE-ALIST-CLAUSE-FINISH" data-part-args="PT,POT-LST,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,LITS" data-part-body="NULL,EQUAL,OR,PT,POT-LST,RECONSIDER-TYPE-ALIST,NEW-TYPE-ALIST,T,MV,COND,WRLD,ENS,FORCE-FLG,TTREE-LST,LITS,TYPE-ALIST-CLAUSE-FINISH1,TTREE,TYPE-ALIST,CONTRADICTIONP,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-CLAUSE-FINISH">type-alist-clause-finish</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-clause-finish" data-sym="TYPE-ALIST-CLAUSE-FINISH" title="(defun type-alist-clause-finish
       (lits ttree-lst force-flg type-alist ens wrld pot-lst pt)
  (mv-let (contradictionp type-alist ttree)
          (type-alist-clause-finish1 lits ttree-lst force-flg type-alist ens
                                     wrld)
...">type-alist-clause-finish</a>
  (lits ttree-lst force-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld pot-lst pt)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp type-alist ttree)
    (<a class="sym-link local-def" href="#def-type-alist-clause-finish1" data-sym="TYPE-ALIST-CLAUSE-FINISH1" title="(defun type-alist-clause-finish1 (lits ttree-lst force-flg type-alist ens wrld)
  (cond ((null lits) (mv nil type-alist nil))
        (t
         (mv-let (mbt mbf tta fta ttree)
                 (assume-true-false (car lits) (car ttree-lst) force-flg nil
...">type-alist-clause-finish1</a> lits
      ttree-lst
      force-flg
      type-alist
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> contradictionp type-alist ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-type-alist ttree)
          (<a class="sym-link local-def" href="#def-reconsider-type-alist" data-sym="RECONSIDER-TYPE-ALIST" title="(defun reconsider-type-alist
       (type-alist xtype-alist force-flg ens w pot-lst pt)
  (cond ((null type-alist) (mv nil xtype-alist nil))
        ((ffn-symb-p (caar type-alist) &#39;if)
         (reconsider-type-alist (cdr type-alist) xtype-alist force-flg ens w
...">reconsider-type-alist</a> type-alist
            type-alist
            force-flg
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            pot-lst
            pt)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> contradictionp new-type-alist ttree))
            ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (equal new-type-alist type-alist) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> contradictionp new-type-alist ttree))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-reconsider-type-alist" data-sym="RECONSIDER-TYPE-ALIST" title="(defun reconsider-type-alist
       (type-alist xtype-alist force-flg ens w pot-lst pt)
  (cond ((null type-alist) (mv nil xtype-alist nil))
        ((ffn-symb-p (caar type-alist) &#39;if)
         (reconsider-type-alist (cdr type-alist) xtype-alist force-flg ens w
...">reconsider-type-alist</a> new-type-alist
                new-type-alist
                force-flg
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                pot-lst
                pt))))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-sort-lits-heavy-p" data-defines="SORT-LITS-HEAVY-P" data-references="CDR,NOT,EQ,OR,CAR,X1,LET,ENDP,SYMBOLP,PSEUDO-TERM-LISTP,AND,VAR,LST,FARGS,SORT-LITS-HEAVY-LISTP,T,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,PSEUDO-TERMP,XARGS,DECLARE,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="SORT-LITS1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-LITS-HEAVY-P">sort-lits-heavy-p</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-lits-heavy-p" data-sym="SORT-LITS-HEAVY-P" title="(mutual-recursion
 (defun sort-lits-heavy-p (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) term) ((fquotep term) nil)
         ((flambda-applicationp term) t)
...">sort-lits-heavy-p</a>
    (term)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) term)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) nil)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (sort-lits-heavy-listp (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) nil))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> sort-lits-heavy-listp
    (lst var)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp lst) (symbolp var))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) var)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((x1 (<a class="sym-link local-def" href="#def-sort-lits-heavy-p" data-sym="SORT-LITS-HEAVY-P" title="(mutual-recursion
 (defun sort-lits-heavy-p (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) term) ((fquotep term) nil)
         ((flambda-applicationp term) t)
...">sort-lits-heavy-p</a> (car lst))))
          (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> x1 var (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x1 var)))
            (sort-lits-heavy-listp (cdr lst) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> x1 var))))))))</pre>
  </div>

<div class="form-block function" id="def-sort-lits1" data-defines="SORT-LITS1" data-references="CONS,CAR,SORT-LITS-HEAVY-P,EQ,CDR,TTREE-LST-POST,CL-POST,TTREE-LST-PRE,CL-PRE,MV-LET,T,MV,ENDP,COND,TTREE-LST,CL,DEFUN" data-used-by="SORT-LITS" data-part-name="SORT-LITS1" data-part-args="TTREE-LST,CL" data-part-body="CONS,CAR,SORT-LITS-HEAVY-P,EQ,TTREE-LST,CDR,SORT-LITS1,TTREE-LST-POST,CL-POST,TTREE-LST-PRE,CL-PRE,MV-LET,T,MV,CL,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-LITS1">sort-lits1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-lits1" data-sym="SORT-LITS1" title="(defun sort-lits1 (cl ttree-lst)
  (cond ((endp cl) (mv nil nil nil nil))
        (t
         (mv-let (cl-pre ttree-lst-pre cl-post ttree-lst-post)
                 (sort-lits1 (cdr cl) (cdr ttree-lst))
...">sort-lits1</a>
  (cl ttree-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> cl) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cl-pre ttree-lst-pre cl-post ttree-lst-post)
        (<a class="sym-link local-def" href="#def-sort-lits1" data-sym="SORT-LITS1" title="(defun sort-lits1 (cl ttree-lst)
  (cond ((endp cl) (mv nil nil nil nil))
        (t
         (mv-let (cl-pre ttree-lst-pre cl-post ttree-lst-post)
                 (sort-lits1 (cdr cl) (cdr ttree-lst))
...">sort-lits1</a> (cdr cl) (cdr ttree-lst))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-sort-lits-heavy-p" data-sym="SORT-LITS-HEAVY-P" title="(mutual-recursion
 (defun sort-lits-heavy-p (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) term) ((fquotep term) nil)
         ((flambda-applicationp term) t)
...">sort-lits-heavy-p</a> (car cl)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> cl-pre
              ttree-lst-pre
              (cons (car cl) cl-post)
              (cons (car ttree-lst) ttree-lst-post)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons (car cl) cl-pre)
              (cons (car ttree-lst) ttree-lst-pre)
              cl-post
              ttree-lst-post)))))))</pre>
  </div>

<div class="form-block function" id="def-sort-lits" data-defines="SORT-LITS" data-references="APPEND?,MV,SORT-LITS1,TTREE-LST-POST,CL-POST,TREE-LST-PRE,CL-PRE,MV-LET,TTREE-LST,CL,DEFUN" data-part-name="SORT-LITS" data-part-args="TTREE-LST,CL" data-part-body="APPEND?,MV,TTREE-LST,CL,SORT-LITS1,TTREE-LST-POST,CL-POST,TREE-LST-PRE,CL-PRE,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-LITS">sort-lits</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-lits" data-sym="SORT-LITS" title="(defun sort-lits (cl ttree-lst)
  (mv-let (cl-pre tree-lst-pre cl-post ttree-lst-post)
          (sort-lits1 cl ttree-lst)
          (mv (append? cl-pre cl-post) (append? tree-lst-pre ttree-lst-post))))">sort-lits</a>
  (cl ttree-lst)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cl-pre tree-lst-pre cl-post ttree-lst-post)
    (<a class="sym-link local-def" href="#def-sort-lits1" data-sym="SORT-LITS1" title="(defun sort-lits1 (cl ttree-lst)
  (cond ((endp cl) (mv nil nil nil nil))
        (t
         (mv-let (cl-pre ttree-lst-pre cl-post ttree-lst-post)
                 (sort-lits1 (cdr cl) (cdr ttree-lst))
...">sort-lits1</a> cl ttree-lst)
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-append_3F" data-sym="APPEND?">append?</a> cl-pre cl-post)
      (<a class="sym-link system" href="axioms.html#def-append_3F" data-sym="APPEND?">append?</a> tree-lst-pre ttree-lst-post))))</pre>
  </div>

<div class="form-block function" id="def-type-alist-clause" data-defines="TYPE-ALIST-CLAUSE" data-references="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*,TYPE-ALIST-EQUALITY-LOOP,T,MV,COND,TTREE0,TYPE-ALIST0,CONTRADICTIONP,MV-LET,TYPE-ALIST-CLAUSE-FINISH,IF,PT,POT-LST,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,CL,DEFUN" data-part-name="TYPE-ALIST-CLAUSE" data-part-args="PT,POT-LST,WRLD,ENS,TYPE-ALIST,FORCE-FLG,TTREE-LST,CL" data-part-body="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*,TYPE-ALIST-EQUALITY-LOOP,T,MV,COND,TTREE0,TYPE-ALIST0,CONTRADICTIONP,MV-LET,PT,POT-LST,WRLD,ENS,TYPE-ALIST,TTREE-LST,CL,TYPE-ALIST-CLAUSE-FINISH,FORCE-FLG,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-CLAUSE">type-alist-clause</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-clause" data-sym="TYPE-ALIST-CLAUSE" title="(defun type-alist-clause
       (cl ttree-lst force-flg type-alist ens wrld pot-lst pt)
  (if force-flg
      (type-alist-clause-finish cl ttree-lst force-flg type-alist ens wrld
                                pot-lst pt)
...">type-alist-clause</a>
  (cl ttree-lst force-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld pot-lst pt)
  (if force-flg
    (<a class="sym-link local-def" href="#def-type-alist-clause-finish" data-sym="TYPE-ALIST-CLAUSE-FINISH" title="(defun type-alist-clause-finish
       (lits ttree-lst force-flg type-alist ens wrld pot-lst pt)
  (mv-let (contradictionp type-alist ttree)
          (type-alist-clause-finish1 lits ttree-lst force-flg type-alist ens
                                     wrld)
...">type-alist-clause-finish</a> cl
      ttree-lst
      force-flg
      type-alist
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      pot-lst
      pt)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp type-alist0 ttree0)
      (<a class="sym-link local-def" href="#def-type-alist-clause-finish" data-sym="TYPE-ALIST-CLAUSE-FINISH" title="(defun type-alist-clause-finish
       (lits ttree-lst force-flg type-alist ens wrld pot-lst pt)
  (mv-let (contradictionp type-alist ttree)
          (type-alist-clause-finish1 lits ttree-lst force-flg type-alist ens
                                     wrld)
...">type-alist-clause-finish</a> cl
        ttree-lst
        nil
        type-alist
        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
        wrld
        pot-lst
        pt)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil ttree0))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-type-alist-equality-loop" data-sym="TYPE-ALIST-EQUALITY-LOOP" title="(defun type-alist-equality-loop (type-alist0 ens w n)
  (let ((type-alist (clean-type-alist type-alist0)))
    (mv-let (hitp type-alist ttree)
            (type-alist-equality-loop1 type-alist type-alist ens w)
            (cond ((eq hitp &#39;contradiction) (mv t nil ttree))
...">type-alist-equality-loop</a> type-alist0
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            <a class="sym-link local-def" href="#def-_2Atype-alist-equality-loop-max-depth_2A" data-sym="*TYPE-ALIST-EQUALITY-LOOP-MAX-DEPTH*" title="(defconst *type-alist-equality-loop-max-depth* 10)">*type-alist-equality-loop-max-depth*</a>))))))</pre>
  </div>

<div class="form-block function" id="def-known-whether-nil" data-defines="KNOWN-WHETHER-NIL" data-references="TS-INTERSECTP,*TS-NIL*,TS=,TYPE-SET,TTREE1,TS,MV-LET,*NIL*,EQUAL,T,MV,QUOTEP,COND,TTREE,WRLD,DWP,FORCE-FLG,ENS,TYPE-ALIST,X,DEFUN" data-part-name="KNOWN-WHETHER-NIL" data-part-args="TTREE,WRLD,DWP,FORCE-FLG,ENS,TYPE-ALIST,X" data-part-body="TS-INTERSECTP,*TS-NIL*,TS=,WRLD,ENS,TYPE-ALIST,DWP,FORCE-FLG,TYPE-SET,TTREE1,TS,MV-LET,TTREE,*NIL*,EQUAL,T,MV,X,QUOTEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KNOWN-WHETHER-NIL">known-whether-nil</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-known-whether-nil" data-sym="KNOWN-WHETHER-NIL" title="(defun known-whether-nil (x type-alist ens force-flg dwp wrld ttree)
  (cond ((quotep x) (mv t (equal x *nil*) ttree))
        (t
         (mv-let (ts ttree1)
                 (type-set x force-flg dwp type-alist ens wrld ttree nil nil)
...">known-whether-nil</a>
  (x type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> force-flg dwp wrld ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> x) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (equal x <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree1)
        (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> x force-flg dwp type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree nil nil)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1))
          ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil ttree1)))))))</pre>
  </div>

<div class="form-block function" id="def-ts-booleanp" data-defines="TS-BOOLEANP" data-references="*TS-BOOLEAN*,TS-SUBSETP,T,HARD,ER,ASSUMPTION,QUOTE,TAGGED-OBJECTSP,COND,TYPE-SET,TTREE,TS,MV-LET,WRLD,ENS,TERM,DEFUN" data-part-name="TS-BOOLEANP" data-part-args="WRLD,ENS,TERM" data-part-body="*TS-BOOLEAN*,TS-SUBSETP,T,TS-BOOLEANP,HARD,ER,ASSUMPTION,QUOTE,TAGGED-OBJECTSP,COND,WRLD,ENS,TERM,TYPE-SET,TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TS-BOOLEANP">ts-booleanp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ts-booleanp" data-sym="TS-BOOLEANP" title="(defun ts-booleanp (term ens wrld)
  (mv-let (ts ttree) (type-set term nil nil nil ens wrld nil nil nil)
          (cond
           ((tagged-objectsp &#39;assumption ttree)
            (er hard &#39;ts-booleanp
...">ts-booleanp</a>
  (term <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
    (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> term nil nil nil <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld nil nil nil)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((tagged-objectsp 'assumption ttree) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          '<a class="sym-link local-def" href="#def-ts-booleanp" data-sym="TS-BOOLEANP" title="(defun ts-booleanp (term ens wrld)
  (mv-let (ts ttree) (type-set term nil nil nil ens wrld nil nil nil)
          (cond
           ((tagged-objectsp &#39;assumption ttree)
            (er hard &#39;ts-booleanp
...">ts-booleanp</a>
          <span class="string">"It was thought impossible for a call of type-set with ~
                      force-flg = nil to produce an &#39;assumption, but ~
                      ts-booleanp did it on ~x0."</span>
          term))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (ts-subsetp ts *ts-boolean*)))))</pre>
  </div>

<div class="form-block function" id="def-weak-cons-occur" data-defines="WEAK-CONS-OCCUR" data-references="EQUAL,T,FARGN,OR,CONS,QUOTE,FFN-SYMB,FQUOTEP,EQ,VARIABLEP,COND,Y,X,DEFUN" data-used-by="EQUAL-X-CONS-X-YP" data-part-name="WEAK-CONS-OCCUR" data-part-args="Y,X" data-part-body="EQUAL,T,FARGN,WEAK-CONS-OCCUR,OR,CONS,QUOTE,FFN-SYMB,FQUOTEP,X,EQ,Y,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WEAK-CONS-OCCUR">weak-cons-occur</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a>
  (x y)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> y) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x y))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> y) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> y) 'cons) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> x (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> y <span class="number">1</span>))
        (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> x (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> y <span class="number">2</span>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (equal x y))))</pre>
  </div>

<div class="form-block function" id="def-equal-x-cons-x-yp" data-defines="EQUAL-X-CONS-X-YP" data-references="CONS,QUOTE,FFN-SYMB,EQ,FQUOTEP,T,FARGN,WEAK-CONS-OCCUR,OR,CONSITYP,VARIABLEP,COND,RHS,LHS,DEFUN" data-used-by="NOT-IDENT" data-part-name="EQUAL-X-CONS-X-YP" data-part-args="RHS,LHS" data-part-body="CONS,QUOTE,FFN-SYMB,EQ,FQUOTEP,T,FARGN,WEAK-CONS-OCCUR,OR,RHS,CONSITYP,LHS,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-X-CONS-X-YP">equal-x-cons-x-yp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-equal-x-cons-x-yp" data-sym="EQUAL-X-CONS-X-YP" title="(defun equal-x-cons-x-yp (lhs rhs)
  (cond
   ((variablep lhs)
    (cond
     ((consityp rhs)
...">equal-x-cons-x-yp</a>
  (lhs rhs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> lhs) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-consityp" data-sym="CONSITYP">consityp</a> rhs) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">1</span>))
            (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">2</span>))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> lhs) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lhs) 'cons) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> rhs) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lhs <span class="number">1</span>))
            (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lhs <span class="number">2</span>))))
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> rhs) nil)
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> rhs) 'cons) nil)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lhs <span class="number">1</span>))
            (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lhs <span class="number">2</span>))))))
    ((<a class="sym-link system" href="basis-b.html#def-consityp" data-sym="CONSITYP">consityp</a> rhs) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">1</span>))
        (<a class="sym-link local-def" href="#def-weak-cons-occur" data-sym="WEAK-CONS-OCCUR" title="(defun weak-cons-occur (x y)
  (cond ((variablep y) (eq x y)) ((fquotep y) nil)
        ((eq (ffn-symb y) &#39;cons)
         (or (weak-cons-occur x (fargn y 1)) (weak-cons-occur x (fargn y 2))))
        (t (equal x y))))">weak-cons-occur</a> lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">2</span>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-not-ident" data-defines="NOT-IDENT" data-references="EQUAL-X-CONS-X-YP,TS-DISJOINTP,TS2,TYPE-SET,TTREE,TS1,MV-LET,T,EQUAL,NOT,MV,QUOTEP,AND,COND,WRLD,ENS,TYPE-ALIST,TERM2,TERM1,DEFUN" data-used-by="NORMALIZE" data-part-name="NOT-IDENT" data-part-args="WRLD,ENS,TYPE-ALIST,TERM2,TERM1" data-part-body="EQUAL-X-CONS-X-YP,TS-DISJOINTP,TS2,WRLD,ENS,TYPE-ALIST,TYPE-SET,TTREE,TS1,MV-LET,T,EQUAL,NOT,MV,TERM2,TERM1,QUOTEP,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOT-IDENT">not-ident</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a>
  (term1 term2 type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term1) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal term1 term2)) nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree)
        (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> term1 nil nil type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld nil nil nil)
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts2 ttree)
          (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> term2 nil nil type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree nil nil)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts1 ts2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree))
            ((<a class="sym-link local-def" href="#def-equal-x-cons-x-yp" data-sym="EQUAL-X-CONS-X-YP" title="(defun equal-x-cons-x-yp (lhs rhs)
  (cond
   ((variablep lhs)
    (cond
     ((consityp rhs)
...">equal-x-cons-x-yp</a> term1 term2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))))))</pre>
  </div>

<div class="form-block function" id="def-first-if" data-defines="FIRST-IF" data-references="1+,CDR,T,IF,QUOTE,CAR,FFN-SYMB-P,MV,NULL,COND,I,ARGS,DEFUN" data-used-by="NORMALIZE" data-part-name="FIRST-IF" data-part-args="I,ARGS" data-part-body="1+,CDR,FIRST-IF,T,I,IF,QUOTE,CAR,FFN-SYMB-P,MV,ARGS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIRST-IF">first-if</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-first-if" data-sym="FIRST-IF" title="(defun first-if (args i)
  (cond ((null args) (mv nil nil))
        ((ffn-symb-p (car args) &#39;if) (mv i (car args)))
        (t (first-if (cdr args) (1+ i)))))">first-if</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> i)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) 'if) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> i (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-first-if" data-sym="FIRST-IF" title="(defun first-if (args i)
  (cond ((null args) (mv nil nil))
        ((ffn-symb-p (car args) &#39;if) (mv i (car args)))
        (t (first-if (cdr args) (1+ i)))))">first-if</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> i)))))</pre>
  </div>

<div class="form-block function" id="def-all-variablep" data-defines="ALL-VARIABLEP" data-references="CDR,CAR,VARIABLEP,AND,T,NULL,COND,LST,DEFUN" data-part-name="ALL-VARIABLEP" data-part-args="LST" data-part-body="CDR,ALL-VARIABLEP,CAR,VARIABLEP,AND,T,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-VARIABLEP">all-variablep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-variablep" data-sym="ALL-VARIABLEP" title="(defun all-variablep (lst)
  (cond ((null lst) t)
        (t (and (variablep (car lst)) (all-variablep (cdr lst))))))">all-variablep</a>
  (lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car lst)) (<a class="sym-link local-def" href="#def-all-variablep" data-sym="ALL-VARIABLEP" title="(defun all-variablep (lst)
  (cond ((null lst) t)
        (t (and (variablep (car lst)) (all-variablep (cdr lst))))))">all-variablep</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-normalize-with-type-set" data-defines="NORMALIZE-WITH-TYPE-SET" data-references="EQUAL,IF,MV,*1*,*TS-ONE*,*0*,*TS-ZERO*,*TS-T*,*T*,T,*NIL*,TS=,*TS-NIL*,TS-INTERSECTP,COND,NEW-TERM,LET,TYPE-SET-BC,NEW-TTREE,TS,MV-LET,TS-BACKCHAIN-LIMIT,TTREE,WRLD,ENS,TYPE-ALIST,IFF-FLG,TERM,DEFUN" data-used-by="NORMALIZE" data-part-name="NORMALIZE-WITH-TYPE-SET" data-part-args="TS-BACKCHAIN-LIMIT,TTREE,WRLD,ENS,TYPE-ALIST,IFF-FLG,TERM" data-part-body="EQUAL,IF,MV,*1*,*TS-ONE*,*0*,*TS-ZERO*,*TS-T*,*T*,IFF-FLG,T,*NIL*,TS=,*TS-NIL*,TS-INTERSECTP,COND,NEW-TERM,LET,TS-BACKCHAIN-LIMIT,TTREE,WRLD,ENS,TYPE-ALIST,TERM,TYPE-SET-BC,NEW-TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-WITH-TYPE-SET">normalize-with-type-set</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-with-type-set" data-sym="NORMALIZE-WITH-TYPE-SET" title="(defun normalize-with-type-set
       (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
  (mv-let (ts new-ttree)
          (type-set-bc term nil nil type-alist ens wrld ttree nil nil
                       ts-backchain-limit)
...">normalize-with-type-set</a>
  (term iff-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts new-ttree)
    (<a class="sym-link local-def" href="#def-type-set-bc" data-sym="TYPE-SET-BC" title="(defun type-set-bc
       (x force-flg dwp type-alist ens w ttree pot-lst pt ts-backchain-limit)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  ts-backchain-limit)))">type-set-bc</a> term
      nil
      nil
      type-alist
      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
      wrld
      ttree
      nil
      nil
      ts-backchain-limit)
    (let ((new-term (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term)))
           (iff-flg <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
           ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-t*) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
           ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-zero*) <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a>)
           ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-one*) <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>)
           (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term))))
      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-term
        (if (equal term new-term)
          ttree
          new-ttree)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-normalize" data-defines="NORMALIZE" data-references="SUBST-FOR-NTH-ARG,BBODY,FORMALS,SUBCOR-VAR,*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*,MEMBER-EQ,FIRST-IF,IF-EXPR,N,OR,NORMALIZE-OR-DISTRIBUTE-FIRST-IF,CONS,CDR,CAR,NORMAL-ARG,NULL,ARGS,DISTRIBUTE-FIRST-IF,NOT-IDENT,CONS-TERM,HIDE,*TS-BOOLEAN*,TS-SUBSETP,TYPE-SET-BC,TS1,MCONS-TERM*,T13,T12,T11,FFN-SYMB-P,CONS-TAG-TREES,ASSUME-TRUE-FALSE-BC,TTREE1,FTA,TTA,MBF,MBT,T3,T2,LET,FARGN,T1,IF,EQ,LAMBDA,QUOTE,LIST,MCONS-TERM,TYPE-SET-LST,LAMBDA-FORMALS,ZIP-VARIABLE-TYPE-ALIST,FFN-SYMB,LAMBDA-BODY,NORMAL-BODY,FARGS,NORMALIZE-LST,NORMAL-ARGS,MV-LET,FLAMBDA-APPLICATIONP,T,*T*,*NIL*,EQUAL,NOT,AND,MV,FQUOTEP,NORMALIZE-WITH-TYPE-SET,VARIABLEP,COND,TS-BACKCHAIN-LIMIT,TTREE,WRLD,ENS,TYPE-ALIST,IFF-FLG,TERM,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE">normalize</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a>
    (term iff-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-normalize-with-type-set" data-sym="NORMALIZE-WITH-TYPE-SET" title="(defun normalize-with-type-set
       (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
  (mv-let (ts new-ttree)
          (type-set-bc term nil nil type-alist ens wrld ttree nil nil
                       ts-backchain-limit)
...">normalize-with-type-set</a> term
          iff-flg
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          wrld
          ttree
          ts-backchain-limit))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> iff-flg (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal term <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term))
          ttree))
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (normal-args ttree)
          (normalize-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
            nil
            type-alist
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            ttree
            ts-backchain-limit)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (normal-body ttree)
            (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
              iff-flg
              (<a class="sym-link local-def" href="#def-zip-variable-type-alist" data-sym="ZIP-VARIABLE-TYPE-ALIST" title="(defun zip-variable-type-alist (vars pairs)
  (cond ((null vars) nil)
        ((ts= (caar pairs) *ts-unknown*)
         (zip-variable-type-alist (cdr vars) (cdr pairs)))
        (t
...">zip-variable-type-alist</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
                (type-set-lst normal-args
                  nil
                  nil
                  type-alist
                  nil
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  wrld
                  nil
                  nil
                  ts-backchain-limit))
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld
              ttree
              ts-backchain-limit)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term" data-sym="MCONS-TERM">mcons-term</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'lambda (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) normal-body)
                normal-args)
              ttree))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (t1 ttree)
          (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            type-alist
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            ttree
            ts-backchain-limit)
          (let ((t2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (t3 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree1)
              (<a class="sym-link local-def" href="#def-assume-true-false-bc" data-sym="ASSUME-TRUE-FALSE-BC" title="(defun assume-true-false-bc
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
...">assume-true-false-bc</a> t1
                nil
                nil
                nil
                type-alist
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                nil
                nil
                nil
                ts-backchain-limit)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> t2
                    iff-flg
                    type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    (cons-tag-trees ttree1 ttree)
                    ts-backchain-limit))
                (mbf (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> t3
                    iff-flg
                    type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    (cons-tag-trees ttree1 ttree)
                    ts-backchain-limit))
                ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> t1 'if) (let ((t11 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> t1 <span class="number">1</span>)) (t12 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> t1 <span class="number">2</span>)) (t13 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> t1 <span class="number">3</span>)))
                    (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if
                        t11
                        (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t12 t2 t3)
                        (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t13 t2 t3))
                      iff-flg
                      type-alist
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      wrld
                      ttree
                      ts-backchain-limit)))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (t2 ttree)
                    (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> t2 iff-flg tta <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (t3 ttree)
                      (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> t3 iff-flg fta <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal t2 t3) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t2 ttree))
                        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal t1 t2) (equal t3 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 ttree))
                        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal t2 <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (equal t3 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (iff-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 ttree))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                                (<a class="sym-link local-def" href="#def-type-set-bc" data-sym="TYPE-SET-BC" title="(defun type-set-bc
       (x force-flg dwp type-alist ens w ttree pot-lst pt ts-backchain-limit)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  ts-backchain-limit)))">type-set-bc</a> t1
                                  nil
                                  nil
                                  type-alist
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  wrld
                                  nil
                                  nil
                                  nil
                                  ts-backchain-limit)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts1 *ts-boolean*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 (cons-tag-trees ttree1 ttree)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t1 t2 t3) ttree)))))))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t1 t2 t3) ttree)))))))))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (normal-args ttree)
          (normalize-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
            nil
            type-alist
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            ttree
            ts-backchain-limit)
          (let ((term (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) normal-args)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree))
              ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'equal) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> ttree1)
                      (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                        type-alist
                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                        wrld)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (cons-tag-trees ttree1 ttree)))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (distribute-first-if term
                            iff-flg
                            type-alist
                            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                            wrld
                            ttree
                            ts-backchain-limit)))))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (distribute-first-if term
                  iff-flg
                  type-alist
                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                  wrld
                  ttree
                  ts-backchain-limit))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> normalize-lst
    (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> iff-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (normal-arg ttree)
          (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
            iff-flg
            type-alist
            <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
            wrld
            ttree
            ts-backchain-limit)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (normal-args ttree)
            (normalize-lst (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
              iff-flg
              type-alist
              <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
              wrld
              ttree
              ts-backchain-limit)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons normal-arg normal-args) ttree))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> normalize-or-distribute-first-if
    (term iff-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)) (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> term
          iff-flg
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          wrld
          ttree
          ts-backchain-limit))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'equal) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> ttree1)
              (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                type-alist
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link local-def" href="#def-not-ident" data-sym="NOT-IDENT" title="(defun not-ident (term1 term2 type-alist ens wrld)
  (cond
   ((and (quotep term1) (quotep term2)) (mv (not (equal term1 term2)) nil))
   (t
    (mv-let (ts1 ttree)
...">not-ident</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (cons-tag-trees ttree1 ttree)))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (distribute-first-if term
                    iff-flg
                    type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    ttree
                    ts-backchain-limit)))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (distribute-first-if term
          iff-flg
          type-alist
          <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
          wrld
          ttree
          ts-backchain-limit))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> distribute-first-if
    (term iff-flg type-alist <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> wrld ttree ts-backchain-limit)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (n if-expr)
      (<a class="sym-link local-def" href="#def-first-if" data-sym="FIRST-IF" title="(defun first-if (args i)
  (cond ((null args) (mv nil nil))
        ((ffn-symb-p (car args) &#39;if) (mv i (car args)))
        (t (first-if (cdr args) (1+ i)))))">first-if</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) <span class="number">0</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> n) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
               <a class="sym-link system" href="axioms.html#def-_2Aexpandable-boot-strap-non-rec-fns_2A" data-sym="*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*">*expandable-boot-strap-non-rec-fns*</a>) (<a class="sym-link local-def" href="#def-normalize" data-sym="NORMALIZE" title="(mutual-recursion
 (defun normalize (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
   (cond
    ((variablep term)
     (normalize-with-type-set term iff-flg type-alist ens wrld ttree
...">normalize</a> (<a class="sym-link system" href="basis-b.html#def-subcor-var" data-sym="SUBCOR-VAR">subcor-var</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld)
                  (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
                  (<a class="sym-link system" href="axioms.html#def-bbody" data-sym="BBODY">bbody</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
                iff-flg
                type-alist
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                ttree
                ts-backchain-limit))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-normalize-with-type-set" data-sym="NORMALIZE-WITH-TYPE-SET" title="(defun normalize-with-type-set
       (term iff-flg type-alist ens wrld ttree ts-backchain-limit)
  (mv-let (ts new-ttree)
          (type-set-bc term nil nil type-alist ens wrld ttree nil nil
                       ts-backchain-limit)
...">normalize-with-type-set</a> term
                iff-flg
                type-alist
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                ttree
                ts-backchain-limit))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((t1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> if-expr <span class="number">1</span>)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> mbf tta fta ttree1)
              (<a class="sym-link local-def" href="#def-assume-true-false-bc" data-sym="ASSUME-TRUE-FALSE-BC" title="(defun assume-true-false-bc
       (x xttree force-flg dwp type-alist ens w pot-lst pt ignore0
        ts-backchain-limit)
  (let ((bound (assume-true-false-aggressive-p)) (dwp (get-dwp dwp w)))
    (cond
...">assume-true-false-bc</a> t1
                nil
                nil
                nil
                type-alist
                <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                wrld
                nil
                nil
                nil
                ts-backchain-limit)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (normalize-or-distribute-first-if (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                      (<a class="sym-link system" href="axioms.html#def-subst-for-nth-arg" data-sym="SUBST-FOR-NTH-ARG">subst-for-nth-arg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> if-expr <span class="number">2</span>) n (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))
                    iff-flg
                    type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    (cons-tag-trees ttree1 ttree)
                    ts-backchain-limit))
                (mbf (normalize-or-distribute-first-if (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                      (<a class="sym-link system" href="axioms.html#def-subst-for-nth-arg" data-sym="SUBST-FOR-NTH-ARG">subst-for-nth-arg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> if-expr <span class="number">3</span>) n (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))
                    iff-flg
                    type-alist
                    <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                    wrld
                    (cons-tag-trees ttree1 ttree)
                    ts-backchain-limit))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (t2 ttree)
                    (normalize-or-distribute-first-if (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                        (<a class="sym-link system" href="axioms.html#def-subst-for-nth-arg" data-sym="SUBST-FOR-NTH-ARG">subst-for-nth-arg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> if-expr <span class="number">2</span>) n (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))
                      iff-flg
                      tta
                      <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                      wrld
                      ttree
                      ts-backchain-limit)
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (t3 ttree)
                      (normalize-or-distribute-first-if (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                          (<a class="sym-link system" href="axioms.html#def-subst-for-nth-arg" data-sym="SUBST-FOR-NTH-ARG">subst-for-nth-arg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> if-expr <span class="number">3</span>) n (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))
                        iff-flg
                        fta
                        <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                        wrld
                        ttree
                        ts-backchain-limit)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal t2 t3) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t2 ttree))
                        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal t1 t2) (equal t3 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 ttree))
                        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal t2 <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (equal t3 <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (iff-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 ttree))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts1 ttree1)
                                (<a class="sym-link local-def" href="#def-type-set-bc" data-sym="TYPE-SET-BC" title="(defun type-set-bc
       (x force-flg dwp type-alist ens w ttree pot-lst pt ts-backchain-limit)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  ts-backchain-limit)))">type-set-bc</a> t1
                                  nil
                                  nil
                                  type-alist
                                  <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
                                  wrld
                                  nil
                                  nil
                                  nil
                                  ts-backchain-limit)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts1 *ts-boolean*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> t1 (cons-tag-trees ttree1 ttree)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t1 t2 t3) ttree)))))))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if t1 t2 t3) ttree))))))))))))))</pre>
  </div>

<div class="form-block function" id="def-decode-type-set1" data-defines="DECODE-TYPE-SET1" data-references="T,CDR,TS-COMPLEMENT,TS-INTERSECTION,CAAR,CONS,CDAR,TS-SUBSETP,LIST,NULL,*TS-EMPTY*,TS=,COND,ALIST,TS,DEFUN" data-used-by="DECODE-TYPE-SET" data-part-name="DECODE-TYPE-SET1" data-part-args="ALIST,TS" data-part-body="T,CDR,TS-COMPLEMENT,TS-INTERSECTION,DECODE-TYPE-SET1,CAAR,CONS,CDAR,TS-SUBSETP,LIST,ALIST,NULL,*TS-EMPTY*,TS,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECODE-TYPE-SET1">decode-type-set1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-decode-type-set1" data-sym="DECODE-TYPE-SET1" title="(defun decode-type-set1 (ts alist)
  (cond ((ts= ts *ts-empty*) nil) ((null alist) (list ts))
        ((ts-subsetp (cdar alist) ts)
         (cons (caar alist)
               (decode-type-set1
...">decode-type-set1</a>
  (ts alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-empty*) nil)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> ts))
    ((ts-subsetp (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist) ts) (cons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)
        (<a class="sym-link local-def" href="#def-decode-type-set1" data-sym="DECODE-TYPE-SET1" title="(defun decode-type-set1 (ts alist)
  (cond ((ts= ts *ts-empty*) nil) ((null alist) (list ts))
        ((ts-subsetp (cdar alist) ts)
         (cons (caar alist)
               (decode-type-set1
...">decode-type-set1</a> (ts-intersection ts (ts-complement (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)))
          (cdr alist))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-decode-type-set1" data-sym="DECODE-TYPE-SET1" title="(defun decode-type-set1 (ts alist)
  (cond ((ts= ts *ts-empty*) nil) ((null alist) (list ts))
        ((ts-subsetp (cdar alist) ts)
         (cons (caar alist)
               (decode-type-set1
...">decode-type-set1</a> ts (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-decode-type-set" data-defines="DECODE-TYPE-SET" data-references="TS-UNION,CONS,CAR,CDR,NULL,*CODE-TYPE-SET-ALIST*,DECODE-TYPE-SET1,LST,LET,T,TS-COMPLEMENT,LIST,TS-COMPLEMENTP,*TS-EMPTY*,QUOTE,*TS-UNKNOWN*,TS=,COND,TS,DEFUN" data-used-by="DTS" data-part-name="DECODE-TYPE-SET" data-part-args="TS" data-part-body="TS-UNION,CONS,CAR,CDR,NULL,*CODE-TYPE-SET-ALIST*,DECODE-TYPE-SET1,LST,LET,T,DECODE-TYPE-SET,TS-COMPLEMENT,LIST,TS-COMPLEMENTP,*TS-EMPTY*,QUOTE,*TS-UNKNOWN*,TS,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECODE-TYPE-SET">decode-type-set</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-decode-type-set" data-sym="DECODE-TYPE-SET" title="(defun decode-type-set (ts)
  (cond ((ts= ts *ts-unknown*) &#39;*ts-unknown*) ((ts= ts *ts-empty*) &#39;*ts-empty*)
        ((ts-complementp ts)
         (list &#39;ts-complement (decode-type-set (ts-complement ts))))
        (t
...">decode-type-set</a>
  (ts)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-unknown*) '*ts-unknown*)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-empty*) '*ts-empty*)
    ((<a class="sym-link system" href="basis-b.html#def-ts-complementp" data-sym="TS-COMPLEMENTP">ts-complementp</a> ts) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'ts-complement (<a class="sym-link local-def" href="#def-decode-type-set" data-sym="DECODE-TYPE-SET" title="(defun decode-type-set (ts)
  (cond ((ts= ts *ts-unknown*) &#39;*ts-unknown*) ((ts= ts *ts-empty*) &#39;*ts-empty*)
        ((ts-complementp ts)
         (list &#39;ts-complement (decode-type-set (ts-complement ts))))
        (t
...">decode-type-set</a> (ts-complement ts))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((lst (<a class="sym-link local-def" href="#def-decode-type-set1" data-sym="DECODE-TYPE-SET1" title="(defun decode-type-set1 (ts alist)
  (cond ((ts= ts *ts-empty*) nil) ((null alist) (list ts))
        ((ts-subsetp (cdar alist) ts)
         (cons (caar alist)
               (decode-type-set1
...">decode-type-set1</a> ts *code-type-set-alist*)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr lst)) (car lst)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons 'ts-union lst)))))))</pre>
  </div>

<div class="form-block macro" id="def-dts" data-defines="DTS" data-references="DECODE-TYPE-SET,MV,W,STATE,ENS,TYPE-SET,TTREE,TS,MV-LET,QUASIQUOTE,TYPE-ALIST,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DTS">dts</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-dts" data-sym="DTS" title="(defmacro dts (term type-alist)
  `(mv-let (ts ttree)
           (type-set ,term nil nil ,type-alist (ens state) (w state) nil nil
                     nil)
           (mv (decode-type-set ts) ttree)))">dts</a>
  (term type-alist)
  `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree)
    (<a class="sym-link local-def" href="#def-type-set" data-sym="TYPE-SET" title="(defun type-set (x force-flg dwp type-alist ens w ttree pot-lst pt)
  (let ((dwp (get-dwp dwp w)))
    (type-set-rec x force-flg dwp type-alist nil ens w ttree pot-lst pt
                  (backchain-limit w :ts))))">type-set</a> ,TERM
      nil
      nil
      ,TYPE-ALIST
      (<a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a> state)
      (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)
      nil
      nil
      nil)
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-decode-type-set" data-sym="DECODE-TYPE-SET" title="(defun decode-type-set (ts)
  (cond ((ts= ts *ts-unknown*) &#39;*ts-unknown*) ((ts= ts *ts-empty*) &#39;*ts-empty*)
        ((ts-complementp ts)
         (list &#39;ts-complement (decode-type-set (ts-complement ts))))
        (t
...">decode-type-set</a> ts) ttree)))</pre>
  </div>

<div class="form-block function" id="def-ens" data-defines="ENS" data-references="GLOBAL-ENABLED-STRUCTURE,QUOTE,F-GET-GLOBAL,T,XARGS,DECLARE,STATE,DEFUN" data-used-by="DTS,NORMALIZE,NORMALIZE-WITH-TYPE-SET,NOT-IDENT,TS-BOOLEANP,KNOWN-WHETHER-NIL,TYPE-ALIST-CLAUSE,TYPE-ALIST-CLAUSE-FINISH,TYPE-ALIST-CLAUSE-FINISH1,RECONSIDER-TYPE-ALIST,TYPE-ALIST-EQUALITY-LOOP,TYPE-ALIST-EQUALITY-LOOP1,ADD-LINEAR-ASSUMPTION,OK-TO-FORCE-ENS,ASSUME-TRUE-FALSE-BC,ASSUME-TRUE-FALSE,ASSUME-TRUE-FALSE-AGGRESSIVE,TYPE-SET-BC,TYPE-SET,TYPE-SET-REC,RECOGNIZER-EXPR-P,STRONG-RECOGNIZER-EXPR-P,LOOKUP-HYP,TERM-AND-TYP-TO-LOOKUP,MOST-RECENT-ENABLED-RECOG-TUPLE,MOST-RECENT-ENABLED-RECOG-TUPLE1,IMMEDIATE-FORCEP,LOAD-THEORY-INTO-ENABLED-STRUCTURE-1,UPDATE-ENABLED-STRUCTURE,INCREMENT-ARRAY-NAME,SUBLIS-VAR!,ENABLED-XFNP,ACTIVE-OR-NON-RUNEP,ACTIVE-RUNEP,ENABLED-RUNEP,ENABLED-ARITH-NUMEP,ENABLED-NUMEP,ENABLED-STRUCTURE-P" data-part-name="ENS" data-part-args="STATE" data-part-declare="T,XARGS,DECLARE" data-part-body="STATE,GLOBAL-ENABLED-STRUCTURE,QUOTE,F-GET-GLOBAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ENS">ens</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ens" data-sym="ENS" title="(defun ens (state)
  (declare (xargs :guard t))
  (f-get-global &#39;global-enabled-structure state))">ens</a>
  (state)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'global-enabled-structure state))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>