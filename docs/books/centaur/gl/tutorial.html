<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tutorial - ACL2 Book</title>
  <meta property="name" content="tutorial">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">‚òÄÔ∏è</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">tutorial</h1>
    <div class="path"><a href="tutorial.lisp" class="source-link">books/centaur/gl/tutorial</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"GL"</span>)</pre>
  </div>

<div class="form-block other" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/top.html" title="Open xdoc/top">"xdoc/top"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc basic-tutorial
  <span class="keyword">:parents</span> (gl)
  <span class="keyword">:short</span> <span class="string">"An introductory guide, recommended for new users of @(see GL)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This is a tutorial introduction to using GL to prove ACL2 theorems.
We recommend going through the entire tutorial before beginning to use GL.&lt;/p&gt;

&lt;p&gt;You can think of this tutorial as a quick-start guide.  By the time you&#39;re
done with it, you should have a good understanding of how GL works, and be able
to use GL to easily prove many theorems.&lt;/p&gt;

&lt;p&gt;We don&#39;t try to cover more advanced topics, like @(see optimization) and
@(see term-level-reasoning).  You&#39;ll probably want to get some practice using
GL before exploring these topics.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |1. An Example GL Proof|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;The usual way to load GL is to start with&lt;/p&gt;
@({
    (include-book &quot;centaur/gl/gl&quot; :dir :system)
})

&lt;p&gt;Let&#39;s use GL to prove a theorem.  The following C code, from Sean
Anderson &lt;a href=&#39;http://graphics.stanford.edu/~seander/bithacks.html&#39;&gt;Bit
Twiddling Hacks&lt;/a&gt; page, is a fast way to count how many bits are set in a
32-bit integer.&lt;/p&gt;

@({
     v = v - ((v &gt;&gt; 1) &amp; 0x55555555);
     v = (v &amp; 0x33333333) + ((v &gt;&gt; 2) &amp; 0x33333333);
     c = ((v + (v &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24;
})

&lt;p&gt;We can model this in ACL2 as follows.  It turns out that using
arbitrary-precision addition and subtraction does not affect the result, but we
must take care to use a 32-bit multiply to match the C code.&lt;/p&gt;

@({
    (defun 32* (x y)
      (logand (* x y) (1- (expt 2 32))))

    (defun fast-logcount-32 (v)
      (let* ((v (- v (logand (ash v -1) #x55555555)))
             (v (+ (logand v #x33333333)
                   (logand (ash v -2) #x33333333))))
        (ash (32* (logand (+ v (ash v -4)) #xF0F0F0F)
                  #x1010101)
             -24)))
})

&lt;p&gt;We can then use GL to prove @(&#39;fast-logcount-32&#39;) computes the same
result as ACL2&#39;s built-in @(&#39;logcount&#39;) function for all unsigned 32-bit
inputs.&lt;/p&gt;

@({
    (def-gl-thm fast-logcount-32-correct
      :hyp   (unsigned-byte-p 32 x)
      :concl (equal (fast-logcount-32 x)
                    (logcount x))
      :g-bindings `((x ,(g-int 0 1 33))))
})

&lt;p&gt;The @(&#39;:g-bindings&#39;) form is the only help GL needs from the user.  It tells
GL how to construct a symbolic object that can represent every value for @(&#39;x&#39;)
that satisfies the hypothesis (we&#39;ll cover this shortly).  No arithmetic books
or lemmas are required&amp;mdash;we actually don&#39;t even know why this algorithm
works.  The proof completes in 0.09 seconds and results in the following ACL2
theorem.&lt;/p&gt;

@({
    (defthm fast-logcount-32-correct
      (implies (unsigned-byte-p 32 x)
               (equal (fast-logcount-32 x)
                      (logcount x)))
      :hints ((gl-hint ...)))
})

&lt;p&gt;GL can generate counterexamples to non-theorems.  At first, we didn&#39;t
realize we needed to use a 32-bit multiply in @(&#39;fast-logcount-32&#39;), and we
just used an arbitrary-precision multiply instead.  The function still worked
for test cases like @(&#39;0&#39;), @(&#39;1&#39;) @(&#39;#b111&#39;), and @(&#39;#b10111&#39;), but when we
tried to prove its correctness, GL showed us three counterexamples:
@(&#39;#x80000000&#39;), @(&#39;#xFFFFFFFF&#39;), and @(&#39;#x9448C263&#39;).  By default, GL
generates a first counterexample by setting bits to 0 wherever possible, a
second by setting bits to 1, and a third with random bit settings.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |2. Symbolic Objects|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;At its heart, GL works by manipulating Boolean expressions.  There are
many ways to represent Boolean expressions.  GL currently supports a hons-based
&lt;see topic=&#39;@(url ubdds)&#39;&gt;BDD package&lt;/see&gt; and also has support for using a
hons-based @(see aig) representation.&lt;/p&gt;

&lt;p&gt;For any particular proof, you can choose which representation to use by
picking one of the available proof @(see modes).  Each representation has
strengths and weaknesses, and the choice of representation can significantly
impact performance.  We give some advice about choosing these modes in @(see
modes).&lt;/p&gt;

&lt;p&gt;The GL user does not need to know how BDDs and AIGs are represented; in this
documentation we will just adopt a conventional syntax to describe Boolean
expressions, e.g., @(&#39;true&#39;), @(&#39;false&#39;), @(&#39;A &amp; B&#39;), @(&#39;~C&#39;), etc.&lt;/p&gt;

&lt;p&gt;GL groups Boolean expressions into &lt;b&gt;symbolic objects&lt;/b&gt;.  Much like a
Boolean expression can be evaluated to obtain a Boolean value, a symbolic
object can be evaluated to produce an ACL2 object.  There are several kinds of
symbolic objects, but numbers are a good start.  GL represents symbolic, signed
integers as&lt;/p&gt;

@({
    (:g-integer . &lt;lsb-bits&gt;)
})

&lt;p&gt;Where @(&#39;lsb-bits&#39;) is a list of Boolean expressions that represent the
two&#39;s complement bits of the number.  The bits are in lsb-first order, and the
last, most significant bit is the sign bit.  For instance, if @(&#39;p&#39;) is the
following @(&#39;:g-integer&#39;),&lt;/p&gt;

@({
    p = (:g-integer true   false   A &amp; B   false)
})

&lt;p&gt;Then @(&#39;p&#39;) represents a 4-bit, signed integer whose value is either 1 or 5,
depending on the value of @(&#39;A &amp; B&#39;).&lt;/p&gt;

&lt;p&gt;GL uses another kind of symbolic object to represent ACL2 Booleans.
In particular,&lt;/p&gt;

@({
    (:g-boolean . &lt;val&gt;)
})

&lt;p&gt;represents @(&#39;t&#39;) or @(&#39;nil&#39;), depending on the Boolean expression
@(&#39;&lt;val&gt;&#39;).  For example,&lt;/p&gt;

@({
     (:g-boolean . ~(A &amp; B))
})

&lt;p&gt;is a symbolic object whose value is @(&#39;t&#39;) when @(&#39;p&#39;) has value 1, and
@(&#39;nil&#39;) when @(&#39;p&#39;) has value 5.&lt;/p&gt;

&lt;p&gt;GL has a few other kinds of symbolic objects that are also tagged with
keywords, such as @(&#39;:g-var&#39;) and @(&#39;:g-apply&#39;).  But an ACL2 object
that does not have any of these special keywords within it is &lt;i&gt;also&lt;/i&gt;
considered to be a symbolic object, and just represents itself.  Furthermore, a
cons of two symbolic objects represents the cons of the two objects they
represent.  For instance,&lt;/p&gt;

@({
    (1 . (:g-boolean .  A &amp; B))
})

&lt;p&gt;represents either @(&#39;(1 . t)&#39;) or @(&#39;(1 . nil)&#39;).  Together, these
conventions allow GL to avoid lots of tagging as symbolic objects are
manipulated.&lt;/p&gt;

&lt;p&gt;One last kind of symbolic object we will mention represents an if-then-else
among other symbolic objects.  Its syntax is:&lt;/p&gt;

@({
     (:g-ite  &lt;test&gt;  &lt;then&gt;  .  &lt;else&gt;)
})

&lt;p&gt;where @(&#39;&lt;test&gt;&#39;), @(&#39;&lt;then&gt;&#39;), and @(&#39;&lt;else&gt;&#39;) are themselves symbolic
objects.  The value of a @(&#39;:g-ite&#39;) is either the value of @(&#39;&lt;then&gt;&#39;) or
of @(&#39;&lt;else&gt;&#39;), depending on the value of @(&#39;&lt;test&gt;&#39;).  For example,&lt;/p&gt;

@({
     (:g-ite  (:g-boolean . A)
              (:g-integer B  A  false)
              . #\C)
})

&lt;p&gt;represents either 2, 3, or the character @(&#39;C&#39;).&lt;/p&gt;

&lt;p&gt;GL doesn&#39;t have a special symbolic object format for ACL2 objects other than
numbers and Booleans.  But it is still possible to create symbolic objects that
take any finite range of values among ACL2 objects, by using a nesting of
@(&#39;:g-ite&#39;)s where the tests are @(&#39;:g-boolean&#39;)s.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |3. Computing with Symbolic Objects|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;Once we have a representation for symbolic objects, we can perform symbolic
executions on those objects.  For instance, recall the symbolic number @(&#39;p&#39;)
which can have value 1 or 5,&lt;/p&gt;

@({
    p = (:g-integer  true   false   A &amp; B   false)
})

&lt;p&gt;We might symbolically add 1 to @(&#39;p&#39;) to obtain a new symbolic number, say
@(&#39;q&#39;),&lt;/p&gt;

@({
    q = (:g-integer  false   true    A &amp; B   false)
})

&lt;p&gt;which represents either 2 or 6.  Suppose @(&#39;r&#39;) is another symbolic number,&lt;/p&gt;

@({
    r = (:g-integer  A   false   true   false)
})

&lt;p&gt;which represents either 4 or 5.  We might add @(&#39;q&#39;) and @(&#39;r&#39;) to obtain
@(&#39;s&#39;),&lt;/p&gt;

@({
    s = (:g-integer  A    true    ~(A &amp; B)    (A &amp; B)    false)
})

&lt;p&gt;whose value can be 6, 7, or 11.&lt;/p&gt;

&lt;p&gt;Why can&#39;t @(&#39;s&#39;) be 10 if @(&#39;q&#39;) can be 6 and @(&#39;r&#39;) can be 4?  This
combination isn&#39;t possible because @(&#39;q&#39;) and @(&#39;r&#39;) involve the same
expression, @(&#39;A&#39;).  The only way for @(&#39;r&#39;) to be 4 is for @(&#39;A&#39;) to be false,
but then @(&#39;q&#39;) must be 2.&lt;/p&gt;

&lt;p&gt;The underlying algorithm GL uses for symbolic additions is just a
ripple-carry addition on the Boolean expressions making up the bits of the two
numbers.  Performing a symbolic addition, then, means constructing new @(see
ubdds) or @(see aig)s, depending on which mode is being used.&lt;/p&gt;

&lt;p&gt;GL has built-in support for symbolically executing most ACL2 primitives.
Generally, this is done by cases on the types of the symbolic objects being
passed in as arguments.  For instance, if we want to symbolically execute @(see
consp) on @(&#39;s&#39;), then we are asking whether a @(&#39;:g-integer&#39;) may ever
represent a cons, so the answer is simply @(&#39;nil&#39;).  Similarly, if we ever try
to add a @(&#39;:g-boolean&#39;) to a @(&#39;:g-integer&#39;), by the ACL2 axioms the
@(&#39;:g-boolean&#39;) is simply treated as 0.&lt;/p&gt;

&lt;p&gt;Beyond these primitives, GL provides what is essentially a &lt;a
href=&#39;http://www-formal.stanford.edu/jmc/recursive.pdf&#39;&gt;McCarthy-style
interpreter&lt;/a&gt; for symbolically executing terms.  By default, it expands
function definitions until it reaches primitives, with some special handling
for @(see if).  For better performance, its interpretation scheme can be
customized with more efficient definitions and other @(see optimization)s.&lt;/p&gt;
"</span>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |4. Proving Theorems by Symbolic Execution|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;To see how symbolic execution can be used to prove theorems, let&#39;s return to
the bit-counting example, where our goal was to prove&lt;/p&gt;

@({
    (implies (unsigned-byte-p 32 x)
             (equal (fast-logcount-32 x)
                    (logcount x)))
})

&lt;p&gt;The basic idea is to first symbolically execute the above formula, and then
check whether it can ever evaluate to @(&#39;nil&#39;).  But to do this symbolic
execution, we need some symbolic object to represent @(&#39;x&#39;).&lt;/p&gt;

&lt;p&gt;We want our symbolic execution to cover all the cases necessary for proving
the theorem, namely all @(&#39;x&#39;) for which the hypothesis @(&#39;(unsigned-byte-p 32
x)&#39;) holds.  In other words, the symbolic object we choose needs to be able to
represent any integer from 0 to @(&#39;2^32 - 1&#39;).&lt;/p&gt;

&lt;p&gt;Many symbolic objects cover this range.  As notation, let @(&#39;b0, b1, ...&#39;)
represent independent Boolean variables in our Boolean expression
representation.  Then, one suitable object is:&lt;/p&gt;

@({
    Xinit = (:g-integer b0 b1 ... b31 b32).
})

&lt;p&gt;Why does this have 33 variables?  The final bit, @(&#39;b32&#39;), represents the
sign, so this object covers the integers from @(&#39;-2^32&#39;) to @(&#39;2^32 - 1&#39;).  We
could instead use a 34-bit integer, or a 35-bit integer, or some esoteric
creation involving @(&#39;:g-ite&#39;) forms.  But perhaps the best object to use would
be:&lt;/p&gt;

@({
   Xbest = (:g-integer b0 b1 ... b31 false).
})

&lt;p&gt;since it covers exactly the desired range using the simplest possible
Boolean expressions.&lt;/p&gt;

&lt;p&gt;Suppose we choose @(&#39;Xbest&#39;) to stand for @(&#39;x&#39;). We can now symbolically
execute the goal formula on that object.&lt;/p&gt;

&lt;p&gt;What does this involve?  First, @(&#39;(unsigned-byte-p 32 x)&#39;) produces the
symbolic result @(&#39;t&#39;), since it is always true of the possible values of
@(&#39;Xbest&#39;).  It would have been equally valid for this to produce
@(&#39;(:g-boolean . true)&#39;), but GL prefers to produce constants when
possible.&lt;/p&gt;

&lt;p&gt;Next, the @(&#39;(fast-logcount-32 x)&#39;) and @(&#39;(logcount x)&#39;) forms each yield
@(&#39;:g-integer&#39;) objects whose bits are Boolean expressions in the variables
@(&#39;b0, ..., b31&#39;).  For example, the least significant bit will be an
expression representing the XOR of all these variables.&lt;/p&gt;

&lt;p&gt;Finally, we symbolically execute @(see equal) on these two results.  This
compares the Boolean expressions for their bits to determine if they are
equivalent, and produces a symbolic object representing the answer.&lt;/p&gt;

&lt;p&gt;So far we have basically ignored the differences between using @(see ubdds)
or @(see aig)s as our Boolean expression representation.  But here, the two
approaches produce very different answers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Since UBDDs are canonical, the expressions for the bits of the two numbers
  are syntactically equal, and the result from @(see equal) is simply @(&#39;t&#39;).&lt;/li&gt;

&lt;li&gt;With AIGs, the expressions for the bits are semantically equivalent but not
  syntactically equal.  The result is therefore @(&#39;(:g-boolean . phi)&#39;), where
  @(&#39;phi&#39;) is a large Boolean expression in the variables @(&#39;b0, ..., b31&#39;).
  The fact that @(&#39;phi&#39;) always evaluates to @(&#39;t&#39;) is not obvious just from
  its syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this point we have completed the symbolic execution of our goal formula,
obtaining either @(&#39;t&#39;) in BDD mode, or this @(&#39;:g-boolean&#39;) object in AIG
mode.  Recall that to prove theorems using symbolic execution, the idea is to
symbolically execute the goal formula and then check whether its symbolic
result can represent @(&#39;nil&#39;).  If we are using BDDs, it is obvious that @(&#39;t&#39;)
cannot represent @(&#39;nil&#39;).  With AIGs, we simply ask a SAT solver whether
@(&#39;phi&#39;) can evaluate to @(&#39;false&#39;), and find that it cannot.  This completes
the proof.&lt;/p&gt;

&lt;p&gt;GL automates this proof strategy, taking care of many of the details
relating to creating symbolic objects, ensuring that they cover all the
possible cases, and ensuring that @(&#39;nil&#39;) cannot be represented by the
symbolic result.  When GL is asked to prove a non-theorem, it can generate
counterexamples by finding assignments to the Boolean variables that cause the
result to become @(&#39;nil&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |5. Using def-gl-thm|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;The @(see def-gl-thm) command is the main interface for using GL to prove
theorems.  Here is the command we used in the bit-counting example from @(csee
|1. An Example GL Proof|):&lt;/p&gt;

@({
    (def-gl-thm fast-logcount-32-correct
      :hyp   (unsigned-byte-p 32 x)
      :concl (equal (fast-logcount-32 x)
                    (logcount x))
      :g-bindings `((x ,(g-int 0 1 33))))
})

&lt;p&gt;Unlike an ordinary @(see defthm) command, @(see def-gl-thm) takes separate
hypothesis and conclusion terms (its @(&#39;hyp&#39;) and @(&#39;:concl&#39;) arguments).  This
separation allows GL to use the hypothesis to limit the scope of the symbolic
execution it will perform.  You also have to provide GL with @(&#39;:g-bindings&#39;)
that describe the symbolic objects to use for each free variable in the
theorem.&lt;/p&gt;

&lt;p&gt;What are these bindings?  In the @(&#39;fast-logcount-32-correct&#39;) theorem, we
used a convenient function, @(&#39;g-int&#39;), to construct the @(&#39;:g-bindings&#39;).
Expanding this away, here are the actual bindings:&lt;/p&gt;

@({
   ((x (:g-integer 0 1 2 ... 32)))
})

&lt;p&gt;The @(&#39;:g-bindings&#39;) argument uses a slight modification of the symbolic
object format where the Boolean expressions are replaced by distinct natural
numbers, each representing a Boolean variable.  In this case, our binding for
@(&#39;x&#39;) stands for the following symbolic object:&lt;/p&gt;

@({
    Xinit = (:g-integer b0 b1 ... b31 b32)
})

&lt;p&gt;Note that @(&#39;Xinit&#39;) is not the same object as @(&#39;Xbest&#39;) from @(see
|4. Proving Theorems by Symbolic Execution|)&amp;mdash;its sign bit is @(&#39;b32&#39;)
instead of @(&#39;false&#39;), so @(&#39;Xinit&#39;) can represent any 33-bit signed integer
whereas @(&#39;Xbest&#39;) only represents 32-bit unsigned values.  In fact, the
@(&#39;:g-bindings&#39;) syntax does not even allow us to describe objects like
@(&#39;Xbest&#39;), which has the constant @(&#39;false&#39;) instead of a variable as one of
its bits.&lt;/p&gt;

&lt;p&gt;There is a good reason for this restriction.  One of the steps in our proof
strategy is to prove &lt;b&gt;coverage&lt;/b&gt;: we need to show the symbolic objects we
are starting out with have a sufficient range of values to cover all cases for
which the hypothesis holds; more on this in @(see |7. Proving Coverage|).  The
restricted syntax permitted by @(&#39;:g-bindings&#39;) ensures that the range of
values represented by each symbolic object is easy to determine.  Because of
this, coverage proofs are usually automatic.&lt;/p&gt;

&lt;p&gt;Despite these restrictions, GL will still end up using @(&#39;Xbest&#39;) to carry
out the symbolic execution.  GL optimizes the original symbolic objects
inferred from the @(&#39;:g-bindings&#39;) by using the hypothesis to reduce the space
of objects that are represented.  In BDD mode this optimization uses &lt;a
href=&#39;http://dx.doi.org/10.1145/309847.309968&#39;&gt;BDD parametrization&lt;/a&gt;, which
restricts the symbolic objects so they cover exactly the inputs recognized by
the hypothesis.  In AIG mode we use a lighter-weight transformation that
replaces variables with constants when the hypothesis sufficiently restricts
them.  In this example, either optimization transforms @(&#39;Xinit&#39;) into
@(&#39;Xbest&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |6. Writing :g-bindings forms|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;In a typical @(see def-gl-thm) command, the @(&#39;:g-bindings&#39;) should have an
entry for every free variable in the theorem.  Here is an example that shows
some typical bindings.&lt;/p&gt;

@({
    :g-bindings &#39;((flag   (:g-boolean . 0))
                  (a-bus  (:g-integer 1 3 5 7 9))
                  (b-bus  (:g-integer 2 4 6 8 10))
                  (mode   (:g-ite (:g-boolean . 11) exact . fast))
                  (opcode #b0010100))
})

&lt;p&gt;These bindings allow @(&#39;flag&#39;) to take an arbitrary Boolean value,
@(&#39;a-bus&#39;) and @(&#39;b-bus&#39;) any five-bit signed integer values, @(&#39;mode&#39;) either
the symbol @(&#39;exact&#39;) or @(&#39;fast&#39;), and @(&#39;opcode&#39;) only the value 20.&lt;/p&gt;

&lt;p&gt;(Aside: Note that since @(&#39;#b0010100&#39;) is not within a @(&#39;:g-boolean&#39;) or
@(&#39;:g-integer&#39;) form, it is &lt;b&gt;not&lt;/b&gt; the index of a Boolean variable.
Instead, like the symbols @(&#39;exact&#39;) and @(&#39;fast&#39;), it is just an ordinary ACL2
constant that stands for itself, i.e., 20.)&lt;/p&gt;

&lt;p&gt;These @(&#39;:g-boolean&#39;) and @(&#39;:g-integer&#39;) are called @(see shape-specs).
They are similar to the symbolic objects GL uses to compute with, except that
natural number indices take the places of Boolean expressions.  The indices
used throughout all of the bindings must be distinct, and represent free,
independent Boolean variables.&lt;/p&gt;

&lt;p&gt;In BDD mode, these indices have additional meaning: they specify the BDD
variable ordering, with smaller indices coming first in the order.  This
ordering can greatly affect performance.  In AIG mode the choice of indices has
no particular bearing on efficiency.&lt;/p&gt;

&lt;p&gt;How do you choose a good BDD ordering?  It is often good to interleave the
bits of data buses that are going to be combined in some way.  It is also
typically a good idea to put any important control signals such as opcodes and
mode settings before the data buses.&lt;/p&gt;

&lt;p&gt;Often the same @(&#39;:g-bindings&#39;) can be used throughout several theorems,
either verbatim or with only small changes.  In practice, we almost always
generate the @(&#39;:g-bindings&#39;) forms by calling functions or macros.  One
convenient function is&lt;/p&gt;

@({(g-int start by n)})

&lt;p&gt;which generates a @(&#39;:g-integer&#39;) form with @(&#39;n&#39;) bits, using
indices that start at @(&#39;start&#39;) and increment by @(&#39;by&#39;).  This is
particularly useful for interleaving the bits of numbers, as we did for the
@(&#39;a-bus&#39;) and @(&#39;b-bus&#39;) bindings above:&lt;/p&gt;

@({
     (g-int 1 2 5)  ---&gt; (:g-integer 1 3 5 7 9)
     (g-int 2 2 5)  ---&gt; (:g-integer 2 4 6 8 10)
})

&lt;p&gt;Writing out @(&#39;:g-bindings&#39;) and getting all the indices can be tedious.
See @(see auto-bindings) for a convenient macro that helps ensure that all the
indices are different.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |7. Proving Coverage|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"

&lt;p&gt;There are really two parts to any GL theorem.  First, we need to
symbolically execute the goal formula and ensure it cannot evaluate to
@(&#39;nil&#39;).  But in addition to this, we must ensure that the objects we use to
represent the variables of the theorem cover all the cases that satisfy the
hypothesis.  This part of the proof is called the &lt;b&gt;coverage
obligation&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;For @(&#39;fast-logcount-32-correct&#39;), the coverage obligation is to show that
our binding for @(&#39;x&#39;) is able to represent every integer from 0 to @(&#39;2^32 -
1&#39;).  This is true of @(&#39;Xinit&#39;), and the coverage proof goes through
automatically.&lt;/p&gt;

&lt;p&gt;But suppose we forget that @(&#39;:g-integer&#39;)s use a signed representation, and
attempt to prove @(&#39;fast-logcount-32-correct&#39;) using the following (incorrect)
g-bindings.&lt;/p&gt;

@({
    :g-bindings `((x ,(g-int 0 1 32)))
})

&lt;p&gt;This looks like a 32-bit integer, but because of the sign bit it does not cover
the intended unsigned range.  If we submit the @(see def-gl-thm) command
with these bindings, the symbolic execution part of the proof is still successful.
But this execution has only really shown the goal holds for 31-bit unsigned
integers, so @(see def-gl-thm) prints the message&lt;/p&gt;

@({
     ERROR: Coverage proof appears to have failed.
})

&lt;p&gt;and leaves us with a failed subgoal,&lt;/p&gt;

@({
    (implies (and (integerp x)
                  (&lt;= 0 x)
                  (&lt; x 4294967296))
             (&lt; x 2147483648))
})

&lt;p&gt;This goal is clearly not provable: we are trying to show @(&#39;x&#39;) must be less
than @(&#39;2^31&#39;) (from our @(&#39;:g-bindings&#39;)) whenever it is less than
@(&#39;2^32&#39;) (from the hypothesis).&lt;/p&gt;

&lt;p&gt;Usually when the @(&#39;:g-bindings&#39;) are correct, the coverage proof will be
automatic, so if you see that a coverage proof has failed, the first thing to
do is check whether your bindings are really sufficient.&lt;/p&gt;

&lt;p&gt;On the other hand, proving coverage is undecidable in principle, so
sometimes GL will fail to prove coverage even though the bindings are
appropriate.  For these cases, there are some keyword arguments to @(see
def-gl-thm) that may help coverage proofs succeed.&lt;/p&gt;

&lt;p&gt;First, as a practical matter, GL does the symbolic execution part of the
proof &lt;b&gt;before&lt;/b&gt; trying to prove coverage.  This can get in the way of
debugging coverage proofs when the symbolic execution takes a long time.  You
can use @(&#39;:test-side-goals t&#39;) to have GL skip the symbolic execution and go
straight to the coverage proof.  Of course, no @(see defthm) is produced when
this option is used.&lt;/p&gt;

&lt;p&gt;By default, our coverage proof strategy uses a restricted set of rules and
ignores the current theory.  It heuristically expands functions in the
hypothesis and throws away terms that seem irrelevant.  When this strategy
fails, it is usually for one of two reasons.&lt;/p&gt;

&lt;ol&gt;

&lt;li&gt;The heuristics expand too many terms and overwhelm ACL2.  GL tries to avoid
this by throwing away irrelevant terms, but sometimes this approach is
insufficient.  It may be helpful to disable the expansion of functions that are
not important for proving coverage.  The @(&#39;:do-not-expand&#39;) argument allows
you to list functions that should not be expanded.&lt;/li&gt;

&lt;li&gt;The heuristics throw away a necessary hypothesis, leading to unprovable
goals.  GL&#39;s coverage proof strategy tries to show that the binding for each
variable is sufficient, one variable at a time.  During this process it throws
away hypotheses that do not mention the variable, but in some cases this can be
inappropriate.  For instance, suppose the following is a coverage goal for
@(&#39;b&#39;):

@({
    (implies (and (natp a)
                  (natp b)
                  (&lt; a (expt 2 15))
                  (&lt; b a))
             (&lt; b (expt 2 15)))
})

Here, throwing away the terms that don&#39;t mention @(&#39;b&#39;) will cause the proof to
fail.  A good way to avoid this problem is to separate type and size hypotheses
from more complicated assumptions that are not important for proving coverage,
along these lines:

@({
    (def-gl-thm my-theorem
      :hyp (and (type-assms-1 x)
                (type-assms-2 y)
                (type-assms-3 z)
                (complicated-non-type-assms x y z))
      :concl ...
      :g-bindings ...
      :do-not-expand &#39;(complicated-non-type-assms))
})

&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more control, you can also use the @(&#39;:cov-theory-add&#39;) argument to
enable additional rules during the coverage proof, e.g., @(&#39;:cov-theory-add
&#39;(type-rule1 type-rule2)&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-10" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc |8. Exercises|
  <span class="keyword">:parents</span> (basic-tutorial)
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Here are some exercises you can use to get some experience with
using GL.&lt;/p&gt;

&lt;p&gt;These exercises will get you into some rough spots, so that you can learn
how to get out.  If you get stuck, you can see our solutions in the file
@(&#39;centaur/gl/solutions.lsp&#39;).&lt;/p&gt;

&lt;p&gt;We recommend trying to carry out these exercises in a new file.  You will
probably want to start your file with:&lt;/p&gt;

@({
    (in-package &quot;ACL2&quot;)
    (include-book &quot;centaur/gl/gl&quot; :dir :system)
})

&lt;p&gt;At certain points in the exercises, we assume your computer has at least
&lt;b&gt;8 GB&lt;/b&gt; of memory.&lt;/p&gt;


&lt;h3&gt;Arithmetic Exercises&lt;/h3&gt;

&lt;p&gt;&lt;b&gt;1a.&lt;/b&gt; Use GL to prove that addition commutes for 4-bit unsigned
numbers:&lt;/p&gt;

@({
     (implies (and (unsigned-byte-p 4 x)
                   (unsigned-byte-p 4 y))
              (equal (+ x y) (+ y x)))
})

&lt;p&gt;&lt;b&gt;1b.&lt;/b&gt; Carry out the same proof as in 1a, but construct your
G-bindings:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Using @(see auto-bindings)&lt;/li&gt;
 &lt;li&gt;Using @(see g-int)&lt;/li&gt;
 &lt;li&gt;&quot;Manually&quot;, without using either of these.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hints: you may want to consult @(see |6. Writing :g-bindings forms|) and
@(see shape-specs).&lt;/p&gt;


&lt;p&gt;&lt;b&gt;1c.&lt;/b&gt; Extend your proof from 1a to 20-bit numbers.  How long does the
proof take?  How much memory did it use?  Try the @(see hons-summary) command
get a sense of the memory usage.&lt;/p&gt;


&lt;p&gt;&lt;b&gt;1d.&lt;/b&gt; In the same ACL2 session, undo your proof of 1c and submit it
again.  How long did it take this time?  Can you explain what happened?&lt;/p&gt;


&lt;p&gt;&lt;b&gt;1e.&lt;/b&gt; Figure out how to optimize your G-bindings to make the proof in
1c go through quickly.  For reliable timings, use @(see clear-memoize-tables)
and @(see hons-clear) before each proof attempt.  Implement your solution using
both @(see g-int) and @(see auto-bindings).&lt;/p&gt;


&lt;p&gt;&lt;b&gt;1f.&lt;/b&gt; Use GL to prove that addition commutes up to 3,000 bits.
Hint: the @(see debugging) section might be able to help you.&lt;/p&gt;


"</span>)</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = 'üåô';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>