<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>structures - ACL2 Book</title>
  <meta property="name" content="structures">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">structures</h1>
    <div class="path"><a href="structures.lisp" class="source-link">books/data-structures/structures</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"DEFSTRUCTURE"</span>)</pre>
  </div>

<div class="form-block other" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="utilities.html" title="Open utilities">"utilities"</a>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-program" data-sym="PROGRAM">program</a>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
  <span class="keyword">:parents</span> (data-structures)
  <span class="keyword">:short</span> <span class="string">"Define and characterize a general purpose record structure with typed
slots."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The on-line documentation only contains examples and a formal
syntax description. The complete documentation for DEFSTRUCTURE is a report
entitled &quot;DEFSTRUCTURE for ACL2.&quot; This report is distributed with the ACL2
release, and is also available from the &lt;a
href=&#39;http://www.cs.utexas.edu/users/moore/acl2&#39;&gt;ACL2 home page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

@({

 (DEFSTRUCTURE SHIP X-POSITION Y-POSITION X-VELOCITY Y-VELOCITY MASS)

 (DEFSTRUCTURE MC-STATE
   &quot;The state of the MC68020.&quot;
   (STATUS (:ASSERT (SYMBOLP STATUS) :TYPE-PRESCRIPTION))
   (RFILE  (:ASSERT (RFILEP RFILE) :REWRITE))
   (PC     (:ASSERT (LONGWORD-P PC) :REWRITE
                    (:TYPE-PRESCRIPTION (NATURALP PC))))
   (CCR    (:ASSERT (CCR-P CCR) :REWRITE
                    (:TYPE-PRESCRIPTION (NATURALP CCR))))
   (MEM    (:ASSERT (MEMORYP MEM) :REWRITE))

   (:OPTIONS :GUARDS (:CONC-NAME MC-)))

 (DEFSTRUCTURE S&amp;ADDR
   &quot;An MC68020 effective address abstraction.&quot;
   (S     (:ASSERT (MC-STATE-P S) :REWRITE))
   (LOC   (:ASSERT (SYMBOLP LOC)  :TYPE-PRESCRIPTION))
   (ADDR  (:ASSERT ((LAMBDA (LOC ADDR)
                      (CASE LOC
                        ((D A) (RN-NUMBERP ADDR))
                        ((M I) (LONGWORD-P ADDR))
                        (OTHERWISE (NULL ADDR))))
                    LOC ADDR)
                   (:REWRITE
                    (IMPLIES
                     (OR (EQUAL LOC &#39;D) (EQUAL LOC &#39;A))
                     (RN-NUMBERP ADDR)))
                   (:REWRITE
                    (IMPLIES
                     (OR (EQUAL LOC &#39;M) (EQUAL LOC &#39;I))
                     (LONGWORD-P ADDR)))))

   (:OPTIONS :GUARDS))

 (DEFSTRUCTURE V&amp;CVZNX
   &quot;An MC68020 value abstraction.&quot;
   (V     (:ASSERT (LONGWORD-P V) :REWRITE
                   (:TYPE-PRESCRIPTION (NATURALP V))))
   (CVZNX (:ASSERT (CCR-P CVZNX) :REWRITE
                   (:TYPE-PRESCRIPTION (NATURALP CVZNX))))

   ;;  These options make this nothing more than a typed CONS.

   (:OPTIONS :GUARDS (:REPRESENTATION (V . CVZNX)) (:DO-NOT :TAG)))
})

&lt;p&gt;Syntax:&lt;/p&gt;

@({
DEFSTRUCTURE name [documentation] {slot-and-options}* [option-list]

  option-list ::= (:OPTIONS [[options]])

  options ::= guards-option |
              verify-guards-option |
              slot-writers-option |
              inline-option
              conc-name-option |
              set-conc-name-option |
              keyword-constructor-option |
              keyword-updater-option |
              predicate-option |
              weak-predicate-option |
              force-option |
              representation-option |
              do-not-option |
              mv-intro-macro-option
              update-method-option |
              assertion-lemma-hints-option |
              predicate-guard-hints-option |
              prefix-option |
              {assert-option}*

  slot-and-options ::= slot-name | (slot-name [[slot-options]])

  slot-options ::= default-option |
                   read-only-option |
                   {assert-option}*

  default-option ::= :DEFAULT | (:DEFAULT) | (:DEFAULT slot-initform)

  read-only-option ::= :READ-ONLY

  assert-option ::= (:ASSERT assertion {assertion-rule-descriptor}*)

  assertion-rule-descriptor ::= rule-token |
                                (rule-token corollary [other-rule-forms])

  rule-token ::= NIL | :REWRITE | :LINEAR | :LINEAR-ALIAS |
                 :WELL-FOUNDED-RELATION | :BUILT-IN-CLAUSE |
                 :COMPOUND-RECOGNIZER | :ELIM | :GENERALIZE | :META |
                 :FORWARD-CHAINING | :EQUIVALENCE | :REFINEMENT |
                 :CONGRUENCE | :TYPE-PRESCRIPTION | :DEFINITION | :INDUCTION |
                 :TYPE-SET-INVERTER

  guards-option ::= :GUARDS

  verify-guards-option ::= :VERIFY-GUARDS | (:VERIFY-GUARDS) |
                           (:VERIFY-GUARDS T) | (:VERIFY-GUARDS NIL)

  slot-writers-option ::= :SLOT-WRITERS

  inline-option ::= :INLINE

  conc-name-option ::= :CONC-NAME | (:CONC-NAME) | (:CONC-NAME conc-name)

  set-conc-name-option ::= :SET-CONC-NAME | (:SET-CONC-NAME) |
                           (:SET-CONC-NAME set-conc-name)

  keyword-constructor-option ::= :KEYWORD-CONSTRUCTOR |
                                 (:KEYWORD-CONSTRUCTOR) |
                                 (:KEYWORD-CONSTRUCTOR keyword-constructor)

  keyword-updater-option ::= :KEYWORD-UPDATER | (:KEYWORD-UPDATER) |
                          (:KEYWORD-UPDATER keyword-updater)

  predicate-option ::=  :PREDICATE | (:PREDICATE) | (:PREDICATE predicate)

  weak-predicate-option ::=  :WEAK-PREDICATE | (:WEAK-PREDICATE) |
                             (:WEAK-PREDICATE weak-predicate)

  force-option ::= :FORCE

  do-not-option ::= (:DO-NOT [[do-not-options]])

  do-not-options ::= :TAG | :READ-WRITE | :WRITE-WRITE

  representation-option ::= :REPRESENTATION | (:REPRESENTATION) |
                            (:REPRESENTATION representation)

  representation ::= :LIST | :MV | :DOTTED-LIST | :TREE | template

  mv-intro-macro-option ::=  :MV-INTRO-MACRO |
                             (:MV-INTRO-MACRO) |
                             (:MV-INTRO-MACRO mv-intro-macro)

  update-method-option ::= :UPDATE-METHOD | (:UPDATE-METHOD) |
                           (:UPDATE-METHOD update-method)

  update-method ::= :HEURISTIC | :SET | :COPY

  assertion-lemma-hints-option ::=
    :ASSERTION-LEMMA-HINTS | (:ASSERTION-LEMMA-HINTS) |
    (:ASSERTION-LEMMA-HINTS hints)

  predicate-guard-hints-option ::=
    :PREDICATE-GUARD-HINTS | (:PREDICATE-GUARD-HINTS) |
    (:PREDICATE-GUARD-HINTS hints)

  prefix-option ::= :PREFIX | (:PREFIX) | (:PREFIX prefix)
})

&lt;p&gt;Arguments and Values:&lt;/p&gt;

@({
assertion -- a slots-assertion.

corollary -- a slots-assertion.

conc-name -- a string-designator.

documentation -- a string; not evaluated.

hints -- an acl2-hints.

keyword-constructor -- a symbol.

keyword-updater -- a symbol.

name -- a symbol.

mv-intro-macro -- a symbol.

other-rule-forms -- Some acl2-rule-forms.

predicate -- a symbol.

prefix -- a string-designator.

read-write-lemma -- a symbol.

set-conc-name -- a string-designator.

slot-initform -- a form; not evaluated.

slot-name -- a valid-slot-name.

tag -- a symbol.

template -- A slots-template.

weak-predicate -- a symbol.

write-write-lemma -- a symbol.
})

&lt;p&gt;Definitions:&lt;/p&gt;

@({
acl2-hints -- any form valid as the hints argument of defthm.  See the
documentation for HINTS in the ACL2 documentation.

acl2-rule-forms -- Any forms that would be valid in an ACL2 rule-classes
form, except for the rule class itself, or a corollary and formula.  See the
documentation for the DEFSTRUCTURE assertion theory in the DEFSTRUCTURE
document,and the ACL2 documentations for RULE-CLASSES.

slots-assertion -- DEFSTRUCTURE assertions are covered in the DEFSTRUCTURE
document.

slots-template -- A cons tree whose flattened form (by DEFSTRUCTURE::FLATTEN) is
a permutation of the list of slot names of the structure.

string-designator -- a character, string or symbol, it designates the string
obtained by (STRING STRING-DESIGNATOR) except that by convention the symbol
NIL designates the empty string.

valid-slot-name -- Any symbol valid for use as a formal parameter of a
function. This is any symbol not in the &quot;keyword&quot; package, neither T nor NIL,
neither beginning nor ending with `*&#39;, and not beginning with `&amp;&#39;.  In
addition, no slot-name may be the same as the structure name, and all
slot-names must have unique print names, i.e., it is illegal to duplicate
slot names, and it is illegal to use symbols from different packages that
have the same print name.
})"</span>)</pre>
  </div>

<div class="form-block macro" id="def-acons-up" data-defines="ACONS-UP" data-references="ACONS$,QUASIQUOTE,T,QUOTE,NULL,COND,FORMS,&REST,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACONS-UP">acons-up</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-acons-up" data-sym="ACONS-UP" title="(defmacro defstructure::acons-up (&amp;rest defstructure::forms)
  (cond ((null defstructure::forms) &#39;nil)
        (t
         `(defstructure::acons$ ,(caar defstructure::forms)
           ,(cadar defstructure::forms)">acons-up</a>
  (&amp;rest forms)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> forms) 'nil)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link local-def" href="#def-acons_24" data-sym="ACONS$" title="(defun defstructure::acons$
       (defstructure::key defstructure::datum defstructure::value)
  (cons (cons defstructure::key defstructure::datum) defstructure::value))">acons$</a> ,(CAAR DEFSTRUCTURE::FORMS)
        ,(CADAR DEFSTRUCTURE::FORMS)
        (<a class="sym-link local-def" href="#def-acons-up" data-sym="ACONS-UP" title="(defmacro defstructure::acons-up (&amp;rest defstructure::forms)
  (cond ((null defstructure::forms) &#39;nil)
        (t
         `(defstructure::acons$ ,(caar defstructure::forms)
           ,(cadar defstructure::forms)">acons-up</a> ,@(CDR DEFSTRUCTURE::FORMS))))))</pre>
  </div>

<div class="form-block macro" id="def-bomb-from" data-defines="BOMB-FROM" data-references="HARD,ER,QUASIQUOTE,ARGS,&REST,FMT,WHERE,DEFMACRO" data-used-by="KEYWORD-UPDATER-FN,KEYWORD-CONSTRUCTOR-FN,KEYWORD-SLOT-CHECKER,ACONS-DB,DB,DB-SLOT-FN,DB-FN,KEYWORDIFY-TREE,BOMB" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BOMB-FROM">bomb-from</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a>
  (where <a class="sym-link system" href="../../basis-a.html#def-fmt" data-sym="FMT">fmt</a>
    &amp;rest
    <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  `(<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
    ,DEFSTRUCTURE::WHERE
    ,DEFSTRUCTURE::FMT
    ,@DEFSTRUCTURE::ARGS))</pre>
  </div>

<div class="form-block macro" id="def-bomb" data-defines="BOMB" data-references="DEFSTRUCTURE,QUOTE,BOMB-FROM,QUASIQUOTE,ARGS,&REST,FMT,DEFMACRO" data-used-by="PREPARE-FOR-CODE-GEN,PARSE-DEFSTRUCTURE,GET-REPRESENTATION,PARSE-RULE,CHECK-ASSERTION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BOMB">bomb</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a>
  (<a class="sym-link system" href="../../basis-a.html#def-fmt" data-sym="FMT">fmt</a> &amp;rest <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  `(<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
    ,DEFSTRUCTURE::FMT
    ,@DEFSTRUCTURE::ARGS))</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> mlambda-fn-lst
    (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>) nil)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (mlambda-fn <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> (car <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>))
          (mlambda-fn-lst <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> (cdr <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>))))))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> mlambda-fn
    (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> form)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> form) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> form <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) form)
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> 'quote form))))
      ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car form) 'quote) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> 'quote form))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons '<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>
          (cons (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> 'quote (car form))
            (mlambda-fn-lst <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
              (cdr form))))))))</pre>
  </div>

<div class="form-block macro" id="def-mlambda" data-defines="MLAMBDA" data-references="MLAMBDA-FN,SYMBOL-LISTP,XARGS,DECLARE,FORM,ARGS,DEFMACRO" data-used-by="CONSTRUCTOR" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MLAMBDA">mlambda</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-mlambda" data-sym="MLAMBDA" title="(defmacro defstructure::mlambda (defstructure::args defstructure::form)
  &quot;A macro lambda that doesn&#39;t substitute function symbols or quoted
   constants.&quot;
  (declare
   (defstructure::xargs :guard
...">mlambda</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> form)
  <span class="string">"A macro lambda that doesn&#39;t substitute function symbols or quoted
   constants."</span>
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
  (mlambda-fn <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    form))</pre>
  </div>

<div class="form-block function" id="def-acons_24" data-defines="ACONS$" data-references="CONS,VALUE,DATUM,KEY,DEFUN" data-used-by="ACONS-DB,ACONS-UP" data-part-name="ACONS$" data-part-args="VALUE,DATUM,KEY" data-part-body="VALUE,DATUM,KEY,CONS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACONS$">acons$</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-acons_24" data-sym="ACONS$" title="(defun defstructure::acons$
       (defstructure::key defstructure::datum defstructure::value)
  (cons (cons defstructure::key defstructure::datum) defstructure::value))">acons$</a>
  (key datum <a class="sym-link system" href="../../axioms.html#def-value" data-sym="VALUE">value</a>)
  (cons (cons key datum)
    <a class="sym-link system" href="../../axioms.html#def-value" data-sym="VALUE">value</a>))</pre>
  </div>

<div class="form-block function" id="def-ncars" data-defines="NCARS" data-references="CDR,-,CAR,CONS,T,NULL,=,COND,L,N,DEFUN" data-used-by="FOLD" data-part-name="NCARS" data-part-args="L,N" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NCARS">ncars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ncars" data-sym="NCARS" title="(defun defstructure::ncars (defstructure::n defstructure::l)
  &quot;The 1st n CARs of l.&quot;
  (cond ((= defstructure::n 0) nil) ((null defstructure::l) nil)
        (t
         (cons (car defstructure::l)
...">ncars</a>
  (n l)
  <span class="string">"The 1st n CARs of l."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>) nil)
    ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> l) nil)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (car l)
        (<a class="sym-link local-def" href="#def-ncars" data-sym="NCARS" title="(defun defstructure::ncars (defstructure::n defstructure::l)
  &quot;The 1st n CARs of l.&quot;
  (cond ((= defstructure::n 0) nil) ((null defstructure::l) nil)
        (t
         (cons (car defstructure::l)
...">ncars</a> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>)
          (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-fold" data-defines="FOLD" data-references="NTHCDR,LENGTH,TRUNCATE,NCARS,CONS,T,CAR,CDR,NULL,COND,ARGS,DEFUN" data-used-by="MAKE-TEMPLATE" data-part-name="FOLD" data-part-args="ARGS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FOLD">fold</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fold" data-sym="FOLD" title="(defun defstructure::fold (defstructure::args)
  &quot;Folds a list into a somewhat balanced tree.&quot;
  (cond ((null defstructure::args) nil)
        ((null (cdr defstructure::args)) (car defstructure::args))
        (t
...">fold</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  <span class="string">"Folds a list into a somewhat balanced tree."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)
    ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> (cdr <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)) (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-fold" data-sym="FOLD" title="(defun defstructure::fold (defstructure::args)
  &quot;Folds a list into a somewhat balanced tree.&quot;
  (cond ((null defstructure::args) nil)
        ((null (cdr defstructure::args)) (car defstructure::args))
        (t
...">fold</a> (<a class="sym-link local-def" href="#def-ncars" data-sym="NCARS" title="(defun defstructure::ncars (defstructure::n defstructure::l)
  &quot;The 1st n CARs of l.&quot;
  (cond ((= defstructure::n 0) nil) ((null defstructure::l) nil)
        (t
         (cons (car defstructure::l)
...">ncars</a> (truncate (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">2</span>)
            <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
        (<a class="sym-link local-def" href="#def-fold" data-sym="FOLD" title="(defun defstructure::fold (defstructure::args)
  &quot;Folds a list into a somewhat balanced tree.&quot;
  (cond ((null defstructure::args) nil)
        ((null (cdr defstructure::args)) (car defstructure::args))
        (t
...">fold</a> (<a class="sym-link system" href="../../axioms.html#def-nthcdr" data-sym="NTHCDR">nthcdr</a> (truncate (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">2</span>)
            <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))))))</pre>
  </div>

<div class="form-block function" id="def-flatten" data-defines="FLATTEN" data-references="CDR,CAR,APPEND,LIST,T,NULL,ATOM,COND,ARGS,DEFUN" data-used-by="GET-REPRESENTATION,MV-INTRO-MACRO-FN,WRITE-WRITE-LEMMA,SIMPLE-SLOT-P" data-part-name="FLATTEN" data-part-args="ARGS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FLATTEN">flatten</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  <span class="string">"An `improper&#39; list flattener.  NIL is always flattened away."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
        (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> (cdr <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))))))</pre>
  </div>

<div class="form-block function" id="def-dotify" data-defines="DOTIFY" data-references="T,CADR,CAR,CONS,NULL,CDR,ATOM,COND,L,DEFUN" data-used-by="MAKE-TEMPLATE" data-part-name="DOTIFY" data-part-args="L" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DOTIFY">dotify</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-dotify" data-sym="DOTIFY" title="(defun defstructure::dotify (defstructure::l)
  &quot;Make the last CONS of l a `dotted pair&#39; if possible.&quot;
  (cond ((atom defstructure::l) defstructure::l)
        ((atom (cdr defstructure::l)) defstructure::l)
        ((atom (cdr (cdr defstructure::l)))
...">dotify</a>
  (l)
  <span class="string">"Make the last CONS of l a `dotted pair&#39; if possible."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> l) l)
    ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr l)) l)
    ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr (cdr l))) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> (cdr (cdr l))) (cons (car l) (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> l)))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> l)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (car l)
        (<a class="sym-link local-def" href="#def-dotify" data-sym="DOTIFY" title="(defun defstructure::dotify (defstructure::l)
  &quot;Make the last CONS of l a `dotted pair&#39; if possible.&quot;
  (cond ((atom defstructure::l) defstructure::l)
        ((atom (cdr defstructure::l)) defstructure::l)
        ((atom (cdr (cdr defstructure::l)))
...">dotify</a> (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-duplicates-equal" data-defines="DUPLICATES-EQUAL" data-references="T,ADD-TO-SET-EQUAL,CDR,CAR,MEMBER-EQUAL,ATOM,COND,LST,DEFUN" data-part-name="DUPLICATES-EQUAL" data-part-args="LST" data-part-body="T,DUPLICATES-EQUAL,ADD-TO-SET-EQUAL,CDR,CAR,MEMBER-EQUAL,LST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DUPLICATES-EQUAL">duplicates-equal</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-duplicates-equal" data-sym="DUPLICATES-EQUAL" title="(defun defstructure::duplicates-equal (defstructure::lst)
  (cond ((atom defstructure::lst) nil)
        ((defstructure::member-equal (car defstructure::lst)
          (cdr defstructure::lst))
         (defstructure::add-to-set-equal (car defstructure::lst)
...">duplicates-equal</a>
  (lst)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> lst) nil)
    ((<a class="sym-link system" href="../../axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (car lst)
       (cdr lst)) (<a class="sym-link system" href="../../axioms.html#def-add-to-set-equal" data-sym="ADD-TO-SET-EQUAL">add-to-set-equal</a> (car lst)
        (<a class="sym-link local-def" href="#def-duplicates-equal" data-sym="DUPLICATES-EQUAL" title="(defun defstructure::duplicates-equal (defstructure::lst)
  (cond ((atom defstructure::lst) nil)
        ((defstructure::member-equal (car defstructure::lst)
          (cdr defstructure::lst))
         (defstructure::add-to-set-equal (car defstructure::lst)
...">duplicates-equal</a> (cdr lst))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-duplicates-equal" data-sym="DUPLICATES-EQUAL" title="(defun defstructure::duplicates-equal (defstructure::lst)
  (cond ((atom defstructure::lst) nil)
        ((defstructure::member-equal (car defstructure::lst)
          (cdr defstructure::lst))
         (defstructure::add-to-set-equal (car defstructure::lst)
...">duplicates-equal</a> (cdr lst)))))</pre>
  </div>

<div class="form-block function" id="def-keywordify" data-defines="KEYWORDIFY" data-references="STRING,INTERN-IN-PACKAGE-OF-SYMBOL,STRING-DESIGNATOR,DEFUN" data-used-by="INLINE-UPDATE-FN,KEYWORDIFY-TREE" data-part-name="KEYWORDIFY" data-part-args="STRING-DESIGNATOR" data-part-body="STRING-DESIGNATOR,STRING,INTERN-IN-PACKAGE-OF-SYMBOL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORDIFY">keywordify</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a>
  (string-designator)
  (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> string-designator)
    <span class="keyword">:keyword</span>))</pre>
  </div>

<div class="form-block other" id="form-16" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop keywordify-list
  (l)
  (for ((x in l))
    (collect (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> x))))</pre>
  </div>

<div class="form-block function" id="def-keywordify-tree" data-defines="KEYWORDIFY-TREE" data-references="CDR,CAR,CONS,KEYWORDIFY,T,QUOTE,BOMB-FROM,SYMBOLP,NOT,ATOM,COND,TREE,DEFUN" data-used-by="SET-HEURISTIC" data-part-name="KEYWORDIFY-TREE" data-part-args="TREE" data-part-body="CDR,CAR,CONS,KEYWORDIFY,T,KEYWORDIFY-TREE,QUOTE,BOMB-FROM,SYMBOLP,NOT,TREE,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORDIFY-TREE">keywordify-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keywordify-tree" data-sym="KEYWORDIFY-TREE" title="(defun defstructure::keywordify-tree (defstructure::tree)
  (cond
   ((atom defstructure::tree)
    (cond ((not defstructure::tree) nil)
          ((not (symbolp defstructure::tree))
...">keywordify-tree</a>
  (tree)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> tree) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> tree) nil)
        ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp tree)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-keywordify-tree" data-sym="KEYWORDIFY-TREE" title="(defun defstructure::keywordify-tree (defstructure::tree)
  (cond
   ((atom defstructure::tree)
    (cond ((not defstructure::tree) nil)
          ((not (symbolp defstructure::tree))
...">keywordify-tree</a>
            <span class="string">"Bug. ~p0"</span>
            tree))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> tree))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-keywordify-tree" data-sym="KEYWORDIFY-TREE" title="(defun defstructure::keywordify-tree (defstructure::tree)
  (cond
   ((atom defstructure::tree)
    (cond ((not defstructure::tree) nil)
          ((not (symbolp defstructure::tree))
...">keywordify-tree</a> (car tree))
        (<a class="sym-link local-def" href="#def-keywordify-tree" data-sym="KEYWORDIFY-TREE" title="(defun defstructure::keywordify-tree (defstructure::tree)
  (cond
   ((atom defstructure::tree)
    (cond ((not defstructure::tree) nil)
          ((not (symbolp defstructure::tree))
...">keywordify-tree</a> (cdr tree))))))</pre>
  </div>

<div class="form-block other" id="form-18" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop keywordp-listp
  (l)
  (for ((x in l))
    (always (<a class="sym-link system" href="../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> x))))</pre>
  </div>

<div class="form-block other" id="form-19" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop list-all
  (l)
  (for ((x in l))
    (collect (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> x))))</pre>
  </div>

<div class="form-block other" id="form-20" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-string
  (l)
  (for ((x in l))
    (collect (<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> x))))</pre>
  </div>

<div class="form-block other" id="form-21" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop <a class="sym-link system" href="../../axioms.html#def-remove-strings" data-sym="REMOVE-STRINGS">remove-strings</a>
  (l)
  (for ((x in l))
    (unless (stringp x)
      (collect x))))</pre>
  </div>

<div class="form-block function" id="def-x-or-car-x" data-defines="X-OR-CAR-X" data-references="CAR,ATOM,IF,X,DEFUN" data-part-name="X-OR-CAR-X" data-part-args="X" data-part-body="CAR,X,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="X-OR-CAR-X">x-or-car-x</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-x-or-car-x" data-sym="X-OR-CAR-X" title="(defun defstructure::x-or-car-x (defstructure::x)
  (if (atom defstructure::x)
      defstructure::x
      (car defstructure::x)))">x-or-car-x</a>
  (x)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    x
    (car x)))</pre>
  </div>

<div class="form-block other" id="form-23" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-x-or-car-x
  (l)
  (for ((x in l))
    (collect (<a class="sym-link local-def" href="#def-x-or-car-x" data-sym="X-OR-CAR-X" title="(defun defstructure::x-or-car-x (defstructure::x)
  (if (atom defstructure::x)
      defstructure::x
      (car defstructure::x)))">x-or-car-x</a> x))))</pre>
  </div>

<div class="form-block function" id="def-x-or-cadr-x" data-defines="X-OR-CADR-X" data-references="CADR,IF,CDR,CONSP,AND,ATOM,OR,XARGS,DECLARE,X,DEFUN" data-part-name="X-OR-CADR-X" data-part-args="X" data-part-declare="CDR,CONSP,AND,X,ATOM,OR,XARGS,DECLARE" data-part-body="CADR,X,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="X-OR-CADR-X">x-or-cadr-x</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-x-or-cadr-x" data-sym="X-OR-CADR-X" title="(defun defstructure::x-or-cadr-x (defstructure::x)
  (declare
   (defstructure::xargs :guard
    (or (atom defstructure::x)
        (and (consp defstructure::x) (consp (cdr defstructure::x))))))
...">x-or-cadr-x</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x) (consp (cdr x))))))
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    x
    (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> x)))</pre>
  </div>

<div class="form-block other" id="form-25" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-x-or-cadr-x
  (l)
  (for ((x in l))
    (collect (<a class="sym-link local-def" href="#def-x-or-cadr-x" data-sym="X-OR-CADR-X" title="(defun defstructure::x-or-cadr-x (defstructure::x)
  (declare
   (defstructure::xargs :guard
    (or (atom defstructure::x)
        (and (consp defstructure::x) (consp (cdr defstructure::x))))))
...">x-or-cadr-x</a> x))))</pre>
  </div>

<div class="form-block function" id="def-designated-string" data-defines="DESIGNATED-STRING" data-references="STRING,T,NULL,COND,STRING-DESIGNATOR,DEFUN" data-used-by="GET-STRING-DESIGNATOR" data-part-name="DESIGNATED-STRING" data-part-args="STRING-DESIGNATOR" data-part-body="STRING,T,STRING-DESIGNATOR,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DESIGNATED-STRING">designated-string</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-designated-string" data-sym="DESIGNATED-STRING" title="(defun defstructure::designated-string (defstructure::string-designator)
  (cond ((null defstructure::string-designator) &quot;&quot;)
        (t (string defstructure::string-designator))))">designated-string</a>
  (string-designator)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> string-designator) <span class="string">""</span>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> string-designator))))</pre>
  </div>

<div class="form-block function" id="def-lambda-function-p" data-defines="LAMBDA-FUNCTION-P" data-references="SECOND,LAMBDA,QUOTE,FIRST,LENGTH,EQUAL,TRUE-LISTP,AND,X,DEFUN" data-part-name="LAMBDA-FUNCTION-P" data-part-args="X" data-part-body="SECOND,LAMBDA,QUOTE,FIRST,LENGTH,EQUAL,X,TRUE-LISTP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LAMBDA-FUNCTION-P">lambda-function-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lambda-function-p" data-sym="LAMBDA-FUNCTION-P" title="(defun defstructure::lambda-function-p (defstructure::x)
  (and (defstructure::true-listp defstructure::x)
       (equal (length defstructure::x) 3)
       (equal (first defstructure::x) &#39;lambda)
       (defstructure::true-listp (second defstructure::x))))">lambda-function-p</a>
  (x)
  (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x)
    (equal (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> x) <span class="number">3</span>)
    (equal (<a class="sym-link system" href="../../axioms.html#def-first" data-sym="FIRST">first</a> x) 'lambda)
    (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (<a class="sym-link system" href="../../axioms.html#def-second" data-sym="SECOND">second</a> x))))</pre>
  </div>

<div class="form-block other" id="form-28" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> assertion-termp
    (term)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> term) <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)
      ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car term) 'quote) <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (symbolp (car term))
            (<a class="sym-link local-def" href="#def-lambda-function-p" data-sym="LAMBDA-FUNCTION-P" title="(defun defstructure::lambda-function-p (defstructure::x)
  (and (defstructure::true-listp defstructure::x)
       (equal (length defstructure::x) 3)
       (equal (first defstructure::x) &#39;lambda)
       (defstructure::true-listp (second defstructure::x))))">lambda-function-p</a> (car term)))
          (assertion-termp-list (cdr term))))))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> assertion-termp-list
    (l)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> l) (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> l))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (assertion-termp (car l))
          (assertion-termp-list (cdr l)))))))</pre>
  </div>

<div class="form-block other" id="form-29" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> reason-for-not-assertion-termp
    (term)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> term) nil)
      ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car term) 'quote) nil)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (symbolp (car term))
            (<a class="sym-link local-def" href="#def-lambda-function-p" data-sym="LAMBDA-FUNCTION-P" title="(defun defstructure::lambda-function-p (defstructure::x)
  (and (defstructure::true-listp defstructure::x)
       (equal (length defstructure::x) 3)
       (equal (first defstructure::x) &#39;lambda)
       (defstructure::true-listp (second defstructure::x))))">lambda-function-p</a> (car term)))
          (reason-for-not-assertion-termp-list (cdr term))
          (<a class="sym-link system" href="../../axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the CAR of ~p0 is neither a symbol nor a LAMBDA function."</span>
            term)))))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> reason-for-not-assertion-termp-list
    (l)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> l) (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> l)
          (<a class="sym-link system" href="../../axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"it contains an `improper&#39; list terminated by the atom ~
                        ~p0."</span>
            l)))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (reason-for-not-assertion-termp (car l))
          (reason-for-not-assertion-termp-list (cdr l)))))))</pre>
  </div>

<div class="form-block other" id="form-30" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> free-vars1
    (term ans)
    <span class="string">"A free variable is a symbol that is not a constant, i.e., it excludes T,
    NIL, and *CONST* etc."</span>
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> term) (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (symbolp term)
            (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../basis-a.html#def-legal-variable-or-constant-namep" data-sym="LEGAL-VARIABLE-OR-CONSTANT-NAMEP">legal-variable-or-constant-namep</a> term)
                'constant)))
          (<a class="sym-link system" href="../../axioms.html#def-add-to-set-eq" data-sym="ADD-TO-SET-EQ">add-to-set-eq</a> term
            ans)
          ans))
      ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car term) 'quote) ans)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (free-vars1-lst (cdr term)
          ans))))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> free-vars1-lst
    (terms ans)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> terms) ans)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (free-vars1-lst (cdr terms)
          (free-vars1 (car terms)
            ans))))))</pre>
  </div>

<div class="form-block function" id="def-free-vars" data-defines="FREE-VARS" data-references="QUOTE,FREE-VARS1,TERM,DEFUN" data-used-by="CHECK-ASSERTION" data-part-name="FREE-VARS" data-part-args="TERM" data-part-body="QUOTE,TERM,FREE-VARS1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FREE-VARS">free-vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-free-vars" data-sym="FREE-VARS" title="(defun defstructure::free-vars (defstructure::term)
  (defstructure::free-vars1 defstructure::term &#39;nil))">free-vars</a>
  (term)
  (free-vars1 term 'nil))</pre>
  </div>

<div class="form-block other" id="form-32" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link system" href="../../rewrite.html#def-subst-expr" data-sym="SUBST-EXPR">subst-expr</a>
    (new old term)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((equal term old) new)
      ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> term) term)
      ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car term) 'quote) term)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (car term)
          (subst-expr-lst new
            old
            (cdr term))))))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> subst-expr-lst
    (new old <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="../../rewrite.html#def-subst-expr" data-sym="SUBST-EXPR">subst-expr</a> new
            old
            (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
          (subst-expr-lst new
            old
            (cdr <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-subst-expr-all" data-defines="SUBST-EXPR-ALL" data-references="CDR,CAR,SUBST-EXPR,T,ATOM,COND,OLD-LIST,NEW-LIST,TERM,DEFUN" data-used-by="CHECK-ASSERTION" data-part-name="SUBST-EXPR-ALL" data-part-args="OLD-LIST,NEW-LIST,TERM" data-part-body="CDR,NEW-LIST,CAR,SUBST-EXPR,SUBST-EXPR-ALL,T,TERM,OLD-LIST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EXPR-ALL">subst-expr-all</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-expr-all" data-sym="SUBST-EXPR-ALL" title="(defun defstructure::subst-expr-all
       (defstructure::term defstructure::new-list defstructure::old-list)
  (cond ((atom defstructure::old-list) defstructure::term)
        (t
         (defstructure::subst-expr-all
...">subst-expr-all</a>
  (term new-list
    old-list)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> old-list) term)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subst-expr-all" data-sym="SUBST-EXPR-ALL" title="(defun defstructure::subst-expr-all
       (defstructure::term defstructure::new-list defstructure::old-list)
  (cond ((atom defstructure::old-list) defstructure::term)
        (t
         (defstructure::subst-expr-all
...">subst-expr-all</a> (<a class="sym-link system" href="../../rewrite.html#def-subst-expr" data-sym="SUBST-EXPR">subst-expr</a> (car new-list)
          (car old-list)
          term)
        (cdr new-list)
        (cdr old-list)))))</pre>
  </div>

<div class="form-block other" id="form-34" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-logic" data-sym="LOGIC">logic</a>)</pre>
  </div>

<div class="form-block other" id="form-35" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> open-mv-nth
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp n)
        (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car n) 'quote)))
    (equal (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> n l)
      (if (<a class="sym-link system" href="../../axioms.html#def-zp" data-sym="ZP">zp</a> n)
        (car l)
        (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> (<a class="sym-link system" href="../../axioms.html#def-1-" data-sym="1-">1-</a> n)
          (cdr l)))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a>))))</pre>
  </div>

<div class="form-block other" id="form-36" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable open-mv-nth))</pre>
  </div>

<div class="form-block other" id="form-37" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-program" data-sym="PROGRAM">program</a>)</pre>
  </div>

<div class="form-block other" id="form-38" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *db-fields*
  '(<span class="keyword">:acl2-count-lemma</span> <span class="keyword">:assertions</span> <span class="keyword">:assertion-lemma</span> <span class="keyword">:assertion-lemma-hints</span> <span class="keyword">:conc-name</span> <span class="keyword">:constructor-call</span> <span class="keyword">:definition-theory</span> <span class="keyword">:doc</span> <span class="keyword">:elimination-lemma</span> <span class="keyword">:force</span> <span class="keyword">:guards</span> <span class="keyword">:inline</span> <span class="keyword">:intro-macro</span> <span class="keyword">:keyword-constructor</span> <span class="keyword">:keyword-slot-names</span> <span class="keyword">:keyword-updater</span> <span class="keyword">:lemma-theory</span> <span class="keyword">:lift-if-lemma</span> <span class="keyword">:mv-intro-macro</span> <span class="keyword">:name</span> <span class="keyword">:predicate</span> <span class="keyword">:predicate-call</span> <span class="keyword">:predicate-constructor-lemma</span> <span class="keyword">:predicate-slot-writers-lemma</span> <span class="keyword">:predicate-guard-hints</span> <span class="keyword">:predicate-weak-predicate-lemma</span> <span class="keyword">:prefix</span> <span class="keyword">:read-lemma</span> <span class="keyword">:read-only</span> <span class="keyword">:read-write</span> <span class="keyword">:read-write-lemma</span> <span class="keyword">:representation</span> <span class="keyword">:required-slot-names</span> <span class="keyword">:set-conc-name</span> <span class="keyword">:slot-names</span> <span class="keyword">:tag</span> <span class="keyword">:template</span> <span class="keyword">:update-method</span> <span class="keyword">:value-variable</span> <span class="keyword">:value-variable1</span> <span class="keyword">:verify-guards</span> <span class="keyword">:weak-predicate</span> <span class="keyword">:weak-predicate-call</span> <span class="keyword">:weak-predicate-constructor-lemma</span> <span class="keyword">:weak-predicate-slot-writers-lemma</span> <span class="keyword">:write-lemma</span> <span class="keyword">:write-write</span> <span class="keyword">:write-write-lemma</span>))</pre>
  </div>

<div class="form-block other" id="form-39" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *db-slot-fields*
  '(<span class="keyword">:assertions</span> <span class="keyword">:default</span> <span class="keyword">:default-specified</span> <span class="keyword">:reader</span> <span class="keyword">:reader-call</span> <span class="keyword">:read-only</span> <span class="keyword">:writer</span> <span class="keyword">:writer-call</span>))</pre>
  </div>

<div class="form-block other" id="form-40" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *function-names*
  `(<span class="keyword">:name</span> <span class="keyword">:predicate</span> <span class="keyword">:weak-predicate</span>))</pre>
  </div>

<div class="form-block other" id="form-41" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *slot-function-names*
  '(<span class="keyword">:reader</span> <span class="keyword">:writer</span>))</pre>
  </div>

<div class="form-block other" id="form-42" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *macro-names*
  '(<span class="keyword">:keyword-constructor</span> <span class="keyword">:keyword-updater</span>))</pre>
  </div>

<div class="form-block other" id="form-43" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *lemma-names*
  '(<span class="keyword">:acl2-count-lemma</span> <span class="keyword">:assertion-lemma</span> <span class="keyword">:elimination-lemma</span> <span class="keyword">:lift-if-lemma</span> <span class="keyword">:predicate-constructor-lemma</span> <span class="keyword">:predicate-slot-writers-lemma</span> <span class="keyword">:predicate-weak-predicate-lemma</span> <span class="keyword">:read-lemma</span> <span class="keyword">:read-write-lemma</span> <span class="keyword">:weak-predicate-constructor-lemma</span> <span class="keyword">:weak-predicate-slot-writers-lemma</span> <span class="keyword">:write-lemma</span> <span class="keyword">:write-write-lemma</span>))</pre>
  </div>

<div class="form-block function" id="def-db-fn" data-defines="DB-FN" data-references="QUOTE,BOMB-FROM,T,CDR,COND,ASSOC,PAIR,LET,DB,FORM,KEY,DEFUN" data-used-by="DB" data-part-name="DB-FN" data-part-args="DB,FORM,KEY" data-part-body="FORM,DB-FN,QUOTE,BOMB-FROM,T,CDR,COND,DB,KEY,ASSOC,PAIR,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DB-FN">db-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-db-fn" data-sym="DB-FN" title="(defun defstructure::db-fn
       (defstructure::key defstructure::form defstructure::db)
  (let ((defstructure::pair (assoc defstructure::key defstructure::db)))
    (cond (defstructure::pair (cdr defstructure::pair))
          (t
...">db-fn</a>
  (key form <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (let ((pair (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> key <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (pair (cdr pair))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-db-fn" data-sym="DB-FN" title="(defun defstructure::db-fn
       (defstructure::key defstructure::form defstructure::db)
  (let ((defstructure::pair (assoc defstructure::key defstructure::db)))
    (cond (defstructure::pair (cdr defstructure::pair))
          (t
...">db-fn</a>
          <span class="string">"Key not present at runtime: ~p0."</span>
          form)))))</pre>
  </div>

<div class="form-block function" id="def-db-slot-fn" data-defines="DB-SLOT-FN" data-references="QUOTE,BOMB-FROM,T,CDR,COND,CONS,ASSOC-EQUAL,PAIR,LET,DB,FORM,KEY,SLOT,DEFUN" data-used-by="DB" data-part-name="DB-SLOT-FN" data-part-args="DB,FORM,KEY,SLOT" data-part-body="FORM,DB-SLOT-FN,QUOTE,BOMB-FROM,T,CDR,COND,DB,KEY,SLOT,CONS,ASSOC-EQUAL,PAIR,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DB-SLOT-FN">db-slot-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-db-slot-fn" data-sym="DB-SLOT-FN" title="(defun defstructure::db-slot-fn
       (defstructure::slot defstructure::key defstructure::form
        defstructure::db)
  (let ((defstructure::pair
         (defstructure::assoc-equal (cons defstructure::slot defstructure::key)
...">db-slot-fn</a>
  (slot key
    form
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (let ((pair (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (cons slot key)
         <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (pair (cdr pair))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-db-slot-fn" data-sym="DB-SLOT-FN" title="(defun defstructure::db-slot-fn
       (defstructure::slot defstructure::key defstructure::form
        defstructure::db)
  (let ((defstructure::pair
         (defstructure::assoc-equal (cons defstructure::slot defstructure::key)
...">db-slot-fn</a>
          <span class="string">"Key not present at runtime: ~p0."</span>
          form)))))</pre>
  </div>

<div class="form-block macro" id="def-db" data-defines="DB" data-references="DB-SLOT-FN,*DB-SLOT-FIELDS*,CADR,DB-FN,QUASIQUOTE,T,QUOTE,BOMB-FROM,*DB-FIELDS*,CAR,MEMBER,NOT,COND,LENGTH,CASE,ARGS,&REST,FORM,&WHOLE,DEFMACRO" data-used-by="DEFSTRUCTURE,PREPARE-FOR-CODE-GEN,PARSE-DEFSTRUCTURE,PARSE-RULE,CHECK-ASSERTION,LEMMA-THEORY,DEFINITION-THEORY,MV-INTRO-MACRO,NAKED-PROOFS,ALL-RULE-CLASSES,WRITE-WRITE-LEMMA,READ-WRITE-LEMMA,SLOT-WRITERS-LEMMAS,SIMPLE-SLOT-P,ALL-BOUND-SLOTS,ELIMINATION-LEMMA,LIFT-IF-LEMMA,LIFT-IF-LEMMA-FN,WRITE-LEMMA,READ-LEMMA,KEYWORD-UPDATER,WRITERS,READERS,KEYWORD-CONSTRUCTOR,PREDICATE,PREDICATE-ASSERTIONS-EXPLICIT,PREDICATE-BODY,WEAK-PREDICATE,CONSTRUCTOR,GUARD-DECLARATION,MAKE-TEMPLATE,MAKE-PREFIX-NAME,MAKE-COROLLARY,EXTEND-DB,APPEND-DB,ACONS-DB,DB-SLOT-FN,DB-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DB">db</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>
  (&amp;whole form &amp;rest <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (<a class="sym-link system" href="../../axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<span class="number">1</span> (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) *db-fields*)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>
            <span class="string">"Unrecognized field: ~p0"</span>
            form))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link local-def" href="#def-db-fn" data-sym="DB-FN" title="(defun defstructure::db-fn
       (defstructure::key defstructure::form defstructure::db)
  (let ((defstructure::pair (assoc defstructure::key defstructure::db)))
    (cond (defstructure::pair (cdr defstructure::pair))
          (t
...">db-fn</a> ,(CAR DEFSTRUCTURE::ARGS)
            ',DEFSTRUCTURE::FORM
            <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))))
    (<span class="number">2</span> (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
             *db-slot-fields*)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>
            <span class="string">"Unrecognized slot field: ~p0"</span>
            form))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link local-def" href="#def-db-slot-fn" data-sym="DB-SLOT-FN" title="(defun defstructure::db-slot-fn
       (defstructure::slot defstructure::key defstructure::form
        defstructure::db)
  (let ((defstructure::pair
         (defstructure::assoc-equal (cons defstructure::slot defstructure::key)
...">db-slot-fn</a> ,(CAR DEFSTRUCTURE::ARGS)
            ,(CADR DEFSTRUCTURE::ARGS)
            ',DEFSTRUCTURE::FORM
            <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> <span class="string">"DB coded with wrong # of args: ~p0"</span>
        form))))</pre>
  </div>

<div class="form-block macro" id="def-acons-db" data-defines="ACONS-DB" data-references="ACONS$,LET,QUASIQUOTE,BOMB-FROM,*DB-FIELDS*,CAAR,MEMBER,NOT,T,DB,QUOTE,NULL,COND,FORMS,&REST,DEFMACRO" data-used-by="PREPARE-FOR-CODE-GEN,PARSE-DEFSTRUCTURE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACONS-DB">acons-db</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a>
  (&amp;rest forms)
  <span class="string">"Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> forms) '<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> forms)
             *db-fields*)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a>
            <span class="string">"Unrecognized field: ~p0"</span>
            (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> forms)))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(let ((<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> (<a class="sym-link local-def" href="#def-acons_24" data-sym="ACONS$" title="(defun defstructure::acons$
       (defstructure::key defstructure::datum defstructure::value)
  (cons (cons defstructure::key defstructure::datum) defstructure::value))">acons$</a> ,(CAAR DEFSTRUCTURE::FORMS)
                 ,(CADAR DEFSTRUCTURE::FORMS)
                 <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
            (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> ,@(CDR DEFSTRUCTURE::FORMS))))))))</pre>
  </div>

<div class="form-block macro" id="def-append-db" data-defines="APPEND-DB" data-references="APPEND,LET,QUASIQUOTE,T,DB,QUOTE,NULL,COND,FORMS,&REST,DEFMACRO" data-used-by="PREPARE-FOR-CODE-GEN,PARSE-DEFSTRUCTURE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="APPEND-DB">append-db</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a>
  (&amp;rest forms)
  <span class="string">"APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> forms) '<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(let ((<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> ,(CAR DEFSTRUCTURE::FORMS) <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
        (<a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a> ,@(CDR DEFSTRUCTURE::FORMS))))))</pre>
  </div>

<div class="form-block macro" id="def-extend-db" data-defines="EXTEND-DB" data-references="LET,QUASIQUOTE,T,DB,QUOTE,NULL,COND,FORMS,&REST,DEFMACRO" data-used-by="PREPARE-FOR-CODE-GEN,PARSE-DEFSTRUCTURE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-DB">extend-db</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-extend-db" data-sym="EXTEND-DB" title="(defmacro defstructure::extend-db (&amp;rest defstructure::forms)
  &quot;Evaluate each form in the context of the DB that successive forms
   created.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">extend-db</a>
  (&amp;rest forms)
  <span class="string">"Evaluate each form in the context of the DB that successive forms
   created."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> forms) '<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(let ((<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> ,(CAR DEFSTRUCTURE::FORMS)))
        (<a class="sym-link local-def" href="#def-extend-db" data-sym="EXTEND-DB" title="(defmacro defstructure::extend-db (&amp;rest defstructure::forms)
  &quot;Evaluate each form in the context of the DB that successive forms
   created.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">extend-db</a> ,@(CDR DEFSTRUCTURE::FORMS))))))</pre>
  </div>

<div class="form-block other" id="form-50" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop db-let-fn
  (fields)
  (for ((field in fields))
    (collect (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp field) `(,DEFSTRUCTURE::FIELD (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> ,(DEFSTRUCTURE::KEYWORDIFY DEFSTRUCTURE::FIELD))))
        ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp field)
           (consp (cdr field))
           (symbolp (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> field))) `(,(CADR DEFSTRUCTURE::FIELD) (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> ,(CAR DEFSTRUCTURE::FIELD)
              ,(DEFSTRUCTURE::KEYWORDIFY (CADR DEFSTRUCTURE::FIELD)))))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> 'db-let-fn
            <span class="string">"Illegal field: ~p0"</span>
            field))))))</pre>
  </div>

<div class="form-block macro" id="def-db-let" data-defines="DB-LET" data-references="LET,QUASIQUOTE,FORMS,&REST,FIELDS,DEFMACRO" data-used-by="DEFSTRUCTURE,PREPARE-FOR-CODE-GEN,CHECK-ASSERTION,LEMMA-THEORY,DEFINITION-THEORY,MV-INTRO-MACRO,NAKED-PROOFS,ALL-RULE-CLASSES,WRITE-WRITE-LEMMA,READ-WRITE-LEMMA,SLOT-WRITERS-LEMMAS,SIMPLE-SLOT-P,ELIMINATION-LEMMA,LIFT-IF-LEMMA,WRITE-LEMMA,READ-LEMMA,KEYWORD-UPDATER,WRITERS,READERS,KEYWORD-CONSTRUCTOR,PREDICATE,PREDICATE-ASSERTIONS-EXPLICIT,PREDICATE-BODY,WEAK-PREDICATE,CONSTRUCTOR,GUARD-DECLARATION,MAKE-TEMPLATE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DB-LET">db-let</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a>
  (fields &amp;rest forms)
  <span class="string">"This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field)."</span>
  `(let ,(DEFSTRUCTURE::DB-LET-FN DEFSTRUCTURE::FIELDS)
    ,@DEFSTRUCTURE::FORMS))</pre>
  </div>

<div class="form-block other" id="form-52" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-slots-db
  (slot-names key
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Return a list in SLOT order of the indicated key."</span>
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-slot-fn" data-sym="DB-SLOT-FN" title="(defun defstructure::db-slot-fn
       (defstructure::slot defstructure::key defstructure::form
        defstructure::db)
  (let ((defstructure::pair
         (defstructure::assoc-equal (cons defstructure::slot defstructure::key)
...">db-slot-fn</a> slot
        key
        `(map-slots-db on
          ,DEFSTRUCTURE::SLOT
          ,DEFSTRUCTURE::KEY)
        <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))))</pre>
  </div>

<div class="form-block other" id="form-53" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-if-slots-db
  (slot-names key
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Return a list in SLOT order of the indicated key if non-NIL."</span>
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (let ((val (<a class="sym-link local-def" href="#def-db-slot-fn" data-sym="DB-SLOT-FN" title="(defun defstructure::db-slot-fn
       (defstructure::slot defstructure::key defstructure::form
        defstructure::db)
  (let ((defstructure::pair
         (defstructure::assoc-equal (cons defstructure::slot defstructure::key)
...">db-slot-fn</a> slot
             key
             `(map-if-slots-db on
               ,DEFSTRUCTURE::SLOT
               ,DEFSTRUCTURE::KEY)
             <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
        (if val
          (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> val)
          nil)))))</pre>
  </div>

<div class="form-block other" id="form-54" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> assertion
  (assertion bound-slots
    subst-assertion
    slot
    rules)
  nil)</pre>
  </div>

<div class="form-block other" id="form-55" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> rule
  (assertion rule-class)
  nil)</pre>
  </div>

<div class="form-block other" id="form-56" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop required-slot-names
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"A slot is required by the constructor macro if no default was specified."</span>
  (for ((slot in
       slot-names))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:default-specified</span>)
      (collect (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> slot)))))</pre>
  </div>

<div class="form-block function" id="def-make-corollary" data-defines="MAKE-COROLLARY" data-references="IMPLIES,QUASIQUOTE,IF,HYP,PREDICATE-CALL,FORCE,LET*,DB,ASSERTION,DEFUN" data-part-name="MAKE-COROLLARY" data-part-args="DB,ASSERTION" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-COROLLARY">make-corollary</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-corollary" data-sym="MAKE-COROLLARY" title="(defun defstructure::make-corollary (defstructure::assertion defstructure::db)
  &quot;Create the :COROLLARY rule for the assertion.&quot;
  (let* ((defstructure::force (defstructure::db :force))
         (defstructure::predicate-call (defstructure::db :predicate-call))
         (defstructure::hyp
...">make-corollary</a>
  (assertion <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Create the :COROLLARY rule for the assertion."</span>
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((<a class="sym-link system" href="../../axioms.html#def-force" data-sym="FORCE">force</a> (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:force</span>)) (predicate-call (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:predicate-call</span>))
      (hyp (if <a class="sym-link system" href="../../axioms.html#def-force" data-sym="FORCE">force</a>
          `(<a class="sym-link system" href="../../axioms.html#def-force" data-sym="FORCE">force</a> ,DEFSTRUCTURE::PREDICATE-CALL)
          predicate-call)))
    `(<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::HYP
      ,(DEFSTRUCTURE::ACCESS DEFSTRUCTURE::ASSERTION DEFSTRUCTURE::ASSERTION
  :SUBST-ASSERTION))))</pre>
  </div>

<div class="form-block macro" id="def-make-prefix-name" data-defines="MAKE-PREFIX-NAME" data-references="DB,PACK-INTERN,QUASIQUOTE,NAMES,&REST,DEFMACRO" data-used-by="PREPARE-FOR-CODE-GEN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-PREFIX-NAME">make-prefix-name</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a>
  (&amp;rest names)
  `(pack-intern (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:name</span>)
    (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:prefix</span>)
    ,@DEFSTRUCTURE::NAMES))</pre>
  </div>

<div class="form-block function" id="def-make-template" data-defines="MAKE-TEMPLATE" data-references="CONS,IF,T,FOLD,DOTIFY,CASE,TEMPLATE,LET,TAG,SLOT-NAMES,REPRESENTATION,DB-LET,DB,DEFUN" data-used-by="PREPARE-FOR-CODE-GEN" data-part-name="MAKE-TEMPLATE" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-TEMPLATE">make-template</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-template" data-sym="MAKE-TEMPLATE" title="(defun defstructure::make-template (defstructure::db)
  &quot;Using the :SLOT-NAMES, :REPRESENTATION, and :TAG, make a template for
   function generation.  If the structure is tagged, the tag is always added
   as the CAR.  We know that the :TAG is a symbol, and that the
   :REPRSENTATION is of the proper form.&quot;
...">make-template</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Using the :SLOT-NAMES, :REPRESENTATION, and :TAG, make a template for
   function generation.  If the structure is tagged, the tag is always added
   as the CAR.  We know that the :TAG is a symbol, and that the
   :REPRSENTATION is of the proper form."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (representation slot-names
      tag)
    (let ((template (<a class="sym-link system" href="../../axioms.html#def-case" data-sym="CASE">case</a> representation
           ((<span class="keyword">:mv</span> <span class="keyword">:list</span>) slot-names)
           (<span class="keyword">:dotted-list</span> (<a class="sym-link local-def" href="#def-dotify" data-sym="DOTIFY" title="(defun defstructure::dotify (defstructure::l)
  &quot;Make the last CONS of l a `dotted pair&#39; if possible.&quot;
  (cond ((atom defstructure::l) defstructure::l)
        ((atom (cdr defstructure::l)) defstructure::l)
        ((atom (cdr (cdr defstructure::l)))
...">dotify</a> slot-names))
           (<span class="keyword">:tree</span> (<a class="sym-link local-def" href="#def-fold" data-sym="FOLD" title="(defun defstructure::fold (defstructure::args)
  &quot;Folds a list into a somewhat balanced tree.&quot;
  (cond ((null defstructure::args) nil)
        ((null (cdr defstructure::args)) (car defstructure::args))
        (t
...">fold</a> slot-names))
           (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> representation))))
      (if tag
        (cons tag template)
        template))))</pre>
  </div>

<div class="form-block other" id="form-60" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop reader-names
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name conc-name)
        (cons (cons slot <span class="keyword">:reader</span>)
          (pack-intern name
            conc-name
            slot))))))</pre>
  </div>

<div class="form-block other" id="form-61" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop writer-names
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Generate the writer name, setting to NIL if either the slot or the
   structure as a whole is :READ-ONLY."</span>
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name set-conc-name
          (slot read-only))
        (cons (cons slot <span class="keyword">:writer</span>)
          (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> read-only (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:read-only</span>))
            nil
            (pack-intern name
              set-conc-name
              slot)))))))</pre>
  </div>

<div class="form-block other" id="form-62" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop reader-calls
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Create a symbolic access form for a slot.  The default access form for
  slot A of structure FOO looks like (FOO-A FOO)."</span>
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name)
        (cons (cons slot <span class="keyword">:reader-call</span>)
          `(,(DEFSTRUCTURE::DB DEFSTRUCTURE::SLOT :READER) ,DEFSTRUCTURE::NAME))))))</pre>
  </div>

<div class="form-block other" id="form-63" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop writer-calls
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Create a symbolic update form for a slot.  The default update form for
  slot A of structure FOO with slots A, B, and C looks like
  (SET-FOO-A FOOABC FOO)."</span>
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name value-variable
          (slot writer))
        (cons (cons slot <span class="keyword">:writer-call</span>)
          (if writer
            `(,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
              ,DEFSTRUCTURE::NAME)
            nil))))))</pre>
  </div>

<div class="form-block function" id="def-guard-declaration" data-defines="GUARD-DECLARATION" data-references="XARGS,DECLARE,QUASIQUOTE,LIST,IF,VERIFY-GUARDS,GUARDS,DB-LET,DB,VERIFYP,GUARD,DEFUN" data-part-name="GUARD-DECLARATION" data-part-args="DB,VERIFYP,GUARD" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GUARD-DECLARATION">guard-declaration</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-guard-declaration" data-sym="GUARD-DECLARATION" title="(defun defstructure::guard-declaration
       (defstructure::guard defstructure::verifyp defstructure::db)
  &quot;If :GUARDS was specified, declare a guard and verify based on
  :VERIFY-GUARDS.  Note that the default is :DEFAULT.&quot;
  (defstructure::db-let (defstructure::guards defstructure::verify-guards)
...">guard-declaration</a>
  (<a class="sym-link system" href="../../basis-b.html#def-guard" data-sym="GUARD">guard</a> verifyp <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"If :GUARDS was specified, declare a guard and verify based on
  :VERIFY-GUARDS.  Note that the default is :DEFAULT."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (guards <a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>)
    (if guards
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(declare (xargs <span class="keyword">:guard</span> ,DEFSTRUCTURE::GUARD
            ,@(COND
   ((OR (NULL DEFSTRUCTURE::VERIFYP) (NULL DEFSTRUCTURE::VERIFY-GUARDS))
    &#39;(:VERIFY-GUARDS NIL))
   ((EQ DEFSTRUCTURE::VERIFY-GUARDS T) &#39;(:VERIFY-GUARDS T))))))
      nil)))</pre>
  </div>

<div class="form-block function" id="def-constructor-body" data-defines="CONSTRUCTOR-BODY" data-references="CONS,QUASIQUOTE,T,ATOM,COND,TEMPLATE,DEFUN" data-part-name="CONSTRUCTOR-BODY" data-part-args="TEMPLATE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONSTRUCTOR-BODY">constructor-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-constructor-body" data-sym="CONSTRUCTOR-BODY" title="(defun defstructure::constructor-body (defstructure::template)
  &quot;Use the template to create a large CONS expression that creates the new
   tuple.  The elements of the template are the argument names.&quot;
  (cond ((atom defstructure::template) defstructure::template)
        (t
...">constructor-body</a>
  (template)
  <span class="string">"Use the template to create a large CONS expression that creates the new
   tuple.  The elements of the template are the argument names."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) template)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(cons ,(DEFSTRUCTURE::CONSTRUCTOR-BODY (CAR DEFSTRUCTURE::TEMPLATE))
        ,(DEFSTRUCTURE::CONSTRUCTOR-BODY (CDR DEFSTRUCTURE::TEMPLATE))))))</pre>
  </div>

<div class="form-block function" id="def-template-cost" data-defines="TEMPLATE-COST" data-references="CDR,CAR,+,T,ATOM,COND,TEMPLATE,DEFUN" data-used-by="SET-HEURISTIC" data-part-name="TEMPLATE-COST" data-part-args="TEMPLATE" data-part-body="CDR,CAR,TEMPLATE-COST,+,T,TEMPLATE,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TEMPLATE-COST">template-cost</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-template-cost" data-sym="TEMPLATE-COST" title="(defun defstructure::template-cost (defstructure::template)
  (cond ((atom defstructure::template) 0)
        (t
         (+ 1 (defstructure::template-cost (car defstructure::template))
            (defstructure::template-cost (cdr defstructure::template))))))">template-cost</a>
  (template)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) <span class="number">0</span>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span>
        (<a class="sym-link local-def" href="#def-template-cost" data-sym="TEMPLATE-COST" title="(defun defstructure::template-cost (defstructure::template)
  (cond ((atom defstructure::template) 0)
        (t
         (+ 1 (defstructure::template-cost (car defstructure::template))
            (defstructure::template-cost (cdr defstructure::template))))))">template-cost</a> (car template))
        (<a class="sym-link local-def" href="#def-template-cost" data-sym="TEMPLATE-COST" title="(defun defstructure::template-cost (defstructure::template)
  (cond ((atom defstructure::template) 0)
        (t
         (+ 1 (defstructure::template-cost (car defstructure::template))
            (defstructure::template-cost (cdr defstructure::template))))))">template-cost</a> (cdr template))))))</pre>
  </div>

<div class="form-block other" id="form-67" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop acl2-countify-slots
  (slots)
  (for ((slot in slots))
    (collect `(<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> ,DEFSTRUCTURE::SLOT))))</pre>
  </div>

<div class="form-block function" id="def-constructor" data-defines="CONSTRUCTOR" data-references="+,ACL2-COUNT,EQUAL,DEFTHM,T,MLAMBDA,LET,IF,MV,QUOTE,CONS,DEFMACRO,QUASIQUOTE,LIST,EQ,COND,INLINE,TEMPLATE,DOC,TAG,REPRESENTATION,SLOT-NAMES,CONSTRUCTOR-CALL,ACL2-COUNT-LEMMA,NAME,DB-LET,DB,DEFUN" data-part-name="CONSTRUCTOR" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONSTRUCTOR">constructor</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-constructor" data-sym="CONSTRUCTOR" title="(defun defstructure::constructor (defstructure::db)
  &quot;If :REPRESENTATION is :MV, create an MV macro.  Else create a function or
   macro under control of the :INLINE option.  For tagged structures the tag
   is in the constructor-body as a free variable, so we need to bind it.&quot;
  (defstructure::db-let
...">constructor</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"If :REPRESENTATION is :MV, create an MV macro.  Else create a function or
   macro under control of the :INLINE option.  For tagged structures the tag
   is in the constructor-body as a free variable, so we need to bind it."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name acl2-count-lemma
      constructor-call
      slot-names
      representation
      tag
      <a class="sym-link system" href="../../history-management.html#def-doc" data-sym="DOC">doc</a>
      template
      inline)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  The constructor is defined as a macro that expands into an MV form for
;  every slot.
 "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::NAME
            ,DEFSTRUCTURE::SLOT-NAMES
            ,@(IF DEFSTRUCTURE::DOC
      (LIST DEFSTRUCTURE::DOC)
      NIL)
            (cons '<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ,@DEFSTRUCTURE::SLOT-NAMES)))))
      (inline (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  The constructor is defined as a macro that accepts every slot.
 "</span>
          (if tag
            `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::NAME
              ,DEFSTRUCTURE::SLOT-NAMES
              ,@(IF DEFSTRUCTURE::DOC
      (LIST DEFSTRUCTURE::DOC)
      NIL)
              (let ((,DEFSTRUCTURE::TAG '',DEFSTRUCTURE::TAG))
                (<a class="sym-link local-def" href="#def-mlambda" data-sym="MLAMBDA" title="(defmacro defstructure::mlambda (defstructure::args defstructure::form)
  &quot;A macro lambda that doesn&#39;t substitute function symbols or quoted
   constants.&quot;
  (declare
   (defstructure::xargs :guard
...">mlambda</a> (,DEFSTRUCTURE::TAG ,@DEFSTRUCTURE::SLOT-NAMES)
                  ,(DEFSTRUCTURE::CONSTRUCTOR-BODY DEFSTRUCTURE::TEMPLATE))))
            `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::NAME
              ,DEFSTRUCTURE::SLOT-NAMES
              ,@(IF DEFSTRUCTURE::DOC
      (LIST DEFSTRUCTURE::DOC)
      NIL)
              (<a class="sym-link local-def" href="#def-mlambda" data-sym="MLAMBDA" title="(defmacro defstructure::mlambda (defstructure::args defstructure::form)
  &quot;A macro lambda that doesn&#39;t substitute function symbols or quoted
   constants.&quot;
  (declare
   (defstructure::xargs :guard
...">mlambda</a> ,DEFSTRUCTURE::SLOT-NAMES
                ,(DEFSTRUCTURE::CONSTRUCTOR-BODY DEFSTRUCTURE::TEMPLATE))))))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  The constructor is defined as a function that accepts every slot.
 "</span>
          (if tag
            `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::NAME
              ,DEFSTRUCTURE::SLOT-NAMES
              ,@(IF DEFSTRUCTURE::DOC
      (LIST DEFSTRUCTURE::DOC)
      NIL)
              ,@(DEFSTRUCTURE::GUARD-DECLARATION T T DEFSTRUCTURE::DB)
              (let ((,DEFSTRUCTURE::TAG ',DEFSTRUCTURE::TAG))
                ,(DEFSTRUCTURE::CONSTRUCTOR-BODY DEFSTRUCTURE::TEMPLATE)))
            `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::NAME
              ,DEFSTRUCTURE::SLOT-NAMES
              ,@(IF DEFSTRUCTURE::DOC
      (LIST DEFSTRUCTURE::DOC)
      NIL)
              ,@(DEFSTRUCTURE::GUARD-DECLARATION T T DEFSTRUCTURE::DB)
              ,(DEFSTRUCTURE::CONSTRUCTOR-BODY DEFSTRUCTURE::TEMPLATE)))
          <span class="string">"
;  This lemma justifies recursion on any slot of the structure.  It is
;  unlikely to be used unless the structure is itself recursive.
  "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::ACL2-COUNT-LEMMA
            (equal (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> ,DEFSTRUCTURE::CONSTRUCTOR-CALL)
              (<a class="sym-link system" href="../../axioms.html#def-_2B" data-sym="+">+</a> ,(DEFSTRUCTURE::TEMPLATE-COST DEFSTRUCTURE::TEMPLATE)
                ,@(DEFSTRUCTURE::ACL2-COUNTIFY-SLOTS DEFSTRUCTURE::SLOT-NAMES)))))))))</pre>
  </div>

<div class="form-block function" id="def-weak-predicate-body" data-defines="WEAK-PREDICATE-BODY" data-references="CDR,CAR,CONSP,APPEND,T,QUASIQUOTE,LIST,NULL,ATOM,COND,TREE,TEMPLATE,DEFUN" data-used-by="WEAK-PREDICATE" data-part-name="WEAK-PREDICATE-BODY" data-part-args="TREE,TEMPLATE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WEAK-PREDICATE-BODY">weak-predicate-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-weak-predicate-body" data-sym="WEAK-PREDICATE-BODY" title="(defun defstructure::weak-predicate-body
       (defstructure::template defstructure::tree)
  &quot;Traverse the template, creating CONSP and NULL expressions wherever
   needed.  It is necessary for the read/write lemmas that if the template
   contains a NULL entry, that entry must be NULL in every shell.  This
...">weak-predicate-body</a>
  (template tree)
  <span class="string">"Traverse the template, creating CONSP and NULL expressions wherever
   needed.  It is necessary for the read/write lemmas that if the template
   contains a NULL entry, that entry must be NULL in every shell.  This
   is initialized with tree = &lt;structure-name&gt; which is the formal parameter
   of the weak predicate."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> template) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> ,DEFSTRUCTURE::TREE)))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(consp ,DEFSTRUCTURE::TREE))
        (<a class="sym-link local-def" href="#def-weak-predicate-body" data-sym="WEAK-PREDICATE-BODY" title="(defun defstructure::weak-predicate-body
       (defstructure::template defstructure::tree)
  &quot;Traverse the template, creating CONSP and NULL expressions wherever
   needed.  It is necessary for the read/write lemmas that if the template
   contains a NULL entry, that entry must be NULL in every shell.  This
...">weak-predicate-body</a> (car template)
          `(car ,DEFSTRUCTURE::TREE))
        (<a class="sym-link local-def" href="#def-weak-predicate-body" data-sym="WEAK-PREDICATE-BODY" title="(defun defstructure::weak-predicate-body
       (defstructure::template defstructure::tree)
  &quot;Traverse the template, creating CONSP and NULL expressions wherever
   needed.  It is necessary for the read/write lemmas that if the template
   contains a NULL entry, that entry must be NULL in every shell.  This
...">weak-predicate-body</a> (cdr template)
          `(cdr ,DEFSTRUCTURE::TREE))))))</pre>
  </div>

<div class="form-block function" id="def-reader-body" data-defines="READER-BODY" data-references="CDR,QUASIQUOTE,CAR,OR,T,EQ,ATOM,COND,SYMBOLP,XARGS,DECLARE,TREE,TEMPLATE,SLOT,DEFUN" data-part-name="READER-BODY" data-part-args="TREE,TEMPLATE,SLOT" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="READER-BODY">reader-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-reader-body" data-sym="READER-BODY" title="(defun defstructure::reader-body
       (defstructure::slot defstructure::template defstructure::tree)
  &quot;Write a CA/DR form to get slot from a structure.  Tree is initialized with
   the structure name, which is the formal parameter of the reader.&quot;
  (declare (defstructure::xargs :guard (symbolp defstructure::slot)))
...">reader-body</a>
  (slot template
    tree)
  <span class="string">"Write a CA/DR form to get slot from a structure.  Tree is initialized with
   the structure name, which is the formal parameter of the reader."</span>
  (declare (xargs <span class="keyword">:guard</span> (symbolp slot)))
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> slot template) tree)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-reader-body" data-sym="READER-BODY" title="(defun defstructure::reader-body
       (defstructure::slot defstructure::template defstructure::tree)
  &quot;Write a CA/DR form to get slot from a structure.  Tree is initialized with
   the structure name, which is the formal parameter of the reader.&quot;
  (declare (defstructure::xargs :guard (symbolp defstructure::slot)))
...">reader-body</a> slot
          (car template)
          `(car ,DEFSTRUCTURE::TREE))
        (<a class="sym-link local-def" href="#def-reader-body" data-sym="READER-BODY" title="(defun defstructure::reader-body
       (defstructure::slot defstructure::template defstructure::tree)
  &quot;Write a CA/DR form to get slot from a structure.  Tree is initialized with
   the structure name, which is the formal parameter of the reader.&quot;
  (declare (defstructure::xargs :guard (symbolp defstructure::slot)))
...">reader-body</a> slot
          (cdr template)
          `(cdr ,DEFSTRUCTURE::TREE))))))</pre>
  </div>

<div class="form-block function" id="def-weak-predicate" data-defines="WEAK-PREDICATE" data-references="EQUAL,DEFTHM,IF,LIST*,QUOTE,CAR,EQ,AND,T,IGNORE,DECLARE,ATOM,QUASIQUOTE,LIST,NULL,COND,BODY,WEAK-PREDICATE-BODY,WP-BODY,LET*,INLINE,TAG,TEMPLATE,NAME,CONSTRUCTOR-CALL,WEAK-PREDICATE-CONSTRUCTOR-LEMMA,DB-LET,DB,DEFUN" data-used-by="PREPARE-FOR-CODE-GEN,DEFINITION-THEORY,SLOT-WRITERS-LEMMAS" data-part-name="WEAK-PREDICATE" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WEAK-PREDICATE">weak-predicate</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a> weak-predicate-constructor-lemma
      constructor-call
      name
      template
      tag
      inline)
    (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((wp-body (<a class="sym-link local-def" href="#def-weak-predicate-body" data-sym="WEAK-PREDICATE-BODY" title="(defun defstructure::weak-predicate-body
       (defstructure::template defstructure::tree)
  &quot;Traverse the template, creating CONSP and NULL expressions wherever
   needed.  It is necessary for the read/write lemmas that if the template
   contains a NULL entry, that entry must be NULL in every shell.  This
...">weak-predicate-body</a> template
           name)) (<a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a> (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> template) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> ,DEFSTRUCTURE::NAME)))
            ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(declare (ignore ,DEFSTRUCTURE::NAME)) <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
            (tag (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@DEFSTRUCTURE::WP-BODY
                  (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car ,DEFSTRUCTURE::NAME) ',DEFSTRUCTURE::TAG))))
            (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@DEFSTRUCTURE::WP-BODY))))))
      (<a class="sym-link system" href="../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="string">"
;  This predicate defines the `structure&#39; of the structure, and is used as a
;  weak guard on the readers and writers (if defined).
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::WEAK-PREDICATE
          (,DEFSTRUCTURE::NAME)
          ,@(DEFSTRUCTURE::GUARD-DECLARATION T T DEFSTRUCTURE::DB)
          ,@DEFSTRUCTURE::BODY)
        (if inline
          nil
          (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  The weak-predicate is satisfied by any explicit reference of the
;  constructor.  We also store this information as a :BUILT-IN-CLAUSE
 "</span>
            `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::WEAK-PREDICATE-CONSTRUCTOR-LEMMA
              (equal (,DEFSTRUCTURE::WEAK-PREDICATE ,DEFSTRUCTURE::CONSTRUCTOR-CALL)
                <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)
              <span class="keyword">:rule-classes</span> ((<span class="keyword">:rewrite</span>) (<span class="keyword">:built-in-clause</span> <span class="keyword">:corollary</span> (,DEFSTRUCTURE::WEAK-PREDICATE ,DEFSTRUCTURE::CONSTRUCTOR-CALL))))))))))</pre>
  </div>

<div class="form-block other" id="form-72" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-access-assertion-assertion
  (assertions)
  (for ((assertion in
       assertions))
    (collect (<a class="sym-link system" href="../../axioms.html#def-access" data-sym="ACCESS">access</a> assertion
        assertion
        <span class="keyword">:assertion</span>))))</pre>
  </div>

<div class="form-block other" id="form-73" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop slot-assertions
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot assertions))
        (map-access-assertion-assertion assertions)))))</pre>
  </div>

<div class="form-block other" id="form-74" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-access-assertion-subst-assertion
  (assertions)
  (for ((assertion in
       assertions))
    (collect (<a class="sym-link system" href="../../axioms.html#def-access" data-sym="ACCESS">access</a> assertion
        assertion
        <span class="keyword">:subst-assertion</span>))))</pre>
  </div>

<div class="form-block other" id="form-75" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop slot-subst-assertions
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot assertions))
        (map-access-assertion-subst-assertion assertions)))))</pre>
  </div>

<div class="form-block function" id="def-predicate-body" data-defines="PREDICATE-BODY" data-references="T,AND,QUASIQUOTE,ASSERTIONS,SLOT-NAMES,WEAK-PREDICATE-CALL,DB-LET,DB,DEFUN" data-part-name="PREDICATE-BODY" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREDICATE-BODY">predicate-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-predicate-body" data-sym="PREDICATE-BODY" title="(defun defstructure::predicate-body (defstructure::db)
  &quot;The predicate body is a conjunction of the weak predicate, and all
   assertions about the slots.&quot;
  (defstructure::db-let
   (defstructure::weak-predicate-call defstructure::slot-names
...">predicate-body</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"The predicate body is a conjunction of the weak predicate, and all
   assertions about the slots."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (weak-predicate-call slot-names
      assertions)
    `(<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,DEFSTRUCTURE::WEAK-PREDICATE-CALL
      ,@(DEFSTRUCTURE::REMOVE-DUPLICATES-EQUAL
   (APPEND
    (DEFSTRUCTURE::SLOT-SUBST-ASSERTIONS DEFSTRUCTURE::SLOT-NAMES
     DEFSTRUCTURE::DB)
    (DEFSTRUCTURE::MAP-ACCESS-ASSERTION-SUBST-ASSERTION
     DEFSTRUCTURE::ASSERTIONS)))
      <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)))</pre>
  </div>

<div class="form-block function" id="def-predicate-assertions-explicit" data-defines="PREDICATE-ASSERTIONS-EXPLICIT" data-references="QUOTE,T,AND,QUASIQUOTE,COND,MAP-ACCESS-ASSERTION-ASSERTION,SLOT-ASSERTIONS,APPEND,REMOVE-DUPLICATES-EQUAL,LET,ASSERTIONS,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="PREDICATE-ASSERTIONS-EXPLICIT" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREDICATE-ASSERTIONS-EXPLICIT">predicate-assertions-explicit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-predicate-assertions-explicit" data-sym="PREDICATE-ASSERTIONS-EXPLICIT" title="(defun defstructure::predicate-assertions-explicit (defstructure::db)
  &quot;The predicate, as the set of assertions for explicit instances of the
   constructor.&quot;
  (defstructure::db-let (defstructure::slot-names defstructure::assertions)
   (let ((defstructure::assertions
...">predicate-assertions-explicit</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"The predicate, as the set of assertions for explicit instances of the
   constructor."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names assertions)
    (let ((assertions (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-equal" data-sym="REMOVE-DUPLICATES-EQUAL">remove-duplicates-equal</a> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (slot-assertions slot-names
               <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
             (map-access-assertion-assertion assertions)))))
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (assertions `(<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@DEFSTRUCTURE::ASSERTIONS <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> '<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)))))</pre>
  </div>

<div class="form-block function" id="def-predicate" data-defines="PREDICATE" data-references="EQUAL,IMPLIES,DEFTHM,LIST,IF,QUASIQUOTE,LIST*,INLINE,PREDICATE-CONSTRUCTOR-LEMMA,PREDICATE-WEAK-PREDICATE-LEMMA,CONSTRUCTOR-CALL,WEAK-PREDICATE-CALL,PREDICATE-CALL,NAME,DB-LET,DB,DEFUN" data-used-by="PREPARE-FOR-CODE-GEN,DEFINITION-THEORY,NAKED-PROOFS,SLOT-WRITERS-LEMMAS" data-part-name="PREDICATE" data-part-args="DB" data-part-body="EQUAL,IMPLIES,DEFTHM,LIST,IF,DEFUN,QUASIQUOTE,LIST*,INLINE,PREDICATE-CONSTRUCTOR-LEMMA,PREDICATE-WEAK-PREDICATE-LEMMA,CONSTRUCTOR-CALL,WEAK-PREDICATE-CALL,PREDICATE-CALL,NAME,PREDICATE,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREDICATE">predicate</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a> name
      predicate-call
      weak-predicate-call
      constructor-call
      predicate-weak-predicate-lemma
      predicate-constructor-lemma
      inline)
    (<a class="sym-link system" href="../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="string">"
;  This is the predicate, which contains the weak predicate and every
;  assertion made about the slots of the structure.  The final T guarantees
;  that all DEFSTRUCTURE predicates are Boolean.
 "</span>
      `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::PREDICATE
        (,DEFSTRUCTURE::NAME)
        ,@(DEFSTRUCTURE::GUARD-DECLARATION T NIL DEFSTRUCTURE::DB)
        ,(DEFSTRUCTURE::PREDICATE-BODY DEFSTRUCTURE::DB))
      (if inline
        nil
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma shows that the predicate includes the weak predicate, as
;  :REWRITE, :FORWARD-CHAINING, and :BUILT-IN-CLAUSE rules.  Note that the
;  :REWRITE rule is sometimes implicated in thrashing in conjunction with the
;  normalization lemmas.
 "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::PREDICATE-WEAK-PREDICATE-LEMMA
            (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::PREDICATE-CALL
              ,DEFSTRUCTURE::WEAK-PREDICATE-CALL)
            <span class="keyword">:rule-classes</span> (<span class="keyword">:forward-chaining</span> <span class="keyword">:rewrite</span> <span class="keyword">:built-in-clause</span>))
          <span class="string">"
;  This lemma rewrites the predicate on an explicit reference of
;  the constructor.
 "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::PREDICATE-CONSTRUCTOR-LEMMA
            (equal (,DEFSTRUCTURE::PREDICATE ,DEFSTRUCTURE::CONSTRUCTOR-CALL)
              ,(DEFSTRUCTURE::PREDICATE-ASSERTIONS-EXPLICIT DEFSTRUCTURE::DB))))))))</pre>
  </div>

<div class="form-block other" id="form-79" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop default-alist
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (cons (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> slot)
        (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:default</span>)))))</pre>
  </div>

<div class="form-block other" id="form-80" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop keyword-constructor-body
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> keyword-slot-names
    default-alist)
  (for ((keyword-slot in
       keyword-slot-names))
    (collect (let ((tail (<a class="sym-link system" href="../../axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> keyword-slot
             <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
        (if tail
          (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> tail)
          (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> keyword-slot
              default-alist)))))))</pre>
  </div>

<div class="form-block function" id="def-keyword-slot-checker" data-defines="KEYWORD-SLOT-CHECKER" data-references="T,SET-DIFFERENCE-EQUAL,EVENS,SUBSETP,REASON-FOR-NON-KEYWORD-VALUE-LISTP,BOMB-FROM,KEYWORD-VALUE-LISTP,NOT,COND,KEYWORD-SLOT-NAMES,ARGS,FORM,MACRO-NAME,DEFUN" data-used-by="KEYWORD-UPDATER-FN,KEYWORD-CONSTRUCTOR-FN" data-part-name="KEYWORD-SLOT-CHECKER" data-part-args="KEYWORD-SLOT-NAMES,ARGS,FORM,MACRO-NAME" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-SLOT-CHECKER">keyword-slot-checker</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-slot-checker" data-sym="KEYWORD-SLOT-CHECKER" title="(defun defstructure::keyword-slot-checker
       (defstructure::macro-name defstructure::form defstructure::args
        defstructure::keyword-slot-names)
  &quot;Check keyword argument list for basic syntax and either bomb or return
   NIL.&quot;
...">keyword-slot-checker</a>
  (macro-name form
    <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    keyword-slot-names)
  <span class="string">"Check keyword argument list for basic syntax and either bomb or return
   NIL."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-keyword-value-listp" data-sym="KEYWORD-VALUE-LISTP">keyword-value-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> macro-name
        <span class="string">"The argument list in the macro invocation ~p0 ~
                does not match the syntax of a keyword argument ~
                list because ~@1."</span>
        form
        (<a class="sym-link system" href="../../defthm.html#def-reason-for-non-keyword-value-listp" data-sym="REASON-FOR-NON-KEYWORD-VALUE-LISTP">reason-for-non-keyword-value-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
    ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
         keyword-slot-names)) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> macro-name
        <span class="string">"The argument list in the macro invocation ~p0 is not ~
                 a valid keyword argument list because it contains the ~
                 ~#1~[keyword~/keywords~] ~&amp;1, which ~#1~[is~/are~] ~
                 not the keyword ~#1~[form~/forms~] of any of the ~
                 slot names ~&amp;2."</span>
        form
        (<a class="sym-link system" href="../../axioms.html#def-set-difference-equal" data-sym="SET-DIFFERENCE-EQUAL">set-difference-equal</a> (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
          keyword-slot-names)
        keyword-slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-keyword-constructor-fn" data-defines="KEYWORD-CONSTRUCTOR-FN" data-references="QUASIQUOTE,T,SET-DIFFERENCE-EQUAL,BOMB-FROM,EVENS,SUBSETP,NOT,KEYWORD-SLOT-CHECKER,COND,REQUIRED-SLOT-NAMES,KEYWORD-SLOT-NAMES,DEFAULT-ALIST,KEYWORD-CONSTRUCTOR,NAME,ARGS,FORM,DEFUN" data-used-by="KEYWORD-CONSTRUCTOR" data-part-name="KEYWORD-CONSTRUCTOR-FN" data-part-args="REQUIRED-SLOT-NAMES,KEYWORD-SLOT-NAMES,DEFAULT-ALIST,KEYWORD-CONSTRUCTOR,NAME,ARGS,FORM" data-part-body="QUASIQUOTE,T,SET-DIFFERENCE-EQUAL,BOMB-FROM,EVENS,REQUIRED-SLOT-NAMES,SUBSETP,NOT,KEYWORD-SLOT-NAMES,ARGS,FORM,KEYWORD-CONSTRUCTOR,KEYWORD-SLOT-CHECKER,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-CONSTRUCTOR-FN">keyword-constructor-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-constructor-fn" data-sym="KEYWORD-CONSTRUCTOR-FN" title="(defun defstructure::keyword-constructor-fn
       (defstructure::form defstructure::args defstructure::name
        defstructure::keyword-constructor defstructure::default-alist
        defstructure::keyword-slot-names defstructure::required-slot-names)
  (cond
...">keyword-constructor-fn</a>
  (form <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    name
    <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
    default-alist
    keyword-slot-names
    required-slot-names)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-keyword-slot-checker" data-sym="KEYWORD-SLOT-CHECKER" title="(defun defstructure::keyword-slot-checker
       (defstructure::macro-name defstructure::form defstructure::args
        defstructure::keyword-slot-names)
  &quot;Check keyword argument list for basic syntax and either bomb or return
   NIL.&quot;
...">keyword-slot-checker</a> <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
       form
       <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
       keyword-slot-names))
    ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> required-slot-names
         (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
        <span class="string">"The argument list in the macro invocation ~p0 is not ~
                 valid does not specify a value for the required ~
                 ~#1~[keyword~/keywords~] ~&amp;1. ~
                 Any slot which has no :DEFAULT option at ~
                 DEFSTRUCTURE time must be specified in every ~
                 invocation of the constructor macro."</span>
        form
        (<a class="sym-link system" href="../../axioms.html#def-set-difference-equal" data-sym="SET-DIFFERENCE-EQUAL">set-difference-equal</a> required-slot-names
          (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
        keyword-slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(,DEFSTRUCTURE::NAME ,@(DEFSTRUCTURE::KEYWORD-CONSTRUCTOR-BODY DEFSTRUCTURE::ARGS
   DEFSTRUCTURE::KEYWORD-SLOT-NAMES DEFSTRUCTURE::DEFAULT-ALIST)))))</pre>
  </div>

<div class="form-block function" id="def-keyword-constructor" data-defines="KEYWORD-CONSTRUCTOR" data-references="QUOTE,KEYWORD-CONSTRUCTOR-FN,ARGS,&REST,FORM,&WHOLE,DEFMACRO,QUASIQUOTE,LIST,IF,REQUIRED-SLOT-NAMES,KEYWORD-SLOT-NAMES,SLOT-NAMES,NAME,DB-LET,DB,DEFUN" data-used-by="KEYWORD-CONSTRUCTOR-FN" data-part-name="KEYWORD-CONSTRUCTOR" data-part-args="DB" data-part-body="QUOTE,KEYWORD-CONSTRUCTOR-FN,ARGS,&REST,FORM,&WHOLE,DEFMACRO,QUASIQUOTE,LIST,IF,REQUIRED-SLOT-NAMES,KEYWORD-SLOT-NAMES,SLOT-NAMES,KEYWORD-CONSTRUCTOR,NAME,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-CONSTRUCTOR">keyword-constructor</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
      slot-names
      keyword-slot-names
      required-slot-names)
    (if <a class="sym-link local-def" href="#def-keyword-constructor" data-sym="KEYWORD-CONSTRUCTOR" title="(defun defstructure::keyword-constructor (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::keyword-constructor
    defstructure::slot-names defstructure::keyword-slot-names
    defstructure::required-slot-names)
...">keyword-constructor</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This is the keyword constructor macro.  It will expand into a call of the
;  constructor, with appropriate defaulting.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::KEYWORD-CONSTRUCTOR
          (&amp;whole form &amp;rest <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
          (<a class="sym-link local-def" href="#def-keyword-constructor-fn" data-sym="KEYWORD-CONSTRUCTOR-FN" title="(defun defstructure::keyword-constructor-fn
       (defstructure::form defstructure::args defstructure::name
        defstructure::keyword-constructor defstructure::default-alist
        defstructure::keyword-slot-names defstructure::required-slot-names)
  (cond
...">keyword-constructor-fn</a> form
            <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
            ',DEFSTRUCTURE::NAME
            ',DEFSTRUCTURE::KEYWORD-CONSTRUCTOR
            ',(DEFSTRUCTURE::DEFAULT-ALIST DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB)
            ',DEFSTRUCTURE::KEYWORD-SLOT-NAMES
            ',DEFSTRUCTURE::REQUIRED-SLOT-NAMES)))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-84" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop reader-definitions
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot reader) name
          weak-predicate-call
          template
          inline)
        (if inline
          `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::READER
            (,DEFSTRUCTURE::NAME)
            (<a class="sym-link local-def" href="#def-mlambda" data-sym="MLAMBDA" title="(defmacro defstructure::mlambda (defstructure::args defstructure::form)
  &quot;A macro lambda that doesn&#39;t substitute function symbols or quoted
   constants.&quot;
  (declare
   (defstructure::xargs :guard
...">mlambda</a> (,DEFSTRUCTURE::NAME)
              ,(DEFSTRUCTURE::READER-BODY DEFSTRUCTURE::SLOT DEFSTRUCTURE::TEMPLATE
  DEFSTRUCTURE::NAME)))
          `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::READER
            (,DEFSTRUCTURE::NAME)
            ,@(DEFSTRUCTURE::GUARD-DECLARATION DEFSTRUCTURE::WEAK-PREDICATE-CALL T
   DEFSTRUCTURE::DB)
            ,(DEFSTRUCTURE::READER-BODY DEFSTRUCTURE::SLOT DEFSTRUCTURE::TEMPLATE
  DEFSTRUCTURE::NAME)))))))</pre>
  </div>

<div class="form-block function" id="def-readers" data-defines="READERS" data-references="READER-DEFINITIONS,CONS,IF,SLOT-NAMES,DB-LET,DB,DEFUN" data-used-by="MV-INTRO-MACRO-FN,MV-INTRO-MACRO-CASE-BODY" data-part-name="READERS" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="READERS">readers</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-readers" data-sym="READERS" title="(defun defstructure::readers (defstructure::db)
  &quot;Define the reader functions&quot;
  (defstructure::db-let (defstructure::slot-names)
   (if defstructure::slot-names
       (cons &quot;
...">readers</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Define the reader functions"</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names)
    (if slot-names
      (cons <span class="string">"
;  These are the `readers&#39; for the structure.
 "</span>
        (reader-definitions slot-names
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-86" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *binding-variable*
  '|x|)</pre>
  </div>

<div class="form-block other" id="form-87" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *binding-variable1*
  '|y|)</pre>
  </div>

<div class="form-block function" id="def-writer-body" data-defines="WRITER-BODY" data-references="CONS,CDR,CDR-SIDE,QUASIQUOTE,CAR,CAR-SIDE,LET,T,EQ,ATOM,COND,SYMBOLP,XARGS,DECLARE,TREE,VAR,TEMPLATE,SLOT,DEFUN" data-used-by="WRITER-MACRO-FN" data-part-name="WRITER-BODY" data-part-args="TREE,VAR,TEMPLATE,SLOT" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WRITER-BODY">writer-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-writer-body" data-sym="WRITER-BODY" title="(defun defstructure::writer-body
       (defstructure::slot defstructure::template defstructure::var
        defstructure::tree)
  &quot;Write a CONS form to put a new slot into a structure, given the slot,
   the structure template, a variable name (a formal parameter) and the
...">writer-body</a>
  (slot template
    var
    tree)
  <span class="string">"Write a CONS form to put a new slot into a structure, given the slot,
   the structure template, a variable name (a formal parameter) and the
   `tree&#39;."</span>
  (declare (xargs <span class="keyword">:guard</span> (symbolp slot)))
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> slot template) var)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (let ((car-side (<a class="sym-link local-def" href="#def-writer-body" data-sym="WRITER-BODY" title="(defun defstructure::writer-body
       (defstructure::slot defstructure::template defstructure::var
        defstructure::tree)
  &quot;Write a CONS form to put a new slot into a structure, given the slot,
   the structure template, a variable name (a formal parameter) and the
...">writer-body</a> slot
             (car template)
             var
             `(car ,DEFSTRUCTURE::TREE))) (cdr-side (<a class="sym-link local-def" href="#def-writer-body" data-sym="WRITER-BODY" title="(defun defstructure::writer-body
       (defstructure::slot defstructure::template defstructure::var
        defstructure::tree)
  &quot;Write a CONS form to put a new slot into a structure, given the slot,
   the structure template, a variable name (a formal parameter) and the
...">writer-body</a> slot
              (cdr template)
              var
              `(cdr ,DEFSTRUCTURE::TREE))))
        (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (car-side `(cons ,DEFSTRUCTURE::CAR-SIDE
              ,(COND ((NULL (CDR DEFSTRUCTURE::TEMPLATE)) NIL) (T `(CDR ,DEFSTRUCTURE::TREE)))))
          (cdr-side `(cons (car ,DEFSTRUCTURE::TREE) ,DEFSTRUCTURE::CDR-SIDE)))))))</pre>
  </div>

<div class="form-block function" id="def-writer-macro-fn" data-defines="WRITER-MACRO-FN" data-references="WRITER-BODY,CHECK-VARS-NOT-FREE,LET,QUASIQUOTE,IF,NAME,VALUE,TEMPLATE,SLOT,BIND,DEFUN" data-part-name="WRITER-MACRO-FN" data-part-args="NAME,VALUE,TEMPLATE,SLOT,BIND" data-part-body="NAME,VALUE,TEMPLATE,SLOT,WRITER-BODY,CHECK-VARS-NOT-FREE,LET,QUASIQUOTE,BIND,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WRITER-MACRO-FN">writer-macro-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-writer-macro-fn" data-sym="WRITER-MACRO-FN" title="(defun defstructure::writer-macro-fn
       (defstructure::bind defstructure::slot defstructure::template
        defstructure::value defstructure::name)
  (if defstructure::bind
      `(let ((,defstructure::*binding-variable*
...">writer-macro-fn</a>
  (bind slot
    template
    <a class="sym-link system" href="../../axioms.html#def-value" data-sym="VALUE">value</a>
    name)
  (if bind
    `(let ((,DEFSTRUCTURE::*BINDING-VARIABLE* (<a class="sym-link system" href="../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,DEFSTRUCTURE::*BINDING-VARIABLE*)
           ,DEFSTRUCTURE::NAME)))
      ,(DEFSTRUCTURE::WRITER-BODY DEFSTRUCTURE::SLOT DEFSTRUCTURE::TEMPLATE
  DEFSTRUCTURE::VALUE DEFSTRUCTURE::*BINDING-VARIABLE*))
    (<a class="sym-link local-def" href="#def-writer-body" data-sym="WRITER-BODY" title="(defun defstructure::writer-body
       (defstructure::slot defstructure::template defstructure::var
        defstructure::tree)
  &quot;Write a CONS form to put a new slot into a structure, given the slot,
   the structure template, a variable name (a formal parameter) and the
...">writer-body</a> slot
      template
      <a class="sym-link system" href="../../axioms.html#def-value" data-sym="VALUE">value</a>
      name)))</pre>
  </div>

<div class="form-block other" id="form-90" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop writer-definitions
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot writer) name
          weak-predicate-call
          template
          value-variable
          inline)
        (if writer
          (if inline
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::WRITER
                (,DEFSTRUCTURE::VALUE-VARIABLE ,DEFSTRUCTURE::NAME)
                (<a class="sym-link local-def" href="#def-writer-macro-fn" data-sym="WRITER-MACRO-FN" title="(defun defstructure::writer-macro-fn
       (defstructure::bind defstructure::slot defstructure::template
        defstructure::value defstructure::name)
  (if defstructure::bind
      `(let ((,defstructure::*binding-variable*
...">writer-macro-fn</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> ,DEFSTRUCTURE::NAME))
                  ',DEFSTRUCTURE::SLOT
                  ',DEFSTRUCTURE::TEMPLATE
                  ,DEFSTRUCTURE::VALUE-VARIABLE
                  ,DEFSTRUCTURE::NAME)))
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,DEFSTRUCTURE::WRITER
                (,DEFSTRUCTURE::VALUE-VARIABLE ,DEFSTRUCTURE::NAME)
                ,@(DEFSTRUCTURE::GUARD-DECLARATION DEFSTRUCTURE::WEAK-PREDICATE-CALL T
   DEFSTRUCTURE::DB)
                ,(DEFSTRUCTURE::WRITER-BODY DEFSTRUCTURE::SLOT DEFSTRUCTURE::TEMPLATE
  DEFSTRUCTURE::VALUE-VARIABLE DEFSTRUCTURE::NAME))))
          nil)))))</pre>
  </div>

<div class="form-block function" id="def-writers" data-defines="WRITERS" data-references="WRITER-DEFINITIONS,CONS,IF,READ-ONLY,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="WRITERS" data-part-args="DB" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WRITERS">writers</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-writers" data-sym="WRITERS" title="(defun defstructure::writers (defstructure::db)
  &quot;Define the writer functions.&quot;
  (defstructure::db-let (defstructure::slot-names defstructure::read-only)
   (if defstructure::read-only
       nil
...">writers</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Define the writer functions."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names read-only)
    (if read-only
      nil
      (cons <span class="string">"
;  These are the `writers&#39; for the structure.
 "</span>
        (writer-definitions slot-names
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))</pre>
  </div>

<div class="form-block other" id="form-92" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop keyword-writer-map
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot writer))
        (cons (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> slot)
          writer)))))</pre>
  </div>

<div class="form-block other" id="form-93" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop keyword-reader-map
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot reader))
        (cons (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> slot)
          reader)))))</pre>
  </div>

<div class="form-block other" id="form-94" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop read-only-keyword-slots
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (when (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:read-only</span>)
      (collect (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> slot)))))</pre>
  </div>

<div class="form-block function" id="def-slot-cost" data-defines="SLOT-COST" data-references="CDR,1+,CAR,OR,T,EQ,ATOM,COND,ACCUM,TEMPLATE,SLOT,DEFUN" data-used-by="SET-COST" data-part-name="SLOT-COST" data-part-args="ACCUM,TEMPLATE,SLOT" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SLOT-COST">slot-cost</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-slot-cost" data-sym="SLOT-COST" title="(defun defstructure::slot-cost
       (defstructure::slot defstructure::template defstructure::accum)
  &quot;Compute the cost of reading (CAR/CDR) and writing (CONS) a slot.&quot;
  (cond
   ((atom defstructure::template)
...">slot-cost</a>
  (slot template
    accum)
  <span class="string">"Compute the cost of reading (CAR/CDR) and writing (CONS) a slot."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> slot template) accum)
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> nil)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-slot-cost" data-sym="SLOT-COST" title="(defun defstructure::slot-cost
       (defstructure::slot defstructure::template defstructure::accum)
  &quot;Compute the cost of reading (CAR/CDR) and writing (CONS) a slot.&quot;
  (cond
   ((atom defstructure::template)
...">slot-cost</a> slot
          (car template)
          (<a class="sym-link system" href="../../axioms.html#def-1_2B" data-sym="1+">1+</a> accum))
        (<a class="sym-link local-def" href="#def-slot-cost" data-sym="SLOT-COST" title="(defun defstructure::slot-cost
       (defstructure::slot defstructure::template defstructure::accum)
  &quot;Compute the cost of reading (CAR/CDR) and writing (CONS) a slot.&quot;
  (cond
   ((atom defstructure::template)
...">slot-cost</a> slot
          (cdr template)
          (<a class="sym-link system" href="../../axioms.html#def-1_2B" data-sym="1+">1+</a> accum))))))</pre>
  </div>

<div class="form-block function" id="def-set-cost" data-defines="SET-COST" data-references="CDR,CAR,SLOT-COST,+,T,ATOM,COND,TEMPLATE,SLOTS,DEFUN" data-used-by="SET-HEURISTIC" data-part-name="SET-COST" data-part-args="TEMPLATE,SLOTS" data-part-body="CDR,SET-COST,TEMPLATE,CAR,SLOT-COST,+,T,SLOTS,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-COST">set-cost</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-set-cost" data-sym="SET-COST" title="(defun defstructure::set-cost (defstructure::slots defstructure::template)
  (cond ((atom defstructure::slots) 0)
        (t
         (+
          (defstructure::slot-cost (car defstructure::slots)
...">set-cost</a>
  (slots template)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> slots) <span class="number">0</span>)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link local-def" href="#def-slot-cost" data-sym="SLOT-COST" title="(defun defstructure::slot-cost
       (defstructure::slot defstructure::template defstructure::accum)
  &quot;Compute the cost of reading (CAR/CDR) and writing (CONS) a slot.&quot;
  (cond
   ((atom defstructure::template)
...">slot-cost</a> (car slots)
          template
          <span class="number">0</span>)
        (<a class="sym-link local-def" href="#def-set-cost" data-sym="SET-COST" title="(defun defstructure::set-cost (defstructure::slots defstructure::template)
  (cond ((atom defstructure::slots) 0)
        (t
         (+
          (defstructure::slot-cost (car defstructure::slots)
...">set-cost</a> (cdr slots)
          template)))))</pre>
  </div>

<div class="form-block function" id="def-set-heuristic" data-defines="SET-HEURISTIC" data-references="TEMPLATE-COST,<=,SET-COST,KEYWORDIFY-TREE,KEYWORD-TEMPLATE,LET*,TEMPLATE,KEYWORD-SET-SLOTS,DEFUN" data-used-by="KEYWORD-UPDATER-FN" data-part-name="SET-HEURISTIC" data-part-args="TEMPLATE,KEYWORD-SET-SLOTS" data-part-body="TEMPLATE-COST,<=,KEYWORD-SET-SLOTS,SET-COST,TEMPLATE,KEYWORDIFY-TREE,KEYWORD-TEMPLATE,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-HEURISTIC">set-heuristic</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-set-heuristic" data-sym="SET-HEURISTIC" title="(defun defstructure::set-heuristic
       (defstructure::keyword-set-slots defstructure::template)
  (let* ((defstructure::keyword-template
          (defstructure::keywordify-tree defstructure::template))
         (defstructure::set-cost
...">set-heuristic</a>
  (keyword-set-slots template)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((keyword-template (<a class="sym-link local-def" href="#def-keywordify-tree" data-sym="KEYWORDIFY-TREE" title="(defun defstructure::keywordify-tree (defstructure::tree)
  (cond
   ((atom defstructure::tree)
    (cond ((not defstructure::tree) nil)
          ((not (symbolp defstructure::tree))
...">keywordify-tree</a> template)) (<a class="sym-link local-def" href="#def-set-cost" data-sym="SET-COST" title="(defun defstructure::set-cost (defstructure::slots defstructure::template)
  (cond ((atom defstructure::slots) 0)
        (t
         (+
          (defstructure::slot-cost (car defstructure::slots)
...">set-cost</a> (<a class="sym-link local-def" href="#def-set-cost" data-sym="SET-COST" title="(defun defstructure::set-cost (defstructure::slots defstructure::template)
  (cond ((atom defstructure::slots) 0)
        (t
         (+
          (defstructure::slot-cost (car defstructure::slots)
...">set-cost</a> keyword-set-slots
          keyword-template)))
    (<a class="sym-link system" href="../../axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <a class="sym-link local-def" href="#def-set-cost" data-sym="SET-COST" title="(defun defstructure::set-cost (defstructure::slots defstructure::template)
  (cond ((atom defstructure::slots) 0)
        (t
         (+
          (defstructure::slot-cost (car defstructure::slots)
...">set-cost</a>
      (<a class="sym-link local-def" href="#def-template-cost" data-sym="TEMPLATE-COST" title="(defun defstructure::template-cost (defstructure::template)
  (cond ((atom defstructure::template) 0)
        (t
         (+ 1 (defstructure::template-cost (car defstructure::template))
            (defstructure::template-cost (cdr defstructure::template))))))">template-cost</a> keyword-template))))</pre>
  </div>

<div class="form-block function" id="def-set-update" data-defines="SET-UPDATE" data-references="QUASIQUOTE,T,ATOM,COND,STRUCT,KEYWORD-WRITER-MAP,ARGS,DEFUN" data-used-by="KEYWORD-UPDATER-FN" data-part-name="SET-UPDATE" data-part-args="STRUCT,KEYWORD-WRITER-MAP,ARGS" data-part-body="QUASIQUOTE,T,STRUCT,ARGS,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-UPDATE">set-update</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-set-update" data-sym="SET-UPDATE" title="(defun defstructure::set-update
       (defstructure::args defstructure::keyword-writer-map
        defstructure::struct)
  (cond ((atom defstructure::args) defstructure::struct)
        (t
...">set-update</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> keyword-writer-map
    struct)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) struct)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(,(CDR (ASSOC (CAR DEFSTRUCTURE::ARGS) DEFSTRUCTURE::KEYWORD-WRITER-MAP)) ,(CADR DEFSTRUCTURE::ARGS)
        ,(DEFSTRUCTURE::SET-UPDATE (CDDR DEFSTRUCTURE::ARGS)
  DEFSTRUCTURE::KEYWORD-WRITER-MAP DEFSTRUCTURE::STRUCT)))))</pre>
  </div>

<div class="form-block other" id="form-99" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop copy-update-fn
  (keyword-slot-names <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    keyword-reader-map
    struct
    check)
  (for ((keyword-slot in
       keyword-slot-names))
    (collect (let ((assigned? (<a class="sym-link system" href="../../axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> keyword-slot
             <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
        (if assigned?
          (if check
            `(<a class="sym-link system" href="../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,DEFSTRUCTURE::*BINDING-VARIABLE*)
              ,(CADR DEFSTRUCTURE::ASSIGNED?))
            (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> assigned?))
          `(,(CDR (ASSOC DEFSTRUCTURE::KEYWORD-SLOT DEFSTRUCTURE::KEYWORD-READER-MAP)) ,DEFSTRUCTURE::STRUCT))))))</pre>
  </div>

<div class="form-block other" id="form-100" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop all-slots-assigned-p
  (keyword-slot-names <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (for ((keyword-slot in
       keyword-slot-names))
    (always (<a class="sym-link system" href="../../axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> keyword-slot
        <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))))</pre>
  </div>

<div class="form-block function" id="def-copy-update" data-defines="COPY-UPDATE" data-references="LET,QUASIQUOTE,ALL-SLOTS-ASSIGNED-P,ATOM,OR,IF,STRUCT,KEYWORD-READER-MAP,ARGS,KEYWORD-SLOT-NAMES,NAME,DEFUN" data-used-by="KEYWORD-UPDATER-FN" data-part-name="COPY-UPDATE" data-part-args="STRUCT,KEYWORD-READER-MAP,ARGS,KEYWORD-SLOT-NAMES,NAME" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COPY-UPDATE">copy-update</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-copy-update" data-sym="COPY-UPDATE" title="(defun defstructure::copy-update
       (defstructure::name defstructure::keyword-slot-names defstructure::args
        defstructure::keyword-reader-map defstructure::struct)
  &quot;If all slots are assigned (equivalent to a constructor call), or the
   updated thing is an atom (variable symbol), then we can simply do the
...">copy-update</a>
  (name keyword-slot-names
    <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    keyword-reader-map
    struct)
  <span class="string">"If all slots are assigned (equivalent to a constructor call), or the
   updated thing is an atom (variable symbol), then we can simply do the
   copy. Otherwise, bind the struct to a temp and then do the copy."</span>
  (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> struct)
      (all-slots-assigned-p keyword-slot-names
        <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    `(,DEFSTRUCTURE::NAME ,@(DEFSTRUCTURE::COPY-UPDATE-FN DEFSTRUCTURE::KEYWORD-SLOT-NAMES
   DEFSTRUCTURE::ARGS DEFSTRUCTURE::KEYWORD-READER-MAP DEFSTRUCTURE::STRUCT NIL))
    `(let ((,DEFSTRUCTURE::*BINDING-VARIABLE* ,DEFSTRUCTURE::STRUCT))
      (,DEFSTRUCTURE::NAME ,@(DEFSTRUCTURE::COPY-UPDATE-FN DEFSTRUCTURE::KEYWORD-SLOT-NAMES
   DEFSTRUCTURE::ARGS DEFSTRUCTURE::KEYWORD-READER-MAP
   DEFSTRUCTURE::*BINDING-VARIABLE* T)))))</pre>
  </div>

<div class="form-block function" id="def-inline-update-fn" data-defines="INLINE-UPDATE-FN" data-references="CONS,OR,NOT,CDR,CDR-RESULT,CDR-FOUND,CAR,CAR-RESULT,CAR-FOUND,MV-LET,CHECK-VARS-NOT-FREE,QUASIQUOTE,CADR,VAL,ASSOC-KEYWORD,FOUND,KEYWORDIFY,KEYWORD-SLOT,LET*,T,MV,NULL,ATOM,COND,CHECK,TREE,TEMPLATE,ARGS,DEFUN" data-used-by="INLINE-UPDATE" data-part-name="INLINE-UPDATE-FN" data-part-args="CHECK,TREE,TEMPLATE,ARGS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INLINE-UPDATE-FN">inline-update-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-inline-update-fn" data-sym="INLINE-UPDATE-FN" title="(defun defstructure::inline-update-fn
       (defstructure::args defstructure::template defstructure::tree
        defstructure::check)
  &quot;Write a CONS form to update slots from args, given the structure template
   and tree.&quot;
...">inline-update-fn</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> template
    tree
    check)
  <span class="string">"Write a CONS form to update slots from args, given the structure template
   and tree."</span>
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> template) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> template) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((keyword-slot (<a class="sym-link local-def" href="#def-keywordify" data-sym="KEYWORDIFY" title="(defun defstructure::keywordify (defstructure::string-designator)
  (defstructure::intern-in-package-of-symbol
   (string defstructure::string-designator) :keyword))">keywordify</a> template)) (found (<a class="sym-link system" href="../../axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> keyword-slot
                  <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
              (val (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> found)))
            (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (found (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>
                  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (check `(<a class="sym-link system" href="../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,DEFSTRUCTURE::*BINDING-VARIABLE*)
                        ,DEFSTRUCTURE::VAL))
                    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> val))))
              (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil tree)))))))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (car-found car-result)
        (<a class="sym-link local-def" href="#def-inline-update-fn" data-sym="INLINE-UPDATE-FN" title="(defun defstructure::inline-update-fn
       (defstructure::args defstructure::template defstructure::tree
        defstructure::check)
  &quot;Write a CONS form to update slots from args, given the structure template
   and tree.&quot;
...">inline-update-fn</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
          (car template)
          `(car ,DEFSTRUCTURE::TREE)
          check)
        (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cdr-found cdr-result)
          (<a class="sym-link local-def" href="#def-inline-update-fn" data-sym="INLINE-UPDATE-FN" title="(defun defstructure::inline-update-fn
       (defstructure::args defstructure::template defstructure::tree
        defstructure::check)
  &quot;Write a CONS form to update slots from args, given the structure template
   and tree.&quot;
...">inline-update-fn</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
            (cdr template)
            `(cdr ,DEFSTRUCTURE::TREE)
            check)
          (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> car-found cdr-found)) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil tree))
            (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>
                `(cons ,(COND (DEFSTRUCTURE::CAR-FOUND DEFSTRUCTURE::CAR-RESULT)
       (T `(CAR ,DEFSTRUCTURE::TREE)))
                  ,(COND (DEFSTRUCTURE::CDR-FOUND DEFSTRUCTURE::CDR-RESULT)
       ((NULL (CDR DEFSTRUCTURE::TEMPLATE)) NIL) (T `(CDR ,DEFSTRUCTURE::TREE))))))))))))</pre>
  </div>

<div class="form-block function" id="def-inline-update" data-defines="INLINE-UPDATE" data-references="T,QUASIQUOTE,COND,IGNORE,DECLARE,*BINDING-VARIABLE*,IF,INLINE-UPDATE-FN,FORM,FOUND,MV-LET,ALL-SLOTS-ASSIGNED-P,ATOM,NOT,AND,BIND,LET,KEYWORD-SLOT-NAMES,STRUCT,TEMPLATE,ARGS,DEFUN" data-used-by="KEYWORD-UPDATER-FN" data-part-name="INLINE-UPDATE" data-part-args="KEYWORD-SLOT-NAMES,STRUCT,TEMPLATE,ARGS" data-part-body="T,QUASIQUOTE,COND,IGNORE,DECLARE,*BINDING-VARIABLE*,IF,TEMPLATE,INLINE-UPDATE-FN,FORM,FOUND,MV-LET,ARGS,KEYWORD-SLOT-NAMES,ALL-SLOTS-ASSIGNED-P,STRUCT,ATOM,NOT,AND,BIND,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INLINE-UPDATE">inline-update</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-inline-update" data-sym="INLINE-UPDATE" title="(defun defstructure::inline-update
       (defstructure::args defstructure::template defstructure::struct
        defstructure::keyword-slot-names)
  (let ((defstructure::bind
         (and (not (atom defstructure::struct))
...">inline-update</a>
  (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> template
    struct
    keyword-slot-names)
  (let ((bind (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> struct))
         (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (all-slots-assigned-p keyword-slot-names
             <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))))
    (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (found form)
      (<a class="sym-link local-def" href="#def-inline-update-fn" data-sym="INLINE-UPDATE-FN" title="(defun defstructure::inline-update-fn
       (defstructure::args defstructure::template defstructure::tree
        defstructure::check)
  &quot;Write a CONS form to update slots from args, given the structure template
   and tree.&quot;
...">inline-update-fn</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
        template
        (if bind
          *binding-variable*
          struct)
        bind)
      (declare (ignore found))
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (bind `(let ((,DEFSTRUCTURE::*BINDING-VARIABLE* ,DEFSTRUCTURE::STRUCT))
            ,DEFSTRUCTURE::FORM))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> form)))))</pre>
  </div>

<div class="form-block function" id="def-keyword-updater-fn" data-defines="KEYWORD-UPDATER-FN" data-references="QUOTE,INLINE-UPDATE,COPY-UPDATE,SET-UPDATE,CASE,SET-HEURISTIC,EQ,IF,METHOD,KEYWORD-SET-SLOTS,LET*,T,BOMB-FROM,EVENS,INTERSECTION-EQ,KEYWORD-SLOT-CHECKER,COND,KEYWORD-WRITER-MAP,KEYWORD-READER-MAP,TEMPLATE,UPDATE-METHOD,READ-ONLY-KEYWORD-SLOTS,KEYWORD-SLOT-NAMES,KEYWORD-UPDATER,NAME,ARGS,STRUCT,FORM,DEFUN" data-used-by="KEYWORD-UPDATER" data-part-name="KEYWORD-UPDATER-FN" data-part-args="KEYWORD-WRITER-MAP,KEYWORD-READER-MAP,TEMPLATE,UPDATE-METHOD,READ-ONLY-KEYWORD-SLOTS,KEYWORD-SLOT-NAMES,KEYWORD-UPDATER,NAME,ARGS,STRUCT,FORM" data-part-body="KEYWORD-UPDATER-FN,QUOTE,INLINE-UPDATE,KEYWORD-READER-MAP,NAME,COPY-UPDATE,STRUCT,KEYWORD-WRITER-MAP,SET-UPDATE,CASE,TEMPLATE,SET-HEURISTIC,UPDATE-METHOD,EQ,IF,METHOD,KEYWORD-SET-SLOTS,LET*,T,BOMB-FROM,READ-ONLY-KEYWORD-SLOTS,EVENS,INTERSECTION-EQ,KEYWORD-SLOT-NAMES,ARGS,FORM,KEYWORD-UPDATER,KEYWORD-SLOT-CHECKER,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-UPDATER-FN">keyword-updater-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-updater-fn" data-sym="KEYWORD-UPDATER-FN" title="(defun defstructure::keyword-updater-fn
       (defstructure::form defstructure::struct defstructure::args
        defstructure::name defstructure::keyword-updater
        defstructure::keyword-slot-names defstructure::read-only-keyword-slots
        defstructure::update-method defstructure::template
...">keyword-updater-fn</a>
  (form struct
    <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
    name
    <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>
    keyword-slot-names
    read-only-keyword-slots
    update-method
    template
    keyword-reader-map
    keyword-writer-map)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-keyword-slot-checker" data-sym="KEYWORD-SLOT-CHECKER" title="(defun defstructure::keyword-slot-checker
       (defstructure::macro-name defstructure::form defstructure::args
        defstructure::keyword-slot-names)
  &quot;Check keyword argument list for basic syntax and either bomb or return
   NIL.&quot;
...">keyword-slot-checker</a> <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>
       form
       <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
       keyword-slot-names))
    ((<a class="sym-link system" href="../../axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
       read-only-keyword-slots) (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>
        <span class="string">"The argument list in the macro invocation ~p0 is not ~
                valid because it specifies ~#1~[a~/an~] update for the ~
                ~#1~[slot~/slots~] ~&amp;1 which ~#1~[is a~/are~] ~
                :READ-ONLY ~#1~[slot~/slots~]."</span>
        form
        (<a class="sym-link system" href="../../axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
          read-only-keyword-slots)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((keyword-set-slots (<a class="sym-link system" href="../../axioms.html#def-evens" data-sym="EVENS">evens</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)) (method (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> update-method <span class="keyword">:heuristic</span>)
              (if (<a class="sym-link local-def" href="#def-set-heuristic" data-sym="SET-HEURISTIC" title="(defun defstructure::set-heuristic
       (defstructure::keyword-set-slots defstructure::template)
  (let* ((defstructure::keyword-template
          (defstructure::keywordify-tree defstructure::template))
         (defstructure::set-cost
...">set-heuristic</a> keyword-set-slots
                  template)
                <span class="keyword">:set</span> <span class="keyword">:copy</span>)
              update-method)))
        (<a class="sym-link system" href="../../axioms.html#def-case" data-sym="CASE">case</a> method
          (<span class="keyword">:set</span> (<a class="sym-link local-def" href="#def-set-update" data-sym="SET-UPDATE" title="(defun defstructure::set-update
       (defstructure::args defstructure::keyword-writer-map
        defstructure::struct)
  (cond ((atom defstructure::args) defstructure::struct)
        (t
...">set-update</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
              keyword-writer-map
              struct))
          (<span class="keyword">:copy</span> (<a class="sym-link local-def" href="#def-copy-update" data-sym="COPY-UPDATE" title="(defun defstructure::copy-update
       (defstructure::name defstructure::keyword-slot-names defstructure::args
        defstructure::keyword-reader-map defstructure::struct)
  &quot;If all slots are assigned (equivalent to a constructor call), or the
   updated thing is an atom (variable symbol), then we can simply do the
...">copy-update</a> name
              keyword-slot-names
              <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
              keyword-reader-map
              struct))
          (<span class="keyword">:inline</span> (<a class="sym-link local-def" href="#def-inline-update" data-sym="INLINE-UPDATE" title="(defun defstructure::inline-update
       (defstructure::args defstructure::template defstructure::struct
        defstructure::keyword-slot-names)
  (let ((defstructure::bind
         (and (not (atom defstructure::struct))
...">inline-update</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
              template
              struct
              keyword-slot-names))
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-bomb-from" data-sym="BOMB-FROM" title="(defmacro defstructure::bomb-from
          (defstructure::where defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::er defstructure::hard ,defstructure::where ,defstructure::fmt
    ,@defstructure::args))">bomb-from</a> '<a class="sym-link local-def" href="#def-keyword-updater-fn" data-sym="KEYWORD-UPDATER-FN" title="(defun defstructure::keyword-updater-fn
       (defstructure::form defstructure::struct defstructure::args
        defstructure::name defstructure::keyword-updater
        defstructure::keyword-slot-names defstructure::read-only-keyword-slots
        defstructure::update-method defstructure::template
...">keyword-updater-fn</a>
              <span class="string">"Illegal method: ~p0."</span>
              method)))))))</pre>
  </div>

<div class="form-block function" id="def-keyword-updater" data-defines="KEYWORD-UPDATER" data-references="QUOTE,KEYWORD-UPDATER-FN,ARGS,&REST,STRUCT,FORM,&WHOLE,DEFMACRO,QUASIQUOTE,LIST,IF,TEMPLATE,UPDATE-METHOD,SLOT-NAMES,KEYWORD-SLOT-NAMES,NAME,DB-LET,DB,DEFUN" data-used-by="PREPARE-FOR-CODE-GEN,KEYWORD-UPDATER-FN" data-part-name="KEYWORD-UPDATER" data-part-args="DB" data-part-body="QUOTE,KEYWORD-UPDATER-FN,ARGS,&REST,STRUCT,FORM,&WHOLE,DEFMACRO,QUASIQUOTE,LIST,IF,TEMPLATE,UPDATE-METHOD,SLOT-NAMES,KEYWORD-SLOT-NAMES,NAME,KEYWORD-UPDATER,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-UPDATER">keyword-updater</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a> name
      keyword-slot-names
      slot-names
      update-method
      template)
    (if <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This is the macro that provides for updates of multiple slots of a
;  structure.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::KEYWORD-UPDATER
          (&amp;whole form
            struct
            &amp;rest
            <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
          (<a class="sym-link local-def" href="#def-keyword-updater-fn" data-sym="KEYWORD-UPDATER-FN" title="(defun defstructure::keyword-updater-fn
       (defstructure::form defstructure::struct defstructure::args
        defstructure::name defstructure::keyword-updater
        defstructure::keyword-slot-names defstructure::read-only-keyword-slots
        defstructure::update-method defstructure::template
...">keyword-updater-fn</a> form
            struct
            <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
            ',DEFSTRUCTURE::NAME
            ',DEFSTRUCTURE::KEYWORD-UPDATER
            ',DEFSTRUCTURE::KEYWORD-SLOT-NAMES
            ',(DEFSTRUCTURE::READ-ONLY-KEYWORD-SLOTS DEFSTRUCTURE::SLOT-NAMES
  DEFSTRUCTURE::DB)
            ',DEFSTRUCTURE::UPDATE-METHOD
            ',DEFSTRUCTURE::TEMPLATE
            ',(DEFSTRUCTURE::KEYWORD-READER-MAP DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB)
            ',(DEFSTRUCTURE::KEYWORD-WRITER-MAP DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB))))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-106" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop read-lemma-body
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot reader) constructor-call)
        `(equal (,DEFSTRUCTURE::READER ,DEFSTRUCTURE::CONSTRUCTOR-CALL)
          ,DEFSTRUCTURE::SLOT)))))</pre>
  </div>

<div class="form-block function" id="def-read-lemma" data-defines="READ-LEMMA" data-references="AND,DEFTHM,QUASIQUOTE,LIST,IF,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="READ-LEMMA" data-part-args="DB" data-part-body="AND,DEFTHM,QUASIQUOTE,LIST,IF,READ-LEMMA,SLOT-NAMES,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="READ-LEMMA">read-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-read-lemma" data-sym="READ-LEMMA" title="(defun defstructure::read-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::read-lemma)
   (if defstructure::read-lemma
       (list &quot;
;  This lemma simplifies reads of an explicit constructor.
...">read-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names <a class="sym-link local-def" href="#def-read-lemma" data-sym="READ-LEMMA" title="(defun defstructure::read-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::read-lemma)
   (if defstructure::read-lemma
       (list &quot;
;  This lemma simplifies reads of an explicit constructor.
...">read-lemma</a>)
    (if <a class="sym-link local-def" href="#def-read-lemma" data-sym="READ-LEMMA" title="(defun defstructure::read-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::read-lemma)
   (if defstructure::read-lemma
       (list &quot;
;  This lemma simplifies reads of an explicit constructor.
...">read-lemma</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma simplifies reads of an explicit constructor.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::READ-LEMMA
          (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::READ-LEMMA-BODY DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB))))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-108" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop write-lemma-body
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:read-only</span>)
      (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot writer) constructor-call
            value-variable)
          `(equal (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
              ,DEFSTRUCTURE::CONSTRUCTOR-CALL)
            ,(SUBST DEFSTRUCTURE::VALUE-VARIABLE DEFSTRUCTURE::SLOT
        DEFSTRUCTURE::CONSTRUCTOR-CALL)))))))</pre>
  </div>

<div class="form-block function" id="def-write-lemma" data-defines="WRITE-LEMMA" data-references="AND,DEFTHM,QUASIQUOTE,LIST,IF,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="WRITE-LEMMA" data-part-args="DB" data-part-body="AND,DEFTHM,QUASIQUOTE,LIST,IF,WRITE-LEMMA,SLOT-NAMES,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WRITE-LEMMA">write-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-write-lemma" data-sym="WRITE-LEMMA" title="(defun defstructure::write-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::write-lemma)
   (if defstructure::write-lemma
       (list &quot;
;  This lemma simplifies writes of an explicit constructor.
...">write-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names <a class="sym-link local-def" href="#def-write-lemma" data-sym="WRITE-LEMMA" title="(defun defstructure::write-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::write-lemma)
   (if defstructure::write-lemma
       (list &quot;
;  This lemma simplifies writes of an explicit constructor.
...">write-lemma</a>)
    (if <a class="sym-link local-def" href="#def-write-lemma" data-sym="WRITE-LEMMA" title="(defun defstructure::write-lemma (defstructure::db)
  (defstructure::db-let (defstructure::slot-names defstructure::write-lemma)
   (if defstructure::write-lemma
       (list &quot;
;  This lemma simplifies writes of an explicit constructor.
...">write-lemma</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma simplifies writes of an explicit constructor.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::WRITE-LEMMA
          (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::WRITE-LEMMA-BODY DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB))))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-110" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop lift-if-writers
  (slots test
    left
    right
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in slots))
    (when (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:writer</span>)
      (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (value-variable (slot writer))
          `(equal (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
              (if ,DEFSTRUCTURE::TEST
                ,DEFSTRUCTURE::LEFT
                ,DEFSTRUCTURE::RIGHT))
            (if ,DEFSTRUCTURE::TEST
              (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                ,DEFSTRUCTURE::LEFT)
              (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                ,DEFSTRUCTURE::RIGHT))))))))</pre>
  </div>

<div class="form-block other" id="form-111" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop lift-if-readers
  (slots test
    left
    right
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in slots))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot reader))
        `(equal (,DEFSTRUCTURE::READER (if ,DEFSTRUCTURE::TEST
              ,DEFSTRUCTURE::LEFT
              ,DEFSTRUCTURE::RIGHT))
          (if ,DEFSTRUCTURE::TEST
            (,DEFSTRUCTURE::READER ,DEFSTRUCTURE::LEFT)
            (,DEFSTRUCTURE::READER ,DEFSTRUCTURE::RIGHT)))))))</pre>
  </div>

<div class="form-block function" id="def-lift-if-lemma-fn" data-defines="LIFT-IF-LEMMA-FN" data-references="LIFT-IF-WRITERS,LIFT-IF-READERS,APPEND,DB,RIGHT,LEFT,TEST,SLOTS,DEFUN" data-part-name="LIFT-IF-LEMMA-FN" data-part-args="DB,RIGHT,LEFT,TEST,SLOTS" data-part-body="LIFT-IF-WRITERS,DB,RIGHT,LEFT,TEST,SLOTS,LIFT-IF-READERS,APPEND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIFT-IF-LEMMA-FN">lift-if-lemma-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lift-if-lemma-fn" data-sym="LIFT-IF-LEMMA-FN" title="(defun defstructure::lift-if-lemma-fn
       (defstructure::slots defstructure::test defstructure::left
        defstructure::right defstructure::db)
  (append
   (defstructure::lift-if-readers defstructure::slots defstructure::test
...">lift-if-lemma-fn</a>
  (slots test
    left
    right
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (lift-if-readers slots
      test
      left
      right
      <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
    (lift-if-writers slots
      test
      left
      right
      <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))</pre>
  </div>

<div class="form-block function" id="def-lift-if-lemma" data-defines="LIFT-IF-LEMMA" data-references="AND,DEFTHM,QUASIQUOTE,LIST,IF,RIGHT,LEFT,PACK-INTERN,TEST,LET,SLOT-NAMES,NAME,DB-LET,DB,DEFUN" data-part-name="LIFT-IF-LEMMA" data-part-args="DB" data-part-body="AND,DEFTHM,QUASIQUOTE,LIST,IF,RIGHT,LEFT,PACK-INTERN,TEST,LET,SLOT-NAMES,LIFT-IF-LEMMA,NAME,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIFT-IF-LEMMA">lift-if-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lift-if-lemma" data-sym="LIFT-IF-LEMMA" title="(defun defstructure::lift-if-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::lift-if-lemma defstructure::slot-names)
   (let ((defstructure::test
          (defstructure::pack-intern defstructure::name defstructure::name
...">lift-if-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name <a class="sym-link local-def" href="#def-lift-if-lemma" data-sym="LIFT-IF-LEMMA" title="(defun defstructure::lift-if-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::lift-if-lemma defstructure::slot-names)
   (let ((defstructure::test
          (defstructure::pack-intern defstructure::name defstructure::name
...">lift-if-lemma</a>
      slot-names)
    (let ((test (pack-intern name
           name
           <span class="string">"-TEST"</span>)) (left (pack-intern name
            name
            <span class="string">"-LEFT"</span>))
        (right (pack-intern name
            name
            <span class="string">"-RIGHT"</span>)))
      (if <a class="sym-link local-def" href="#def-lift-if-lemma" data-sym="LIFT-IF-LEMMA" title="(defun defstructure::lift-if-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::lift-if-lemma defstructure::slot-names)
   (let ((defstructure::test
          (defstructure::pack-intern defstructure::name defstructure::name
...">lift-if-lemma</a>
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma lifts IF through calls of the slot accessors.
 "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::LIFT-IF-LEMMA
            (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::LIFT-IF-LEMMA-FN DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::TEST
   DEFSTRUCTURE::LEFT DEFSTRUCTURE::RIGHT DEFSTRUCTURE::DB))))
        nil))))</pre>
  </div>

<div class="form-block function" id="def-elimination-lemma" data-defines="ELIMINATION-LEMMA" data-references="EQUAL,IMPLIES,DEFTHM,QUASIQUOTE,LIST,IF,WEAK-PREDICATE-CALL,FORCE,NAME,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="ELIMINATION-LEMMA" data-part-args="DB" data-part-body="EQUAL,IMPLIES,DEFTHM,QUASIQUOTE,LIST,IF,WEAK-PREDICATE-CALL,FORCE,NAME,SLOT-NAMES,ELIMINATION-LEMMA,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ELIMINATION-LEMMA">elimination-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-elimination-lemma" data-sym="ELIMINATION-LEMMA" title="(defun defstructure::elimination-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::elimination-lemma defstructure::slot-names defstructure::name
    defstructure::force defstructure::weak-predicate-call)
   (if defstructure::elimination-lemma
...">elimination-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-elimination-lemma" data-sym="ELIMINATION-LEMMA" title="(defun defstructure::elimination-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::elimination-lemma defstructure::slot-names defstructure::name
    defstructure::force defstructure::weak-predicate-call)
   (if defstructure::elimination-lemma
...">elimination-lemma</a> slot-names
      name
      <a class="sym-link system" href="../../axioms.html#def-force" data-sym="FORCE">force</a>
      weak-predicate-call)
    (if <a class="sym-link local-def" href="#def-elimination-lemma" data-sym="ELIMINATION-LEMMA" title="(defun defstructure::elimination-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::elimination-lemma defstructure::slot-names defstructure::name
    defstructure::force defstructure::weak-predicate-call)
   (if defstructure::elimination-lemma
...">elimination-lemma</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This is the :ELIM lemma for the constructor.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::ELIMINATION-LEMMA
          (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,(IF DEFSTRUCTURE::FORCE
     `(DEFSTRUCTURE::FORCE ,DEFSTRUCTURE::WEAK-PREDICATE-CALL)
     DEFSTRUCTURE::WEAK-PREDICATE-CALL)
            (equal (,DEFSTRUCTURE::NAME ,@(DEFSTRUCTURE::MAP-SLOTS-DB DEFSTRUCTURE::SLOT-NAMES :READER-CALL
   DEFSTRUCTURE::DB))
              ,DEFSTRUCTURE::NAME))
          <span class="keyword">:rule-classes</span> (<span class="keyword">:rewrite</span> <span class="keyword">:elim</span>)))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-115" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop weak-predicate-slot-writers-lemma-fn
  (<a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a> writer-calls)
  (for ((call in
       writer-calls))
    (collect `(,DEFSTRUCTURE::WEAK-PREDICATE ,DEFSTRUCTURE::CALL))))</pre>
  </div>

<div class="form-block other" id="form-116" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop normalization-rhs
  (slot-names written-slot
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (value-variable (slot reader)
          name)
        (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> slot written-slot) value-variable)
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(,DEFSTRUCTURE::READER ,DEFSTRUCTURE::NAME)))))))</pre>
  </div>

<div class="form-block other" id="form-117" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-access-assertion-bound-slots
  (assertions)
  (for ((assertion in
       assertions))
    (collect (<a class="sym-link system" href="../../axioms.html#def-access" data-sym="ACCESS">access</a> assertion
        assertion
        <span class="keyword">:bound-slots</span>))))</pre>
  </div>

<div class="form-block other" id="form-118" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-subst-assertions
  (assertions slot
    value-variable)
  (for ((assertion in
       assertions))
    (collect (<a class="sym-link local-def" href="#def-subst-expr-all" data-sym="SUBST-EXPR-ALL" title="(defun defstructure::subst-expr-all
       (defstructure::term defstructure::new-list defstructure::old-list)
  (cond ((atom defstructure::old-list) defstructure::term)
        (t
         (defstructure::subst-expr-all
...">subst-expr-all</a> assertion
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> value-variable)
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> slot)))))</pre>
  </div>

<div class="form-block other" id="form-119" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop all-bound-slots-fn
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (map-access-assertion-bound-slots (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:assertions</span>)))))</pre>
  </div>

<div class="form-block function" id="def-all-bound-slots" data-defines="ALL-BOUND-SLOTS" data-references="ALL-BOUND-SLOTS-FN,MAP-ACCESS-ASSERTION-BOUND-SLOTS,APPEND,DB,SLOT-NAMES,DEFUN" data-used-by="SIMPLE-SLOT-P" data-part-name="ALL-BOUND-SLOTS" data-part-args="DB,SLOT-NAMES" data-part-body="SLOT-NAMES,ALL-BOUND-SLOTS-FN,DB,MAP-ACCESS-ASSERTION-BOUND-SLOTS,APPEND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-BOUND-SLOTS">all-bound-slots</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-bound-slots" data-sym="ALL-BOUND-SLOTS" title="(defun defstructure::all-bound-slots
       (defstructure::slot-names defstructure::db)
  (append
   (defstructure::map-access-assertion-bound-slots
    (defstructure::db :assertions))
...">all-bound-slots</a>
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (map-access-assertion-bound-slots (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:assertions</span>))
    (all-bound-slots-fn slot-names
      <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))</pre>
  </div>

<div class="form-block function" id="def-simple-slot-p" data-defines="SIMPLE-SLOT-P" data-references="REMOVE,ALL-BOUND-SLOTS,FLATTEN,MEMBER,NOT,LIST,MAP-ACCESS-ASSERTION-BOUND-SLOTS,REMOVE-DUPLICATES-EQUAL,EQUAL,AND,SLOT-NAMES,ASSERTIONS,DB-LET,DB,SLOT,DEFUN" data-part-name="SIMPLE-SLOT-P" data-part-args="DB,SLOT" data-part-body="DB,REMOVE,ALL-BOUND-SLOTS,FLATTEN,MEMBER,NOT,LIST,MAP-ACCESS-ASSERTION-BOUND-SLOTS,REMOVE-DUPLICATES-EQUAL,EQUAL,AND,SLOT-NAMES,ASSERTIONS,SLOT,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SIMPLE-SLOT-P">simple-slot-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-simple-slot-p" data-sym="SIMPLE-SLOT-P" title="(defun defstructure::simple-slot-p (defstructure::slot defstructure::db)
  (defstructure::db-let
   ((defstructure::slot defstructure::assertions) defstructure::slot-names)
   (and
    (equal
...">simple-slot-p</a>
  (slot <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot assertions) slot-names)
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-equal" data-sym="REMOVE-DUPLICATES-EQUAL">remove-duplicates-equal</a> (map-access-assertion-bound-slots assertions))
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> slot)))
      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> slot
          (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> (<a class="sym-link local-def" href="#def-all-bound-slots" data-sym="ALL-BOUND-SLOTS" title="(defun defstructure::all-bound-slots
       (defstructure::slot-names defstructure::db)
  (append
   (defstructure::map-access-assertion-bound-slots
    (defstructure::db :assertions))
...">all-bound-slots</a> (<a class="sym-link system" href="../../axioms.html#def-remove" data-sym="REMOVE">remove</a> slot slot-names)
              <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))))</pre>
  </div>

<div class="form-block other" id="form-122" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop predicate-slot-writers-lemma-fn
  (<a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a> slot-names
    all-slot-names
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:read-only</span>)
      (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name predicate-call
            weak-predicate-call
            value-variable
            (slot writer-call))
          (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-simple-slot-p" data-sym="SIMPLE-SLOT-P" title="(defun defstructure::simple-slot-p (defstructure::slot defstructure::db)
  (defstructure::db-let
   ((defstructure::slot defstructure::assertions) defstructure::slot-names)
   (and
    (equal
...">simple-slot-p</a> slot
                <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))
            `(<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::WEAK-PREDICATE-CALL
              (equal (,DEFSTRUCTURE::PREDICATE ,DEFSTRUCTURE::WRITER-CALL)
                (,DEFSTRUCTURE::PREDICATE (,DEFSTRUCTURE::NAME ,@(DEFSTRUCTURE::NORMALIZATION-RHS DEFSTRUCTURE::ALL-SLOT-NAMES
   DEFSTRUCTURE::SLOT DEFSTRUCTURE::DB)))))
            (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((slot-assertions-assertions (map-access-assertion-assertion (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:assertions</span>))) (subst-assertions (map-subst-assertions slot-assertions-assertions
                    slot
                    value-variable)))
              `(<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::PREDICATE-CALL
                (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (,DEFSTRUCTURE::PREDICATE ,DEFSTRUCTURE::WRITER-CALL)
                  ,(IF DEFSTRUCTURE::SUBST-ASSERTIONS
     (COND
      ((CDR DEFSTRUCTURE::SUBST-ASSERTIONS)
       `(AND ,@DEFSTRUCTURE::SUBST-ASSERTIONS))
      (T (CAR DEFSTRUCTURE::SUBST-ASSERTIONS)))
     &#39;T))))))))))</pre>
  </div>

<div class="form-block function" id="def-slot-writers-lemmas" data-defines="SLOT-WRITERS-LEMMAS" data-references="AND,IMPLIES,DEFTHM,QUASIQUOTE,LIST,IF,APPEND,SLOT-NAMES,PREDICATE,PREDICATE-SLOT-WRITERS-LEMMA,WEAK-PREDICATE,WEAK-PREDICATE-CALL,WEAK-PREDICATE-SLOT-WRITERS-LEMMA,DB-LET,DB,DEFUN" data-part-name="SLOT-WRITERS-LEMMAS" data-part-args="DB" data-part-body="AND,IMPLIES,DEFTHM,QUASIQUOTE,LIST,IF,APPEND,SLOT-NAMES,PREDICATE,PREDICATE-SLOT-WRITERS-LEMMA,WEAK-PREDICATE,WEAK-PREDICATE-CALL,WEAK-PREDICATE-SLOT-WRITERS-LEMMA,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SLOT-WRITERS-LEMMAS">slot-writers-lemmas</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-slot-writers-lemmas" data-sym="SLOT-WRITERS-LEMMAS" title="(defun defstructure::slot-writers-lemmas (defstructure::db)
  (defstructure::db-let
   (defstructure::weak-predicate-slot-writers-lemma
    defstructure::weak-predicate-call defstructure::weak-predicate
    defstructure::predicate-slot-writers-lemma defstructure::predicate
...">slot-writers-lemmas</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (weak-predicate-slot-writers-lemma weak-predicate-call
      <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
      predicate-slot-writers-lemma
      <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
      slot-names)
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (if weak-predicate-slot-writers-lemma
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma backchains the weak predicate through the slot writers.
  "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::WEAK-PREDICATE-SLOT-WRITERS-LEMMA
            (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::WEAK-PREDICATE-CALL
              (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::WEAK-PREDICATE-SLOT-WRITERS-LEMMA-FN
   DEFSTRUCTURE::WEAK-PREDICATE
   (DEFSTRUCTURE::MAP-IF-SLOTS-DB DEFSTRUCTURE::SLOT-NAMES :WRITER-CALL
    DEFSTRUCTURE::DB))))))
        nil)
      (if predicate-slot-writers-lemma
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma proves the predicate on a slot writer call.  For simple slots
;  whose assertions (if any) only mention the slot itself one need only prove
;  the assertion about the new slot.  For more complex slot assertions, or if
;  the structure as a whole has an assertion, it is necessary to normalize
;  the slot writer call to an explicit instance of the constructor.
  "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::PREDICATE-SLOT-WRITERS-LEMMA
            (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::PREDICATE-SLOT-WRITERS-LEMMA-FN DEFSTRUCTURE::PREDICATE
   DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB))))
        nil))))</pre>
  </div>

<div class="form-block other" id="form-124" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop read-write-conjuncts1
  (slot-names write-slot
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((read-slot in
       slot-names))
    (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (value-variable (read-slot reader)
          (write-slot writer)
          name)
        (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> read-slot write-slot) `(equal (,DEFSTRUCTURE::READER (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                  ,DEFSTRUCTURE::NAME))
              ,DEFSTRUCTURE::VALUE-VARIABLE))
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> `(equal (,DEFSTRUCTURE::READER (,DEFSTRUCTURE::WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                  ,DEFSTRUCTURE::NAME))
              (,DEFSTRUCTURE::READER ,DEFSTRUCTURE::NAME))))))))</pre>
  </div>

<div class="form-block other" id="form-125" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop read-write-conjuncts
  (slot-names all-slot-names
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((write-slot in
       slot-names))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> write-slot <span class="keyword">:read-only</span>)
      (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (read-write-conjuncts1 all-slot-names
          write-slot
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))</pre>
  </div>

<div class="form-block function" id="def-read-write-lemma" data-defines="READ-WRITE-LEMMA" data-references="AND,DEFTHM,QUASIQUOTE,LIST,IF,SLOT-NAMES,DB-LET,DB,DEFUN" data-part-name="READ-WRITE-LEMMA" data-part-args="DB" data-part-body="AND,DEFTHM,QUASIQUOTE,LIST,IF,SLOT-NAMES,READ-WRITE-LEMMA,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="READ-WRITE-LEMMA">read-write-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-read-write-lemma" data-sym="READ-WRITE-LEMMA" title="(defun defstructure::read-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::read-write-lemma defstructure::slot-names)
   (if defstructure::read-write-lemma
       (list &quot;
...">read-write-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-read-write-lemma" data-sym="READ-WRITE-LEMMA" title="(defun defstructure::read-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::read-write-lemma defstructure::slot-names)
   (if defstructure::read-write-lemma
       (list &quot;
...">read-write-lemma</a> slot-names)
    (if <a class="sym-link local-def" href="#def-read-write-lemma" data-sym="READ-WRITE-LEMMA" title="(defun defstructure::read-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::read-write-lemma defstructure::slot-names)
   (if defstructure::read-write-lemma
       (list &quot;
...">read-write-lemma</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma normalizes symbolic reads of symbolic writes by `pushing&#39;
;  reads though nested writes until either 1) a symbolic write of the read
;  slot is detected, or 2) something unrecognized is found.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::READ-WRITE-LEMMA
          (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::READ-WRITE-CONJUNCTS DEFSTRUCTURE::SLOT-NAMES
   DEFSTRUCTURE::SLOT-NAMES DEFSTRUCTURE::DB))))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-127" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop write-write-conjuncts1
  (deep-slot template
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((shallow-slot in
       template))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> shallow-slot <span class="keyword">:read-only</span>)
      (collect (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (value-variable value-variable1
            name)
          (let ((deep-writer (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> deep-slot <span class="keyword">:writer</span>)) (shallow-writer (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> shallow-slot <span class="keyword">:writer</span>)))
            (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> deep-slot shallow-slot)
              `(equal (,DEFSTRUCTURE::DEEP-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                  (,DEFSTRUCTURE::DEEP-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE1
                    ,DEFSTRUCTURE::NAME))
                (,DEFSTRUCTURE::DEEP-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                  ,DEFSTRUCTURE::NAME))
              `(equal (,DEFSTRUCTURE::DEEP-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                  (,DEFSTRUCTURE::SHALLOW-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE1
                    ,DEFSTRUCTURE::NAME))
                (,DEFSTRUCTURE::SHALLOW-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE1
                  (,DEFSTRUCTURE::DEEP-WRITER ,DEFSTRUCTURE::VALUE-VARIABLE
                    ,DEFSTRUCTURE::NAME))))))))))</pre>
  </div>

<div class="form-block other" id="form-128" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop write-write-conjuncts
  (template <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in template))
    (unless (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> slot <span class="keyword">:read-only</span>)
      (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (write-write-conjuncts1 slot
          template
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))</pre>
  </div>

<div class="form-block function" id="def-write-write-lemma" data-defines="WRITE-WRITE-LEMMA" data-references="AND,DEFTHM,QUASIQUOTE,LIST,CDR,FLATTEN,REVERSE,LET,IF,TAG,TEMPLATE,DB-LET,DB,DEFUN" data-part-name="WRITE-WRITE-LEMMA" data-part-args="DB" data-part-body="AND,DEFTHM,QUASIQUOTE,LIST,CDR,FLATTEN,REVERSE,LET,IF,TAG,TEMPLATE,WRITE-WRITE-LEMMA,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WRITE-WRITE-LEMMA">write-write-lemma</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-write-write-lemma" data-sym="WRITE-WRITE-LEMMA" title="(defun defstructure::write-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::write-write-lemma defstructure::template defstructure::tag)
   (if defstructure::write-write-lemma
       (let ((defstructure::template
...">write-write-lemma</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-write-write-lemma" data-sym="WRITE-WRITE-LEMMA" title="(defun defstructure::write-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::write-write-lemma defstructure::template defstructure::tag)
   (if defstructure::write-write-lemma
       (let ((defstructure::template
...">write-write-lemma</a> template
      tag)
    (if <a class="sym-link local-def" href="#def-write-write-lemma" data-sym="WRITE-WRITE-LEMMA" title="(defun defstructure::write-write-lemma (defstructure::db)
  (defstructure::db-let
   (defstructure::write-write-lemma defstructure::template defstructure::tag)
   (if defstructure::write-write-lemma
       (let ((defstructure::template
...">write-write-lemma</a>
      (let ((template (<a class="sym-link system" href="../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> (if tag
                 (cdr template)
                 template)))))
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma normalizes multiple nested writes of a structure by pushing
;  writes for `deep&#39; slots through writes to `shallow&#39; slots, and reducing
;  redundant writes to the same slot to a single write.
  "</span>
          `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::WRITE-WRITE-LEMMA
            (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@(DEFSTRUCTURE::WRITE-WRITE-CONJUNCTS DEFSTRUCTURE::TEMPLATE DEFSTRUCTURE::DB)))))
      nil)))</pre>
  </div>

<div class="form-block other" id="form-130" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-rules-for-rule-classes
  (rules)
  (for ((rule in rules))
    (collect (<a class="sym-link system" href="../../axioms.html#def-access" data-sym="ACCESS">access</a> rule
        rule
        <span class="keyword">:rule-class</span>))))</pre>
  </div>

<div class="form-block other" id="form-131" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-assertions-for-rule-classes
  (assertions)
  (for ((assertion in
       assertions))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (map-rules-for-rule-classes (<a class="sym-link system" href="../../axioms.html#def-access" data-sym="ACCESS">access</a> assertion
          assertion
          <span class="keyword">:rules</span>)))))</pre>
  </div>

<div class="form-block other" id="form-132" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop map-slot-assertions-for-rule-classes
  (slot-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((slot in
       slot-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> ((slot assertions))
        (map-assertions-for-rule-classes assertions)))))</pre>
  </div>

<div class="form-block function" id="def-all-rule-classes" data-defines="ALL-RULE-CLASSES" data-references="MAP-ASSERTIONS-FOR-RULE-CLASSES,MAP-SLOT-ASSERTIONS-FOR-RULE-CLASSES,APPEND,SLOT-NAMES,ASSERTIONS,DB-LET,DB,DEFUN" data-used-by="PREPARE-FOR-CODE-GEN" data-part-name="ALL-RULE-CLASSES" data-part-args="DB" data-part-body="MAP-ASSERTIONS-FOR-RULE-CLASSES,DB,MAP-SLOT-ASSERTIONS-FOR-RULE-CLASSES,APPEND,SLOT-NAMES,ASSERTIONS,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-RULE-CLASSES">all-rule-classes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-rule-classes" data-sym="ALL-RULE-CLASSES" title="(defun defstructure::all-rule-classes (defstructure::db)
  (defstructure::db-let (defstructure::assertions defstructure::slot-names)
   (append
    (defstructure::map-slot-assertions-for-rule-classes
     defstructure::slot-names defstructure::db)">all-rule-classes</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (assertions slot-names)
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (map-slot-assertions-for-rule-classes slot-names
        <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
      (map-assertions-for-rule-classes assertions))))</pre>
  </div>

<div class="form-block function" id="def-naked-proofs" data-defines="NAKED-PROOFS" data-references="IMPLIES,DEFTHM,ENABLE,IN-THEORY,LOCAL,QUASIQUOTE,LIST,APPEND,AND,OR,IF,VERIFY-GUARDS,GUARDS,ASSERTION-LEMMA-HINTS,PREDICATE-GUARD-HINTS,PREDICATE-CALL,PREDICATE,ASSERTION-LEMMA,DB-LET,DB,DEFUN" data-part-name="NAKED-PROOFS" data-part-args="DB" data-part-body="IMPLIES,DEFTHM,ENABLE,IN-THEORY,LOCAL,QUASIQUOTE,LIST,APPEND,AND,OR,IF,VERIFY-GUARDS,GUARDS,ASSERTION-LEMMA-HINTS,PREDICATE-GUARD-HINTS,PREDICATE-CALL,PREDICATE,ASSERTION-LEMMA,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NAKED-PROOFS">naked-proofs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-naked-proofs" data-sym="NAKED-PROOFS" title="(defun defstructure::naked-proofs (defstructure::db)
  (defstructure::db-let
   (defstructure::assertion-lemma defstructure::predicate
    defstructure::predicate-call defstructure::predicate-guard-hints
    defstructure::assertion-lemma-hints defstructure::guards
...">naked-proofs</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (assertion-lemma <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
      predicate-call
      predicate-guard-hints
      assertion-lemma-hints
      guards
      <a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>)
    (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> assertion-lemma
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> guards <a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>))
      (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> `(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (enable ,DEFSTRUCTURE::PREDICATE))))
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> guards
          <a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>
          (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  The guard verification for the predicate is performed here since it may
;  need the current environment.  If it does not prove then you may need some
;  hints.  Any :PREDICATE-GUARD-HINTS option to DEFSTRUCTURE will be attached
;  to this lemma.
 "</span>
            `(<a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a> ,DEFSTRUCTURE::PREDICATE
              ,@(AND DEFSTRUCTURE::PREDICATE-GUARD-HINTS
       (LIST :HINTS DEFSTRUCTURE::PREDICATE-GUARD-HINTS)))))
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> assertion-lemma
          (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This lemma captures all assertions about the structure.  This lemma is not
;  guaranteed to prove.  If it does not prove than you may have to provide
;  some :HINTS.  Any :ASSERTION-LEMMA-HINTS option to DEFSTRUCTURE will be
;  attached to this lemma.  Be sure that you have not specified
;  unsatisfiable assertions.
 "</span>
            `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::ASSERTION-LEMMA
              (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ,DEFSTRUCTURE::PREDICATE-CALL
                ,(DEFSTRUCTURE::PREDICATE-BODY DEFSTRUCTURE::DB))
              <span class="keyword">:rule-classes</span> ,(DEFSTRUCTURE::ALL-RULE-CLASSES DEFSTRUCTURE::DB)
              ,@(AND DEFSTRUCTURE::ASSERTION-LEMMA-HINTS
       (LIST :HINTS DEFSTRUCTURE::ASSERTION-LEMMA-HINTS))))))
      nil)))</pre>
  </div>

<div class="form-block function" id="def-mv-intro-macro-case-body" data-defines="MV-INTRO-MACRO-CASE-BODY" data-references="1+,CDR,QUASIQUOTE,CONS,T,ATOM,COND,N,FORM,READERS,DEFUN" data-part-name="MV-INTRO-MACRO-CASE-BODY" data-part-args="N,FORM,READERS" data-part-body="N,1+,FORM,CDR,MV-INTRO-MACRO-CASE-BODY,QUASIQUOTE,CONS,T,READERS,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MV-INTRO-MACRO-CASE-BODY">mv-intro-macro-case-body</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-mv-intro-macro-case-body" data-sym="MV-INTRO-MACRO-CASE-BODY" title="(defun defstructure::mv-intro-macro-case-body
       (defstructure::readers defstructure::form defstructure::n)
  (cond ((atom defstructure::readers) nil)
        (t
         (cons
...">mv-intro-macro-case-body</a>
  (<a class="sym-link local-def" href="#def-readers" data-sym="READERS" title="(defun defstructure::readers (defstructure::db)
  &quot;Define the reader functions&quot;
  (defstructure::db-let (defstructure::slot-names)
   (if defstructure::slot-names
       (cons &quot;
...">readers</a> form n)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link local-def" href="#def-readers" data-sym="READERS" title="(defun defstructure::readers (defstructure::db)
  &quot;Define the reader functions&quot;
  (defstructure::db-let (defstructure::slot-names)
   (if defstructure::slot-names
       (cons &quot;
...">readers</a>) nil)
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons `(,DEFSTRUCTURE::N (,(CAR DEFSTRUCTURE::READERS) ,DEFSTRUCTURE::FORM))
        (<a class="sym-link local-def" href="#def-mv-intro-macro-case-body" data-sym="MV-INTRO-MACRO-CASE-BODY" title="(defun defstructure::mv-intro-macro-case-body
       (defstructure::readers defstructure::form defstructure::n)
  (cond ((atom defstructure::readers) nil)
        (t
         (cons
...">mv-intro-macro-case-body</a> (cdr <a class="sym-link local-def" href="#def-readers" data-sym="READERS" title="(defun defstructure::readers (defstructure::db)
  &quot;Define the reader functions&quot;
  (defstructure::db-let (defstructure::slot-names)
   (if defstructure::slot-names
       (cons &quot;
...">readers</a>)
          form
          (<a class="sym-link system" href="../../axioms.html#def-1_2B" data-sym="1+">1+</a> n))))))</pre>
  </div>

<div class="form-block function" id="def-mv-intro-macro-fn" data-defines="MV-INTRO-MACRO-FN" data-references="OPEN-MV-NTH,ZP,HIDE,T,CASE,EQUAL,DEFTHM,MV-NTH,QUASIQUOTE,MV-NTH-FORM,FLATTEN,MV-INTRO-MACRO-N,QUOTE,UNIQUE-SYMBOLS,N,CAR,PACK-INTERN,IF,LET*,READERS,EVENT-NAME,FORM,NAME,DEFUN" data-used-by="MV-INTRO-MACRO" data-part-name="MV-INTRO-MACRO-FN" data-part-args="READERS,EVENT-NAME,FORM,NAME" data-part-body="OPEN-MV-NTH,ZP,HIDE,T,CASE,EQUAL,DEFTHM,MV-NTH,QUASIQUOTE,MV-NTH-FORM,FLATTEN,MV-INTRO-MACRO-N,QUOTE,UNIQUE-SYMBOLS,N,NAME,FORM,CAR,PACK-INTERN,IF,EVENT-NAME,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MV-INTRO-MACRO-FN">mv-intro-macro-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-mv-intro-macro-fn" data-sym="MV-INTRO-MACRO-FN" title="(defun defstructure::mv-intro-macro-fn
       (defstructure::name defstructure::form defstructure::event-name
        defstructure::readers)
  (let* ((defstructure::event-name
          (if defstructure::event-name
...">mv-intro-macro-fn</a>
  (name form
    event-name
    <a class="sym-link local-def" href="#def-readers" data-sym="READERS" title="(defun defstructure::readers (defstructure::db)
  &quot;Define the reader functions&quot;
  (defstructure::db-let (defstructure::slot-names)
   (if defstructure::slot-names
       (cons &quot;
...">readers</a>)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((event-name (if event-name
         event-name
         (pack-intern (car form)
           name
           <span class="string">"-MV-INTRO-"</span>
           (car form)))) (n (car (unique-symbols <span class="number">1</span>
            'mv-intro-macro-n
            (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> form))))
      (mv-nth-form `(<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> ,DEFSTRUCTURE::N ,DEFSTRUCTURE::FORM)))
    `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,DEFSTRUCTURE::EVENT-NAME
      (equal ,DEFSTRUCTURE::MV-NTH-FORM
        (<a class="sym-link system" href="../../axioms.html#def-case" data-sym="CASE">case</a> ,DEFSTRUCTURE::N
          ,@(DEFSTRUCTURE::MV-INTRO-MACRO-CASE-BODY DEFSTRUCTURE::READERS
   DEFSTRUCTURE::FORM 0)
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-hide" data-sym="HIDE">hide</a> ,DEFSTRUCTURE::MV-NTH-FORM))))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> '(<a class="sym-link system" href="../../axioms.html#def-zp" data-sym="ZP">zp</a> open-mv-nth
           ,@DEFSTRUCTURE::READERS)
         <span class="keyword">:expand</span> (<a class="sym-link system" href="../../axioms.html#def-hide" data-sym="HIDE">hide</a> ,DEFSTRUCTURE::MV-NTH-FORM))))))</pre>
  </div>

<div class="form-block function" id="def-mv-intro-macro" data-defines="MV-INTRO-MACRO" data-references="QUOTE,MV-INTRO-MACRO-FN,SYMBOLP,SYMBOL-LISTP,AND,XARGS,DECLARE,EVENT-NAME,&KEY,FORM,DEFMACRO,QUASIQUOTE,LIST,IF,SLOT-NAMES,NAME,DB-LET,DB,DEFUN" data-part-name="MV-INTRO-MACRO" data-part-args="DB" data-part-body="QUOTE,MV-INTRO-MACRO-FN,SYMBOLP,SYMBOL-LISTP,AND,XARGS,DECLARE,EVENT-NAME,&KEY,FORM,DEFMACRO,QUASIQUOTE,LIST,IF,MV-INTRO-MACRO,SLOT-NAMES,NAME,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MV-INTRO-MACRO">mv-intro-macro</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-mv-intro-macro" data-sym="MV-INTRO-MACRO" title="(defun defstructure::mv-intro-macro (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::slot-names defstructure::mv-intro-macro)
   (if defstructure::mv-intro-macro
       (list &quot;
...">mv-intro-macro</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name slot-names
      <a class="sym-link local-def" href="#def-mv-intro-macro" data-sym="MV-INTRO-MACRO" title="(defun defstructure::mv-intro-macro (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::slot-names defstructure::mv-intro-macro)
   (if defstructure::mv-intro-macro
       (list &quot;
...">mv-intro-macro</a>)
    (if <a class="sym-link local-def" href="#def-mv-intro-macro" data-sym="MV-INTRO-MACRO" title="(defun defstructure::mv-intro-macro (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::slot-names defstructure::mv-intro-macro)
   (if defstructure::mv-intro-macro
       (list &quot;
...">mv-intro-macro</a>
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This macro generates a lemma that will rewrite MV-NTH applied to any form
;  as a call of the appropriate reader for this MV structure.
"</span>
        `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,DEFSTRUCTURE::MV-INTRO-MACRO
          (form &amp;key event-name)
          (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> form
                (<a class="sym-link system" href="../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> form)
                (symbolp event-name))))
          (<a class="sym-link local-def" href="#def-mv-intro-macro-fn" data-sym="MV-INTRO-MACRO-FN" title="(defun defstructure::mv-intro-macro-fn
       (defstructure::name defstructure::form defstructure::event-name
        defstructure::readers)
  (let* ((defstructure::event-name
          (if defstructure::event-name
...">mv-intro-macro-fn</a> ',DEFSTRUCTURE::NAME
            form
            event-name
            ',(DEFSTRUCTURE::MAP-SLOTS-DB DEFSTRUCTURE::SLOT-NAMES :READER DEFSTRUCTURE::DB))))
      nil)))</pre>
  </div>

<div class="form-block function" id="def-definition-theory" data-defines="DEFINITION-THEORY" data-references="DISABLE,IN-THEORY,QUOTE,DEFTHEORY,QUASIQUOTE,LIST,IF,INLINE,REPRESENTATION,SLOT-NAMES,PREDICATE,WEAK-PREDICATE,NAME,DB-LET,DB,DEFUN" data-part-name="DEFINITION-THEORY" data-part-args="DB" data-part-body="DISABLE,IN-THEORY,QUOTE,DEFTHEORY,QUASIQUOTE,LIST,IF,INLINE,REPRESENTATION,SLOT-NAMES,DEFINITION-THEORY,PREDICATE,WEAK-PREDICATE,NAME,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFINITION-THEORY">definition-theory</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-definition-theory" data-sym="DEFINITION-THEORY" title="(defun defstructure::definition-theory (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::weak-predicate defstructure::predicate
    defstructure::definition-theory defstructure::slot-names
    defstructure::representation inline)
...">definition-theory</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (name <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
      <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
      <a class="sym-link local-def" href="#def-definition-theory" data-sym="DEFINITION-THEORY" title="(defun defstructure::definition-theory (defstructure::db)
  (defstructure::db-let
   (defstructure::name defstructure::weak-predicate defstructure::predicate
    defstructure::definition-theory defstructure::slot-names
    defstructure::representation inline)
...">definition-theory</a>
      slot-names
      representation
      inline)
    (if inline
      nil
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This theory consists of all :DEFINITION runes associated with the
;  constructor, predicates, and slot readers/writers.  Only the
;  :TYPE-PRESCRIPTIONS and :EXECUTABLE-COUNTERPARTS remain ENABLEd.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-deftheory" data-sym="DEFTHEORY">deftheory</a> ,DEFSTRUCTURE::DEFINITION-THEORY
          '(,@(IF (EQ DEFSTRUCTURE::REPRESENTATION :MV)
      NIL
      (LIST DEFSTRUCTURE::NAME)) ,DEFSTRUCTURE::WEAK-PREDICATE
            ,DEFSTRUCTURE::PREDICATE
            ,@(DEFSTRUCTURE::MAP-IF-SLOTS-DB DEFSTRUCTURE::SLOT-NAMES :READER
   DEFSTRUCTURE::DB)
            ,@(DEFSTRUCTURE::MAP-IF-SLOTS-DB DEFSTRUCTURE::SLOT-NAMES :WRITER
   DEFSTRUCTURE::DB)))
        `(<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable ,DEFSTRUCTURE::DEFINITION-THEORY))))))</pre>
  </div>

<div class="form-block other" id="form-139" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop lemma-theory-names
  (lemma-names <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((lemma-key in
       lemma-names))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (let ((lemma-name (<a class="sym-link local-def" href="#def-db-fn" data-sym="DB-FN" title="(defun defstructure::db-fn
       (defstructure::key defstructure::form defstructure::db)
  (let ((defstructure::pair (assoc defstructure::key defstructure::db)))
    (cond (defstructure::pair (cdr defstructure::pair))
          (t
...">db-fn</a> lemma-key
             `(<a class="sym-link local-def" href="#def-lemma-theory" data-sym="LEMMA-THEORY" title="(defun defstructure::lemma-theory (defstructure::db)
  (defstructure::db-let (defstructure::lemma-theory inline)
   (if inline
       nil
       (list &quot;
...">lemma-theory</a> ,DEFSTRUCTURE::LEMMA-KEY)
             <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
        (if lemma-name
          (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> lemma-name)
          nil)))))</pre>
  </div>

<div class="form-block function" id="def-lemma-theory" data-defines="LEMMA-THEORY" data-references="QUOTE,DEFTHEORY,QUASIQUOTE,LIST,IF,INLINE,DB-LET,DB,DEFUN" data-part-name="LEMMA-THEORY" data-part-args="DB" data-part-body="QUOTE,DEFTHEORY,QUASIQUOTE,LIST,IF,INLINE,LEMMA-THEORY,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LEMMA-THEORY">lemma-theory</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lemma-theory" data-sym="LEMMA-THEORY" title="(defun defstructure::lemma-theory (defstructure::db)
  (defstructure::db-let (defstructure::lemma-theory inline)
   (if inline
       nil
       (list &quot;
...">lemma-theory</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (<a class="sym-link local-def" href="#def-lemma-theory" data-sym="LEMMA-THEORY" title="(defun defstructure::lemma-theory (defstructure::db)
  (defstructure::db-let (defstructure::lemma-theory inline)
   (if inline
       nil
       (list &quot;
...">lemma-theory</a> inline)
    (if inline
      nil
      (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="string">"
;  This theory lists every lemma generated by this DEFSTRUCTURE.  These are
;  normally to remain ENABLEd.
 "</span>
        `(<a class="sym-link system" href="../../axioms.html#def-deftheory" data-sym="DEFTHEORY">deftheory</a> ,DEFSTRUCTURE::LEMMA-THEORY
          '(,@(DEFSTRUCTURE::LEMMA-THEORY-NAMES DEFSTRUCTURE::*LEMMA-NAMES*
   DEFSTRUCTURE::DB)))))))</pre>
  </div>

<div class="form-block other" id="form-141" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *update-methods*
  '(<span class="keyword">:heuristic</span> <span class="keyword">:set</span> <span class="keyword">:copy</span>))</pre>
  </div>

<div class="form-block other" id="form-142" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *keyword-representations*
  '(<span class="keyword">:list</span> <span class="keyword">:mv</span> <span class="keyword">:dotted-list</span> <span class="keyword">:tree</span>))</pre>
  </div>

<div class="form-block other" id="form-143" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *options*
  '(<span class="keyword">:assert</span> <span class="keyword">:assertion-lemma-hints</span> <span class="keyword">:conc-name</span> <span class="keyword">:do-not</span> <span class="keyword">:force</span> <span class="keyword">:guards</span> <span class="keyword">:mv-intro-macro</span> <span class="keyword">:keyword-constructor</span> <span class="keyword">:keyword-updater</span> <span class="keyword">:predicate</span> <span class="keyword">:predicate-guard-hints</span> <span class="keyword">:prefix</span> <span class="keyword">:inline</span> <span class="keyword">:read-write-lemma</span> <span class="keyword">:representation</span> <span class="keyword">:set-conc-name</span> <span class="keyword">:slot-writers</span> <span class="keyword">:weak-predicate</span> <span class="keyword">:update-method</span> <span class="keyword">:verify-guards</span> <span class="keyword">:write-write-lemma</span>))</pre>
  </div>

<div class="form-block other" id="form-144" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *duplicate-options*
  '(<span class="keyword">:assert</span> <span class="keyword">:do-not</span>))</pre>
  </div>

<div class="form-block other" id="form-145" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *do-not-options*
  '(<span class="keyword">:tag</span> <span class="keyword">:read-write</span> <span class="keyword">:write-write</span>))</pre>
  </div>

<div class="form-block other" id="form-146" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *slot-options*
  '(<span class="keyword">:default</span> <span class="keyword">:read-only</span> <span class="keyword">:assert</span>))</pre>
  </div>

<div class="form-block other" id="form-147" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *duplicate-slot-options*
  '(<span class="keyword">:assert</span>))</pre>
  </div>

<div class="form-block other" id="form-148" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *rule-tokens*
  '(<span class="keyword">:built-in-clause</span> <span class="keyword">:compound-recognizer</span> <span class="keyword">:congruence</span> <span class="keyword">:definition</span> <span class="keyword">:elim</span> <span class="keyword">:equivalence</span> <span class="keyword">:forward-chaining</span> <span class="keyword">:generalize</span> <span class="keyword">:induction</span> <span class="keyword">:linear</span> <span class="keyword">:linear-alias</span> <span class="keyword">:meta</span> nil
    <span class="keyword">:refinement</span> <span class="keyword">:rewrite</span> <span class="keyword">:type-prescription</span> <span class="keyword">:type-set-inverter</span> <span class="keyword">:well-founded-relation</span>))</pre>
  </div>

<div class="form-block function" id="def-check-assertion" data-defines="CHECK-ASSERTION" data-references="MAP-SLOTS-DB,SUBST-EXPR-ALL,MAKE,IF,MEMBER,AND,MSG,SUBSETP,ERR,FREE-VARS,BOUND-SLOTS,LET*,T,REASON-FOR-NOT-ASSERTION-TERMP,BOMB,ASSERTION-TERMP,NOT,COND,SLOT-NAMES,DB-LET,DB,CONTEXT,SLOT,ASSERTION,DEFUN" data-used-by="PARSE-RULE" data-part-name="CHECK-ASSERTION" data-part-args="DB,CONTEXT,SLOT,ASSERTION" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHECK-ASSERTION">check-assertion</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-check-assertion" data-sym="CHECK-ASSERTION" title="(defun defstructure::check-assertion
       (defstructure::assertion defstructure::slot defstructure::context
        defstructure::db)
  &quot;Check the assertion for syntax, and return an ASSERTION record containing
   the assertion, its bound slots, its substitution, and its associated slot.&quot;
...">check-assertion</a>
  (assertion slot
    context
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Check the assertion for syntax, and return an ASSERTION record containing
   the assertion, its bound slots, its substitution, and its associated slot."</span>
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (assertion-termp assertion)) (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"Assertions are required to satisfy DEFSTRUCTURE::ASSERTION-TERMP, ~
             and ~p0 does not because ~@1."</span>
          assertion
          (reason-for-not-assertion-termp assertion)))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((bound-slots (<a class="sym-link local-def" href="#def-free-vars" data-sym="FREE-VARS" title="(defun defstructure::free-vars (defstructure::term)
  (defstructure::free-vars1 defstructure::term &#39;nil))">free-vars</a> assertion)) (err (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> bound-slots slot-names)) (<a class="sym-link system" href="../../axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"is not a subset of the slot names ~p0."</span>
                    slot-names))
                ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> slot
                   (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> slot bound-slots))) (<a class="sym-link system" href="../../axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"does not contain the current slot ~p0."</span>
                    slot)))))
          (if err
            (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The putative assertion ~p0 in the context ~p1 is not ~
                   a valid assertion because the free variable list of the ~
                   assertion (as defined by DEFSTRUCTURE::FREE-VARS), ~p2, ~
                   ~@3  If you feel that this message is incorrect, ~
                   then restate your assertion as a LAMBDA function ~
                   and try again."</span>
              assertion
              context
              bound-slots
              err)
            (<a class="sym-link system" href="../../basis-a.html#def-make" data-sym="MAKE">make</a> assertion
              <span class="keyword">:assertion</span> assertion
              <span class="keyword">:bound-slots</span> bound-slots
              <span class="keyword">:subst-assertion</span> (<a class="sym-link local-def" href="#def-subst-expr-all" data-sym="SUBST-EXPR-ALL" title="(defun defstructure::subst-expr-all
       (defstructure::term defstructure::new-list defstructure::old-list)
  (cond ((atom defstructure::old-list) defstructure::term)
        (t
         (defstructure::subst-expr-all
...">subst-expr-all</a> assertion
                (map-slots-db bound-slots
                  <span class="keyword">:reader-call</span> <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
                bound-slots)
              <span class="keyword">:slot</span> slot
              <span class="keyword">:rules</span> nil)))))))</pre>
  </div>

<div class="form-block function" id="def-parse-rule" data-defines="PARSE-RULE" data-references="REST,APPEND,SECOND,CHECK-ASSERTION,ASSERTION,T,TRUE-LISTP,QUASIQUOTE,MAKE,CDR,NULL,COND,EQUAL,BOMB,*RULE-TOKENS*,MEMBER,SYMBOLP,NOT,OR,CAR,ATOM,IF,RULE-TOKEN,LET,DB,SLOT,CONTEXT,DEFAULT-ASSERTION,RULE,DEFUN" data-part-name="PARSE-RULE" data-part-args="DB,SLOT,CONTEXT,DEFAULT-ASSERTION,RULE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PARSE-RULE">parse-rule</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-parse-rule" data-sym="PARSE-RULE" title="(defun defstructure::parse-rule
       (defstructure::rule defstructure::default-assertion
        defstructure::context defstructure::slot defstructure::db)
  &quot;Check rule syntax and return a RULE record.&quot;
  (let ((defstructure::rule-token
...">parse-rule</a>
  (rule default-assertion
    context
    slot
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Check rule syntax and return a RULE record."</span>
  (let ((rule-token (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> rule)
         rule
         (car rule))))
    (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp rule-token))
        (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> rule-token
            *rule-tokens*)))
      (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The putative rule descriptor ~p0 in the context ~
               ~p1 is not valid because ~#2~[it~/its CAR~] ~
               is not one of the allowable rule tokens ~v3."</span>
        rule
        context
        (if (equal rule rule-token)
          <span class="number">0</span>
          <span class="number">1</span>)
        *rule-tokens*)
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> rule)
           (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> (cdr rule))) (<a class="sym-link system" href="../../basis-a.html#def-make" data-sym="MAKE">make</a> rule
            <span class="keyword">:assertion</span> default-assertion
            <span class="keyword">:rule-class</span> `(,DEFSTRUCTURE::RULE-TOKEN <span class="keyword">:corollary</span> ,(DEFSTRUCTURE::MAKE-COROLLARY DEFSTRUCTURE::DEFAULT-ASSERTION DEFSTRUCTURE::DB))))
        ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> rule)) (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The putative atomic rule descriptor ~p0 in the context ~
           ~p1 is not valid because it is not a true list."</span>
            rule
            context))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (let ((assertion (<a class="sym-link local-def" href="#def-check-assertion" data-sym="CHECK-ASSERTION" title="(defun defstructure::check-assertion
       (defstructure::assertion defstructure::slot defstructure::context
        defstructure::db)
  &quot;Check the assertion for syntax, and return an ASSERTION record containing
   the assertion, its bound slots, its substitution, and its associated slot.&quot;
...">check-assertion</a> (<a class="sym-link system" href="../../axioms.html#def-second" data-sym="SECOND">second</a> rule)
                 slot
                 rule
                 <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
            (<a class="sym-link system" href="../../basis-a.html#def-make" data-sym="MAKE">make</a> rule
              <span class="keyword">:assertion</span> assertion
              <span class="keyword">:rule-class</span> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> `(,DEFSTRUCTURE::RULE-TOKEN <span class="keyword">:corollary</span> ,(DEFSTRUCTURE::MAKE-COROLLARY DEFSTRUCTURE::ASSERTION DEFSTRUCTURE::DB))
                (<a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a> (<a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a> rule))))))))))</pre>
  </div>

<div class="form-block other" id="form-151" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop parse-rule-list
  (rule-list default-assertion
    context
    slot
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (for ((rule in
       rule-list))
    (collect (<a class="sym-link local-def" href="#def-parse-rule" data-sym="PARSE-RULE" title="(defun defstructure::parse-rule
       (defstructure::rule defstructure::default-assertion
        defstructure::context defstructure::slot defstructure::db)
  &quot;Check rule syntax and return a RULE record.&quot;
  (let ((defstructure::rule-token
...">parse-rule</a> rule
        default-assertion
        context
        slot
        <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))))</pre>
  </div>

<div class="form-block other" id="form-152" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop parse-assert-options
  (assert-options slot
    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"Traverse the assert-options (which *only* consist of :ASSERT options),
  and check the syntax and collect a list of ASSERTION records."</span>
  (for ((option in
       assert-options))
    (collect (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> option)
          (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> (<a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a> option))
          (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> option)))
        (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The :ASSERT option ~p0 needs an assertion and optional ~
           rule-descriptors, or it is not a true list."</span>)
        (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((assertion (<a class="sym-link local-def" href="#def-check-assertion" data-sym="CHECK-ASSERTION" title="(defun defstructure::check-assertion
       (defstructure::assertion defstructure::slot defstructure::context
        defstructure::db)
  &quot;Check the assertion for syntax, and return an ASSERTION record containing
   the assertion, its bound slots, its substitution, and its associated slot.&quot;
...">check-assertion</a> (<a class="sym-link system" href="../../axioms.html#def-second" data-sym="SECOND">second</a> option)
               slot
               option
               <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)) (rule-list (parse-rule-list (<a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a> (<a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a> option))
                assertion
                option
                slot
                <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
          (<a class="sym-link system" href="../../basis-a.html#def-change" data-sym="CHANGE">change</a> assertion
            assertion
            <span class="keyword">:rules</span> rule-list))))))</pre>
  </div>

<div class="form-block other" id="form-153" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop parse-slot-options
  (slots <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  <span class="string">"We know that the slot is either a valid symbol, or a CONS whose CAR is a
  valid symbol.  Check all of the rest of the syntax and return an extension
  to be APPENDed to the DB."</span>
  (for ((slot-and-options in
       slots))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((slot-name (if (symbolp slot-and-options)
             slot-and-options
             (car slot-and-options))) (options (if (symbolp slot-and-options)
              nil
              (cdr slot-and-options))))
        (<a class="sym-link local-def" href="#def-acons-up" data-sym="ACONS-UP" title="(defmacro defstructure::acons-up (&amp;rest defstructure::forms)
  (cond ((null defstructure::forms) &#39;nil)
        (t
         `(defstructure::acons$ ,(caar defstructure::forms)
           ,(cadar defstructure::forms)">acons-up</a> ((cons slot-name <span class="keyword">:read-only</span>) (get-option-as-flag '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
              <span class="keyword">:read-only</span> options))
          ((cons slot-name <span class="keyword">:default-specified</span>) (get-option-entry <span class="keyword">:default</span> options))
          ((cons slot-name <span class="keyword">:default</span>) (get-option-argument '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
              <span class="keyword">:default</span> options
              <span class="keyword">:form</span> nil
              nil))
          ((cons slot-name <span class="keyword">:assertions</span>) (parse-assert-options (get-option-entries <span class="keyword">:assert</span> options)
              slot-name
              <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-get-string-designator" data-defines="GET-STRING-DESIGNATOR" data-references="DEFSTRUCTURE,QUOTE,GET-OPTION-ARGUMENT,DESIGNATED-STRING,DEFAULT,OPTIONS,KEY,DEFUN" data-used-by="PARSE-DEFSTRUCTURE" data-part-name="GET-STRING-DESIGNATOR" data-part-args="DEFAULT,OPTIONS,KEY" data-part-body="DEFAULT,OPTIONS,KEY,DEFSTRUCTURE,QUOTE,GET-OPTION-ARGUMENT,DESIGNATED-STRING" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-STRING-DESIGNATOR">get-string-designator</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-string-designator" data-sym="GET-STRING-DESIGNATOR" title="(defun defstructure::get-string-designator
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::designated-string
   (defstructure::get-option-argument &#39;defstructure::defstructure
    defstructure::key defstructure::options :string-designator">get-string-designator</a>
  (key options
    <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)
  (<a class="sym-link local-def" href="#def-designated-string" data-sym="DESIGNATED-STRING" title="(defun defstructure::designated-string (defstructure::string-designator)
  (cond ((null defstructure::string-designator) &quot;&quot;)
        (t (string defstructure::string-designator))))">designated-string</a> (get-option-argument '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
      key
      options
      <span class="keyword">:string-designator</span> <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>
      <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)))</pre>
  </div>

<div class="form-block function" id="def-get-symbol" data-defines="GET-SYMBOL" data-references="DEFSTRUCTURE,QUOTE,GET-OPTION-ARGUMENT,DEFAULT,OPTIONS,KEY,DEFUN" data-used-by="PARSE-DEFSTRUCTURE" data-part-name="GET-SYMBOL" data-part-args="DEFAULT,OPTIONS,KEY" data-part-body="DEFAULT,OPTIONS,KEY,DEFSTRUCTURE,QUOTE,GET-OPTION-ARGUMENT" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-SYMBOL">get-symbol</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a>
  (key options
    <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)
  (get-option-argument '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
    key
    options
    <span class="keyword">:symbol</span> <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>
    <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>))</pre>
  </div>

<div class="form-block other" id="form-156" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop parse-do-not-options
  (do-not-options)
  <span class="string">"We allow any number of :DO-NOT options.  We return an alist to append to
   the DB that resets the defaults."</span>
  (for ((options on
       do-not-options))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (let ((do-nots (get-option-subset '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
             <span class="keyword">:do-not</span> options
             *do-not-options*
             nil)))
        (<a class="sym-link system" href="../../axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> do-nots
          (<a class="sym-link system" href="../../axioms.html#def-make-list" data-sym="MAKE-LIST">make-list</a> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> do-nots)
            <span class="keyword">:initial-element</span> nil))))))</pre>
  </div>

<div class="form-block function" id="def-get-representation" data-defines="GET-REPRESENTATION" data-references="BOMB,LENGTH,EQUAL,SUBSETP,FLATTEN,L,*KEYWORD-REPRESENTATIONS*,CADR,MEMBER,OR,CDDR,TRUE-LISTP,AND,IF,T,CDR,NULL,CONSP,COND,DEFAULT,GET-OPTION-ENTRY,OPT,LET,SLOT-NAMES,OPTIONS,DEFUN" data-used-by="PARSE-DEFSTRUCTURE" data-part-name="GET-REPRESENTATION" data-part-args="SLOT-NAMES,OPTIONS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-REPRESENTATION">get-representation</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-representation" data-sym="GET-REPRESENTATION" title="(defun defstructure::get-representation
       (defstructure::options defstructure::slot-names)
  &quot;The :REPRESENTATION has a special syntax.&quot;
  (let ((defstructure::opt
         (defstructure::get-option-entry :representation
...">get-representation</a>
  (options slot-names)
  <span class="string">"The :REPRESENTATION has a special syntax."</span>
  (let ((opt (get-option-entry <span class="keyword">:representation</span> options)) (<a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a> <span class="keyword">:list</span>))
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> (opt (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((consp opt) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> (cdr opt)) <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)
              (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> opt)
                    (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> opt))
                    (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> opt)
                        *keyword-representations*)
                      (let ((l (<a class="sym-link local-def" href="#def-flatten" data-sym="FLATTEN" title="(defun defstructure::flatten (defstructure::args)
  &quot;An `improper&#39; list flattener.  NIL is always flattened away.&quot;
  (cond
   ((atom defstructure::args)
    (cond ((null defstructure::args) nil) (t (list defstructure::args))))
...">flatten</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> opt))))
                        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> l slot-names)
                          (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> slot-names l)
                          (equal (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> l)
                            (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> slot-names))))))
                  (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> opt)
                  (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The :REPRESENTATION option descriptor must be either ~
                         :REPRESENTATION, (:REPRESENTATION), ~
                         or (:REPRESENTATION representation), where ~
                         representation is either one of ~v0, or a CONS ~
                         tree which when flattened according to ~
                         DEFSTRUCTURE::FLATTEN yields a permutation of the ~
                         slot names ~p1, but ~p2 is not."</span>
                    *keyword-representations*
                    slot-names
                    opt)))))
          (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>))))</pre>
  </div>

<div class="form-block function" id="def-parse-defstructure" data-defines="PARSE-DEFSTRUCTURE" data-references="PARSE-SLOT-OPTIONS,PARSE-ASSERT-OPTIONS,READER-CALLS,READER-NAMES,QUASIQUOTE,CONS,UNIQUE-SYMBOLS,GET-OPTION-ENTRIES,PARSE-DO-NOT-OPTIONS,APPEND-DB,GET-OPTION-ARGUMENT,*UPDATE-METHODS*,METHOD,DEFAULT,CADR,ATOM,OR,GET-OPTION-ENTRY,ENTRY,NOT,DB,COND,SLOT-WRITERS,LET,GET-REPRESENTATION,PACK-INTERN,GET-SYMBOL,STRING,CONCATENATE,GET-STRING-DESIGNATOR,T,GET-OPTION-MEMBER,DEFSTRUCTURE,QUOTE,GET-OPTION-AS-FLAG,ACONS-DB,EXTEND-DB,MAP-X-OR-CAR-X,SLOT-NAMES,BUTLAST,SLOTS,OPTIONS,EQ,CONSP,OPTIONS?,LAST,LAST-CAR,CDR,SLOTS-AND-OPTIONS,CAR,STRINGP,DOC,BOMB,SYMBOLP,AND,IF,LET*,DOC-AND-SLOTS,NAME,DEFUN" data-used-by="DEFSTRUCTURE" data-part-name="PARSE-DEFSTRUCTURE" data-part-args="DOC-AND-SLOTS,NAME" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PARSE-DEFSTRUCTURE">parse-defstructure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-parse-defstructure" data-sym="PARSE-DEFSTRUCTURE" title="(defun defstructure::parse-defstructure
       (defstructure::name defstructure::doc-and-slots)
  &quot;Parse the DEFSTRUCTURE arguments, returning the DB&quot;
  (let* ((defstructure::name
          (if (and defstructure::name (symbolp defstructure::name))
...">parse-defstructure</a>
  (name doc-and-slots)
  <span class="string">"Parse the DEFSTRUCTURE arguments, returning the DB"</span>
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((name (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> name (symbolp name))
         name
         (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The &lt;name&gt; argument of DEFSTRUCTURE must be a ~
               non-NIL symbol, but ~p0 is not."</span>
           name))) (<a class="sym-link system" href="../../history-management.html#def-doc" data-sym="DOC">doc</a> (if (stringp (car doc-and-slots))
          (car doc-and-slots)
          nil))
      (slots-and-options (if <a class="sym-link system" href="../../history-management.html#def-doc" data-sym="DOC">doc</a>
          (cdr doc-and-slots)
          doc-and-slots))
      (last-car (car (<a class="sym-link system" href="../../axioms.html#def-last" data-sym="LAST">last</a> slots-and-options)))
      (options? (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp last-car)
          (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car last-car) <span class="keyword">:options</span>)))
      (options (if options?
          (cdr last-car)
          nil))
      (slots (if options?
          (<a class="sym-link system" href="../../axioms.html#def-butlast" data-sym="BUTLAST">butlast</a> slots-and-options <span class="number">1</span>)
          slots-and-options))
      (slot-names (map-x-or-car-x slots)))
    (<a class="sym-link local-def" href="#def-extend-db" data-sym="EXTEND-DB" title="(defmacro defstructure::extend-db (&amp;rest defstructure::forms)
  &quot;Evaluate each form in the context of the DB that successive forms
   created.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">extend-db</a> nil
      (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> (<span class="keyword">:name</span> name)
        (<span class="keyword">:doc</span> <a class="sym-link system" href="../../history-management.html#def-doc" data-sym="DOC">doc</a>)
        (<span class="keyword">:slot-names</span> slot-names)
        (<span class="keyword">:guards</span> (get-option-as-flag '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:guards</span> options))
        (<span class="keyword">:verify-guards</span> (get-option-member '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:verify-guards</span> options
            '(<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> nil)
            <span class="keyword">:default</span> <span class="keyword">:default</span>))
        (<span class="keyword">:inline</span> (get-option-as-flag '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:inline</span> options))
        (<span class="keyword">:conc-name</span> (<a class="sym-link local-def" href="#def-get-string-designator" data-sym="GET-STRING-DESIGNATOR" title="(defun defstructure::get-string-designator
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::designated-string
   (defstructure::get-option-argument &#39;defstructure::defstructure
    defstructure::key defstructure::options :string-designator">get-string-designator</a> <span class="keyword">:conc-name</span> options
            (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> (<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> name) <span class="string">"-"</span>)))
        (<span class="keyword">:set-conc-name</span> (<a class="sym-link local-def" href="#def-get-string-designator" data-sym="GET-STRING-DESIGNATOR" title="(defun defstructure::get-string-designator
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::designated-string
   (defstructure::get-option-argument &#39;defstructure::defstructure
    defstructure::key defstructure::options :string-designator">get-string-designator</a> <span class="keyword">:set-conc-name</span> options
            (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"SET-"</span> (<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> name) <span class="string">"-"</span>)))
        (<span class="keyword">:keyword-constructor</span> (<a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a> <span class="keyword">:keyword-constructor</span> options
            (pack-intern name
              <span class="string">"MAKE-"</span>
              name)))
        (<span class="keyword">:keyword-updater</span> (<a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a> <span class="keyword">:keyword-updater</span> options
            (pack-intern name
              <span class="string">"UPDATE-"</span>
              name)))
        (<span class="keyword">:predicate</span> (<a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a> <span class="keyword">:predicate</span> options
            (pack-intern name
              name
              <span class="string">"-P"</span>)))
        (<span class="keyword">:weak-predicate</span> (<a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a> <span class="keyword">:weak-predicate</span> options
            (pack-intern name
              <span class="string">"WEAK-"</span>
              name
              <span class="string">"-P"</span>)))
        (<span class="keyword">:force</span> (get-option-as-flag '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:force</span> options))
        (<span class="keyword">:representation</span> (<a class="sym-link local-def" href="#def-get-representation" data-sym="GET-REPRESENTATION" title="(defun defstructure::get-representation
       (defstructure::options defstructure::slot-names)
  &quot;The :REPRESENTATION has a special syntax.&quot;
  (let ((defstructure::opt
         (defstructure::get-option-entry :representation
...">get-representation</a> options
            slot-names))
        (<span class="keyword">:read-only</span> (let ((slot-writers (get-option-as-flag '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
                 <span class="keyword">:slot-writers</span> options)))
            (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> slot-writers
                 (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:representation</span>) <span class="keyword">:mv</span>)) (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">":MV structures can&#39;t have :SLOT-WRITERS."</span>))
              (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> slot-writers)))))
        (<span class="keyword">:mv-intro-macro</span> (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:representation</span>) <span class="keyword">:mv</span>)
            (<a class="sym-link local-def" href="#def-get-symbol" data-sym="GET-SYMBOL" title="(defun defstructure::get-symbol
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::get-option-argument &#39;defstructure::defstructure
   defstructure::key defstructure::options :symbol defstructure::default
   defstructure::default))">get-symbol</a> <span class="keyword">:mv-intro-macro</span> options
              (pack-intern name
                name
                <span class="string">"-INTRO"</span>))
            (let ((entry (get-option-entry <span class="keyword">:mv-intro-macro</span> options)))
              (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> entry
                  (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> entry)
                    (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr entry))
                    (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> entry)))
                (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The :MV-INTRO-MACRO option is illegal unless the ~
                    (:REPRESENTATION :MV) option is chosen."</span>)
                nil))))
        (<span class="keyword">:update-method</span> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((<a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a> (if (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:read-only</span>)
                 <span class="keyword">:copy</span> <span class="keyword">:heuristic</span>)) (method (get-option-member '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
                  <span class="keyword">:update-method</span> options
                  *update-methods*
                  <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>
                  <a class="sym-link system" href="../../axioms.html#def-default" data-sym="DEFAULT">default</a>)))
            (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:read-only</span>) (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> method <span class="keyword">:copy</span>)))
              (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"The only valid :UPDATE-METHOD for structures without ~
                    :SLOT-WRITERS is :COPY."</span>)
              (if (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:inline</span>)
                <span class="keyword">:inline</span> method))))
        (<span class="keyword">:assertion-lemma-hints</span> (get-option-argument '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:assertion-lemma-hints</span> options
            <span class="keyword">:form</span> nil
            nil))
        (<span class="keyword">:predicate-guard-hints</span> (get-option-argument '<a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
            <span class="keyword">:predicate-guard-hints</span> options
            <span class="keyword">:form</span> nil
            nil))
        (<span class="keyword">:prefix</span> (<a class="sym-link local-def" href="#def-get-string-designator" data-sym="GET-STRING-DESIGNATOR" title="(defun defstructure::get-string-designator
       (defstructure::key defstructure::options defstructure::default)
  (defstructure::designated-string
   (defstructure::get-option-argument &#39;defstructure::defstructure
    defstructure::key defstructure::options :string-designator">get-string-designator</a> <span class="keyword">:prefix</span> options
            <span class="string">"DEFS-"</span>))
        (<span class="keyword">:tag</span> name)
        (<span class="keyword">:read-write</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>)
        (<span class="keyword">:write-write</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
      (<a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a> (parse-do-not-options (get-option-entries <span class="keyword">:do-not</span> options)))
      (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> (<span class="keyword">:value-variable</span> (car (unique-symbols <span class="number">2</span>
              (pack-intern name <span class="string">"VALUE"</span>)
              (cons name slot-names))))
        (<span class="keyword">:value-variable1</span> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> (unique-symbols <span class="number">2</span>
              (pack-intern name <span class="string">"VALUE"</span>)
              (cons name slot-names))))
        (<span class="keyword">:predicate-call</span> `(,(DEFSTRUCTURE::DB :PREDICATE) ,DEFSTRUCTURE::NAME)))
      (<a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a> (reader-names slot-names
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
        (reader-calls slot-names
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))
      (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> (<span class="keyword">:assertions</span> (parse-assert-options (get-option-entries <span class="keyword">:assert</span> options)
            nil
            <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
      (<a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a> (parse-slot-options slots
          <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))))</pre>
  </div>

<div class="form-block other" id="form-159" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defloop nullify-lemmas
  (lemma-names)
  (for ((lemma in
       lemma-names))
    (collect (cons lemma nil))))</pre>
  </div>

<div class="form-block function" id="def-prepare-for-code-gen" data-defines="PREPARE-FOR-CODE-GEN" data-references="*LEMMA-NAMES*,NULLIFY-LEMMAS,WRITER-CALLS,WRITER-NAMES,APPEND-DB,ALL-RULE-CLASSES,MAKE-PREFIX-NAME,QUASIQUOTE,KEYWORD-UPDATER,MAKE-TEMPLATE,IF,READ-ONLY-KEYWORD-SLOTS,EQUAL,OR,REQUIRED-SLOT-NAMES,KEYWORDIFY-LIST,ACONS-DB,EXTEND-DB,T,NOT,BOMB,LEN,<,EQ,AND,COND,SET-CONC-NAME,INLINE,WEAK-PREDICATE,WRITE-WRITE,READ-WRITE,TAG,READ-ONLY,PREDICATE,NAME,REPRESENTATION,SLOT-NAMES,DB-LET,DB,DEFUN" data-used-by="DEFSTRUCTURE" data-part-name="PREPARE-FOR-CODE-GEN" data-part-args="DB" data-part-body="*LEMMA-NAMES*,NULLIFY-LEMMAS,WRITER-CALLS,WRITER-NAMES,APPEND-DB,ALL-RULE-CLASSES,MAKE-PREFIX-NAME,QUASIQUOTE,KEYWORD-UPDATER,MAKE-TEMPLATE,IF,READ-ONLY-KEYWORD-SLOTS,EQUAL,OR,DB,REQUIRED-SLOT-NAMES,KEYWORDIFY-LIST,ACONS-DB,EXTEND-DB,T,NOT,BOMB,LEN,<,EQ,AND,COND,SET-CONC-NAME,INLINE,WEAK-PREDICATE,WRITE-WRITE,READ-WRITE,TAG,READ-ONLY,PREDICATE,NAME,REPRESENTATION,SLOT-NAMES,DB-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREPARE-FOR-CODE-GEN">prepare-for-code-gen</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-prepare-for-code-gen" data-sym="PREPARE-FOR-CODE-GEN" title="(defun defstructure::prepare-for-code-gen (defstructure::db)
  (defstructure::db-let
   (defstructure::slot-names defstructure::representation defstructure::name
    defstructure::predicate defstructure::read-only defstructure::tag
    defstructure::read-write defstructure::write-write
...">prepare-for-code-gen</a>
  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
  (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (slot-names representation
      name
      <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
      read-only
      tag
      read-write
      write-write
      <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
      inline
      set-conc-name)
    (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)
         (&lt; (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> slot-names) <span class="number">2</span>)
         (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"An :MV structure must have at least 2 slots in order ~
                  to be valid according to the syntax of Acl2, but ~
                  the current structure has ~#0~[one slot~/no slots~]."</span>
           slot-names)))
      ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>) (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"You have apparently tried to suppress the generation of the
             weak predicate on the structure, which is currently illegal."</span>))
      ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>) (<a class="sym-link local-def" href="#def-bomb" data-sym="BOMB" title="(defmacro defstructure::bomb (defstructure::fmt &amp;rest defstructure::args)
  `(defstructure::bomb-from &#39;defstructure::defstructure ,defstructure::fmt
    ,@defstructure::args))">bomb</a> <span class="string">"You have apparently tried to suppress the generation of the
             predicate on the structure, which is currently illegal."</span>))
      (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-db" data-sym="EXTEND-DB" title="(defmacro defstructure::extend-db (&amp;rest defstructure::forms)
  &quot;Evaluate each form in the context of the DB that successive forms
   created.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">extend-db</a> (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> (<span class="keyword">:keyword-slot-names</span> (keywordify-list slot-names))
            (<span class="keyword">:required-slot-names</span> (required-slot-names slot-names
                <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))
            (<span class="keyword">:read-only</span> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> read-only
                (equal (read-only-keyword-slots slot-names
                    <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
                  (<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> <span class="keyword">:keyword-slot-names</span>))
                (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)))
            (<span class="keyword">:tag</span> (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)
                nil
                tag))
            (<span class="keyword">:template</span> (<a class="sym-link local-def" href="#def-make-template" data-sym="MAKE-TEMPLATE" title="(defun defstructure::make-template (defstructure::db)
  &quot;Using the :SLOT-NAMES, :REPRESENTATION, and :TAG, make a template for
   function generation.  If the structure is tagged, the tag is always added
   as the CAR.  We know that the :TAG is a symbol, and that the
   :REPRSENTATION is of the proper form.&quot;
...">make-template</a> <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)))
          (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (read-only <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>)
            (<a class="sym-link local-def" href="#def-extend-db" data-sym="EXTEND-DB" title="(defmacro defstructure::extend-db (&amp;rest defstructure::forms)
  &quot;Evaluate each form in the context of the DB that successive forms
   created.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">extend-db</a> (<a class="sym-link local-def" href="#def-acons-db" data-sym="ACONS-DB" title="(defmacro defstructure::acons-db (&amp;rest defstructure::forms)
  &quot;Acons up a list of (&lt;keyword&gt; &lt;value&gt;) pairs, evaluting each successive
   form in the context of the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">acons-db</a> (<span class="keyword">:constructor-call</span> `(,DEFSTRUCTURE::NAME ,@DEFSTRUCTURE::SLOT-NAMES))
                (<span class="keyword">:acl2-count-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)
                    nil
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"ACL2-COUNT-"</span>
                      name)))
                (<span class="keyword">:weak-predicate-call</span> `(,DEFSTRUCTURE::WEAK-PREDICATE ,DEFSTRUCTURE::NAME))
                (<span class="keyword">:weak-predicate-constructor-lemma</span> (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
                    <span class="string">"-"</span>
                    name))
                (<span class="keyword">:predicate-weak-predicate-lemma</span> (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
                    <span class="string">"-INCLUDES-"</span>
                    <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>))
                (<span class="keyword">:predicate-constructor-lemma</span> (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
                    <span class="string">"-"</span>
                    name))
                (<span class="keyword">:keyword-updater</span> (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)
                      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> slot-names))
                    nil
                    <a class="sym-link local-def" href="#def-keyword-updater" data-sym="KEYWORD-UPDATER" title="(defun defstructure::keyword-updater (defstructure::db)
  (defstructure::db-let
   (defstructure::keyword-updater defstructure::name
    defstructure::keyword-slot-names defstructure::slot-names
    defstructure::update-method defstructure::template)
...">keyword-updater</a>))
                (<span class="keyword">:read-lemma</span> (if slot-names
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"READ-"</span> name)
                    nil))
                (<span class="keyword">:write-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> read-only (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> slot-names))
                    nil
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"WRITE-"</span> name)))
                (<span class="keyword">:lift-if-lemma</span> (if slot-names
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> name
                      <span class="string">"-LIFT-IF"</span>)
                    nil))
                (<span class="keyword">:elimination-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> representation <span class="keyword">:mv</span>)
                      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> slot-names))
                    nil
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"ELIMINATE-"</span>
                      name)))
                (<span class="keyword">:weak-predicate-slot-writers-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> slot-names (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> read-only))
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <a class="sym-link local-def" href="#def-weak-predicate" data-sym="WEAK-PREDICATE" title="(defun defstructure::weak-predicate (defstructure::db)
  &quot;This is the predicate on the `structure&#39; of the structure. If the
   structure is named, then we include a test that the CAR of the structure
   is the correct name.  We also write a lemma that shows when the
   constructor function satisfies this predicate.&quot;
...">weak-predicate</a>
                      <span class="string">"-"</span>
                      set-conc-name)
                    nil))
                (<span class="keyword">:predicate-slot-writers-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> slot-names (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> read-only))
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
                      <span class="string">"-"</span>
                      set-conc-name)
                    nil))
                (<span class="keyword">:read-write-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> read-write
                      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> read-only)
                      slot-names)
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"READ-WRITE-"</span>
                      name)
                    nil))
                (<span class="keyword">:write-write-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> write-write
                      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> read-only)
                      slot-names)
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> <span class="string">"WRITE-WRITE-"</span>
                      name)
                    nil))
                (<span class="keyword">:assertion-lemma</span> (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> <a class="sym-link local-def" href="#def-predicate" data-sym="PREDICATE" title="(defun defstructure::predicate (defstructure::db)
  (defstructure::db-let
   (defstructure::predicate defstructure::name defstructure::predicate-call
    defstructure::weak-predicate-call defstructure::constructor-call
    defstructure::predicate-weak-predicate-lemma
...">predicate</a>
                      (<a class="sym-link local-def" href="#def-all-rule-classes" data-sym="ALL-RULE-CLASSES" title="(defun defstructure::all-rule-classes (defstructure::db)
  (defstructure::db-let (defstructure::assertions defstructure::slot-names)
   (append
    (defstructure::map-slot-assertions-for-rule-classes
     defstructure::slot-names defstructure::db)">all-rule-classes</a> <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>))
                    (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> name
                      <span class="string">"-ASSERTIONS"</span>)
                    nil))
                (<span class="keyword">:definition-theory</span> (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> name
                    <span class="string">"-DEFINITION-THEORY"</span>))
                (<span class="keyword">:lemma-theory</span> (<a class="sym-link local-def" href="#def-make-prefix-name" data-sym="MAKE-PREFIX-NAME" title="(defmacro defstructure::make-prefix-name (&amp;rest defstructure::names)
  `(defstructure::pack-intern (defstructure::db :name)
    (defstructure::db :prefix) ,@defstructure::names))">make-prefix-name</a> name
                    <span class="string">"-LEMMA-THEORY"</span>)))
              (<a class="sym-link local-def" href="#def-append-db" data-sym="APPEND-DB" title="(defmacro defstructure::append-db (&amp;rest defstructure::forms)
  &quot;APPEND new sublists to DB, evaluting each sucessive form in the context of
   the new DB.&quot;
  (cond ((null defstructure::forms) &#39;defstructure::db)
        (t
...">append-db</a> (writer-names slot-names
                  <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
                (writer-calls slot-names
                  <a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a>)
                (if inline
                  (nullify-lemmas *lemma-names*)
                  nil)))))))))</pre>
  </div>

<div class="form-block macro" id="def-capsule" data-defines="CAPSULE" data-references="ENCAPSULATE,QUASIQUOTE,ARGS,&REST,DEFMACRO" data-used-by="DEFSTRUCTURE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CAPSULE">capsule</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-capsule" data-sym="CAPSULE" title="(defmacro defstructure::capsule (&amp;rest defstructure::args)
  &quot;Remove documentation strings and recast as an ENCAPSULATE.&quot;
  `(defstructure::encapsulate nil
    ,@(defstructure::remove-strings defstructure::args)))">capsule</a>
  (&amp;rest <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  <span class="string">"Remove documentation strings and recast as an ENCAPSULATE."</span>
  `(<a class="sym-link system" href="../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
    ,@(DEFSTRUCTURE::REMOVE-STRINGS DEFSTRUCTURE::ARGS)))</pre>
  </div>

<div class="form-block other" id="form-162" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
  (<a class="sym-link system" href="../../axioms.html#def-logic" data-sym="LOGIC">logic</a>)
  (<a class="sym-link system" href="../../axioms.html#def-deftheory" data-sym="DEFTHEORY">deftheory</a> minimal-theory-for-defstructure
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> <a class="sym-link system" href="../../axioms.html#def-_2Aexpandable-boot-strap-non-rec-fns_2A" data-sym="*EXPANDABLE-BOOT-STRAP-NON-REC-FNS*">*expandable-boot-strap-non-rec-fns*</a>
      (list-all <a class="sym-link system" href="../../history-management.html#def-_2Abuilt-in-executable-counterparts_2A" data-sym="*BUILT-IN-EXECUTABLE-COUNTERPARTS*">*built-in-executable-counterparts*</a>)
      '(<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> <a class="sym-link system" href="../../axioms.html#def-car-cons" data-sym="CAR-CONS">car-cons</a>
        <a class="sym-link system" href="../../axioms.html#def-cdr-cons" data-sym="CDR-CONS">cdr-cons</a>
        <a class="sym-link system" href="../../axioms.html#def-car-cdr-elim" data-sym="CAR-CDR-ELIM">car-cdr-elim</a>
        <a class="sym-link system" href="../../axioms.html#def-eqlablep" data-sym="EQLABLEP">eqlablep</a>
        <a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a>
        <a class="sym-link system" href="../../axioms.html#def-zp" data-sym="ZP">zp</a>
        <a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>
        open-mv-nth
        <a class="sym-link system" href="../../axioms.html#def-o_3C" data-sym="O&lt;">o&lt;</a>
        <a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a>
        (<span class="keyword">:type-prescription</span> <a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a>)
        <a class="sym-link system" href="../../axioms.html#def-integer-abs" data-sym="INTEGER-ABS">integer-abs</a>))))</pre>
  </div>

<div class="form-block macro" id="def-defstructure" data-defines="DEFSTRUCTURE" data-references="MINIMAL-THEORY-FOR-DEFSTRUCTURE,QUOTE,THEORY,IN-THEORY,LOCAL,CAPSULE,PROGN,QUASIQUOTE,GUARDS,INLINE,DB-LET,PARSE-DEFSTRUCTURE,PREPARE-FOR-CODE-GEN,DB,LET,DOC-AND-SLOTS,&REST,NAME,DEFMACRO" data-used-by="PARSE-DEFSTRUCTURE,GET-SYMBOL,GET-STRING-DESIGNATOR,BOMB" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFSTRUCTURE">defstructure</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-defstructure" data-sym="DEFSTRUCTURE" title="(defmacro defstructure::defstructure
          (defstructure::name &amp;rest defstructure::doc-and-slots)
  (let ((defstructure::db
         (defstructure::prepare-for-code-gen
          (defstructure::parse-defstructure defstructure::name
...">defstructure</a>
  (name &amp;rest doc-and-slots)
  (let ((<a class="sym-link local-def" href="#def-db" data-sym="DB" title="(defmacro defstructure::db (&amp;whole defstructure::form &amp;rest defstructure::args)
  (case (length defstructure::args)
    (1
     (cond
      ((not (member (car defstructure::args) defstructure::*db-fields*))
...">db</a> (<a class="sym-link local-def" href="#def-prepare-for-code-gen" data-sym="PREPARE-FOR-CODE-GEN" title="(defun defstructure::prepare-for-code-gen (defstructure::db)
  (defstructure::db-let
   (defstructure::slot-names defstructure::representation defstructure::name
    defstructure::predicate defstructure::read-only defstructure::tag
    defstructure::read-write defstructure::write-write
...">prepare-for-code-gen</a> (<a class="sym-link local-def" href="#def-parse-defstructure" data-sym="PARSE-DEFSTRUCTURE" title="(defun defstructure::parse-defstructure
       (defstructure::name defstructure::doc-and-slots)
  &quot;Parse the DEFSTRUCTURE arguments, returning the DB&quot;
  (let* ((defstructure::name
          (if (and defstructure::name (symbolp defstructure::name))
...">parse-defstructure</a> name
           doc-and-slots))))
    (<a class="sym-link local-def" href="#def-db-let" data-sym="DB-LET" title="(defmacro defstructure::db-let (defstructure::fields &amp;rest defstructure::forms)
  &quot;This macro is a shorthand way to bind fields of the DB to the like-named
   variable.  A field can be a field name, or (slot field).&quot;
  `(let ,(defstructure::db-let-fn defstructure::fields)
     ,@defstructure::forms))">db-let</a> (inline guards)
      `(<a class="sym-link system" href="../../axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link local-def" href="#def-capsule" data-sym="CAPSULE" title="(defmacro defstructure::capsule (&amp;rest defstructure::args)
  &quot;Remove documentation strings and recast as an ENCAPSULATE.&quot;
  `(defstructure::encapsulate nil
    ,@(defstructure::remove-strings defstructure::args)))">capsule</a> <span class="string">"
;  We define the structure and all of the events (except the assertion theory)
;  in the absoulte minimum theory possible in order to expedite the proofs
;  and guarantee that they will always work.  If you ever find a case where
;  one of these proof fails (except due to user syntax errors) please
;  report it as a bug in DEFSTRUCTURE.
 "</span>
          (<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (theory 'minimal-theory-for-defstructure)))
          ,@(DEFSTRUCTURE::CONSTRUCTOR DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::WEAK-PREDICATE DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::READERS DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::WRITERS DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::PREDICATE DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::KEYWORD-CONSTRUCTOR DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::KEYWORD-UPDATER DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::SLOT-WRITERS-LEMMAS DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::READ-WRITE-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::WRITE-WRITE-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::READ-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::WRITE-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::LIFT-IF-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::ELIMINATION-LEMMA DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::MV-INTRO-MACRO DEFSTRUCTURE::DB)
          ,@(DEFSTRUCTURE::DEFINITION-THEORY DEFSTRUCTURE::DB))
        ,@(IF (AND INLINE (NOT DEFSTRUCTURE::GUARDS))
      NIL
      (LIST
       `(DEFSTRUCTURE::CAPSULE ,@(DEFSTRUCTURE::NAKED-PROOFS DEFSTRUCTURE::DB)
         ,@(DEFSTRUCTURE::LEMMA-THEORY DEFSTRUCTURE::DB))))))))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>