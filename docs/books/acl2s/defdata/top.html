<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>top - ACL2 Book</title>
  <meta property="name" content="top">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">‚òÄÔ∏è</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">top</h1>
    <div class="path"><a href="top.lisp" class="source-link">books/acl2s/defdata/top</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"DEFDATA"</span>)</pre>
  </div>

<div class="form-block other" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="base.html" title="Open base">"base"</a>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="sig.html" title="Open sig">"sig"</a> <span class="keyword">:ttags</span> <span class="keyword">:all</span>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/top.html" title="Open xdoc/top">"xdoc/top"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc defdata
  <span class="keyword">:parents</span> (acl2-sedan macro-libraries cgen)
  <span class="keyword">:short</span> <span class="string">"A Data Definition Framework"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;
The defdata framework enables the convenient specification of
data types in ACL2s, the ACL2 Sedan.  The framework concisely
supports common data definition patterns, e.g., list types, map
types, enumerated types, record types, and mutually-recursive
types. It also provides support for polymorphic functions and 
tight integration with Tau.
&lt;/p&gt;

&lt;p&gt;
The data definition framework is a key component of
counterexample generation support in ACL2s, but can be
independently used in ACL2, and is available as a community book.
&lt;/p&gt;

&lt;p&gt;
The defdata framework maintains both a predicative
characterization, via a predicate recognizing elements of the
datatype, and an enumerative characterization, via a function
that can be used to enumerate all the elements of the
datatype. ACL2s picks out the recognizers in a conjecture and can
use the datatype enumerators to generate random elements of the
datatype. This is a key part of counterexample generation in
ACL2s.
&lt;/p&gt;

&lt;p&gt;
The defdata framework also allows us to increase the amount of
automation ACL2s provides for reasoning about data definitions.
For example, our framework generates useful theorems, with
appropriate rule-classes, for list types; it generates accessor
and constructor functions for records with a suitable theory for
reasoning about compositions of these functions; it generates
theorems that characterize the type relations such as inclusion
and exclusion; and it generates events that support polymorphic
type reasoning.
&lt;/p&gt;

&lt;p&gt; The defdata framework is described in our ACL2 2014 paper (a link
to the paper appears later). Below, we provide some examples of its
use.&lt;/p&gt;

&lt;p&gt;Note: If you are trying these examples in a package other than ACL2S,
then you might have to prefix the basic typenames i.e. acl2s::pos.&lt;/p&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;h4&gt;Union and Product types&lt;/h4&gt;
@({
  (defdata inode nat)
  
  (defdata file (cons inode string))
  (defdata er-file (oneof file nil))
  
  (defdata UPNest 
    (oneof (oneof (cons (oneof 11 7) pos-list) &#39;ok symbol-alist) 
           (cons symbol (complex integer -1))
           (oneof (oneof 42 (cons pos file) er-file) t 7/6)
           &quot;nice&quot;))
  
  (defdata loi (oneof nil (cons integer loi)))
})

&lt;h4&gt;Range types&lt;/h4&gt;
@({
  (defdata cache-miss-ratio (range rational (0 &lt; _ &lt; 1)))
  
  (defdata big-unsigned-num (range integer ((expt 2 64) &lt; _)))
})
&lt;p&gt; 
Macros are allowed and the meaning of the defdata body
is the given by its macroexpansion.
&lt;/p&gt;
@({
  (defdata 3d-point (list rational rational rational))
})

&lt;h4&gt;Enum types&lt;/h4&gt;
@({
  (defdata op-code (enum &#39;(lw sw addi subi beqz jr)))
  
  (defun generate-instruction-opcodes (x)
    (if (eq x &#39;mips-risc-model)
        &#39;(lw sw addi subi beqz jr)
      &#39;()))
  
  (defdata op-code1 (enum (generate-instruction-opcodes &#39;mips-risc-model)))
})

&lt;h4&gt;List and Alist types&lt;/h4&gt;
@({
  (defdata files (listof file))

  (defdata symb-alist (alistof symbol all))
})

&lt;h4&gt;Mutually-recursive types&lt;/h4&gt;
@({
  (defdata 
    (dir (listof (cons string dir-entry)))
    (dir-entry (oneof file dir)))
  
  (defdata
    (sexpr (oneof symbol
                  (cons symbol sexpr-list)))
    (sexpr-list (oneof nil
                       (cons sexpr sexpr-list))))  
})

&lt;h4&gt;Record (Struct) types&lt;/h4&gt;
@({
  (defdata reg-num (range integer (0 &lt;= _ &lt; 64)))
  (defdata immediate-range (range integer (0 &lt;= _ &lt; (expt 2 16))))
  
  (defdata inst (record (op  . op-code)
                        (rd  . reg-num)
                        (rs1 . reg-num)
                        (imm . immediate-range)))
})


&lt;h4&gt;Map (unique and sorted entries) types&lt;/h4&gt;
@({
  (defdata p-addr (range integer (0 &lt;= _ &lt; (expt 2 64))))
  (defdata imem (map p-addr inst))
})

&lt;h4&gt;Using record and map types&lt;/h4&gt;
@({
  (b* (;; pick a random imemory
         (I (nth-imem 4511))
         ;; fix a program counter value
         (pc 1)
         ;; get the instruction pointed to by pc
         (instr (mget pc I)) 
         ;; get immediate value field of instr
         (im (inst-imm instr))
         ;; set immediate value field and the pc entry 
         (I1 (mset pc (set-inst-imm (1+ im) instr) I))
         ;; alternative way of getting immediate value field
         (im2 (mget :imm (mget pc I1)))
         ((inst op rd rs1 ?imm) instr)
         )
    (equal (inst op rd rs1 (1- im2)) instr))
})

&lt;h4&gt;Custom types&lt;/h4&gt;
@({
  (defun make-descending-addresses (n)
    (if (zp n)
      nil
      (cons (1- n) (make-descending-addresses (- n 1)))))
  
  (defun imem-custom-enum (n)
    (declare (xargs :mode :program))
    (let* ((m (nth-imem-builtin n))
           (vals (strip-cdrs m))
           (keys (make-descending-addresses (len m))))
      (pairlis$ keys vals)))
  
  (defun imem-customp (x)
    (or (null x)
        (and (consp x)
             (consp (car x))
             (imem-customp (cdr x))
             (instp (cdar x))
             (p-addrp (caar x))
             (or (and (null (cdr x))
                      (equal 0 (caar x)))
                 (&gt; (caar x) (caadr x))))))
  
  (register-type imem-custom
                 :predicate imem-customp
                 :enumerator imem-custom-enum)
  
  
  (defdata-attach imem :test-enumerator imem-custom-enum)
})


&lt;h4&gt;Recursive record types (similar to ML datatype facility)&lt;/h4&gt;
@({
  (defdata tree (oneof &#39;Leaf 
                       (node (val   . string)
                             (left  . tree)
                             (right . tree))))
})


&lt;h4&gt;Polymorphic Type Signatures&lt;/h4&gt;
@({
  (sig binary-append ((listof :a) (listof :a)) =&gt; (listof :a))
  (sig nthcdr (nat (listof :a)) =&gt; (listof :a))
  (sig nth (nat (listof :a)) =&gt; :a 
       :satisfies (&lt; x1 (len x2)))
  ;; xi corresponds to the ith type appearing in the sig form. For example,
  ;; x1 corresponds to nat and x2 to (listof :a) 
})

&lt;h4&gt;Registering a data constructor&lt;/h4&gt;
@({
  (defun acons-caar (x)  (caar x))
  (defun acons-cdar (x)  (cdar x))
  (defun acons-cdr (x)  (cdr x))
  
  (defthm acons-acl2-count-lemma
    (equal (acl2-count (acons x1 x2 x3))
           (+ 2 (acl2-count x1) (acl2-count x2) (acl2-count x3))))
  
  (register-data-constructor (aconsp acons)
                             ((allp acons-caar) (allp acons-cdar) (allp acons-cdr))
                             :rule-classes (:rewrite)
                             :verbose t)
})

&lt;h4&gt;Registering a type&lt;/h4&gt;
@({
  (defun nth-even-builtin (n) 
    (declare (xargs :guard (natp n)))
    (* 2 (nth-integer n)))
  
  (register-type even 
                 :predicate evenp 
                 :enumerator nth-even-builtin)
})

&lt;h4&gt;Registering user-defined combinators&lt;/h4&gt;
@({
  (register-user-combinator alistof 
   :arity 2 :verbose t
   :aliases (acl2::alistof)
   :expansion (lambda (_name _args) `(OR nil (acons ,(car _args) ,(cadr _args) ,_name)))
   :syntax-restriction-fn proper-symbol-listp
   :polymorphic-type-form (alistof :a :b)
   :post-pred-hook-fns (user-alistof-theory-events))
})

&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;
To debug a failed defdata form, you can proceed in multiple ways:
&lt;ul&gt;
&lt;li&gt; At the session editor (or emacs prompt), submit/evaluate
     @(&#39;:trans1 (defdata ...)&#39;)
     And from the output, evaluate the form that says @(&#39;(defdata-events ...)&#39;).&lt;/li&gt;
&lt;li&gt; Use keyword options @(&#39;:verbose t&#39;) and examine the ACL2 output.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;h3&gt;More details&lt;/h3&gt; 

&lt;p&gt; Although most constructs of the defdata language are
package-agnostic, some of the API functions/macros of the Defdata
framework (like &lt;tt&gt;sig&lt;/tt&gt;) reside in the ACL2S package. Use
list (&lt;tt&gt;*acl2s-exports*&lt;/tt&gt;) to import these symbols into your own
package.&lt;/p&gt;

&lt;p&gt; For a comprehensive user guide and more details please refer to the following
&lt;a href=&quot;http://arxiv.org/abs/1406.1557&quot;&gt;paper&lt;/a&gt; &lt;/p&gt;
"</span>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc register-type
  <span class="keyword">:parents</span> (defdata cgen)
  <span class="keyword">:short</span> <span class="string">"Register a name as a defdata type"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Example&lt;/h3&gt;
@({
  (defun nth-odd-builtin (n) 
    (if (evenp n)
        (1+ n)
      (- n)))
  
  (register-type odd
                 :predicate oddp 
                 :enumerator nth-odd-builtin)
})

&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;
A defdata type expression can either be a typename, a quoted constant or
a combinator or constructor expression. To serve as a typename, a symbol
should either have been defined using the @(&#39;defdata&#39;) macro, or
it should have been 
&lt;i&gt;registered&lt;/i&gt; as a &lt;i&gt;defdata type&lt;/i&gt; using the @(&#39;register-type&#39;)
macro.
&lt;/p&gt;

&lt;p&gt;
As an example, after having &lt;i&gt;registered&lt;/i&gt; @(&#39;odd&#39;) above, we can
now use @(&#39;odd&#39;) to define other @(&#39;defdata&#39;) types, e.g., a list of
odd numbers: 
&lt;/p&gt;
@({
  (defdata odds (listof odd))
})

&lt;h4&gt;General Form:&lt;/h4&gt;
@({
(register-type name
               :predicate pred
               :enumerator enum
               [:enum/acc enum2]
               [:enum/test tenum]
               [:enum/test/acc tenum2]
               [:clique tnames]
               [:normalized-def nexp]
               [:prettyified-def pexp]
               ...)
})


Consider the above call of @(&#39;register-type&#39;). We expect the following guards to be satisfied.
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;pred&lt;/i&gt; is a monadic boolean-valued function.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;enum, tenum&lt;/i&gt; are 1-arity functions that take a natural number and return a value of the right type.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;enum2, tenum2&lt;/i&gt; are 2-arity functions that take a natural number and a random seed and return (mv value seed).&lt;/li&gt;
&lt;li&gt; The rest of the options are for experts and are not yet documented. &lt;/li&gt;
&lt;/ul&gt;
"</span>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc register-data-constructor
  <span class="keyword">:parents</span> (defdata)
  <span class="keyword">:short</span> <span class="string">"Register a data constructor (to extend the defdata language)"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;
You must be familiar with compound data types specified by @(&#39;defdata&#39;)
using @(&#39;cons&#39;). Although @(&#39;cons&#39;) has a unique status in ACL2, it
is not natively available in the @(&#39;defdata&#39;) language unlike
built-in combinators such as @(&#39;oneof&#39;) and @(&#39;range&#39;). In fact,
advanced users can introduce custom notions of product data by
using the @(&#39;register-data-constructor&#39;) macro, whose usage we show below.
&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;
Consider the @(&#39;symbol-alist&#39;) type defined as @(&#39;(oneof nil (cons (cons symbol
all) symbol-alist))&#39;). We could have registered @(&#39;acons&#39;) as a data
constructor, and alternatively defined @(&#39;symbol-alist&#39;) using @(&#39;acons&#39;)
instead of @(&#39;cons&#39;).
&lt;/p&gt;
@({
  (defun aconsp (x)
    (and (consp x) (consp (car x))))
  
  (defun acons-caar (x)  (caar x))
  (defun acons-cdar (x)  (cdar x))
  (defun acons-cdr  (x)  (cdr x))
  
  (register-data-constructor (aconsp acons)
                             ((allp acons-caar) (allp acons-cdar) (allp acons-cdr)))
  
  (defdata symbol-alist (oneof nil (acons symbol all symbol-alist)))
})

&lt;p&gt;
In fact, this is how we setup the base environment in
&quot;defdata/base.lisp&quot;: we use @(&#39;register-data-constructor&#39;) to
preregister all the primitive data constructors in ACL2. In
particular, the following (primitive) constructors are available to
build product types: @(&#39;cons&#39;), @(&#39;intern$&#39;), @(&#39;/&#39;) and @(&#39;complex&#39;).
&lt;/p&gt;

&lt;h3&gt;General Form:&lt;/h3&gt;
@({
  (register-data-constructor (recognizer constructor)
                             ((destructor-pred1 destructor1) ...)
                             [:proper bool]
                             [:hints hints]
                             [:rule-classes rule-classes])
})
"</span>)</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc sig
  <span class="keyword">:parents</span> (defdata macro-libraries)
  <span class="keyword">:short</span> <span class="string">"Specify type signatures for polymorphic functions"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Examples:&lt;/h3&gt;
@({
  (sig nthcdr (nat (listof :a)) =&gt; (listof :a))
  
  (sig binary-append ((listof :a) (listof :a)) =&gt; (listof :a))
  
  (sig nth (nat (listof :a)) =&gt; :a 
       :satisfies (&lt; x1 (len x2))) 
  ;; xi corresponds to the ith type appearing in the sig form. For example,
  ;; x1 corresponds to nat and x2 to (listof :a) 

})



&lt;h3&gt;General Form:&lt;/h3&gt;
@({
  (sig fun-name arg-types =&gt; return-type 
       [:satisfies hyp]
       [:hints hints]
       [:gen-rule-classes rule-classes]
       [:rule-classes rule-classes]
       [:verbose t])
})
&lt;p&gt;
where &lt;i&gt;arg-types&lt;/i&gt; is a list of @(&#39;defdata&#39;) type expressions
and &lt;i&gt;return-type&lt;/i&gt; is a @(&#39;defdata&#39;) type expression with the
added capability of referring to type variables, which in our
syntax are represented using keyword symbols @(&#39;:a, :b, :c, ...&#39;).
&lt;/p&gt;

&lt;p&gt;
Note: @(&#39;sig&#39;) is currently limited to only 12 type variables.
Check @(&#39;:pe *allowed-type-vars*&#39;) to view them. We have never encountered
type signatures with more than 3 type variables, so we hope that this is
not a limitation in practice. There are several other limitations
we impose on @(&#39;sig&#39;). If you would like more comprehensive
support, contact Pete and Harsh.
&lt;/p&gt;

&lt;p&gt;
The following keyword arguments are supported by the @(&#39;sig&#39;) macro:
&lt;ul&gt;
&lt;li&gt; :satisfies -- specify additional dependent type hypotheses.&lt;/li&gt;
&lt;li&gt; :hints -- @(see acl2::hints) option to the generic type signature.&lt;/li&gt;
&lt;li&gt; :gen-rule-classes --  @(see acl2::rule-classes) option to the generic type signature.&lt;/li&gt;  
&lt;li&gt; :rule-classes --  @(see acl2::rule-classes) option to the generated theorems.&lt;/li&gt;  
&lt;li&gt; :verbose -- for debugging.&lt;/li&gt;  
&lt;/ul&gt;

&lt;/p&gt;
"</span>)</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc register-user-combinator
  <span class="keyword">:parents</span> (defdata)
  <span class="keyword">:short</span> <span class="string">"Register a user-defined combinator (to add sugar to defdata language)"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt; User-defined combinators add syntactic sugar on top of the core
defdata language. In addition it is also possible to specify the
theory support for such a construct via the
&lt;tt&gt;:post-pred-hook-fns&lt;/tt&gt; keyword option. (See alistof.lisp for
example usage).&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;
Here is how we added &lt;i&gt;alistof&lt;/i&gt; to the defdata language:
@({
  (register-user-combinator alistof 
   :arity 2 :verbose t
   :aliases (acl2::alistof)
   :expansion (lambda (_name _args) `(OR nil (acons ,(car _args) ,(cadr _args) ,_name)))
   :syntax-restriction-fn proper-symbol-listp
   :polymorphic-type-form (alistof :a :b)
   :post-pred-hook-fns (user-alistof-theory-events))
})

&lt;h3&gt;General Form:&lt;/h3&gt;
@({
  (register-user-combinator combinator-name 
                            :arity num 
                            :expansion term 
                            [optional args])
})
"</span>)</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc defdata-attach
  <span class="keyword">:parents</span> (defdata cgen)
  <span class="keyword">:short</span> <span class="string">"Attach/modify metadata for a defdata type"</span>
  <span class="keyword">:long</span> <span class="string">"
&lt;h3&gt;Examples:&lt;/h3&gt;
@({
  (defdata-attach pos :enumerator nth-small-pos-testing)
  
  (defdata-attach imem :enum/acc imem-custom-enum2)
})

&lt;h3&gt;General Form:&lt;/h3&gt;
@({
  (defdata-attach typename 
       [:enum/test enum-fn]
       [:equiv eq-rel]
       [:equiv-fixer eq-fix-fn]
       [:constraint ... ]
       [:sampling constant-list]
       [overridable metadata]
       )

}) 

&lt;p&gt; Defdata-attach can be used to attach custom test enumerators for
certain types. This provides a method to customize Cgen&#39;s test data
generation capability for certain scenarios.&lt;/p&gt;

&lt;p&gt; (Advanced) Type refinement : User can attach rules that
specify (to Cgen) how to refine/expand a variable of this type when
certain additional constraints match (or subterm-match). For those who
are familar with dest-elim rules, the :rule field has a similar form.
For example: &lt;/p&gt;

@({
(defdata-attach imemory
         :constraint (mget a x) ;x is the variable of this type
         :constraint-variable x
         :rule (implies (and (natp a) ;additional hyps
                             (instp x.a)
                             (imemoryp x1))
                        (equal x (mset a x.a x1))) ;refine/expand
         :meta-precondition (or (variablep a)
                                (fquotep a))
         :match-type :subterm-match)
})

&lt;p&gt; Warning: Other optional keyword arguments are currently
unsupported and the use of :override-ok can be unsound.&lt;/p&gt;
"</span>)</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = 'üåô';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>