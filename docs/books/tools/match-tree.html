<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>match-tree - ACL2 Book</title>
  <meta property="name" content="match-tree">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">match-tree</h1>
    <div class="path"><a href="match-tree.lisp" class="source-link">books/tools/match-tree</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../std/util/bstar.html" title="std/util/bstar">bstar</a>
      <a class="include-link" href="../std/lists/mfc-utils.html" title="std/lists/mfc-utils">mfc-utils</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../std/util/bstar.html" title="Open std/util/bstar">"std/util/bstar"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../std/lists/mfc-utils.html" title="Open std/lists/mfc-utils">"std/lists/mfc-utils"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block function" id="def-match-tree-binder-p" data-defines="MATCH-TREE-BINDER-P" data-references="CDDR,EQ,CADR,CDR,QUOTE,CHAR,MEMBER,SYMBOL-NAME,LENGTH,<,KEYWORDP,CAR,SYMBOLP,AND,CONSP,XARGS,DECLARE,PAT,DEFUN" data-used-by="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP,MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER,MATCH-TREE-MATCHEDP-OPENER,SUBST-TREE-OPEN,MATCH-TREE-MATCHEDP,MATCH-TREE-ALIST-EXPAND-CONS,MATCH-TREE-ALIST-EXPAND-BINDER,MATCH-TREE-ALIST,MATCH-TREE-MEASURE-STRONG,MATCH-TREE-RESTRICTIONS,MATCH-TREE-!VARS,MATCH-TREE-BINDERS,SUBST-TREE,MATCH-TREE,SYMBOLP-CADR-WHEN-MATCH-TREE-BINDER-P" data-part-name="MATCH-TREE-BINDER-P" data-part-args="PAT" data-part-declare="PAT,CONSP,XARGS,DECLARE" data-part-body="CDDR,EQ,CADR,CDR,CONSP,QUOTE,CHAR,MEMBER,SYMBOL-NAME,LENGTH,<,KEYWORDP,PAT,CAR,SYMBOLP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-BINDER-P">match-tree-binder-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>
  (pat)
  (declare (xargs <span class="keyword">:guard</span> (consp pat)))
  (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (symbolp (car pat))
    (<a class="sym-link system" href="../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> (car pat))
    (&lt; <span class="number">0</span> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> (symbol-name (car pat))))
    (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-char" data-sym="CHAR">char</a> (symbol-name (car pat)) <span class="number">0</span>) '(#\? #\!))
    (consp (cdr pat))
    (symbolp (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat))
    (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> pat) nil)))</pre>
  </div>

<div class="form-block theorem" id="def-symbolp-cadr-when-match-tree-binder-p" data-defines="SYMBOLP-CADR-WHEN-MATCH-TREE-BINDER-P" data-references="CADR,SYMBOLP,PAT,MATCH-TREE-BINDER-P,IMPLIES,DEFTHM" data-part-name="SYMBOLP-CADR-WHEN-MATCH-TREE-BINDER-P" data-part-term="CADR,SYMBOLP,PAT,MATCH-TREE-BINDER-P,IMPLIES" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SYMBOLP-CADR-WHEN-MATCH-TREE-BINDER-P">symbolp-cadr-when-match-tree-binder-p</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-symbolp-cadr-when-match-tree-binder-p" data-sym="SYMBOLP-CADR-WHEN-MATCH-TREE-BINDER-P" title="(defthm symbolp-cadr-when-match-tree-binder-p
        (implies (match-tree-binder-p pat) (symbolp (cadr pat))) :rule-classes
        :forward-chaining)">symbolp-cadr-when-match-tree-binder-p</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat) (symbolp (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat)))
  <span class="keyword">:rule-classes</span> <span class="keyword">:forward-chaining</span>)</pre>
  </div>

<div class="form-block function" id="def-match-tree-check-binding" data-defines="MATCH-TREE-CHECK-BINDING" data-references="EQ,SYMBOLP,QUOTE,MEMBER,AND,OR,NOT,KEYWORDP,XARGS,DECLARE,X,KW,DEFUN" data-used-by="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER,MATCH-TREE-MATCHEDP-OPENER,MATCH-TREE-MATCHEDP,NOT-NIL-BY-MATCH-TREE-RESTRICTIONS,NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS,SYMBOLP-BY-MATCH-TREE-RESTRICTIONS,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA,MATCH-TREE" data-part-name="MATCH-TREE-CHECK-BINDING" data-part-args="X,KW" data-part-declare="KW,KEYWORDP,XARGS,DECLARE" data-part-body="EQ,X,SYMBOLP,QUOTE,KW,MEMBER,AND,OR,NOT" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-CHECK-BINDING">match-tree-check-binding</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a>
  (kw x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> kw)))
  (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> kw '(<span class="keyword">:?s</span> <span class="keyword">:?f</span> <span class="keyword">:?v</span>)) (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp x)))
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> kw '(<span class="keyword">:?f</span> <span class="keyword">:?l</span>)) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> x 'quote))
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> kw <span class="keyword">:?v</span>) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> x nil)))))</pre>
  </div>

<div class="form-block function" id="def-match-tree" data-defines="MATCH-TREE" data-references="CONS,T,ASSOC,LOOK,CADR,VAR,MATCH-TREE-CHECK-BINDING,KW,CAR,CDR,OK,IF,MATCH-TREE-BINDER-P,UNLESS,EQUAL,MV,ATOM,WHEN,B*,SYMBOL-ALISTP,XARGS,DECLARE,ALIST,X,PAT,DEFUN" data-used-by="MATCH-TREE-WHEN-MATCHEDP,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL,MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL,MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP,MATCH-TREE-OPEN,MATCH-TREE-MATCHEDP-RW,MATCH-TREE-ALIST-RW-WHEN-MATCHED,MATCH-TREE-RESTR-EVENTS,MATCH-TREE-REWRITES-VAR-RW,MATCH-TREE-BLOCK-SUBSTS-VAR-FN,MATCH-TREE-REWRITES-VAR-FN,MATCH-TREE-MEASURE-STRONG,MATCH-TREE-MEASURE-WEAK,NOT-NIL-BY-MATCH-TREE-RESTRICTIONS,NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS,SYMBOLP-BY-MATCH-TREE-RESTRICTIONS,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS,MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA,TREEMATCH-FN,MATCH-TREE-IS-SUBST-TREE,SUBST-TREE-WHEN-ALL-BINDERS-BOUND,MATCH-TREE-ALL-BINDERS-BOUND,MATCH-TREE-BINDERS-BOUND,ASSOC-IN-MATCH-TREE,SYMBOL-ALISTP-MATCH-TREE" data-part-name="MATCH-TREE" data-part-args="ALIST,X,PAT" data-part-declare="ALIST,SYMBOL-ALISTP,XARGS,DECLARE" data-part-body="CONS,T,ASSOC,LOOK,CADR,VAR,MATCH-TREE-CHECK-BINDING,KW,CAR,CDR,MATCH-TREE,OK,IF,MATCH-TREE-BINDER-P,UNLESS,ALIST,X,EQUAL,MV,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE">match-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>
  (pat x alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist) <span class="keyword">:verify-guards</span> nil))
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (equal pat x) alist)) ((unless (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
          (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil alist)
          (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> (cdr pat) (cdr x) alist)) ((unless ok) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))
            (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> (car pat) (car x) alist))))
      (kw (car pat))
      ((unless (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> kw x)) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> nil alist))
      (var (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat))
      (look (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist))
      ((when look) (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (equal (cdr look) x) alist)))
    (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (cons (cons var x) alist))))</pre>
  </div>

<div class="form-block in-theory" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">in-theory</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable <a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>))</pre>
  </div>

<div class="form-block theorem" id="def-symbol-alistp-match-tree" data-defines="SYMBOL-ALISTP-MATCH-TREE" data-references="ALISTP,X,PAT,MATCH-TREE,MV-NTH,AND,ALIST,SYMBOL-ALISTP,IMPLIES,DEFTHM" data-part-name="SYMBOL-ALISTP-MATCH-TREE" data-part-term="ALISTP,X,PAT,MATCH-TREE,MV-NTH,AND,ALIST,SYMBOL-ALISTP,IMPLIES" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SYMBOL-ALISTP-MATCH-TREE">symbol-alistp-match-tree</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-symbol-alistp-match-tree" data-sym="SYMBOL-ALISTP-MATCH-TREE" title="(defthm symbol-alistp-match-tree
        (implies (symbol-alistp alist)
                 (and (symbol-alistp (mv-nth 1 (match-tree pat x alist)))
                      (alistp (mv-nth 1 (match-tree pat x alist))))))">symbol-alistp-match-tree</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist)
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
      (<a class="sym-link system" href="../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))))))</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a> <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-assoc-in-match-tree" data-defines="ASSOC-IN-MATCH-TREE" data-references="X,PAT,MATCH-TREE,MV-NTH,EQUAL,ALIST,K,ASSOC,IMPLIES,DEFTHM" data-part-name="ASSOC-IN-MATCH-TREE" data-part-term="X,PAT,MATCH-TREE,MV-NTH,EQUAL,ALIST,K,ASSOC,IMPLIES" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-IN-MATCH-TREE">assoc-in-match-tree</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-assoc-in-match-tree" data-sym="ASSOC-IN-MATCH-TREE" title="(defthm assoc-in-match-tree
        (implies (assoc k alist)
                 (equal (assoc k (mv-nth 1 (match-tree pat x alist)))
                        (assoc k alist))))">assoc-in-match-tree</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist)
    (equal (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
      (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist))))</pre>
  </div>

<div class="form-block function" id="def-subst-tree" data-defines="SUBST-TREE" data-references="CADR,ASSOC,CDR,CAR,CONS,UNLESS,ATOM,WHEN,B*,MATCH-TREE-BINDER-P,ENABLE,SYMBOL-ALISTP,XARGS,DECLARE,ALIST,PAT,DEFUN" data-used-by="SUBST-TREE-OPEN,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL,MATCH-TREE-IS-SUBST-TREE,SUBST-TREE-WHEN-ALL-BINDERS-BOUND" data-part-name="SUBST-TREE" data-part-args="ALIST,PAT" data-part-declare="MATCH-TREE-BINDER-P,ENABLE,ALIST,SYMBOL-ALISTP,XARGS,DECLARE" data-part-body="CADR,ASSOC,CDR,ALIST,CAR,SUBST-TREE,CONS,MATCH-TREE-BINDER-P,UNLESS,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TREE">subst-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a>
  (pat alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist)
      <span class="keyword">:guard-hints</span> ((<span class="string">"goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>)))))
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) pat) ((unless (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (cons (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> (car pat) alist)
          (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> (cdr pat) alist))))
    (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-binders" data-defines="MATCH-TREE-BINDERS" data-references="CDR,CAR,APPEND,CADR,LIST,MATCH-TREE-BINDER-P,ATOM,WHEN,B*,PAT,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN,TREEMATCH-FN,SUBST-TREE-WHEN-ALL-BINDERS-BOUND,MATCH-TREE-ALL-BINDERS-BOUND,MATCH-TREE-BINDERS-BOUND" data-part-name="MATCH-TREE-BINDERS" data-part-args="PAT" data-part-body="CDR,CAR,MATCH-TREE-BINDERS,APPEND,CADR,LIST,MATCH-TREE-BINDER-P,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-BINDERS">match-tree-binders</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a>
  (pat)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) nil) ((when (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat))))
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> (car pat))
      (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> (cdr pat)))))</pre>
  </div>

<div class="form-block local" id="form-13" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> member-append
    (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> x (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> a b)) (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> x a) (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> x b)))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-binders-bound" data-defines="MATCH-TREE-BINDERS-BOUND" data-references="CONSP,SYMBOL-ALISTP,ASSOC,MATCH-TREE-BINDERS,K,MEMBER,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="MATCH-TREE-BINDERS-BOUND" data-part-term="CONSP,SYMBOL-ALISTP,ASSOC,MATCH-TREE-BINDERS,K,MEMBER,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-BINDERS-BOUND">match-tree-binders-bound</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-binders-bound" data-sym="MATCH-TREE-BINDERS-BOUND" title="(defthm match-tree-binders-bound
        (b* (((mv ok alist) (match-tree pat x alist0)))
         (implies (and (member k (match-tree-binders pat)) ok)
                  (and (assoc k alist)
                       (implies (symbol-alistp alist0)">match-tree-binders-bound</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist0)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> k (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat)) ok)
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist)
        (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist0) (consp (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist)))))))</pre>
  </div>

<div class="form-block function" id="def-keys-subset" data-defines="KEYS-SUBSET" data-references="CDR,CAR,ASSOC-EQUAL,AND,T,ATOM,IF,ALISTP,XARGS,DECLARE,ALIST,KEYS,DEFUN" data-used-by="SUBST-TREE-WHEN-ALL-BINDERS-BOUND,KEYS-SUBSET-OF-APPEND,MATCH-TREE-ALL-BINDERS-BOUND" data-part-name="KEYS-SUBSET" data-part-args="ALIST,KEYS" data-part-declare="ALIST,ALISTP,XARGS,DECLARE" data-part-body="CDR,KEYS-SUBSET,ALIST,CAR,ASSOC-EQUAL,AND,T,KEYS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYS-SUBSET">keys-subset</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a>
  (keys alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist)))
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> keys)
    <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (car keys) alist)
      (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> (cdr keys) alist))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-all-binders-bound" data-defines="MATCH-TREE-ALL-BINDERS-BOUND" data-references="LEN,ENABLE,KEYS-SUBSET,MATCH-TREE-BINDERS,KEYS,SUBSETP,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="MATCH-TREE-ALL-BINDERS-BOUND" data-part-term="KEYS-SUBSET,MATCH-TREE-BINDERS,KEYS,SUBSETP,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="KEYS,LEN,KEYS-SUBSET,SUBSETP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALL-BINDERS-BOUND">match-tree-all-binders-bound</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-all-binders-bound" data-sym="MATCH-TREE-ALL-BINDERS-BOUND" title="(defthm match-tree-all-binders-bound
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (subsetp keys (match-tree-binders pat)))
                  (keys-subset keys alist)))
        :hints">match-tree-all-binders-bound</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> keys (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat)))
      (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> keys alist)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> <a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a>)
     <span class="keyword">:induct</span> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> keys))))</pre>
  </div>

<div class="form-block theorem" id="def-keys-subset-of-append" data-defines="KEYS-SUBSET-OF-APPEND" data-references="AND,A,Y,X,APPEND,KEYS-SUBSET,EQUAL,DEFTHM" data-part-name="KEYS-SUBSET-OF-APPEND" data-part-term="AND,A,Y,X,APPEND,KEYS-SUBSET,EQUAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYS-SUBSET-OF-APPEND">keys-subset-of-append</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-keys-subset-of-append" data-sym="KEYS-SUBSET-OF-APPEND" title="(defthm keys-subset-of-append
        (equal (keys-subset (append x y) a)
               (and (keys-subset x a) (keys-subset y a))))">keys-subset-of-append</a>
  (equal (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> x y) a)
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> x a) (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> y a))))</pre>
  </div>

<div class="form-block theorem" id="def-subst-tree-when-all-binders-bound" data-defines="SUBST-TREE-WHEN-ALL-BINDERS-BOUND" data-references="SUBST-TREE,EQUAL,PAT,MATCH-TREE-BINDERS,KEYS-SUBSET,IMPLIES,ALIST0,X,PAT1,MATCH-TREE,ALIST,?OK,MV,B*,DEFTHM" data-part-name="SUBST-TREE-WHEN-ALL-BINDERS-BOUND" data-part-term="SUBST-TREE,EQUAL,PAT,MATCH-TREE-BINDERS,KEYS-SUBSET,IMPLIES,ALIST0,X,PAT1,MATCH-TREE,ALIST,?OK,MV,B*" data-part-hints="PAT,MATCH-TREE-BINDERS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TREE-WHEN-ALL-BINDERS-BOUND">subst-tree-when-all-binders-bound</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-subst-tree-when-all-binders-bound" data-sym="SUBST-TREE-WHEN-ALL-BINDERS-BOUND" title="(defthm subst-tree-when-all-binders-bound
        (b* (((mv ?ok alist) (match-tree pat1 x alist0)))
         (implies (keys-subset (match-tree-binders pat) alist0)
                  (equal (subst-tree pat alist) (subst-tree pat alist0))))
        :hints ((&quot;goal&quot; :induct (match-tree-binders pat))))">subst-tree-when-all-binders-bound</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ?ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat1 x alist0)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link local-def" href="#def-keys-subset" data-sym="KEYS-SUBSET" title="(defun keys-subset (keys alist)
  (declare (xargs :guard (alistp alist)))
  (if (atom keys)
      t
      (and (assoc-equal (car keys) alist) (keys-subset (cdr keys) alist))))">keys-subset</a> (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat) alist0)
      (equal (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat alist) (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat alist0))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:induct</span> (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat))))</pre>
  </div>

<div class="form-block local" id="form-19" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subsetp-when-subsetp-of-cdr
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> x (cdr y)) (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> x y))))</pre>
  </div>

<div class="form-block local" id="form-20" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subsetp-refl (<a class="sym-link system" href="../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> x x)))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-is-subst-tree" data-defines="MATCH-TREE-IS-SUBST-TREE" data-references="SUBST-TREE,EQUAL,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHMD" data-used-by="MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL" data-part-name="MATCH-TREE-IS-SUBST-TREE" data-part-term="SUBST-TREE,EQUAL,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="ALIST,X,PAT,MATCH-TREE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-IS-SUBST-TREE">match-tree-is-subst-tree</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-is-subst-tree" data-sym="MATCH-TREE-IS-SUBST-TREE" title="(defthmd match-tree-is-subst-tree
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies ok (equal (subst-tree pat alist) x)))
         :hints ((&quot;goal&quot; :induct (match-tree pat x alist))))">match-tree-is-subst-tree</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ok (equal (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat alist) x)))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:induct</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-_21vars" data-defines="MATCH-TREE-!VARS" data-references="CDR,CADR,CONS,CAR,SYMBOL-NAME,CHAR,EQL,AND,ATOM,WHEN,B*,MATCH-TREE-BINDER-P,ENABLE,T,XARGS,DECLARE,ACC,PAT,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN,TREEMATCH-FN" data-part-name="MATCH-TREE-!VARS" data-part-args="ACC,PAT" data-part-declare="MATCH-TREE-BINDER-P,ENABLE,T,XARGS,DECLARE" data-part-body="CDR,MATCH-TREE-!VARS,CADR,CONS,CAR,SYMBOL-NAME,CHAR,EQL,MATCH-TREE-BINDER-P,AND,ACC,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-!VARS">match-tree-!vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-_21vars" data-sym="MATCH-TREE-!VARS" title="(defun match-tree-!vars (pat acc)
  (declare
   (xargs :guard t :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">match-tree-!vars</a>
  (pat acc)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:guard-hints</span> ((<span class="string">"goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>)))))
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) acc) ((when (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)
           (<a class="sym-link system" href="../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../axioms.html#def-char" data-sym="CHAR">char</a> (symbol-name (car pat)) <span class="number">0</span>) #\!))) (cons (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) acc)))
    (<a class="sym-link local-def" href="#def-match-tree-_21vars" data-sym="MATCH-TREE-!VARS" title="(defun match-tree-!vars (pat acc)
  (declare
   (xargs :guard t :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">match-tree-!vars</a> (car pat)
      (<a class="sym-link local-def" href="#def-match-tree-_21vars" data-sym="MATCH-TREE-!VARS" title="(defun match-tree-!vars (pat acc)
  (declare
   (xargs :guard t :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">match-tree-!vars</a> (cdr pat) acc))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-initial-alist-lst" data-defines="MATCH-TREE-INITIAL-ALIST-LST" data-references="CDR,QUOTE,QUASIQUOTE,CONS,ATOM,IF,VARS,DEFUN" data-part-name="MATCH-TREE-INITIAL-ALIST-LST" data-part-args="VARS" data-part-body="CDR,MATCH-TREE-INITIAL-ALIST-LST,QUOTE,QUASIQUOTE,CONS,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-INITIAL-ALIST-LST">match-tree-initial-alist-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-initial-alist-lst" data-sym="MATCH-TREE-INITIAL-ALIST-LST" title="(defun match-tree-initial-alist-lst (vars)
  (if (atom vars)
      nil
      (cons `(cons &#39;,(car vars) ,(car vars))
            (match-tree-initial-alist-lst (cdr vars)))))">match-tree-initial-alist-lst</a>
  (vars)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (cons `(cons ',(CAR VARS) ,(CAR VARS))
      (<a class="sym-link local-def" href="#def-match-tree-initial-alist-lst" data-sym="MATCH-TREE-INITIAL-ALIST-LST" title="(defun match-tree-initial-alist-lst (vars)
  (if (atom vars)
      nil
      (cons `(cons &#39;,(car vars) ,(car vars))
            (match-tree-initial-alist-lst (cdr vars)))))">match-tree-initial-alist-lst</a> (cdr vars)))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-initial-alist-term" data-defines="MATCH-TREE-INITIAL-ALIST-TERM" data-references="LIST,QUASIQUOTE,VARS,DEFUN" data-part-name="MATCH-TREE-INITIAL-ALIST-TERM" data-part-args="VARS" data-part-body="LIST,QUASIQUOTE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-INITIAL-ALIST-TERM">match-tree-initial-alist-term</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-initial-alist-term" data-sym="MATCH-TREE-INITIAL-ALIST-TERM" title="(defun match-tree-initial-alist-term (vars)
  `(list . ,(match-tree-initial-alist-lst vars)))">match-tree-initial-alist-term</a>
  (vars)
  `(<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> . ,(MATCH-TREE-INITIAL-ALIST-LST VARS)))</pre>
  </div>

<div class="form-block function" id="def-prefix-_3F-vars" data-defines="PREFIX-?-VARS" data-references="CDR,CAR,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,CONS,ATOM,IF,SYMBOL-LISTP,XARGS,DECLARE,VARS,DEFUN" data-part-name="PREFIX-?-VARS" data-part-args="VARS" data-part-declare="VARS,SYMBOL-LISTP,XARGS,DECLARE" data-part-body="CDR,PREFIX-?-VARS,CAR,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,CONS,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREFIX-?-VARS">prefix-?-vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-prefix-_3F-vars" data-sym="PREFIX-?-VARS" title="(defun prefix-?-vars (vars)
  (declare (xargs :guard (symbol-listp vars)))
  (if (atom vars)
      nil
      (cons
...">prefix-?-vars</a>
  (vars)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> vars)))
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (cons (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"?"</span> (symbol-name (car vars)))
        (car vars))
      (<a class="sym-link local-def" href="#def-prefix-_3F-vars" data-sym="PREFIX-?-VARS" title="(defun prefix-?-vars (vars)
  (declare (xargs :guard (symbol-listp vars)))
  (if (atom vars)
      nil
      (cons
...">prefix-?-vars</a> (cdr vars)))))</pre>
  </div>

<div class="form-block function" id="def-treematch-fn" data-defines="TREEMATCH-FN" data-references="ASSOCS,_TREEMATCH-ALIST,CHECK-VARS-NOT-FREE,UNLESS,QUOTE,MATCH-TREE,?_TREEMATCH-ALIST,_TREEMATCH-OK,MV,B*,QUASIQUOTE,SET-DIFFERENCE-EQ,VARS?,MATCH-TREE-!VARS,VARS!,MATCH-TREE-BINDERS,REMOVE-DUPLICATES-EQ,ALLVARS,LET*,MATCH-BODY,NOMATCH-BODY,PAT,X,DEFUN" data-used-by="TREEMATCH*-FN" data-part-name="TREEMATCH-FN" data-part-args="MATCH-BODY,NOMATCH-BODY,PAT,X" data-part-body="ASSOCS,_TREEMATCH-ALIST,CHECK-VARS-NOT-FREE,UNLESS,QUOTE,MATCH-TREE,?_TREEMATCH-ALIST,_TREEMATCH-OK,MV,B*,QUASIQUOTE,SET-DIFFERENCE-EQ,VARS?,MATCH-TREE-!VARS,VARS!,PAT,MATCH-TREE-BINDERS,REMOVE-DUPLICATES-EQ,ALLVARS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TREEMATCH-FN">treematch-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-treematch-fn" data-sym="TREEMATCH-FN" title="(defun treematch-fn (x pat nomatch-body match-body)
  (let* ((allvars (remove-duplicates-eq (match-tree-binders pat)))
         (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
         (vars? (set-difference-eq allvars vars!)))
    `(b*
...">treematch-fn</a>
  (x pat nomatch-body match-body)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((allvars (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-eq" data-sym="REMOVE-DUPLICATES-EQ">remove-duplicates-eq</a> (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat))) (vars! (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-eq" data-sym="REMOVE-DUPLICATES-EQ">remove-duplicates-eq</a> (<a class="sym-link local-def" href="#def-match-tree-_21vars" data-sym="MATCH-TREE-!VARS" title="(defun match-tree-!vars (pat acc)
  (declare
   (xargs :guard t :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">match-tree-!vars</a> pat nil)))
      (vars? (<a class="sym-link system" href="../../axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> allvars vars!)))
    `(<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> _treematch-ok ?_treematch-alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ',PAT ,X ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!))) ((unless _treematch-ok) (<a class="sym-link system" href="../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (_treematch-ok _treematch-alist)
            ,NOMATCH-BODY))
        ((assocs . ,(PREFIX-?-VARS VARS?)) _treematch-alist))
      (<a class="sym-link system" href="../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (_treematch-ok _treematch-alist)
        ,MATCH-BODY))))</pre>
  </div>

<div class="form-block other" id="form-27" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../std/util/bstar.html#def-def-b_2A-binder" data-sym="DEF-B*-BINDER">def-b*-binder</a> unless-match
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (equal (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">2</span>))))
  <span class="keyword">:body</span> (<a class="sym-link local-def" href="#def-treematch-fn" data-sym="TREEMATCH-FN" title="(defun treematch-fn (x pat nomatch-body match-body)
  (let* ((allvars (remove-duplicates-eq (match-tree-binders pat)))
         (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
         (vars? (set-difference-eq allvars vars!)))
    `(b*
...">treematch-fn</a> (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    `(<a class="sym-link system" href="../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)
    rest-expr))</pre>
  </div>

<div class="form-block other" id="form-28" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../std/util/bstar.html#def-def-b_2A-binder" data-sym="DEF-B*-BINDER">def-b*-binder</a> when-match
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (equal (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">2</span>))))
  <span class="keyword">:body</span> (<a class="sym-link local-def" href="#def-treematch-fn" data-sym="TREEMATCH-FN" title="(defun treematch-fn (x pat nomatch-body match-body)
  (let* ((allvars (remove-duplicates-eq (match-tree-binders pat)))
         (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
         (vars? (set-difference-eq allvars vars!)))
    `(b*
...">treematch-fn</a> (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    rest-expr
    `(<a class="sym-link system" href="../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)))</pre>
  </div>

<div class="form-block function" id="def-treematch_2A-fn" data-defines="TREEMATCH*-FN" data-references="CDR,TREEMATCH-FN,T,PROGN$,QUASIQUOTE,&,QUOTE,CAAR,EQ,ATOM,COND,PATS,X,DEFUN" data-used-by="TREEMATCH" data-part-name="TREEMATCH*-FN" data-part-args="PATS,X" data-part-body="CDR,TREEMATCH*-FN,X,TREEMATCH-FN,T,PROGN$,QUASIQUOTE,&,QUOTE,CAAR,EQ,PATS,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TREEMATCH*-FN">treematch*-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-treematch_2A-fn" data-sym="TREEMATCH*-FN" title="(defun treematch*-fn (x pats)
  (cond ((atom pats) nil) ((eq (caar pats) &#39;&amp;) `(progn$ . ,(cdar pats)))
        (t
         (treematch-fn x (caar pats) (treematch*-fn x (cdr pats))
          `(progn$ . ,(cdar pats))))))">treematch*-fn</a>
  (x pats)
  (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pats) nil)
    ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> pats) '&amp;) `(<a class="sym-link system" href="../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,(CDAR PATS)))
    (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-treematch-fn" data-sym="TREEMATCH-FN" title="(defun treematch-fn (x pat nomatch-body match-body)
  (let* ((allvars (remove-duplicates-eq (match-tree-binders pat)))
         (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
         (vars? (set-difference-eq allvars vars!)))
    `(b*
...">treematch-fn</a> x
        (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> pats)
        (<a class="sym-link local-def" href="#def-treematch_2A-fn" data-sym="TREEMATCH*-FN" title="(defun treematch*-fn (x pats)
  (cond ((atom pats) nil) ((eq (caar pats) &#39;&amp;) `(progn$ . ,(cdar pats)))
        (t
         (treematch-fn x (caar pats) (treematch*-fn x (cdr pats))
          `(progn$ . ,(cdar pats))))))">treematch*-fn</a> x (cdr pats))
        `(<a class="sym-link system" href="../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,(CDAR PATS))))))</pre>
  </div>

<div class="form-block macro" id="def-treematch" data-defines="TREEMATCH" data-references="B*,QUASIQUOTE,PACK,VAR,LET,TREEMATCH*-FN,ATOM,IF,PATS,&REST,X,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="TREEMATCH">treematch</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-treematch" data-sym="TREEMATCH" title="(defmacro treematch (x &amp;rest pats)
  (if (atom x)
      (treematch*-fn x pats)
      (let ((var (pack x)))
        `(b* ((,var ,x)) ,(treematch*-fn var pats)))))">treematch</a>
  (x &amp;rest pats)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    (<a class="sym-link local-def" href="#def-treematch_2A-fn" data-sym="TREEMATCH*-FN" title="(defun treematch*-fn (x pats)
  (cond ((atom pats) nil) ((eq (caar pats) &#39;&amp;) `(progn$ . ,(cdar pats)))
        (t
         (treematch-fn x (caar pats) (treematch*-fn x (cdr pats))
          `(progn$ . ,(cdar pats))))))">treematch*-fn</a> x pats)
    (let ((var (<a class="sym-link external" href="../std/util/bstar.html#def-pack" data-sym="PACK">pack</a> x)))
      `(<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> ((,VAR ,X)) ,(TREEMATCH*-FN VAR PATS)))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-restrictions" data-defines="MATCH-TREE-RESTRICTIONS" data-references="LIST,CDR,CAR,APPEND,MATCH-TREE-BINDER-P,UNLESS,ATOM,WHEN,B*,T,XARGS,DECLARE,PAT,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN,NOT-NIL-BY-MATCH-TREE-RESTRICTIONS,NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS,SYMBOLP-BY-MATCH-TREE-RESTRICTIONS,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS,MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA" data-part-name="MATCH-TREE-RESTRICTIONS" data-part-args="PAT" data-part-declare="T,XARGS,DECLARE" data-part-body="LIST,CDR,CAR,MATCH-TREE-RESTRICTIONS,APPEND,MATCH-TREE-BINDER-P,UNLESS,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RESTRICTIONS">match-tree-restrictions</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a>
  (pat)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) nil) ((unless (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> (car pat))
          (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> (cdr pat)))))
    (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> pat)))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-restrictions-of-lookup-lemma" data-defines="MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA" data-references="CDR,MATCH-TREE-CHECK-BINDING,MATCH-TREE-RESTRICTIONS,KW,LIST,MEMBER,VAR,ASSOC,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA" data-part-term="CDR,MATCH-TREE-CHECK-BINDING,MATCH-TREE-RESTRICTIONS,KW,LIST,MEMBER,VAR,ASSOC,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA">match-tree-restrictions-of-lookup-lemma</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup-lemma" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP-LEMMA" title="(defthm match-tree-restrictions-of-lookup-lemma
        (b* (((mv ok alist) (match-tree pat x alist0)))
         (implies
          (and ok (assoc var alist0)
               (member (list kw var) (match-tree-restrictions pat)))">match-tree-restrictions-of-lookup-lemma</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist0)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist0)
        (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> kw var) (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> kw (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist))))))</pre>
  </div>

<div class="form-block theorem" id="def-lookup-when-member-match-tree-restrictions" data-defines="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS" data-references="ASSOC,MATCH-TREE-RESTRICTIONS,VAR,KW,LIST,MEMBER,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHMD" data-used-by="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" data-part-name="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS" data-part-term="ASSOC,MATCH-TREE-RESTRICTIONS,VAR,KW,LIST,MEMBER,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS">lookup-when-member-match-tree-restrictions</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-lookup-when-member-match-tree-restrictions" data-sym="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS" title="(defthmd lookup-when-member-match-tree-restrictions
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies
           (and ok (member (list kw var) (match-tree-restrictions pat)))
           (assoc var alist))))">lookup-when-member-match-tree-restrictions</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> kw var) (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-restrictions-of-lookup" data-defines="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" data-references="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS,ENABLE,ASSOC,CDR,MATCH-TREE-CHECK-BINDING,MATCH-TREE-RESTRICTIONS,VAR,KW,LIST,MEMBER,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-used-by="NOT-NIL-BY-MATCH-TREE-RESTRICTIONS,NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS,SYMBOLP-BY-MATCH-TREE-RESTRICTIONS" data-part-name="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" data-part-term="ASSOC,CDR,MATCH-TREE-CHECK-BINDING,MATCH-TREE-RESTRICTIONS,VAR,KW,LIST,MEMBER,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP">match-tree-restrictions-of-lookup</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> kw var) (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> kw (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist)))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-lookup-when-member-match-tree-restrictions" data-sym="LOOKUP-WHEN-MEMBER-MATCH-TREE-RESTRICTIONS" title="(defthmd lookup-when-member-match-tree-restrictions
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies
           (and ok (member (list kw var) (match-tree-restrictions pat)))
           (assoc var alist))))">lookup-when-member-match-tree-restrictions</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-symbolp-by-match-tree-restrictions" data-defines="SYMBOLP-BY-MATCH-TREE-RESTRICTIONS" data-references="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,MEMBER-EQUAL,NOT,QUOTE,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,T,ASSOC,CDR,SYMBOLP,MATCH-TREE-RESTRICTIONS,VAR,LIST,INTERSECTP-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="SYMBOLP-BY-MATCH-TREE-RESTRICTIONS" data-part-term="ASSOC,CDR,SYMBOLP,MATCH-TREE-RESTRICTIONS,VAR,LIST,INTERSECTP-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,MEMBER-EQUAL,NOT,QUOTE,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,AND,T" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SYMBOLP-BY-MATCH-TREE-RESTRICTIONS">symbolp-by-match-tree-restrictions</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-symbolp-by-match-tree-restrictions" data-sym="SYMBOLP-BY-MATCH-TREE-RESTRICTIONS" title="(defthm symbolp-by-match-tree-restrictions
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies
          (and ok
               (intersectp-equal
...">symbolp-by-match-tree-restrictions</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-intersectp-equal" data-sym="INTERSECTP-EQUAL">intersectp-equal</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?s</span> var) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?f</span> var) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?v</span> var))
          (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (symbolp (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist)))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:do-not-induct</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> stable-under-simplificationp
      (let ((lit (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause)))
        (<a class="sym-link system" href="../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> lit
          (('<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link system" href="../../axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> ('cons ('quote kw) &amp;) . &amp;)) `(<span class="keyword">:use</span> ((<span class="keyword">:instance</span> <a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a> (kw ,KW)))
              <span class="keyword">:in-theory</span> (<a class="sym-link system" href="../../axioms.html#def-e_2Fd" data-sym="E/D">e/d</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a>)
                (<a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a>)))))))))</pre>
  </div>

<div class="form-block theorem" id="def-not-quote-by-match-tree-restrictions" data-defines="NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS" data-references="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,MEMBER-EQUAL,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,T,QUOTE,ASSOC,CDR,EQUAL,NOT,MATCH-TREE-RESTRICTIONS,VAR,LIST,INTERSECTP-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS" data-part-term="QUOTE,ASSOC,CDR,EQUAL,NOT,MATCH-TREE-RESTRICTIONS,VAR,LIST,INTERSECTP-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,MEMBER-EQUAL,NOT,QUOTE,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,AND,T" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS">not-quote-by-match-tree-restrictions</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-not-quote-by-match-tree-restrictions" data-sym="NOT-QUOTE-BY-MATCH-TREE-RESTRICTIONS" title="(defthm not-quote-by-match-tree-restrictions
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies
          (and ok
               (intersectp-equal (list (list :?l var) (list :?f var))
...">not-quote-by-match-tree-restrictions</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-intersectp-equal" data-sym="INTERSECTP-EQUAL">intersectp-equal</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?l</span> var) (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?f</span> var))
          (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (equal (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist)) 'quote))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:do-not-induct</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> stable-under-simplificationp
      (let ((lit (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause)))
        (<a class="sym-link system" href="../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> lit
          (('<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link system" href="../../axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> ('cons ('quote kw) &amp;) . &amp;)) `(<span class="keyword">:use</span> ((<span class="keyword">:instance</span> <a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a> (kw ,KW)))
              <span class="keyword">:in-theory</span> (<a class="sym-link system" href="../../axioms.html#def-e_2Fd" data-sym="E/D">e/d</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a>)
                (<a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a>)))))))))</pre>
  </div>

<div class="form-block theorem" id="def-not-nil-by-match-tree-restrictions" data-defines="NOT-NIL-BY-MATCH-TREE-RESTRICTIONS" data-references="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,NOT,QUOTE,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,T,ASSOC,CDR,MATCH-TREE-RESTRICTIONS,VAR,LIST,MEMBER-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*,DEFTHM" data-part-name="NOT-NIL-BY-MATCH-TREE-RESTRICTIONS" data-part-term="ASSOC,CDR,MATCH-TREE-RESTRICTIONS,VAR,LIST,MEMBER-EQUAL,AND,IMPLIES,X,PAT,MATCH-TREE,ALIST,OK,MV,B*" data-part-hints="MATCH-TREE-CHECK-BINDING,E/D,MATCH-TREE-RESTRICTIONS-OF-LOOKUP,QUASIQUOTE,&,KW,CONS,MEMBER-EQUAL,NOT,QUOTE,CASE-MATCH,CLAUSE,CADR,LIT,LET,STABLE-UNDER-SIMPLIFICATIONP,AND,T" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOT-NIL-BY-MATCH-TREE-RESTRICTIONS">not-nil-by-match-tree-restrictions</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-not-nil-by-match-tree-restrictions" data-sym="NOT-NIL-BY-MATCH-TREE-RESTRICTIONS" title="(defthm not-nil-by-match-tree-restrictions
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies
          (and ok (member-equal (list :?v var) (match-tree-restrictions pat)))
          (cdr (assoc var alist))))
...">not-nil-by-match-tree-restrictions</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> ok alist) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok
        (<a class="sym-link system" href="../../axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:?v</span> var) (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat)))
      (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> var alist))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:do-not-induct</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> stable-under-simplificationp
      (let ((lit (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause)))
        (<a class="sym-link system" href="../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> lit
          (('<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> ('<a class="sym-link system" href="../../axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> ('cons ('quote kw) &amp;) . &amp;)) `(<span class="keyword">:use</span> ((<span class="keyword">:instance</span> <a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a> (kw ,KW)))
              <span class="keyword">:in-theory</span> (<a class="sym-link system" href="../../axioms.html#def-e_2Fd" data-sym="E/D">e/d</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a>)
                (<a class="sym-link local-def" href="#def-match-tree-restrictions-of-lookup" data-sym="MATCH-TREE-RESTRICTIONS-OF-LOOKUP" title="(defthm match-tree-restrictions-of-lookup
        (b* (((mv ok alist) (match-tree pat x alist)))
         (implies (and ok (member (list kw var) (match-tree-restrictions pat)))
                  (match-tree-check-binding kw (cdr (assoc var alist)))))
        :hints
...">match-tree-restrictions-of-lookup</a>)))))))))</pre>
  </div>

<div class="form-block in-theory" id="form-38" typeof="Code">
    <div class="form-header"><span class="form-type">in-theory</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>))</pre>
  </div>

<div class="form-block local" id="form-39" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable <a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a>)))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-measure-weak" data-defines="MATCH-TREE-MEASURE-WEAK" data-references="ENABLE,QUOTE,STABLE-UNDER-SIMPLIFICATIONP,AND,T,E/D,X,PAT,MATCH-TREE,MV-NTH,CDR,ACL2-COUNT,<=,ALIST0,K,ASSOC,NOT,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-MEASURE-WEAK" data-part-term="X,PAT,MATCH-TREE,MV-NTH,CDR,ACL2-COUNT,<=,ALIST0,K,ASSOC,NOT,IMPLIES" data-part-hints="ENABLE,QUOTE,STABLE-UNDER-SIMPLIFICATIONP,AND,T,ACL2-COUNT,MATCH-TREE,E/D" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MEASURE-WEAK">match-tree-measure-weak</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-measure-weak" data-sym="MATCH-TREE-MEASURE-WEAK" title="(defthm match-tree-measure-weak
        (implies (not (assoc k alist0))
                 (&lt;=
                  (acl2-count
                   (cdr (assoc k (mv-nth 1 (match-tree pat x alist0)))))
...">match-tree-measure-weak</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist0))
    (<a class="sym-link system" href="../../axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist0)))))
      (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (<a class="sym-link system" href="../../axioms.html#def-e_2Fd" data-sym="E/D">e/d</a> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>) (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a>))
     <span class="keyword">:induct</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> stable-under-simplificationp
      '(<span class="keyword">:in-theory</span> (enable <a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a>))))
  <span class="keyword">:rule-classes</span> <span class="keyword">:linear</span>)</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-measure-strong" data-defines="MATCH-TREE-MEASURE-STRONG" data-references="T,E/D,CDR,ACL2-COUNT,<,CONSP,MATCH-TREE-BINDER-P,K,ASSOC,NOT,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV-LET,DEFTHM" data-part-name="MATCH-TREE-MEASURE-STRONG" data-part-term="CDR,ACL2-COUNT,<,CONSP,MATCH-TREE-BINDER-P,K,ASSOC,NOT,AND,IMPLIES,ALIST0,X,PAT,MATCH-TREE,ALIST,OK,MV-LET" data-part-hints="T,MATCH-TREE,E/D" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MEASURE-STRONG">match-tree-measure-strong</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-measure-strong" data-sym="MATCH-TREE-MEASURE-STRONG" title="(defthm match-tree-measure-strong
        (mv-let (ok alist) (match-tree pat x alist0)
                (implies
                 (and (not (assoc k alist0)) (not (match-tree-binder-p pat))
                      (consp pat) ok)
...">match-tree-measure-strong</a>
  (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ok alist)
    (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist0)
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist0))
        (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat))
        (consp pat)
        ok)
      (&lt; (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> k alist))) (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (<a class="sym-link system" href="../../axioms.html#def-e_2Fd" data-sym="E/D">e/d</a> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>)) <span class="keyword">:induct</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
  <span class="keyword">:rule-classes</span> <span class="keyword">:linear</span>)</pre>
  </div>

<div class="form-block function" id="def-replace-equalities-thm-fnsym" data-defines="REPLACE-EQUALITIES-THM-FNSYM" data-references="ADD-REPLACE-EQUALITIES-RULE,HARD?,ER,RHS,LHS,EQUAL,HYP-ARGS,HYP-SYM,IMPLIES,CURRENT-ACL2-WORLD,THEOREM,QUOTE,GETPROP,UNLESS-MATCH,B*,PLIST-WORLDP,SYMBOLP,AND,XARGS,DECLARE,W,THMNAME,DEFUN" data-used-by="ADD-REPLACE-EQUALITIES-RULE" data-part-name="REPLACE-EQUALITIES-THM-FNSYM" data-part-args="W,THMNAME" data-part-declare="W,PLIST-WORLDP,THMNAME,SYMBOLP,AND,XARGS,DECLARE" data-part-body="ADD-REPLACE-EQUALITIES-RULE,HARD?,ER,RHS,LHS,EQUAL,HYP-ARGS,HYP-SYM,IMPLIES,W,CURRENT-ACL2-WORLD,THEOREM,QUOTE,THMNAME,GETPROP,UNLESS-MATCH,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REPLACE-EQUALITIES-THM-FNSYM">replace-equalities-thm-fnsym</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-replace-equalities-thm-fnsym" data-sym="REPLACE-EQUALITIES-THM-FNSYM" title="(defun replace-equalities-thm-fnsym (thmname w)
  (declare (xargs :guard (and (symbolp thmname) (plist-worldp w))))
  (b*
   (((unless-match (getprop thmname &#39;theorem nil &#39;current-acl2-world w)
      (implies ((:?f hyp-sym) :? hyp-args) (equal (:? lhs) (:? rhs))))
...">replace-equalities-thm-fnsym</a>
  (thmname <a class="sym-link system" href="../../axioms.html#def-w" data-sym="W">w</a>)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (symbolp thmname) (<a class="sym-link system" href="../../axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> <a class="sym-link system" href="../../axioms.html#def-w" data-sym="W">w</a>))))
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((unless-match (<a class="sym-link system" href="../../axioms.html#def-getprop" data-sym="GETPROP">getprop</a> thmname 'theorem nil 'current-acl2-world <a class="sym-link system" href="../../axioms.html#def-w" data-sym="W">w</a>)
        (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ((<span class="keyword">:?f</span> hyp-sym) <span class="keyword">:?</span> hyp-args)
          (equal (<span class="keyword">:?</span> lhs) (<span class="keyword">:?</span> rhs)))) (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard?
         '<a class="sym-link local-def" href="#def-add-replace-equalities-rule" data-sym="ADD-REPLACE-EQUALITIES-RULE" title="(defmacro add-replace-equalities-rule (thmname)
  `(table replace-equalities-rules
          (replace-equalities-thm-fnsym &#39;,thmname world)
          (cons &#39;,thmname
                (cdr
...">add-replace-equalities-rule</a>
         <span class="string">"Theorem ~x0 not of the right form"</span>
         thmname)))
    hyp-sym))</pre>
  </div>

<div class="form-block macro" id="def-add-replace-equalities-rule" data-defines="ADD-REPLACE-EQUALITIES-RULE" data-references="TABLE-ALIST,ASSOC,CDR,CONS,WORLD,QUOTE,REPLACE-EQUALITIES-THM-FNSYM,REPLACE-EQUALITIES-RULES,TABLE,QUASIQUOTE,THMNAME,DEFMACRO" data-used-by="MATCH-TREE-BLOCK-SUBSTS-VAR-FN,REPLACE-EQUALITIES-THM-FNSYM" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-REPLACE-EQUALITIES-RULE">add-replace-equalities-rule</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-add-replace-equalities-rule" data-sym="ADD-REPLACE-EQUALITIES-RULE" title="(defmacro add-replace-equalities-rule (thmname)
  `(table replace-equalities-rules
          (replace-equalities-thm-fnsym &#39;,thmname world)
          (cons &#39;,thmname
                (cdr
...">add-replace-equalities-rule</a>
  (thmname)
  `(<a class="sym-link system" href="../../axioms.html#def-table" data-sym="TABLE">table</a> replace-equalities-rules
    (<a class="sym-link local-def" href="#def-replace-equalities-thm-fnsym" data-sym="REPLACE-EQUALITIES-THM-FNSYM" title="(defun replace-equalities-thm-fnsym (thmname w)
  (declare (xargs :guard (and (symbolp thmname) (plist-worldp w))))
  (b*
   (((unless-match (getprop thmname &#39;theorem nil &#39;current-acl2-world w)
      (implies ((:?f hyp-sym) :? hyp-args) (equal (:? lhs) (:? rhs))))
...">replace-equalities-thm-fnsym</a> ',THMNAME world)
    (cons ',THMNAME
      (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link local-def" href="#def-replace-equalities-thm-fnsym" data-sym="REPLACE-EQUALITIES-THM-FNSYM" title="(defun replace-equalities-thm-fnsym (thmname w)
  (declare (xargs :guard (and (symbolp thmname) (plist-worldp w))))
  (b*
   (((unless-match (getprop thmname &#39;theorem nil &#39;current-acl2-world w)
      (implies ((:?f hyp-sym) :? hyp-args) (equal (:? lhs) (:? rhs))))
...">replace-equalities-thm-fnsym</a> ',THMNAME world)
          (<a class="sym-link system" href="../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'replace-equalities-rules world))))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rw-fname" data-defines="MATCH-TREE-RW-FNAME" data-references="SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,IF,SYMBOLP,AND,XARGS,DECLARE,VAR,PREFIX,DEFUN" data-used-by="MATCH-TREE-RESTR-EVENTS,MATCH-TREE-REWRITES-VAR-RW,MATCH-TREE-BLOCK-SUBSTS-VAR-FN,MATCH-TREE-RW-MEASURE-THM" data-part-name="MATCH-TREE-RW-FNAME" data-part-args="VAR,PREFIX" data-part-declare="VAR,PREFIX,SYMBOLP,AND,XARGS,DECLARE" data-part-body="VAR,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,PREFIX,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RW-FNAME">match-tree-rw-fname</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rw-fname" data-sym="MATCH-TREE-RW-FNAME" title="(defun match-tree-rw-fname (prefix var)
  (declare (xargs :guard (and (symbolp prefix) (symbolp var))))
  (if prefix
      (intern-in-package-of-symbol
       (concatenate &#39;string (symbol-name prefix) (symbol-name var)) prefix)">match-tree-rw-fname</a>
  (prefix var)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (symbolp prefix) (symbolp var))))
  (if prefix
    (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> (symbol-name prefix) (symbol-name var))
      prefix)
    var))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rewrites-var-fn" data-defines="MATCH-TREE-REWRITES-VAR-FN" data-references="ASSOC,CDR,AND,QUOTE,MATCH-TREE,ALIST,OK,MV-LET,T,XARGS,DECLARE,X,DEFUND,QUASIQUOTE,PREFIX,PAT,VARS!,VAR,DEFUN" data-used-by="MATCH-TREE-REWRITES-FNS" data-part-name="MATCH-TREE-REWRITES-VAR-FN" data-part-args="PREFIX,PAT,VARS!,VAR" data-part-body="ASSOC,CDR,AND,QUOTE,MATCH-TREE,ALIST,OK,MV-LET,T,XARGS,DECLARE,X,DEFUND,QUASIQUOTE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-REWRITES-VAR-FN">match-tree-rewrites-var-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rewrites-var-fn" data-sym="MATCH-TREE-REWRITES-VAR-FN" title="(defun match-tree-rewrites-var-fn (var vars! pat prefix)
  `(defund ,(match-tree-rw-fname prefix var) (x . ,vars!)
           (declare (xargs :guard t))
           (mv-let (ok alist)
                   (match-tree &#39;,pat x ,(match-tree-initial-alist-term vars!))">match-tree-rewrites-var-fn</a>
  (var vars! pat prefix)
  `(defund ,(MATCH-TREE-RW-FNAME PREFIX VAR)
    (x . ,VARS!)
    (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
    (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ok alist)
      (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ',PAT x ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!))
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ok (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> ',VAR alist))))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rewrites-fns" data-defines="MATCH-TREE-REWRITES-FNS" data-references="CDR,CAR,MATCH-TREE-REWRITES-VAR-FN,CONS,ATOM,IF,PREFIX,PAT,VARS!,VARS,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN" data-part-name="MATCH-TREE-REWRITES-FNS" data-part-args="PREFIX,PAT,VARS!,VARS" data-part-body="CDR,MATCH-TREE-REWRITES-FNS,PREFIX,PAT,VARS!,CAR,MATCH-TREE-REWRITES-VAR-FN,CONS,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-REWRITES-FNS">match-tree-rewrites-fns</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rewrites-fns" data-sym="MATCH-TREE-REWRITES-FNS" title="(defun match-tree-rewrites-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-fn (car vars) vars! pat prefix)
            (match-tree-rewrites-fns (cdr vars) vars! pat prefix))))">match-tree-rewrites-fns</a>
  (vars vars! pat prefix)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (cons (<a class="sym-link local-def" href="#def-match-tree-rewrites-var-fn" data-sym="MATCH-TREE-REWRITES-VAR-FN" title="(defun match-tree-rewrites-var-fn (var vars! pat prefix)
  `(defund ,(match-tree-rw-fname prefix var) (x . ,vars!)
           (declare (xargs :guard t))
           (mv-let (ok alist)
                   (match-tree &#39;,pat x ,(match-tree-initial-alist-term vars!))">match-tree-rewrites-var-fn</a> (car vars) vars! pat prefix)
      (<a class="sym-link local-def" href="#def-match-tree-rewrites-fns" data-sym="MATCH-TREE-REWRITES-FNS" title="(defun match-tree-rewrites-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-fn (car vars) vars! pat prefix)
            (match-tree-rewrites-fns (cdr vars) vars! pat prefix))))">match-tree-rewrites-fns</a> (cdr vars) vars! pat prefix))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rw-measure-thm" data-defines="MATCH-TREE-RW-MEASURE-THM" data-references="ENABLE,X,ACL2-COUNT,<=,DEFTHM,QUASIQUOTE,THMNAME-STRONG,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,THMNAME-WEAK,MATCH-TREE-RW-FNAME,FNNAME,B*,PREFIX,PAT,VARS!,VAR,DEFUN" data-used-by="MATCH-TREE-RW-MEASURE-THMS" data-part-name="MATCH-TREE-RW-MEASURE-THM" data-part-args="PREFIX,PAT,VARS!,VAR" data-part-body="ENABLE,X,ACL2-COUNT,<=,DEFTHM,QUASIQUOTE,THMNAME-STRONG,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,THMNAME-WEAK,VAR,PREFIX,MATCH-TREE-RW-FNAME,FNNAME,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RW-MEASURE-THM">match-tree-rw-measure-thm</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rw-measure-thm" data-sym="MATCH-TREE-RW-MEASURE-THM" title="(defun match-tree-rw-measure-thm (var vars! pat prefix)
  (b*
   ((fnname (match-tree-rw-fname prefix var))
    (thmname-weak
     (intern-in-package-of-symbol
...">match-tree-rw-measure-thm</a>
  (var vars! pat prefix)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> ((fnname (<a class="sym-link local-def" href="#def-match-tree-rw-fname" data-sym="MATCH-TREE-RW-FNAME" title="(defun match-tree-rw-fname (prefix var)
  (declare (xargs :guard (and (symbolp prefix) (symbolp var))))
  (if prefix
      (intern-in-package-of-symbol
       (concatenate &#39;string (symbol-name prefix) (symbol-name var)) prefix)">match-tree-rw-fname</a> prefix var)) (thmname-weak (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a>
            (symbol-name fnname)
            <span class="string">"-ACL2-COUNT-WEAK"</span>)
          fnname))
      (thmname-strong (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a>
            (symbol-name fnname)
            <span class="string">"-ACL2-COUNT-STRONG"</span>)
          fnname)))
    `((<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,THMNAME-WEAK
       (<a class="sym-link system" href="../../axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> (,FNNAME x . ,VARS!)) (<a class="sym-link system" href="../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x))
       <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable ,FNNAME)))
       <span class="keyword">:rule-classes</span> <span class="keyword">:linear</span>) . ,(AND (NOT (ATOM PAT)) (NOT (MATCH-TREE-BINDER-P PAT))
      `((DEFTHM ,THMNAME-STRONG
                (IMPLIES
                 (MV-NTH 0
                         (MATCH-TREE &#39;,PAT X
                          ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!)))
                 (&lt; (ACL2-COUNT (,FNNAME X . ,VARS!)) (ACL2-COUNT X)))
                :HINTS ((&quot;Goal&quot; :IN-THEORY (ENABLE ,FNNAME))) :RULE-CLASSES
                :LINEAR))))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rw-measure-thms" data-defines="MATCH-TREE-RW-MEASURE-THMS" data-references="CDR,CAR,MATCH-TREE-RW-MEASURE-THM,APPEND,ATOM,IF,PREFIX,PAT,VARS!,VARS,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN" data-part-name="MATCH-TREE-RW-MEASURE-THMS" data-part-args="PREFIX,PAT,VARS!,VARS" data-part-body="CDR,MATCH-TREE-RW-MEASURE-THMS,PREFIX,PAT,VARS!,CAR,MATCH-TREE-RW-MEASURE-THM,APPEND,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RW-MEASURE-THMS">match-tree-rw-measure-thms</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rw-measure-thms" data-sym="MATCH-TREE-RW-MEASURE-THMS" title="(defun match-tree-rw-measure-thms (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-rw-measure-thm (car vars) vars! pat prefix)
              (match-tree-rw-measure-thms (cdr vars) vars! pat prefix))))">match-tree-rw-measure-thms</a>
  (vars vars! pat prefix)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-match-tree-rw-measure-thm" data-sym="MATCH-TREE-RW-MEASURE-THM" title="(defun match-tree-rw-measure-thm (var vars! pat prefix)
  (b*
   ((fnname (match-tree-rw-fname prefix var))
    (thmname-weak
     (intern-in-package-of-symbol
...">match-tree-rw-measure-thm</a> (car vars) vars! pat prefix)
      (<a class="sym-link local-def" href="#def-match-tree-rw-measure-thms" data-sym="MATCH-TREE-RW-MEASURE-THMS" title="(defun match-tree-rw-measure-thms (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-rw-measure-thm (car vars) vars! pat prefix)
              (match-tree-rw-measure-thms (cdr vars) vars! pat prefix))))">match-tree-rw-measure-thms</a> (cdr vars) vars! pat prefix))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-block-substs-var-fn" data-defines="MATCH-TREE-BLOCK-SUBSTS-VAR-FN" data-references="ADD-REPLACE-EQUALITIES-RULE,EQUAL,X,MATCH-TREE,MV-NTH,IMPLIES,DEFTHM,QUASIQUOTE,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,THMNAME,MATCH-TREE-RW-FNAME,FNNAME,LET*,PREFIX,PAT,VARS!,VAR,DEFUN" data-used-by="MATCH-TREE-BLOCK-SUBSTS-FNS" data-part-name="MATCH-TREE-BLOCK-SUBSTS-VAR-FN" data-part-args="PREFIX,PAT,VARS!,VAR" data-part-body="ADD-REPLACE-EQUALITIES-RULE,EQUAL,X,MATCH-TREE,MV-NTH,IMPLIES,DEFTHM,QUASIQUOTE,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,THMNAME,VAR,PREFIX,MATCH-TREE-RW-FNAME,FNNAME,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-BLOCK-SUBSTS-VAR-FN">match-tree-block-substs-var-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-block-substs-var-fn" data-sym="MATCH-TREE-BLOCK-SUBSTS-VAR-FN" title="(defun match-tree-block-substs-var-fn (var vars! pat prefix)
  (let* ((fnname (match-tree-rw-fname prefix var))
         (thmname
          (intern-in-package-of-symbol
           (concatenate &#39;string (symbol-name fnname) &quot;-BLOCK-EQUALITY-SUBST&quot;)
...">match-tree-block-substs-var-fn</a>
  (var vars! pat prefix)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fnname (<a class="sym-link local-def" href="#def-match-tree-rw-fname" data-sym="MATCH-TREE-RW-FNAME" title="(defun match-tree-rw-fname (prefix var)
  (declare (xargs :guard (and (symbolp prefix) (symbolp var))))
  (if prefix
      (intern-in-package-of-symbol
       (concatenate &#39;string (symbol-name prefix) (symbol-name var)) prefix)">match-tree-rw-fname</a> prefix var)) (thmname (intern-in-package-of-symbol (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a>
            (symbol-name fnname)
            <span class="string">"-BLOCK-EQUALITY-SUBST"</span>)
          fnname)))
    `((<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,THMNAME
       (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span>
           (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ',PAT x ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!)))
         (equal (,FNNAME x . ,VARS!) (,FNNAME x . ,VARS!)))
       <span class="keyword">:rule-classes</span> nil) (<a class="sym-link local-def" href="#def-add-replace-equalities-rule" data-sym="ADD-REPLACE-EQUALITIES-RULE" title="(defmacro add-replace-equalities-rule (thmname)
  `(table replace-equalities-rules
          (replace-equalities-thm-fnsym &#39;,thmname world)
          (cons &#39;,thmname
                (cdr
...">add-replace-equalities-rule</a> ,THMNAME))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-block-substs-fns" data-defines="MATCH-TREE-BLOCK-SUBSTS-FNS" data-references="CDR,CAR,MATCH-TREE-BLOCK-SUBSTS-VAR-FN,APPEND,ATOM,IF,PREFIX,PAT,VARS!,VARS,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN" data-part-name="MATCH-TREE-BLOCK-SUBSTS-FNS" data-part-args="PREFIX,PAT,VARS!,VARS" data-part-body="CDR,MATCH-TREE-BLOCK-SUBSTS-FNS,PREFIX,PAT,VARS!,CAR,MATCH-TREE-BLOCK-SUBSTS-VAR-FN,APPEND,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-BLOCK-SUBSTS-FNS">match-tree-block-substs-fns</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-block-substs-fns" data-sym="MATCH-TREE-BLOCK-SUBSTS-FNS" title="(defun match-tree-block-substs-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-block-substs-var-fn (car vars) vars! pat prefix)
              (match-tree-block-substs-fns (cdr vars) vars! pat prefix))))">match-tree-block-substs-fns</a>
  (vars vars! pat prefix)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-match-tree-block-substs-var-fn" data-sym="MATCH-TREE-BLOCK-SUBSTS-VAR-FN" title="(defun match-tree-block-substs-var-fn (var vars! pat prefix)
  (let* ((fnname (match-tree-rw-fname prefix var))
         (thmname
          (intern-in-package-of-symbol
           (concatenate &#39;string (symbol-name fnname) &quot;-BLOCK-EQUALITY-SUBST&quot;)
...">match-tree-block-substs-var-fn</a> (car vars) vars! pat prefix)
      (<a class="sym-link local-def" href="#def-match-tree-block-substs-fns" data-sym="MATCH-TREE-BLOCK-SUBSTS-FNS" title="(defun match-tree-block-substs-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-block-substs-var-fn (car vars) vars! pat prefix)
              (match-tree-block-substs-fns (cdr vars) vars! pat prefix))))">match-tree-block-substs-fns</a> (cdr vars) vars! pat prefix))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rewrites-var-rw" data-defines="MATCH-TREE-REWRITES-VAR-RW" data-references="ENABLE,ASSOC,CDR,EQUAL,IMPLIES,X,QUOTE,MATCH-TREE,ALIST,OK,MV-LET,DEFTHM,QUASIQUOTE,MATCH-TREE-RW-FNAME,FNNAME,LET*,PREFIX,PAT,VARS!,VAR,DEFUN" data-used-by="MATCH-TREE-REWRITES-RWS" data-part-name="MATCH-TREE-REWRITES-VAR-RW" data-part-args="PREFIX,PAT,VARS!,VAR" data-part-body="ENABLE,ASSOC,CDR,EQUAL,IMPLIES,X,QUOTE,MATCH-TREE,ALIST,OK,MV-LET,DEFTHM,QUASIQUOTE,VAR,PREFIX,MATCH-TREE-RW-FNAME,FNNAME,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-REWRITES-VAR-RW">match-tree-rewrites-var-rw</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rewrites-var-rw" data-sym="MATCH-TREE-REWRITES-VAR-RW" title="(defun match-tree-rewrites-var-rw (var vars! pat prefix)
  (let* ((fnname (match-tree-rw-fname prefix var)))
    `(defthm
      ,(intern-in-package-of-symbol
        (concatenate &#39;string (symbol-name fnname) &quot;-RW&quot;) var)
...">match-tree-rewrites-var-rw</a>
  (var vars! pat prefix)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fnname (<a class="sym-link local-def" href="#def-match-tree-rw-fname" data-sym="MATCH-TREE-RW-FNAME" title="(defun match-tree-rw-fname (prefix var)
  (declare (xargs :guard (and (symbolp prefix) (symbolp var))))
  (if prefix
      (intern-in-package-of-symbol
       (concatenate &#39;string (symbol-name prefix) (symbol-name var)) prefix)">match-tree-rw-fname</a> prefix var)))
    `(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,(INTERN-IN-PACKAGE-OF-SYMBOL (CONCATENATE &#39;STRING (SYMBOL-NAME FNNAME) &quot;-RW&quot;)
                              VAR)
      (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ok alist)
        (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ',PAT x ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!))
        (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> ok
          (equal (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> ',VAR alist)) (,FNNAME x . ,VARS!))))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable ,FNNAME))))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-rewrites-rws" data-defines="MATCH-TREE-REWRITES-RWS" data-references="CDR,CAR,MATCH-TREE-REWRITES-VAR-RW,CONS,ATOM,IF,PREFIX,PAT,VARS!,VARS,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN" data-part-name="MATCH-TREE-REWRITES-RWS" data-part-args="PREFIX,PAT,VARS!,VARS" data-part-body="CDR,MATCH-TREE-REWRITES-RWS,PREFIX,PAT,VARS!,CAR,MATCH-TREE-REWRITES-VAR-RW,CONS,VARS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-REWRITES-RWS">match-tree-rewrites-rws</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-rewrites-rws" data-sym="MATCH-TREE-REWRITES-RWS" title="(defun match-tree-rewrites-rws (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-rw (car vars) vars! pat prefix)
            (match-tree-rewrites-rws (cdr vars) vars! pat prefix))))">match-tree-rewrites-rws</a>
  (vars vars! pat prefix)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> vars)
    nil
    (cons (<a class="sym-link local-def" href="#def-match-tree-rewrites-var-rw" data-sym="MATCH-TREE-REWRITES-VAR-RW" title="(defun match-tree-rewrites-var-rw (var vars! pat prefix)
  (let* ((fnname (match-tree-rw-fname prefix var)))
    `(defthm
      ,(intern-in-package-of-symbol
        (concatenate &#39;string (symbol-name fnname) &quot;-RW&quot;) var)
...">match-tree-rewrites-var-rw</a> (car vars) vars! pat prefix)
      (<a class="sym-link local-def" href="#def-match-tree-rewrites-rws" data-sym="MATCH-TREE-REWRITES-RWS" title="(defun match-tree-rewrites-rws (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-rw (car vars) vars! pat prefix)
            (match-tree-rewrites-rws (cdr vars) vars! pat prefix))))">match-tree-rewrites-rws</a> (cdr vars) vars! pat prefix))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-restr-events" data-defines="MATCH-TREE-RESTR-EVENTS" data-references="ENABLE,X,MATCH-TREE,MV-NTH,IMPLIES,DEFTHM,QUASIQUOTE,QUOTE,MEMBER,AND,MATCH-TREE-RW-FNAME,FNNAME,VAR,KW,LIST,B*,PREFIX,PAT,VARS!,RESTR,DEFUN" data-used-by="MATCH-TREE-RESTRS-EVENTS" data-part-name="MATCH-TREE-RESTR-EVENTS" data-part-args="PREFIX,PAT,VARS!,RESTR" data-part-body="ENABLE,X,MATCH-TREE,MV-NTH,IMPLIES,DEFTHM,QUASIQUOTE,QUOTE,MEMBER,AND,PREFIX,MATCH-TREE-RW-FNAME,FNNAME,RESTR,VAR,KW,LIST,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RESTR-EVENTS">match-tree-restr-events</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-restr-events" data-sym="MATCH-TREE-RESTR-EVENTS" title="(defun match-tree-restr-events (restr vars! pat prefix)
  (b* (((list kw var) restr) (fnname (match-tree-rw-fname prefix var)))
   (and (member kw &#39;(:?s :?v :?f :?l))
        `((defthm
           ,(intern-in-package-of-symbol
...">match-tree-restr-events</a>
  (restr vars! pat prefix)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> kw var) restr) (fnname (<a class="sym-link local-def" href="#def-match-tree-rw-fname" data-sym="MATCH-TREE-RW-FNAME" title="(defun match-tree-rw-fname (prefix var)
  (declare (xargs :guard (and (symbolp prefix) (symbolp var))))
  (if prefix
      (intern-in-package-of-symbol
       (concatenate &#39;string (symbol-name prefix) (symbol-name var)) prefix)">match-tree-rw-fname</a> prefix var)))
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-member" data-sym="MEMBER">member</a> kw '(<span class="keyword">:?s</span> <span class="keyword">:?v</span> <span class="keyword">:?f</span> <span class="keyword">:?l</span>))
      `((<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,(INTERN-IN-PACKAGE-OF-SYMBOL
  (CONCATENATE &#39;STRING (SYMBOL-NAME FNNAME) &quot;-TYPE&quot;) FNNAME)
         (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span>
             (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ',PAT x ,(MATCH-TREE-INITIAL-ALIST-TERM VARS!)))
           ,(CASE KW
   (:?S `(SYMBOLP (,FNNAME X . ,VARS!)))
   (:?V `(AND (SYMBOLP (,FNNAME X . ,VARS!)) (,FNNAME X . ,VARS!)))
   (:?F
    `(AND (SYMBOLP (,FNNAME X . ,VARS!))
          (NOT (EQUAL (,FNNAME X . ,VARS!) &#39;QUOTE))))
   (:?L `(NOT (EQUAL (,FNNAME X . ,VARS!) &#39;QUOTE)))))
         <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable ,FNNAME))))))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-restrs-events" data-defines="MATCH-TREE-RESTRS-EVENTS" data-references="CDR,CAR,MATCH-TREE-RESTR-EVENTS,APPEND,ATOM,IF,PREFIX,PAT,VARS!,RESTRS,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES-FN" data-part-name="MATCH-TREE-RESTRS-EVENTS" data-part-args="PREFIX,PAT,VARS!,RESTRS" data-part-body="CDR,MATCH-TREE-RESTRS-EVENTS,PREFIX,PAT,VARS!,CAR,MATCH-TREE-RESTR-EVENTS,APPEND,RESTRS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-RESTRS-EVENTS">match-tree-restrs-events</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-tree-restrs-events" data-sym="MATCH-TREE-RESTRS-EVENTS" title="(defun match-tree-restrs-events (restrs vars! pat prefix)
  (if (atom restrs)
      nil
      (append (match-tree-restr-events (car restrs) vars! pat prefix)
              (match-tree-restrs-events (cdr restrs) vars! pat prefix))))">match-tree-restrs-events</a>
  (restrs vars! pat prefix)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> restrs)
    nil
    (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-match-tree-restr-events" data-sym="MATCH-TREE-RESTR-EVENTS" title="(defun match-tree-restr-events (restr vars! pat prefix)
  (b* (((list kw var) restr) (fnname (match-tree-rw-fname prefix var)))
   (and (member kw &#39;(:?s :?v :?f :?l))
        `((defthm
           ,(intern-in-package-of-symbol
...">match-tree-restr-events</a> (car restrs) vars! pat prefix)
      (<a class="sym-link local-def" href="#def-match-tree-restrs-events" data-sym="MATCH-TREE-RESTRS-EVENTS" title="(defun match-tree-restrs-events (restrs vars! pat prefix)
  (if (atom restrs)
      nil
      (append (match-tree-restr-events (car restrs) vars! pat prefix)
              (match-tree-restrs-events (cdr restrs) vars! pat prefix))))">match-tree-restrs-events</a> (cdr restrs) vars! pat prefix))))</pre>
  </div>

<div class="form-block function" id="def-def-match-tree-rewrites-fn" data-defines="DEF-MATCH-TREE-REWRITES-FN" data-references="PROGN,QUASIQUOTE,MATCH-TREE-RESTRS-EVENTS,TYPE-EVENTS,MATCH-TREE-RESTRICTIONS,RESTRS,MATCH-TREE-BLOCK-SUBSTS-FNS,BS-EVENTS,MATCH-TREE-REWRITES-RWS,RW-EVENTS,MATCH-TREE-RW-MEASURE-THMS,MEAS-EVENTS,MATCH-TREE-REWRITES-FNS,FN-EVENTS,SET-DIFFERENCE-EQ,VARS?,MATCH-TREE-!VARS,VARS!,MATCH-TREE-BINDERS,REMOVE-DUPLICATES-EQ,ALLVARS,B*,PREFIX,PAT,DEFUN" data-used-by="DEF-MATCH-TREE-REWRITES" data-part-name="DEF-MATCH-TREE-REWRITES-FN" data-part-args="PREFIX,PAT" data-part-body="PROGN,QUASIQUOTE,MATCH-TREE-RESTRS-EVENTS,TYPE-EVENTS,MATCH-TREE-RESTRICTIONS,RESTRS,MATCH-TREE-BLOCK-SUBSTS-FNS,BS-EVENTS,MATCH-TREE-REWRITES-RWS,RW-EVENTS,MATCH-TREE-RW-MEASURE-THMS,MEAS-EVENTS,PREFIX,MATCH-TREE-REWRITES-FNS,FN-EVENTS,SET-DIFFERENCE-EQ,VARS?,MATCH-TREE-!VARS,VARS!,PAT,MATCH-TREE-BINDERS,REMOVE-DUPLICATES-EQ,ALLVARS,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-MATCH-TREE-REWRITES-FN">def-match-tree-rewrites-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-def-match-tree-rewrites-fn" data-sym="DEF-MATCH-TREE-REWRITES-FN" title="(defun def-match-tree-rewrites-fn (pat prefix)
  (b*
   ((allvars (remove-duplicates-eq (match-tree-binders pat)))
    (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
    (vars? (set-difference-eq allvars vars!))
...">def-match-tree-rewrites-fn</a>
  (pat prefix)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> ((allvars (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-eq" data-sym="REMOVE-DUPLICATES-EQ">remove-duplicates-eq</a> (<a class="sym-link local-def" href="#def-match-tree-binders" data-sym="MATCH-TREE-BINDERS" title="(defun match-tree-binders (pat)
  (b*
   (((when (atom pat)) nil)
    ((when (match-tree-binder-p pat)) (list (cadr pat))))
   (append (match-tree-binders (car pat)) (match-tree-binders (cdr pat)))))">match-tree-binders</a> pat))) (vars! (<a class="sym-link system" href="../../axioms.html#def-remove-duplicates-eq" data-sym="REMOVE-DUPLICATES-EQ">remove-duplicates-eq</a> (<a class="sym-link local-def" href="#def-match-tree-_21vars" data-sym="MATCH-TREE-!VARS" title="(defun match-tree-!vars (pat acc)
  (declare
   (xargs :guard t :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">match-tree-!vars</a> pat nil)))
      (vars? (<a class="sym-link system" href="../../axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> allvars vars!))
      (fn-events (<a class="sym-link local-def" href="#def-match-tree-rewrites-fns" data-sym="MATCH-TREE-REWRITES-FNS" title="(defun match-tree-rewrites-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-fn (car vars) vars! pat prefix)
            (match-tree-rewrites-fns (cdr vars) vars! pat prefix))))">match-tree-rewrites-fns</a> vars? vars! pat prefix))
      (meas-events (<a class="sym-link local-def" href="#def-match-tree-rw-measure-thms" data-sym="MATCH-TREE-RW-MEASURE-THMS" title="(defun match-tree-rw-measure-thms (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-rw-measure-thm (car vars) vars! pat prefix)
              (match-tree-rw-measure-thms (cdr vars) vars! pat prefix))))">match-tree-rw-measure-thms</a> vars? vars! pat prefix))
      (rw-events (<a class="sym-link local-def" href="#def-match-tree-rewrites-rws" data-sym="MATCH-TREE-REWRITES-RWS" title="(defun match-tree-rewrites-rws (vars vars! pat prefix)
  (if (atom vars)
      nil
      (cons (match-tree-rewrites-var-rw (car vars) vars! pat prefix)
            (match-tree-rewrites-rws (cdr vars) vars! pat prefix))))">match-tree-rewrites-rws</a> vars? vars! pat prefix))
      (bs-events (<a class="sym-link local-def" href="#def-match-tree-block-substs-fns" data-sym="MATCH-TREE-BLOCK-SUBSTS-FNS" title="(defun match-tree-block-substs-fns (vars vars! pat prefix)
  (if (atom vars)
      nil
      (append (match-tree-block-substs-var-fn (car vars) vars! pat prefix)
              (match-tree-block-substs-fns (cdr vars) vars! pat prefix))))">match-tree-block-substs-fns</a> vars? vars! pat prefix))
      (restrs (<a class="sym-link local-def" href="#def-match-tree-restrictions" data-sym="MATCH-TREE-RESTRICTIONS" title="(defun match-tree-restrictions (pat)
  (declare (xargs :guard t))
  (b*
   (((when (atom pat)) nil)
    ((unless (match-tree-binder-p pat))
...">match-tree-restrictions</a> pat))
      (type-events (<a class="sym-link local-def" href="#def-match-tree-restrs-events" data-sym="MATCH-TREE-RESTRS-EVENTS" title="(defun match-tree-restrs-events (restrs vars! pat prefix)
  (if (atom restrs)
      nil
      (append (match-tree-restr-events (car restrs) vars! pat prefix)
              (match-tree-restrs-events (cdr restrs) vars! pat prefix))))">match-tree-restrs-events</a> restrs vars! pat prefix)))
    `(<a class="sym-link system" href="../../axioms.html#def-progn" data-sym="PROGN">progn</a> ,@FN-EVENTS
      ,@MEAS-EVENTS
      ,@BS-EVENTS
      ,@TYPE-EVENTS . ,RW-EVENTS)))</pre>
  </div>

<div class="form-block macro" id="def-def-match-tree-rewrites" data-defines="DEF-MATCH-TREE-REWRITES" data-references="DEF-MATCH-TREE-REWRITES-FN,PREFIX,&KEY,PAT,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-MATCH-TREE-REWRITES">def-match-tree-rewrites</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-def-match-tree-rewrites" data-sym="DEF-MATCH-TREE-REWRITES" title="(defmacro def-match-tree-rewrites (pat &amp;key prefix)
  (def-match-tree-rewrites-fn pat prefix))">def-match-tree-rewrites</a>
  (pat &amp;key prefix)
  (<a class="sym-link local-def" href="#def-def-match-tree-rewrites-fn" data-sym="DEF-MATCH-TREE-REWRITES-FN" title="(defun def-match-tree-rewrites-fn (pat prefix)
  (b*
   ((allvars (remove-duplicates-eq (match-tree-binders pat)))
    (vars! (remove-duplicates-eq (match-tree-!vars pat nil)))
    (vars? (set-difference-eq allvars vars!))
...">def-match-tree-rewrites-fn</a> pat prefix))</pre>
  </div>

<div class="form-block local" id="form-57" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link local-def" href="#def-def-match-tree-rewrites" data-sym="DEF-MATCH-TREE-REWRITES" title="(defmacro def-match-tree-rewrites (pat &amp;key prefix)
  (def-match-tree-rewrites-fn pat prefix))">def-match-tree-rewrites</a> (if (<span class="keyword">:!</span> foo)
      (<span class="keyword">:?</span> bar)
      (<span class="keyword">:?s</span> baz))))</pre>
  </div>

<div class="form-block local" id="form-58" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link local-def" href="#def-def-match-tree-rewrites" data-sym="DEF-MATCH-TREE-REWRITES" title="(defmacro def-match-tree-rewrites (pat &amp;key prefix)
  (def-match-tree-rewrites-fn pat prefix))">def-match-tree-rewrites</a> (if (<span class="keyword">:!</span> foo)
      (<span class="keyword">:?</span> bar)
      (<span class="keyword">:?s</span> baz))
    <span class="keyword">:prefix</span> fooif-&gt;))</pre>
  </div>

<div class="form-block function" id="def-match-tree-alist" data-defines="MATCH-TREE-ALIST" data-references="CONS,CADR,ASSOC,IF,CAR,CDR,MATCH-TREE-BINDER-P,UNLESS,ATOM,WHEN,B*,ALIST,X,PAT,DEFUND" data-used-by="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP,MATCH-TREE-MATCHEDP-OPENER,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL,MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP,MATCH-TREE-MATCHEDP,MATCH-TREE-ALIST-EXPAND-CONS,MATCH-TREE-ALIST-EXPAND-BINDER,MATCH-TREE-ALIST-EXPAND-ATOM,MATCH-TREE-ALIST-RW-WHEN-MATCHED" data-part-name="MATCH-TREE-ALIST" data-part-args="ALIST,X,PAT" data-part-body="CONS,CADR,ASSOC,IF,CAR,X,CDR,MATCH-TREE-ALIST,MATCH-TREE-BINDER-P,UNLESS,ALIST,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST">match-tree-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(defund <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>
  (pat x alist)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) alist) ((unless (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> ((alist (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (cdr pat) (cdr x) alist)))
          (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (car pat) (car x) alist))))
    (if (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist)
      alist
      (cons (cons (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) x) alist))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-alist-rw-when-matched" data-defines="MATCH-TREE-ALIST-RW-WHEN-MATCHED" data-references="ENABLE,MATCH-TREE-ALIST,EQUAL,IMPLIES,ALIST,X,PAT,MATCH-TREE,ALIST-OUT,MATCH,MV,B*,DEFTHM" data-part-name="MATCH-TREE-ALIST-RW-WHEN-MATCHED" data-part-term="MATCH-TREE-ALIST,EQUAL,IMPLIES,ALIST,X,PAT,MATCH-TREE,ALIST-OUT,MATCH,MV,B*" data-part-hints="MATCH-TREE-ALIST,MATCH-TREE,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST-RW-WHEN-MATCHED">match-tree-alist-rw-when-matched</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-alist-rw-when-matched" data-sym="MATCH-TREE-ALIST-RW-WHEN-MATCHED" title="(defthm match-tree-alist-rw-when-matched
        (b* (((mv match alist-out) (match-tree pat x alist)))
         (implies match (equal alist-out (match-tree-alist pat x alist))))
        :hints ((&quot;Goal&quot; :in-theory (enable match-tree match-tree-alist))))">match-tree-alist-rw-when-matched</a>
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../basis-b.html#def-match" data-sym="MATCH">match</a> alist-out) (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
    (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> <a class="sym-link system" href="../../basis-b.html#def-match" data-sym="MATCH">match</a>
      (equal alist-out (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-alist-expand-atom" data-defines="MATCH-TREE-ALIST-EXPAND-ATOM" data-references="ENABLE,ALIST,X,MATCH-TREE-ALIST,EQUAL,CONSP,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-ALIST-EXPAND-ATOM" data-part-term="ALIST,X,MATCH-TREE-ALIST,EQUAL,CONSP,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-ALIST,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST-EXPAND-ATOM">match-tree-alist-expand-atom</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-alist-expand-atom" data-sym="MATCH-TREE-ALIST-EXPAND-ATOM" title="(defthmd match-tree-alist-expand-atom
         (implies (and (syntaxp (quotep pat)) (not (consp pat)))
                  (equal (match-tree-alist pat x alist) alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-alist))))">match-tree-alist-expand-atom</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (consp pat)))
    (equal (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist) alist))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-alist-expand-binder" data-defines="MATCH-TREE-ALIST-EXPAND-BINDER" data-references="ENABLE,CONS,X,MATCH-TREE-ALIST,T,ALIST,CADR,IF,ASSOC,EQUAL,MATCH-TREE-BINDER-P,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-ALIST-EXPAND-BINDER" data-part-term="CONS,X,MATCH-TREE-ALIST,T,ALIST,CADR,IF,ASSOC,EQUAL,MATCH-TREE-BINDER-P,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-BINDER-P,MATCH-TREE-ALIST,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST-EXPAND-BINDER">match-tree-alist-expand-binder</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-alist-expand-binder" data-sym="MATCH-TREE-ALIST-EXPAND-BINDER" title="(defthmd match-tree-alist-expand-binder
         (implies
          (and (syntaxp (quotep pat)) (match-tree-binder-p pat)
               (equal assoc
                      (if (assoc (cadr pat) alist)
...">match-tree-alist-expand-binder</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
      (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)
      (equal <a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a>
        (if (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist)
          <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>
          nil))
      (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> <a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a>)))
    (equal (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist)
      (if <a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a>
        alist
        (cons (cons (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) x) alist))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-alist-expand-cons" data-defines="MATCH-TREE-ALIST-EXPAND-CONS" data-references="ENABLE,CDR,CAR,ALIST,X,MATCH-TREE-ALIST,EQUAL,CONSP,MATCH-TREE-BINDER-P,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-ALIST-EXPAND-CONS" data-part-term="CDR,CAR,ALIST,X,MATCH-TREE-ALIST,EQUAL,CONSP,MATCH-TREE-BINDER-P,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-ALIST,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST-EXPAND-CONS">match-tree-alist-expand-cons</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-alist-expand-cons" data-sym="MATCH-TREE-ALIST-EXPAND-CONS" title="(defthmd match-tree-alist-expand-cons
         (implies
          (and (syntaxp (quotep pat)) (not (match-tree-binder-p pat))
               (consp pat))
          (equal (match-tree-alist pat x alist)
...">match-tree-alist-expand-cons</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat))
      (consp pat))
    (equal (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist)
      (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (car pat)
        (car x)
        (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (cdr pat) (cdr x) alist))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block other" id="form-64" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-deftheory" data-sym="DEFTHEORY">deftheory</a> match-tree-alist-opener-theory
  '(<a class="sym-link local-def" href="#def-match-tree-alist-expand-atom" data-sym="MATCH-TREE-ALIST-EXPAND-ATOM" title="(defthmd match-tree-alist-expand-atom
         (implies (and (syntaxp (quotep pat)) (not (consp pat)))
                  (equal (match-tree-alist pat x alist) alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-alist))))">match-tree-alist-expand-atom</a> <a class="sym-link local-def" href="#def-match-tree-alist-expand-binder" data-sym="MATCH-TREE-ALIST-EXPAND-BINDER" title="(defthmd match-tree-alist-expand-binder
         (implies
          (and (syntaxp (quotep pat)) (match-tree-binder-p pat)
               (equal assoc
                      (if (assoc (cadr pat) alist)
...">match-tree-alist-expand-binder</a>
    <a class="sym-link local-def" href="#def-match-tree-alist-expand-cons" data-sym="MATCH-TREE-ALIST-EXPAND-CONS" title="(defthmd match-tree-alist-expand-cons
         (implies
          (and (syntaxp (quotep pat)) (not (match-tree-binder-p pat))
               (consp pat))
          (equal (match-tree-alist pat x alist)
...">match-tree-alist-expand-cons</a>))</pre>
  </div>

<div class="form-block function" id="def-match-tree-matchedp" data-defines="MATCH-TREE-MATCHEDP" data-references="NOT,OR,CADR,ASSOC,LOOK,LET,MATCH-TREE-CHECK-BINDING,MATCH-TREE-ALIST,CAR,CDR,CONSP,AND,MATCH-TREE-BINDER-P,UNLESS,EQUAL,ATOM,WHEN,B*,ALIST,X,PAT,DEFUND" data-used-by="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM,MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP,MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER,MATCH-TREE-MATCHEDP-OPENER,MATCH-TREE-WHEN-MATCHEDP,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL,MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL,MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP,MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP-RW" data-part-name="MATCH-TREE-MATCHEDP" data-part-args="ALIST,X,PAT" data-part-body="NOT,OR,CADR,ASSOC,LOOK,LET,MATCH-TREE-CHECK-BINDING,MATCH-TREE-ALIST,CAR,ALIST,CDR,MATCH-TREE-MATCHEDP,CONSP,AND,MATCH-TREE-BINDER-P,UNLESS,X,EQUAL,PAT,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP">match-tree-matchedp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(defund <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a>
  (pat x alist)
  (<a class="sym-link external" href="../std/util/bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)) (equal pat x)) ((unless (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
          (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> (cdr pat) (cdr x) alist)
          (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> (car pat)
            (car x)
            (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (cdr pat) (cdr x) alist)))))
    (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> (car pat) x)
      (let ((look (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist)))
        (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> look) (equal (cdr look) x))))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-matchedp-rw" data-defines="MATCH-TREE-MATCHEDP-RW" data-references="ENABLE,MATCH-TREE-MATCHEDP,ALIST,X,PAT,MATCH-TREE,MV-NTH,EQUAL,DEFTHMD" data-used-by="MATCH-TREE-WHEN-MATCHEDP,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL,MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL,MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP,MATCH-TREE-OPEN" data-part-name="MATCH-TREE-MATCHEDP-RW" data-part-term="MATCH-TREE-MATCHEDP,ALIST,X,PAT,MATCH-TREE,MV-NTH,EQUAL" data-part-hints="MATCH-TREE,MATCH-TREE-MATCHEDP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-RW">match-tree-matchedp-rw</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>
  (equal (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
    (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>))))</pre>
  </div>

<div class="form-block function" id="def-match-tree-matchedp-open" data-defines="MATCH-TREE-MATCHEDP-OPEN" data-references="MATCH-TREE-MATCHEDP,ALIST,X,PAT,DEFUND" data-used-by="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM,MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP,MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER,MATCH-TREE-MATCHEDP-OPENER,MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN-WHEN-SUCCESSFUL,MATCH-TREE-OPEN" data-part-name="MATCH-TREE-MATCHEDP-OPEN" data-part-args="ALIST,X,PAT" data-part-body="ALIST,X,PAT,MATCH-TREE-MATCHEDP" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-OPEN">match-tree-matchedp-open</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(defund <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>
  (pat x alist)
  (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-open" data-defines="MATCH-TREE-OPEN" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-MATCHEDP-OPEN,ALIST,X,PAT,MATCH-TREE,MV-NTH,EQUAL,DEFTHMD" data-part-name="MATCH-TREE-OPEN" data-part-term="MATCH-TREE-MATCHEDP-OPEN,ALIST,X,PAT,MATCH-TREE,MV-NTH,EQUAL" data-part-hints="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP-RW,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-OPEN">match-tree-open</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-open" data-sym="MATCH-TREE-OPEN" title="(defthmd match-tree-open
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp-open pat x alist))
         :hints
         ((&quot;Goal&quot; :in-theory">match-tree-open</a>
  (equal (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
    (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-alist-rw-when-match-tree-matchedp" data-defines="MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-ALIST,MATCH-TREE,MV-NTH,EQUAL,ALIST,X,PAT,MATCH-TREE-MATCHEDP,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP" data-part-term="MATCH-TREE-ALIST,MATCH-TREE,MV-NTH,EQUAL,ALIST,X,PAT,MATCH-TREE-MATCHEDP,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-RW,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP">match-tree-alist-rw-when-match-tree-matchedp</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-alist-rw-when-match-tree-matchedp" data-sym="MATCH-TREE-ALIST-RW-WHEN-MATCH-TREE-MATCHEDP" title="(defthm match-tree-alist-rw-when-match-tree-matchedp
        (implies (match-tree-matchedp pat x alist)
                 (equal (mv-nth 1 (match-tree pat x alist))
                        (match-tree-alist pat x alist)))
        :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp-rw))))">match-tree-alist-rw-when-match-tree-matchedp</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)
    (equal (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
      (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-equals-match-tree-matchedp-when-successful" data-defines="MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL" data-part-term="MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-RW,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL">match-tree-equals-match-tree-matchedp-when-successful</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-equals-match-tree-matchedp-when-successful" data-sym="MATCH-TREE-EQUALS-MATCH-TREE-MATCHEDP-WHEN-SUCCESSFUL" title="(defthmd match-tree-equals-match-tree-matchedp-when-successful
         (implies
          (rewriting-negative-literal `(mv-nth &#39;0 (match-tree ,pat ,x ,alist)))
          (iff (mv-nth 0 (match-tree pat x alist))
               (match-tree-matchedp pat x alist)))">match-tree-equals-match-tree-matchedp-when-successful</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal" data-sym="REWRITING-NEGATIVE-LITERAL">rewriting-negative-literal</a> `(<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> '<span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ,PAT ,X ,ALIST)))
    (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
      (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-obj-equals-subst-when-successful" data-defines="MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,MATCH-TREE-ALIST,SUBST-TREE,EQUAL,MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,AND,DEFTHMD" data-part-name="MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL" data-part-term="MATCH-TREE-ALIST,SUBST-TREE,EQUAL,MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,AND" data-part-hints="MATCH-TREE-ALIST,MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,X" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL">match-tree-obj-equals-subst-when-successful</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-obj-equals-subst-when-successful" data-sym="MATCH-TREE-OBJ-EQUALS-SUBST-WHEN-SUCCESSFUL" title="(defthmd match-tree-obj-equals-subst-when-successful
         (and
          (implies
           (rewriting-negative-literal
            `(mv-nth &#39;0 (match-tree ,pat ,x ,alist)))
...">match-tree-obj-equals-subst-when-successful</a>
  (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal" data-sym="REWRITING-NEGATIVE-LITERAL">rewriting-negative-literal</a> `(<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> '<span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ,PAT ,X ,ALIST)))
      (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)
          (equal (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist)) x)))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:expand</span> ((<span class="keyword">:free</span> (x) (<a class="sym-link system" href="../../axioms.html#def-hide" data-sym="HIDE">hide</a> x)))
     <span class="keyword">:use</span> <a class="sym-link local-def" href="#def-match-tree-is-subst-tree" data-sym="MATCH-TREE-IS-SUBST-TREE" title="(defthmd match-tree-is-subst-tree
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies ok (equal (subst-tree pat alist) x)))
         :hints ((&quot;goal&quot; :induct (match-tree pat x alist))))">match-tree-is-subst-tree</a>
     <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a> <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-open-when-successful" data-defines="MATCH-TREE-OPEN-WHEN-SUCCESSFUL" data-references="MATCH-TREE-ALIST,MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP,AND,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-OPEN-WHEN-SUCCESSFUL" data-part-term="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP,AND,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES" data-part-hints="MATCH-TREE-ALIST,MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,X" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-OPEN-WHEN-SUCCESSFUL">match-tree-open-when-successful</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-open-when-successful" data-sym="MATCH-TREE-OPEN-WHEN-SUCCESSFUL" title="(defthmd match-tree-open-when-successful
         (implies
          (rewriting-negative-literal `(mv-nth &#39;0 (match-tree ,pat ,x ,alist)))
          (iff (mv-nth 0 (match-tree pat x alist))
               (and (match-tree-matchedp pat x alist)
...">match-tree-open-when-successful</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal" data-sym="REWRITING-NEGATIVE-LITERAL">rewriting-negative-literal</a> `(<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> '<span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ,PAT ,X ,ALIST)))
    (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)
        (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:expand</span> ((<span class="keyword">:free</span> (x) (<a class="sym-link system" href="../../axioms.html#def-hide" data-sym="HIDE">hide</a> x)))
     <span class="keyword">:use</span> <a class="sym-link local-def" href="#def-match-tree-is-subst-tree" data-sym="MATCH-TREE-IS-SUBST-TREE" title="(defthmd match-tree-is-subst-tree
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies ok (equal (subst-tree pat alist) x)))
         :hints ((&quot;goal&quot; :induct (match-tree pat x alist))))">match-tree-is-subst-tree</a>
     <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>
       <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>
       <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-obj-equals-subst-and-open-when-successful" data-defines="MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-ALIST,SUBST-TREE,EQUAL,MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,AND,DEFTHMD" data-part-name="MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL" data-part-term="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-ALIST,SUBST-TREE,EQUAL,MATCH-TREE-MATCHEDP,ALIST,X,PAT,IFF,MATCH-TREE,QUOTE,MV-NTH,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL,IMPLIES,AND" data-part-hints="MATCH-TREE-ALIST,MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE-IS-SUBST-TREE,HIDE,X" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL">match-tree-obj-equals-subst-and-open-when-successful</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-obj-equals-subst-and-open-when-successful" data-sym="MATCH-TREE-OBJ-EQUALS-SUBST-AND-OPEN-WHEN-SUCCESSFUL" title="(defthmd match-tree-obj-equals-subst-and-open-when-successful
         (and
          (implies
           (rewriting-negative-literal
            `(mv-nth &#39;0 (match-tree ,pat ,x ,alist)))
...">match-tree-obj-equals-subst-and-open-when-successful</a>
  (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal" data-sym="REWRITING-NEGATIVE-LITERAL">rewriting-negative-literal</a> `(<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> '<span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> ,PAT ,X ,ALIST)))
      (<a class="sym-link system" href="../../axioms.html#def-iff" data-sym="IFF">iff</a> (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist))
        (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)
          (equal (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> pat x alist)) x)
          (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist)))))
  <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:expand</span> ((<span class="keyword">:free</span> (x) (<a class="sym-link system" href="../../axioms.html#def-hide" data-sym="HIDE">hide</a> x)))
     <span class="keyword">:use</span> <a class="sym-link local-def" href="#def-match-tree-is-subst-tree" data-sym="MATCH-TREE-IS-SUBST-TREE" title="(defthmd match-tree-is-subst-tree
         (b* (((mv ok alist) (match-tree pat x alist)))
          (implies ok (equal (subst-tree pat alist) x)))
         :hints ((&quot;goal&quot; :induct (match-tree pat x alist))))">match-tree-is-subst-tree</a>
     <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>
       <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>
       <a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-when-matchedp" data-defines="MATCH-TREE-WHEN-MATCHEDP" data-references="MATCH-TREE-MATCHEDP-RW,ENABLE,MATCH-TREE,MV-NTH,ALIST,X,PAT,MATCH-TREE-MATCHEDP,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-WHEN-MATCHEDP" data-part-term="MATCH-TREE,MV-NTH,ALIST,X,PAT,MATCH-TREE-MATCHEDP,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-RW,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-WHEN-MATCHEDP">match-tree-when-matchedp</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-when-matchedp" data-sym="MATCH-TREE-WHEN-MATCHEDP" title="(defthm match-tree-when-matchedp
        (implies (match-tree-matchedp pat x alist)
                 (mv-nth 0 (match-tree pat x alist)))
        :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp-rw))))">match-tree-when-matchedp</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> pat x alist)
    (<a class="sym-link system" href="../../axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> <span class="number">0</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a> pat x alist)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp-rw" data-sym="MATCH-TREE-MATCHEDP-RW" title="(defthmd match-tree-matchedp-rw
         (equal (mv-nth 0 (match-tree pat x alist))
                (match-tree-matchedp pat x alist))
         :hints ((&quot;Goal&quot; :in-theory (enable match-tree-matchedp match-tree))))">match-tree-matchedp-rw</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-subst-tree-open" data-defines="SUBST-TREE-OPEN" data-references="CAR,CONS,CADR,ASSOC,CDR,MATCH-TREE-BINDER-P,ATOM,IF,ALIST,SUBST-TREE,EQUAL,PAT,QUOTEP,SYNTAXP,IMPLIES,DEFTHM" data-part-name="SUBST-TREE-OPEN" data-part-term="CAR,CONS,CADR,ASSOC,CDR,MATCH-TREE-BINDER-P,ATOM,IF,ALIST,SUBST-TREE,EQUAL,PAT,QUOTEP,SYNTAXP,IMPLIES" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-TREE-OPEN">subst-tree-open</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-subst-tree-open" data-sym="SUBST-TREE-OPEN" title="(defthm subst-tree-open
        (implies (syntaxp (quotep pat))
                 (equal (subst-tree pat alist)
                        (if (atom pat)
                            pat
...">subst-tree-open</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
    (equal (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> pat alist)
      (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> pat)
        pat
        (if (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)
          (cdr (<a class="sym-link system" href="../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist))
          (cons (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> (car pat) alist)
            (<a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a> (cdr pat) alist)))))))</pre>
  </div>

<div class="form-block in-theory" id="form-76" typeof="Code">
    <div class="form-header"><span class="form-type">in-theory</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable <a class="sym-link local-def" href="#def-subst-tree" data-sym="SUBST-TREE" title="(defun subst-tree (pat alist)
  (declare
   (xargs :guard (symbol-alistp alist) :guard-hints
    ((&quot;goal&quot; :in-theory (enable match-tree-binder-p)))))
  (b*
...">subst-tree</a>))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-matchedp-opener" data-defines="MATCH-TREE-MATCHEDP-OPENER" data-references="MATCH-TREE-MATCHEDP,ENABLE,MATCH-TREE-ALIST,CDR,NOT,OR,CADR,ASSOC-EQUAL,LOOK,LET,CAR,MATCH-TREE-CHECK-BINDING,AND,MATCH-TREE-BINDER-P,CONSP,IF,ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,PAT,QUOTEP,SYNTAXP,IMPLIES,DEFTHMD" data-part-name="MATCH-TREE-MATCHEDP-OPENER" data-part-term="MATCH-TREE-ALIST,CDR,NOT,OR,CADR,ASSOC-EQUAL,LOOK,LET,CAR,MATCH-TREE-CHECK-BINDING,AND,MATCH-TREE-BINDER-P,CONSP,IF,ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,PAT,QUOTEP,SYNTAXP,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-OPENER">match-tree-matchedp-opener</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-opener" data-sym="MATCH-TREE-MATCHEDP-OPENER" title="(defthmd match-tree-matchedp-opener
         (implies (syntaxp (quotep pat))
                  (equal (match-tree-matchedp-open pat x alist)
                         (if (consp pat)
                             (if (match-tree-binder-p pat)
...">match-tree-matchedp-opener</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
    (equal (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist)
      (if (consp pat)
        (if (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)
          (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> (car pat) x)
            (let ((look (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist)))
              (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> look) (equal (cdr look) x))))
          (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
            (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> (cdr pat) (cdr x) alist)
            (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> (car pat)
              (car x)
              (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (cdr pat) (cdr x) alist))))
        (equal x pat))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-matchedp-open-when-binder" data-defines="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER" data-references="MATCH-TREE-MATCHEDP,ENABLE,CDR,OR,CAR,MATCH-TREE-CHECK-BINDING,X,MATCH-TREE-MATCHEDP-OPEN,NOT,CONSP,IF,NOT-LOOK,ALIST,CADR,ASSOC-EQUAL,LOOK,EQUAL,MATCH-TREE-BINDER-P,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER" data-part-term="CDR,OR,CAR,MATCH-TREE-CHECK-BINDING,X,MATCH-TREE-MATCHEDP-OPEN,NOT,CONSP,IF,NOT-LOOK,ALIST,CADR,ASSOC-EQUAL,LOOK,EQUAL,MATCH-TREE-BINDER-P,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-BINDER-P,MATCH-TREE-MATCHEDP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER">match-tree-matchedp-open-when-binder</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open-when-binder" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER" title="(defthm match-tree-matchedp-open-when-binder
        (implies
         (and (syntaxp (quotep pat)) (match-tree-binder-p pat)
              (equal look (assoc-equal (cadr pat) alist))
              (equal not-look
...">match-tree-matchedp-open-when-binder</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
      (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)
      (equal look (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pat) alist))
      (equal not-look
        (if (consp look)
          nil
          (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> look)))
      (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> not-look)))
    (equal (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist)
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> (car pat) x)
        (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> not-look (equal (cdr look) x)))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a>
       <a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a>
       <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-matchedp-open-when-consp" data-defines="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP" data-references="MATCH-TREE-MATCHEDP,ENABLE,MATCH-TREE-ALIST,CAR,CDR,ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,MATCH-TREE-BINDER-P,NOT,CONSP,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP" data-part-term="MATCH-TREE-ALIST,CAR,CDR,ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,MATCH-TREE-BINDER-P,NOT,CONSP,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP">match-tree-matchedp-open-when-consp</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open-when-consp" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP" title="(defthm match-tree-matchedp-open-when-consp
        (implies
         (and (syntaxp (quotep pat)) (consp pat)
              (not (match-tree-binder-p pat)))
         (equal (match-tree-matchedp-open pat x alist)
...">match-tree-matchedp-open-when-consp</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat))
      (consp pat)
      (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-match-tree-binder-p" data-sym="MATCH-TREE-BINDER-P" title="(defun match-tree-binder-p (pat)
  (declare (xargs :guard (consp pat)))
  (and (symbolp (car pat)) (keywordp (car pat))
       (&lt; 0 (length (symbol-name (car pat))))
       (member (char (symbol-name (car pat)) 0) &#39;(#\? #\!)) (consp (cdr pat))">match-tree-binder-p</a> pat)))
    (equal (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist)
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
        (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> (cdr pat) (cdr x) alist)
        (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> (car pat)
          (car x)
          (<a class="sym-link local-def" href="#def-match-tree-alist" data-sym="MATCH-TREE-ALIST" title="(defund match-tree-alist (pat x alist)
        (b*
         (((when (atom pat)) alist)
          ((unless (match-tree-binder-p pat))
           (b* ((alist (match-tree-alist (cdr pat) (cdr x) alist)))
...">match-tree-alist</a> (cdr pat) (cdr x) alist)))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-match-tree-matchedp-open-of-atom" data-defines="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM" data-references="MATCH-TREE-MATCHEDP,ENABLE,ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,CONSP,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES,DEFTHM" data-part-name="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM" data-part-term="ALIST,X,MATCH-TREE-MATCHEDP-OPEN,EQUAL,CONSP,NOT,PAT,QUOTEP,SYNTAXP,AND,IMPLIES" data-part-hints="MATCH-TREE-MATCHEDP-OPEN,MATCH-TREE-MATCHEDP,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM">match-tree-matchedp-open-of-atom</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open-of-atom" data-sym="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM" title="(defthm match-tree-matchedp-open-of-atom
        (implies (and (syntaxp (quotep pat)) (not (consp pat)))
                 (equal (match-tree-matchedp-open pat x alist) (equal x pat)))
        :hints
        ((&quot;Goal&quot; :in-theory">match-tree-matchedp-open-of-atom</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> pat)) (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (consp pat)))
    (equal (<a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a> pat x alist) (equal x pat)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-match-tree-matchedp" data-sym="MATCH-TREE-MATCHEDP" title="(defund match-tree-matchedp (pat x alist)
        (b*
         (((when (atom pat)) (equal pat x))
          ((unless (match-tree-binder-p pat))
           (and (consp x) (match-tree-matchedp (cdr pat) (cdr x) alist)
...">match-tree-matchedp</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open" data-sym="MATCH-TREE-MATCHEDP-OPEN" title="(defund match-tree-matchedp-open (pat x alist)
        (match-tree-matchedp pat x alist))">match-tree-matchedp-open</a>))))</pre>
  </div>

<div class="form-block other" id="form-81" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-deftheory" data-sym="DEFTHEORY">deftheory</a> match-tree-opener-theory
  '(<a class="sym-link local-def" href="#def-match-tree-check-binding" data-sym="MATCH-TREE-CHECK-BINDING" title="(defun match-tree-check-binding (kw x)
  (declare (xargs :guard (keywordp kw)))
  (not
   (or (and (member kw &#39;(:?s :?f :?v)) (not (symbolp x)))
       (and (member kw &#39;(:?f :?l)) (eq x &#39;quote))">match-tree-check-binding</a> <a class="sym-link local-def" href="#def-match-tree-matchedp-open-when-binder" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-BINDER" title="(defthm match-tree-matchedp-open-when-binder
        (implies
         (and (syntaxp (quotep pat)) (match-tree-binder-p pat)
              (equal look (assoc-equal (cadr pat) alist))
              (equal not-look
...">match-tree-matchedp-open-when-binder</a>
    <a class="sym-link local-def" href="#def-match-tree-matchedp-open-when-consp" data-sym="MATCH-TREE-MATCHEDP-OPEN-WHEN-CONSP" title="(defthm match-tree-matchedp-open-when-consp
        (implies
         (and (syntaxp (quotep pat)) (consp pat)
              (not (match-tree-binder-p pat)))
         (equal (match-tree-matchedp-open pat x alist)
...">match-tree-matchedp-open-when-consp</a>
    <a class="sym-link local-def" href="#def-match-tree-matchedp-open-of-atom" data-sym="MATCH-TREE-MATCHEDP-OPEN-OF-ATOM" title="(defthm match-tree-matchedp-open-of-atom
        (implies (and (syntaxp (quotep pat)) (not (consp pat)))
                 (equal (match-tree-matchedp-open pat x alist) (equal x pat)))
        :hints
        ((&quot;Goal&quot; :in-theory">match-tree-matchedp-open-of-atom</a>))</pre>
  </div>

<div class="form-block function" id="def-equal-of-cons-open" data-defines="EQUAL-OF-CONS-OPEN" data-references="EQUAL,Y,X,DEFUND" data-used-by="EQUAL-OF-CONS-HYP-OPEN,EQUAL-OF-CONS-OPEN-WHEN-NOT-KNOWN-CONSP,EQUAL-OF-CONS-OPEN-WHEN-CONSP" data-part-name="EQUAL-OF-CONS-OPEN" data-part-args="Y,X" data-part-body="Y,X,EQUAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-OF-CONS-OPEN">equal-of-cons-open</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(defund <a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> (x y) (equal x y))</pre>
  </div>

<div class="form-block theorem" id="def-equal-of-cons-open-when-consp" data-defines="EQUAL-OF-CONS-OPEN-WHEN-CONSP" data-references="ENABLE,CDR,CAR,CONSP,CONS,X,EQUAL-OF-CONS-OPEN,EQUAL,B,A,QUOTEP,AND,NOT,SYNTAXP,IMPLIES,DEFTHM" data-part-name="EQUAL-OF-CONS-OPEN-WHEN-CONSP" data-part-term="CDR,CAR,CONSP,CONS,X,EQUAL-OF-CONS-OPEN,EQUAL,B,A,QUOTEP,AND,NOT,SYNTAXP,IMPLIES" data-part-hints="EQUAL-OF-CONS-OPEN,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-OF-CONS-OPEN-WHEN-CONSP">equal-of-cons-open-when-consp</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-equal-of-cons-open-when-consp" data-sym="EQUAL-OF-CONS-OPEN-WHEN-CONSP" title="(defthm equal-of-cons-open-when-consp
        (implies (syntaxp (not (and (quotep a) (quotep b))))
                 (equal (equal-of-cons-open x (cons a b))
                        (and (consp x) (equal-of-cons-open (car x) a)
                             (equal-of-cons-open (cdr x) b))))">equal-of-cons-open-when-consp</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> a) (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> b))))
    (equal (<a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> x (cons a b))
      (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
        (<a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> (car x) a)
        (<a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> (cdr x) b))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-equal-of-cons-open-when-not-known-consp" data-defines="EQUAL-OF-CONS-OPEN-WHEN-NOT-KNOWN-CONSP" data-references="ENABLE,X,EQUAL-OF-CONS-OPEN,EQUAL,CONS,QUOTE,CAR,EQ,CONSP,AND,NOT,Y,QUOTEP,OR,SYNTAXP,IMPLIES,DEFTHM" data-part-name="EQUAL-OF-CONS-OPEN-WHEN-NOT-KNOWN-CONSP" data-part-term="X,EQUAL-OF-CONS-OPEN,EQUAL,CONS,QUOTE,CAR,EQ,CONSP,AND,NOT,Y,QUOTEP,OR,SYNTAXP,IMPLIES" data-part-hints="EQUAL-OF-CONS-OPEN,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-OF-CONS-OPEN-WHEN-NOT-KNOWN-CONSP">equal-of-cons-open-when-not-known-consp</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-equal-of-cons-open-when-not-known-consp" data-sym="EQUAL-OF-CONS-OPEN-WHEN-NOT-KNOWN-CONSP" title="(defthm equal-of-cons-open-when-not-known-consp
        (implies
         (syntaxp (or (quotep y) (not (and (consp y) (eq (car y) &#39;cons)))))
         (equal (equal-of-cons-open x y) (equal x y)))
        :hints ((&quot;Goal&quot; :in-theory (enable equal-of-cons-open))))">equal-of-cons-open-when-not-known-consp</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> y) (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp y) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car y) 'cons)))))
    (equal (<a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> x y) (equal x y)))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-equal-of-cons-hyp-open" data-defines="EQUAL-OF-CONS-HYP-OPEN" data-references="ENABLE,EQUAL-OF-CONS-OPEN,X,STATE,MFC,CONS,EQUAL,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL-FN,OR,B,A,QUOTEP,NOT,SYNTAXP,AND,IMPLIES,DEFTHMD" data-part-name="EQUAL-OF-CONS-HYP-OPEN" data-part-term="EQUAL-OF-CONS-OPEN,X,STATE,MFC,CONS,EQUAL,QUASIQUOTE,REWRITING-NEGATIVE-LITERAL-FN,OR,B,A,QUOTEP,NOT,SYNTAXP,AND,IMPLIES" data-part-hints="EQUAL-OF-CONS-OPEN,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-OF-CONS-HYP-OPEN">equal-of-cons-hyp-open</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-equal-of-cons-hyp-open" data-sym="EQUAL-OF-CONS-HYP-OPEN" title="(defthmd equal-of-cons-hyp-open
         (implies
          (and (syntaxp (not (and (quotep a) (quotep b))))
               (syntaxp
                (or
...">equal-of-cons-hyp-open</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> a) (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> b))))
      (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal-fn" data-sym="REWRITING-NEGATIVE-LITERAL-FN">rewriting-negative-literal-fn</a> `(equal (cons ,A ,B) ,X)
            mfc
            state)
          (<a class="sym-link external" href="../std/lists/mfc-utils.html#def-rewriting-negative-literal-fn" data-sym="REWRITING-NEGATIVE-LITERAL-FN">rewriting-negative-literal-fn</a> `(equal ,X (cons ,A ,B))
            mfc
            state))))
    (equal (equal (cons a b) x)
      (<a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a> x (cons a b))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link local-def" href="#def-equal-of-cons-open" data-sym="EQUAL-OF-CONS-OPEN" title="(defund equal-of-cons-open (x y) (equal x y))">equal-of-cons-open</a>))))</pre>
  </div>

<div class="form-block theorem" id="def-assoc-equal-of-cons-when-keys-known" data-defines="ASSOC-EQUAL-OF-CONS-WHEN-KEYS-KNOWN" data-references="ENABLE,IF,REST,CONS,ASSOC-EQUAL,KEY,QUOTEP,SYNTAXP,CONSP,PAIR,CAR,KEY1,EQUAL,AND,IMPLIES,DEFTHMD" data-part-name="ASSOC-EQUAL-OF-CONS-WHEN-KEYS-KNOWN" data-part-term="IF,REST,CONS,ASSOC-EQUAL,KEY,QUOTEP,SYNTAXP,CONSP,PAIR,CAR,KEY1,EQUAL,AND,IMPLIES" data-part-hints="ASSOC-EQUAL,ENABLE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-EQUAL-OF-CONS-WHEN-KEYS-KNOWN">assoc-equal-of-cons-when-keys-known</span><span class="form-type">theorem</span></div>
    <div class="part-buttons"><button class="part-btn" data-part="term">term</button><button class="part-btn" data-part="hints">hints</button></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> <a class="sym-link local-def" href="#def-assoc-equal-of-cons-when-keys-known" data-sym="ASSOC-EQUAL-OF-CONS-WHEN-KEYS-KNOWN" title="(defthmd assoc-equal-of-cons-when-keys-known
         (implies
          (and (equal key1 (car pair)) (consp pair)
               (syntaxp (and (quotep key) (quotep key1))))
          (equal (assoc-equal key (cons pair rest))
...">assoc-equal-of-cons-when-keys-known</a>
  (<a class="sym-link system" href="../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (equal key1 (car pair))
      (consp pair)
      (<a class="sym-link system" href="../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> key) (<a class="sym-link system" href="../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> key1))))
    (equal (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> key (cons pair <a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a>))
      (if (equal key key1)
        pair
        (<a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> key <a class="sym-link system" href="../../axioms.html#def-rest" data-sym="REST">rest</a>))))
  <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable <a class="sym-link system" href="../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a>))))</pre>
  </div>

<div class="form-block other" id="form-87" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>
  <span class="keyword">:parents</span> (macro-libraries)
  <span class="keyword">:short</span> <span class="string">"Match an object against a flexible pattern and return the unifying substitution"</span>
  <span class="keyword">:long</span> <span class="string">" 
&lt;p&gt;Match-tree is a function that takes a pattern, object, and alist, and
returns two values: matchedp, which is true only if the pattern matched the
object under the bindings already present in alist, and result-alist, an
extension of the input alist containing the unifying substitution.&lt;/p&gt;

&lt;p&gt;Invocation:&lt;/p&gt;
@({
  (match-tree pattern obj alist)
 --&gt;
  (mv matchedp new-alist)
 )}     

&lt;p&gt;Pseudo-formally, if the input alist is empty, a pattern P matches an object
X and produces bindings as follows:&lt;/p&gt;

@({
  Match conditions                                 Bindings produced
  P is an atom and P = X
  P is (:? &lt;symb&gt;)                                 (&lt;symb&gt; . X)
  P is (:! &lt;symb&gt;)                                 (&lt;symb&gt; . X)
  P is (:?S &lt;symb&gt;) and X is a symbol              (&lt;symb&gt; . X)
  P is (:?V &lt;symb&gt;) and X is a nonnil symbol       (&lt;symb&gt; . X)
  P is (:?F &lt;symb&gt;) and X is a non-quote symbol    (&lt;symb&gt; . X)
  P is (:?L &lt;symb&gt;) and X is not quote             (&lt;symb&gt; . X)
  P is none of the above,
       (car P) matches (car X),
       (cdr P) matches (cdr X),                    car bindings
       and the car and cdrs&#39; bindings                UNION
       agree on all symbols bound in both.         cdr bindings.
 })

&lt;p&gt;If the input alist is not empty, then the bindings produced must also agree
with any bindings of the same symbols that are present in the input alist, and
the result alist is the bindings unioned with the input alist.&lt;/p&gt;

&lt;p&gt;The @(&#39;(:! x)&#39;) binding pattern is the same as @(&#39;(:? x)&#39;) in match-tree
itself, but is treated differently by macros @(see treematch), @(see
when-match), and @(see unless-match); see below.&lt;/p&gt;

&lt;h2&gt;Macro support&lt;/h2&gt;

&lt;p&gt;Match-tree supports the utility @(see treematch), which is similar in spirit to @(see case-match); e.g., &lt;/p&gt;

@({
 (treematch x
   ((cons (:? a) (:? b))    (list a b))
   ((foo (:v q))            (list q))
   (&amp;                       (list x)))
 })
&lt;p&gt;expands to approximately:&lt;/p&gt;
@({
 (b* (
      ;; (cons (:? a) (:? b)) case:
      ((mv matchedp alist) (match-tree &#39;(cons (:? a) (:? b)) x nil))
      ((when matchedp)
       (let* ((a (cdr (assoc &#39;a alist)))
              (b (cdr (assoc &#39;b alist))))
          (list a b)))

      ;; (foo (:v q)) case:
      ((mv matchedp alist) (match-tree &#39;(foo (:v q) (:? y)) x nil))
      ((when matchedp)
       (let* ((q (cdr (assoc &#39;q alist))))
          (list q))))

   ;; default case:
   (list x))
 })

&lt;p&gt;When a pattern contains @(&#39;(:! x)&#39;) binders, @(&#39;treematch&#39;) invokes
match-tree with an alist consisting of the previous bindings of those
variables; then, the pattern will only match if the corresponding location in
the object is equal to the existing binding of the variable, like in @(see
case-match) when a symbol is prefixed with @(&#39;!&#39;).  For example, in the
following form:&lt;/p&gt;

@({
 (let ((y &#39;bar))
   (treematch x
      ((foo (:! y))  ...)
      ...))
 })
&lt;p&gt;the match-tree call generated is:&lt;/p&gt;
@({
 (match-tree &#39;(foo (:! y)) x (list (cons &#39;y y)))
 })
&lt;p&gt;which means that this match will only succeed if x equals @(&#39;(foo bar)&#39;).&lt;/p&gt;

&lt;p&gt;Two @(see B*) binders @(&#39;unless-match&#39;) and @(&#39;when-match&#39;) also use match-tree.  One can think of them as expending to a call of @(&#39;treematch&#39;) with one pattern and a default:&lt;/p&gt;

@({
 (b* (((when-match obj pattern)
       match-form))
    default-form)
 })
&lt;p&gt;and&lt;/p&gt;
@({
 (b* (((unless-match obj pattern)
       default-form))
    match-form)
 })
&lt;p&gt;are both basically equivalent to&lt;/p&gt;
@({
 (treematch obj
   (pattern match-form)
   (&amp; default-form))
 })
    
&lt;h2&gt;Reasoning&lt;/h2&gt;

&lt;p&gt;The main advantage of match-tree over case-match is reasoning
efficiency. When using case-match, each pattern-matching form macroexpands to a
conjunction of conditions followed by a series of bindings.  These are
relatively automatic to reason about, but they make it difficult to debug
problems in proofs (because it takes a lot of reading and decoding car/cdr
nests to figure out which patterns did and did not match), and they are
expensive to reason about because when a pattern does NOT match, ACL2 typically
splits into cases for the disjunction of the matching conditions.&lt;/p&gt;

&lt;p&gt;Since match-tree is a function, the user can control how or whether to open
it.  We offer a couple of levels of reasoning about it, bundled in theories.&lt;/p&gt;

&lt;p&gt;We generally rewrite the second (new-alist) return value of @(&#39;match-tree&#39;)
to @(&#39;match-tree-alist&#39;).  This is a simpler function with fewer conditionals
that equals that value whenever the pattern matches; presumably the alist isn&#39;t
relevant otherwise. The theory @(&#39;match-tree-alist-opener-theory&#39;) opens calls
of @(&#39;match-tree-alist&#39;).  You may additionally want a rule such as
@(&#39;assoc-equal-of-cons&#39;) to simplify lookups in the alist.&lt;/p&gt;

&lt;p&gt;We generally rewrite the first return value (matchedp) to
@(&#39;match-tree-matchedp&#39;) (which is equivalent) when the match was successful.
However, we can use different rules to do this and these rules have different
side effects to help with reasoning:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@(&#39;match-tree-equals-match-tree-matchedp-when-successful&#39;) simply
rewrites the @(&#39;matchedp&#39;) return value to @(&#39;match-tree-matchedp&#39;), without side
effects.&lt;/li&gt;

&lt;li&gt;@(&#39;match-tree-obj-equals-subst-when-successful&#39;) rewrites the @(&#39;matchedp&#39;)
value to the conjunction of @(&#39;match-tree-matchedp&#39;) and a term equating the
object with the substitution of the result alist into the pattern.  Rules that
expand the substitution are enabled by default, so this quickly produces a
hypothesis that gives the shape of the object defined by the pattern.&lt;/li&gt;

&lt;li&gt;@(&#39;match-tree-open-when-successful&#39;) rewrites the @(&#39;matchedp&#39;) value to
the conjunction of @(&#39;match-tree-matchedp&#39;) and @(&#39;match-tree-matchedp-open&#39;),
and equivalent function that has rules to open calls on known patterns enabled
by default (collected in the theory @(&#39;match-tree-opener-theory&#39;).&lt;/li&gt;

&lt;li&gt;@(&#39;match-tree-obj-equals-subst-and-open-when-successful&#39;) rewrites the
@(&#39;matchedp&#39;) value to the conjunction of all three: @(&#39;match-tree-matchedp&#39;),
@(&#39;match-tree-matchedp-open&#39;), and the equivalence of the object with the
substitution.&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;These rules only take effect when we see the @(&#39;matchedp&#39;) return value as a
negative literal (hypothesis/negated conclusion) of a clause, not when
backchaining or a positive literal (negated hypothesis/conclusion).  To prove
that a pattern does in fact match, or a consequence when it doesn&#39;t match, the
rule @(&#39;match-tree-open&#39;) unconditionally rewrites the matchedp value to
@(&#39;match-tree-matchedp-open&#39;), which by default opens into a conjunction of
conditions.&lt;/p&gt;



"</span>)</pre>
  </div>

<div class="form-block other" id="form-88" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-treematch" data-sym="TREEMATCH" title="(defmacro treematch (x &amp;rest pats)
  (if (atom x)
      (treematch*-fn x pats)
      (let ((var (pack x)))
        `(b* ((,var ,x)) ,(treematch*-fn var pats)))))">treematch</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>)
  <span class="keyword">:short</span> <span class="string">"Utility similar to @(&#39;case-match&#39;) that uses @(&#39;match-tree&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see match-tree) for details.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-89" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc when-match
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>)
  <span class="keyword">:short</span> <span class="string">"@(&#39;B*&#39;) binder for @(&#39;match-tree&#39;)"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see match-tree) for details.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-90" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc unless-match
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-match-tree" data-sym="MATCH-TREE" title="(defun match-tree (pat x alist)
  (declare (xargs :guard (symbol-alistp alist) :verify-guards nil))
  (b*
   (((when (atom pat)) (mv (equal pat x) alist))
    ((unless (match-tree-binder-p pat))
...">match-tree</a>)
  <span class="keyword">:short</span> <span class="string">"@(&#39;B*&#39;) binder for @(&#39;match-tree&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see match-tree) for details.&lt;/p&gt;"</span>)</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>