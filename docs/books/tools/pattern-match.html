<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>pattern-match - ACL2 Book</title>
  <meta property="name" content="pattern-match">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">pattern-match</h1>
    <div class="path"><a href="pattern-match.lisp" class="source-link">books/tools/pattern-match</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../xdoc/top.html" title="xdoc/top">top</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../xdoc/top.html" title="Open xdoc/top">"xdoc/top"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-program" data-sym="PROGRAM">program</a>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>
  <span class="keyword">:parents</span> (<a class="sym-link system" href="../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a>)
  <span class="keyword">:short</span> <span class="string">"User-definable pattern-matching."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Examples:&lt;/p&gt;

  @({
  (pattern-match
   x
   ((cons a b) ... body1 ... )
   ((three-elt-constructor a &amp; c) ... body2 ...)
   (&amp; default-value))
  })

&lt;p&gt;@(&#39;pm&#39;) is a convenient abbreviation for @(&#39;pattern-match&#39;).&lt;/p&gt;

&lt;p&gt;Pattern-match is similar to @(see case-match), but the two macros interpret
patterns differently.  If the pattern is @(&#39;(a b c)&#39;), @(&#39;case-match&#39;)
interprets this as a three-element list and, if the input is also a
three-element list, binds the first to @(&#39;a&#39;), second to @(&#39;b&#39;), and third to
@(&#39;c&#39;).  Pattern-match, on the other hand, interprets @(&#39;(a b c)&#39;) as the
application of a constructor @(&#39;a&#39;) to arguments @(&#39;b&#39;) and @(&#39;c&#39;).  Aside from
this difference, pattern-match contains much the same features as case-match.
See @(see case-match) for the significance of special characters such as @(&#39;&amp;&#39;)
and @(&#39;!&#39;).  Also see @(see pattern-match-list), @(see pattern-matches), and
@(see pattern-matches-list).&lt;/p&gt;

&lt;h3&gt;Usage&lt;/h3&gt;

@({
  (pattern-match
     input
     (pattern1 declare-form condition11 condition12 ... declare-form body1)
     (pattern2 condition21 condition22 ... body2)
      ...)
})

&lt;p&gt;In the previous invocation, pattern-match first matches the input to
pattern1.  If it matches, condition11, condition12, ... are evaluated using any
variable bindings that pattern1 created, and using the declare form preceding
them if there is one.  (The declare form is primarily useful for declaring
ignored variables.)  If they all evaluate to non-nil, body1 is evaluated and
returned with the same variable bindings and with the declare form preceding
it, if any.  If pattern1 does not match or any of the conditions evaluate to
nil, body1 is not evaluated and pattern2 is tried, and so on.  The list of
patterns should be comprehensive or else end with a listing of the form @(&#39;(&amp;
finalbody)&#39;), so that finalbody serves as a default value.&lt;/p&gt;

&lt;p&gt;In each pattern clause the declare forms and conditions are optional.
Conditions may be included without declare forms and vice versa.  To
distinguish declare forms from conditions we simply check whether the first
item following the pattern and/or the last item before the body are declare
forms; everything between the pattern and body that is not a declare form is
assumed to be a condition.&lt;/p&gt;

&lt;p&gt;Each pattern may be a variable, to be bound to the value of the input; an
existing variable name prefixed by ! or a constant, the value of which is to be
compared with the input value; the special symbol @(&#39;&amp;&#39;) which matches
anything, or an application of a constructor to a number of arguments.  Each
constructor must have an associated macro which allows pattern-match to process
it.  The macro defines what is acceptable syntax, i.e. the number and type of
arguments the constructor can take, the conditions under which the input
matches the constructor, and the significance of the arguments.  For example,
cons-pattern-matcher is defined so that in a pattern match statement, the
constructor cons is required to take exactly two arguments; it matches any
input satisfying (consp input), and its arguments are treated as subpatterns to
be matched to the car and cdr of the input, respectively.&lt;/p&gt;

&lt;h3&gt;Extensions&lt;/h3&gt;

&lt;p&gt;The pattern-match book includes built-in support for the constructors
@(&#39;cons&#39;), @(&#39;list&#39;), and @(&#39;list*&#39;).  Support may be added for user-defined
constructors.  Some ``special constructors&#39;&#39; are also supported, with less
obvious behavior. @(&#39;raw&#39;) takes one argument, which is matched to the input
using case-match syntax; that is, no constructors are recognized.  @(&#39;bind&#39;)
takes two arguments, one a variable symbol and one a pattern; if the pattern
matches the input, then the input is bound to the variable.  @(&#39;any&#39;) compares
the input to each of its arguments using equal; if any of the arguments are
equal to the input then it is considered a match. @(&#39;force&#39;) assumes that the
pattern matches and makes the specified bindings without checking.&lt;/p&gt;

&lt;p&gt;For example, the following pattern-match statement returns @(&#39;(1 ((1 2
. 3)))&#39;):&lt;/p&gt;

 @({
  (pattern-match (list 1 (cons 1 (cons 2 3)))
    ((cons a (bind k (raw ((a b . c))))) (list a k)))
 })

&lt;p&gt;For documentation on enabling pattern-match to recognize new constructors,
see @(see def-pattern-match-constructor) and for more see @(see
constructor-pattern-match-macros).&lt;/p&gt;

&lt;p&gt;Note 1: Currently pattern-match does not bind the input expression to an
internal variable, but simply copies it everywhere it is used.  Therefore it is
wise, if the input is from some expensive calculation, to bind it to a variable
before applying pattern-match.&lt;/p&gt;

&lt;p&gt;Note 2: The default value of a pattern-match expression in case no patterns
match is nil.  Because of this, if the pattern-match expression is supposed to
evaluate to a special shape (an mv, or state, for instance), a default value of
the correct shape must be defined by including a final clause of the form @(&#39;(&amp;
default-value-of-correct-shape)&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block macro" id="def-pbl-tests-bindings" data-defines="PBL-TESTS-BINDINGS" data-references="PMSTATE,RHSES,LHSES,CDR,PATTERN-BINDINGS-LIST,QUASIQUOTE,BINDINGS,TESTS,DEFMACRO" data-used-by="PATTERN-BINDINGS-LIST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PBL-TESTS-BINDINGS">pbl-tests-bindings</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a>
  (tests bindings)
  `(<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> (cdr lhses)
    (cdr rhses)
    ,TESTS
    ,BINDINGS
    pmstate))</pre>
  </div>

<div class="form-block macro" id="def-execute-patmatch" data-defines="EXECUTE-PATMATCH" data-references="QUASIQUOTE,IF,NEXTCALL,BINDINGS-AND-BODY,TESTCLAUSE,DEFMACRO" data-used-by="PATTERN-MATCH,PATTERN-MATCH-LIST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXECUTE-PATMATCH">execute-patmatch</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-execute-patmatch" data-sym="EXECUTE-PATMATCH" title="(defmacro execute-patmatch (testclause bindings-and-body nextcall)
  (if testclause
      `(if ,testclause
           ,bindings-and-body
           ,nextcall)">execute-patmatch</a>
  (testclause bindings-and-body nextcall)
  (if testclause
    `(if ,TESTCLAUSE
      ,BINDINGS-AND-BODY
      ,NEXTCALL)
    bindings-and-body))</pre>
  </div>

<div class="form-block macro" id="def-check-pattern-matches" data-defines="CHECK-PATTERN-MATCHES" data-references="T,OR,IGNORE,DECLARE,NEXTCALL,BINDINGS-AND-BODY,TESTCLAUSE,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHECK-PATTERN-MATCHES">check-pattern-matches</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-check-pattern-matches" data-sym="CHECK-PATTERN-MATCHES" title="(defmacro check-pattern-matches (testclause bindings-and-body nextcall)
  (declare (ignore bindings-and-body nextcall))
  (or testclause t))">check-pattern-matches</a>
  (testclause bindings-and-body nextcall)
  (declare (ignore bindings-and-body nextcall))
  (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> testclause <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))</pre>
  </div>

<div class="form-block function" id="def-intern-check" data-defines="INTERN-CHECK" data-references="INTERN-IN-PACKAGE-OF-SYMBOL,INTERN,SYMBOL-PACKAGE-NAME,EQUAL,IF,SYM,STR,DEFUN" data-used-by="PATTERN-BINDINGS-LIST" data-part-name="INTERN-CHECK" data-part-args="SYM,STR" data-part-body="INTERN-IN-PACKAGE-OF-SYMBOL,STR,INTERN,SYM,SYMBOL-PACKAGE-NAME,EQUAL,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INTERN-CHECK">intern-check</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-intern-check" data-sym="INTERN-CHECK" title="(defun intern-check (str sym)
  (if (equal (symbol-package-name sym) &quot;COMMON-LISP&quot;)
      (intern str &quot;ACL2&quot;)
      (intern-in-package-of-symbol str sym)))">intern-check</a>
  (str sym)
  (if (equal (symbol-package-name sym) <span class="string">"COMMON-LISP"</span>)
    (<a class="sym-link system" href="../../axioms.html#def-intern" data-sym="INTERN">intern</a> str <span class="string">"ACL2"</span>)
    (intern-in-package-of-symbol str sym)))</pre>
  </div>

<div class="form-block function" id="def-pattern-bindings-list" data-defines="PATTERN-BINDINGS-LIST" data-references="STRING,CONCATENATE,INTERN-CHECK,FUNC-PM-MACRO,CDR,ARGS,FUNC,LIST,EQUAL-X-CONSTANT,NULL,ASSOC-EQ,BINDING,&,QUOTE,EQUAL,CHAR,EQL,SYMBOL-NAME,LENGTH,>,CONS,PBL-TESTS-BINDINGS,SYMBOLP,COND,RHS,LHS,CAR,CONSP,LEN,<,TESTCLAUSE,REVAPPEND,T,EQ,BINDINGS-AND-BODY,AND,LET,QUASIQUOTE,FINAL-TEST,ACTION,NEXTCALL,BODY,DECLARE,FINAL-TESTS,NTH,TESTS-DECLARE,LET*,ATOM,OR,IF,PMSTATE,BINDINGS,TESTS,RHSES,LHSES,DEFUN" data-used-by="FORCE-MATCH-REMOVE-TESTS-PATTERN-MATCHER,FORCE-PATTERN-MATCHER,ANY-PATTERN-MATCHER,BIND-PATTERN-MATCHER,RAW-PATTERN-MATCHER,LIST*-PATTERN-MATCHER,LIST-PATTERN-MATCHER,DEF-PATTERN-MATCH-CONSTRUCTOR,PATTERN-MATCH-LIST-CLAUSES,PATTERN-MATCH-CLAUSES,PBL-TESTS-BINDINGS" data-part-name="PATTERN-BINDINGS-LIST" data-part-args="PMSTATE,BINDINGS,TESTS,RHSES,LHSES" data-part-body="STRING,CONCATENATE,INTERN-CHECK,FUNC-PM-MACRO,CDR,ARGS,FUNC,LIST,EQUAL-X-CONSTANT,NULL,ASSOC-EQ,BINDING,&,QUOTE,EQUAL,CHAR,EQL,SYMBOL-NAME,LENGTH,>,BINDINGS,CONS,PBL-TESTS-BINDINGS,SYMBOLP,COND,RHS,LHS,CAR,CONSP,LEN,<,TESTCLAUSE,REVAPPEND,TESTS,T,EQ,BINDINGS-AND-BODY,AND,LET,QUASIQUOTE,FINAL-TEST,ACTION,NEXTCALL,BODY,DECLARE,FINAL-TESTS,PMSTATE,NTH,TESTS-DECLARE,LET*,RHSES,LHSES,ATOM,OR,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATTERN-BINDINGS-LIST">pattern-bindings-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a>
  (lhses rhses tests bindings pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> lhses) (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> rhses))
    (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((tests-declare (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">0</span> pmstate)) (final-tests (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">1</span> pmstate))
        (declare (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">2</span> pmstate))
        (<a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a> (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">3</span> pmstate))
        (nextcall (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">4</span> pmstate))
        (action (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">5</span> pmstate))
        (final-test (if final-tests
            `((let ,(REVERSE BINDINGS)
               ,@TESTS-DECLARE
               (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@FINAL-TESTS)))
            nil))
        (bindings-and-body (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a> <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a> nil))
            <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>
            `(let ,(REVERSE BINDINGS)
              ,@DECLARE
              ,BODY)))
        (tests (<a class="sym-link system" href="../../axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> tests final-test))
        (testclause (if (&lt; <span class="number">1</span> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> tests))
            `(<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> ,@TESTS)
            (if (consp tests)
              (car tests)
              nil))))
      `(,ACTION ,TESTCLAUSE ,BINDINGS-AND-BODY ,NEXTCALL))
    (let ((lhs (car lhses)) (rhs (car rhses)))
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp lhs) (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> lhs <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> lhs nil)) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons `(<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> ,RHS ,LHS) tests) bindings))
            ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> (symbol-name lhs)) <span class="number">0</span>)
               (<a class="sym-link system" href="../../axioms.html#def-eql" data-sym="EQL">eql</a> #\* (<a class="sym-link system" href="../../axioms.html#def-char" data-sym="CHAR">char</a> (symbol-name lhs) <span class="number">0</span>))) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons `(equal ,RHS ,LHS) tests)
                bindings))
            ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> (symbol-name lhs)) <span class="number">0</span>)
               (<a class="sym-link system" href="../../axioms.html#def-eql" data-sym="EQL">eql</a> #\! (<a class="sym-link system" href="../../axioms.html#def-char" data-sym="CHAR">char</a> (symbol-name lhs) <span class="number">0</span>))) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons `(equal ,RHS
                    ,(INTERN-CHECK (COERCE (CDR (COERCE (SYMBOL-NAME LHS) &#39;LIST)) &#39;STRING) LHS))
                  tests)
                bindings))
            ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> lhs '&amp;) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> tests bindings))
            (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (let ((binding (<a class="sym-link system" href="../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> lhs bindings)))
                (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> binding) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> tests (cons `(,LHS ,RHS) bindings)))
                  (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons `(equal ,RHS ,(CADR BINDING)) tests)
                      bindings)))))))
        ((<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> lhs) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons (<a class="sym-link system" href="../../basis-a.html#def-equal-x-constant" data-sym="EQUAL-X-CONSTANT">equal-x-constant</a> rhs (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> 'quote lhs)) tests)
            bindings))
        ((<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car lhs) 'quote) (<a class="sym-link local-def" href="#def-pbl-tests-bindings" data-sym="PBL-TESTS-BINDINGS" title="(defmacro pbl-tests-bindings (tests bindings)
  `(pattern-bindings-list (cdr lhses) (cdr rhses) ,tests ,bindings pmstate))">pbl-tests-bindings</a> (cons (<a class="sym-link system" href="../../basis-a.html#def-equal-x-constant" data-sym="EQUAL-X-CONSTANT">equal-x-constant</a> rhs lhs) tests)
            bindings))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((func (car lhs)) (<a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> (cdr lhs))
              (func-pm-macro (<a class="sym-link local-def" href="#def-intern-check" data-sym="INTERN-CHECK" title="(defun intern-check (str sym)
  (if (equal (symbol-package-name sym) &quot;COMMON-LISP&quot;)
      (intern str &quot;ACL2&quot;)
      (intern-in-package-of-symbol str sym)))">intern-check</a> (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> (symbol-name func) <span class="string">"-PATTERN-MATCHER"</span>)
                  func)))
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> func-pm-macro
              rhs
              <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>
              tests
              bindings
              (cdr lhses)
              (cdr rhses)
              pmstate)))))))</pre>
  </div>

<div class="form-block function" id="def-test-declare" data-defines="TEST-DECLARE" data-references="LIST,DECLARE,QUOTE,CAR,EQ,CONSP,AND,IF,ELT,DEFUN" data-used-by="SLICE-CLAUSE" data-part-name="TEST-DECLARE" data-part-args="ELT" data-part-body="LIST,DECLARE,QUOTE,CAR,EQ,ELT,CONSP,AND,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TEST-DECLARE">test-declare</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-test-declare" data-sym="TEST-DECLARE" title="(defun test-declare (elt)
  (if (and (consp elt) (eq (car elt) &#39;declare))
      (list elt)
      nil))">test-declare</a>
  (elt)
  (if (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp elt) (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car elt) 'declare))
    (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> elt)
    nil))</pre>
  </div>

<div class="form-block function" id="def-slice-clause" data-defines="SLICE-CLAUSE" data-references="SUBSEQ,TESTS,BODY,-,MAYBE-BODY-DECLARE,NTH,MAYBE-TEST-DECLARE,PATTERN,N,LET*,OTHERWISE,LIST,CADDR,IF,TEST-DECLARE,DECL,LET,CADR,CAR,TOP-LEVEL,QUOTE,HARD,ER,MV,LEN,CASE,CLAUSE,DEFUN" data-used-by="PATTERN-MATCH-LIST-CLAUSES,PATTERN-MATCH-CLAUSES" data-part-name="SLICE-CLAUSE" data-part-args="CLAUSE" data-part-body="SUBSEQ,TESTS,BODY,-,MAYBE-BODY-DECLARE,NTH,MAYBE-TEST-DECLARE,PATTERN,N,LET*,OTHERWISE,LIST,CADDR,IF,TEST-DECLARE,DECL,LET,CADR,CAR,TOP-LEVEL,QUOTE,HARD,ER,MV,CLAUSE,LEN,CASE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SLICE-CLAUSE">slice-clause</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-slice-clause" data-sym="SLICE-CLAUSE" title="(defun slice-clause (clause)
  (case (len clause)
    (0 (mv (er hard &#39;top-level &quot;Empty clause&quot;) nil nil nil nil))
    (1 (mv (er hard &#39;top-level &quot;Pattern needs a body&quot;) nil nil nil nil))
    (2 (mv (car clause) nil nil nil (cadr clause)))
...">slice-clause</a>
  (clause)
  (<a class="sym-link system" href="../../axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> clause)
    (<span class="number">0</span> (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard 'top-level <span class="string">"Empty clause"</span>) nil nil nil nil))
    (<span class="number">1</span> (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard 'top-level <span class="string">"Pattern needs a body"</span>)
        nil
        nil
        nil
        nil))
    (<span class="number">2</span> (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (car clause) nil nil nil (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause)))
    (<span class="number">3</span> (let ((decl (<a class="sym-link local-def" href="#def-test-declare" data-sym="TEST-DECLARE" title="(defun test-declare (elt)
  (if (and (consp elt) (eq (car elt) &#39;declare))
      (list elt)
      nil))">test-declare</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause))))
        (if decl
          (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (car clause) nil nil decl (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> clause))
          (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> (car clause)
            nil
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> clause))
            nil
            (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> clause)))))
    (otherwise (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> clause)) (pattern (car clause))
          (maybe-test-declare (<a class="sym-link local-def" href="#def-test-declare" data-sym="TEST-DECLARE" title="(defun test-declare (elt)
  (if (and (consp elt) (eq (car elt) &#39;declare))
      (list elt)
      nil))">test-declare</a> (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">1</span> clause)))
          (maybe-body-declare (<a class="sym-link local-def" href="#def-test-declare" data-sym="TEST-DECLARE" title="(defun test-declare (elt)
  (if (and (consp elt) (eq (car elt) &#39;declare))
      (list elt)
      nil))">test-declare</a> (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">2</span>) clause)))
          (<a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a> (<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) clause))
          (tests (if maybe-test-declare
              (if maybe-body-declare
                (<a class="sym-link system" href="../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> clause <span class="number">2</span> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">2</span>))
                (<a class="sym-link system" href="../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> clause <span class="number">2</span> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>)))
              (if maybe-body-declare
                (<a class="sym-link system" href="../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> clause <span class="number">1</span> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">2</span>))
                (<a class="sym-link system" href="../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> clause <span class="number">1</span> (<a class="sym-link system" href="../../axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>))))))
        (<a class="sym-link system" href="../../axioms.html#def-mv" data-sym="MV">mv</a> pattern
          maybe-test-declare
          tests
          maybe-body-declare
          <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>)))))</pre>
  </div>

<div class="form-block function" id="def-pattern-match-clauses" data-defines="PATTERN-MATCH-CLAUSES" data-references="PATTERN-MATCH,QUASIQUOTE,LIST,PATTERN-BINDINGS-LIST,T,NULL,&,QUOTE,EQ,AND,COND,CAR,SLICE-CLAUSE,BODY,BODY-DECL,FINAL-TESTS,TEST-DECL,PATTERN,MV-LET,ATOM,IF,ACTION,CLAUSES,TERM,DEFUN" data-used-by="PATTERN-MATCH" data-part-name="PATTERN-MATCH-CLAUSES" data-part-args="ACTION,CLAUSES,TERM" data-part-body="ACTION,PATTERN-MATCH,QUASIQUOTE,TERM,LIST,PATTERN-BINDINGS-LIST,T,NULL,&,QUOTE,EQ,AND,COND,CAR,SLICE-CLAUSE,BODY,BODY-DECL,FINAL-TESTS,TEST-DECL,PATTERN,MV-LET,CLAUSES,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATTERN-MATCH-CLAUSES">pattern-match-clauses</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pattern-match-clauses" data-sym="PATTERN-MATCH-CLAUSES" title="(defun pattern-match-clauses (term clauses action)
  (if (atom clauses)
      nil
      (mv-let (pattern test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-clauses</a>
  (term clauses action)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> clauses)
    nil
    (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (pattern test-decl final-tests body-decl <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>)
      (<a class="sym-link local-def" href="#def-slice-clause" data-sym="SLICE-CLAUSE" title="(defun slice-clause (clause)
  (case (len clause)
    (0 (mv (er hard &#39;top-level &quot;Empty clause&quot;) nil nil nil nil))
    (1 (mv (er hard &#39;top-level &quot;Pattern needs a body&quot;) nil nil nil nil))
    (2 (mv (car clause) nil nil nil (cadr clause)))
...">slice-clause</a> (car clauses))
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> pattern '&amp;) (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> final-tests)) <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>)
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> pattern)
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> term)
            nil
            nil
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> test-decl
              final-tests
              body-decl
              <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>
              `(<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a> ,TERM ,@(CDR CLAUSES))
              action)))))))</pre>
  </div>

<div class="form-block other" id="form-12" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-pattern-match-list" data-sym="PATTERN-MATCH-LIST" title="(defmacro pattern-match-list (term-list &amp;rest clauses)
  (pattern-match-list-clauses term-list clauses &#39;execute-patmatch))">pattern-match-list</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"Pattern matching to a list of terms."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

  @({
  (pattern-match-list
    (a b c d)
    (((cons !c x) 3 (list* !b y) x)
     (declare (ignore x))
     (foo y))
    (&amp; default-value)))
  })

&lt;p&gt;@(&#39;pml&#39;) is a convenient abbreviaton of @(&#39;pattern-match-list&#39;).&lt;/p&gt;

&lt;p&gt;Matches a list of terms to a list of pattern clauses.  See @(see
pattern-match) for more documentation of the pattern semantics.  The first
argument to pattern-match-list should be a list of input terms.  (For best
efficiency, these terms should be bound variables or simple constants, not
containing function calls.) Each subsequent argument should be a pattern
clause, consisting of a list of the following items:&lt;/p&gt;

&lt;ol&gt;

&lt;li&gt;a list of patterns, the same length as the list of input terms&lt;/li&gt;

&lt;li&gt;a declare form, used when evaluating the test forms (optional)&lt;/li&gt;

&lt;li&gt;any number of test forms, which may use variables bound in the
pattern (optional)&lt;/li&gt;

&lt;li&gt;a declare form whose scope is the body (optional)&lt;/li&gt;

&lt;li&gt;the body, an expression to be evaluated if the pattern matches and all the
tests succeed.&lt;/li&gt;

&lt;/ol&gt;

&lt;p&gt;The final pattern clause may be of the form @(&#39;(&amp; default-value)&#39;); this is
an exception to the convention that the pattern list must be a list same length
as the input list, and it simply defines a default value for the pattern-match
clause, to be returned instead of nil when all patterns fail.&lt;/p&gt;

&lt;p&gt;See also @(see pattern-matches-list), which simply tests whether or not a
certain pattern list matches the list of inputs.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block function" id="def-pattern-match-list-clauses" data-defines="PATTERN-MATCH-LIST-CLAUSES" data-references="TOP-LEVEL,HARD,ER,T,PATTERN-MATCH-LIST,QUASIQUOTE,LIST,PATTERN-BINDINGS-LIST,LEN,=,NULL,&,QUOTE,EQ,AND,COND,CAR,SLICE-CLAUSE,BODY,BODY-DECL,FINAL-TESTS,TEST-DECL,PATTERNS,MV-LET,ATOM,IF,ACTION,CLAUSES,TERM-LIST,DEFUN" data-used-by="PATTERN-MATCH-LIST" data-part-name="PATTERN-MATCH-LIST-CLAUSES" data-part-args="ACTION,CLAUSES,TERM-LIST" data-part-body="TOP-LEVEL,HARD,ER,T,ACTION,PATTERN-MATCH-LIST,QUASIQUOTE,LIST,PATTERN-BINDINGS-LIST,TERM-LIST,LEN,=,NULL,&,QUOTE,EQ,AND,COND,CAR,SLICE-CLAUSE,BODY,BODY-DECL,FINAL-TESTS,TEST-DECL,PATTERNS,MV-LET,CLAUSES,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATTERN-MATCH-LIST-CLAUSES">pattern-match-list-clauses</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pattern-match-list-clauses" data-sym="PATTERN-MATCH-LIST-CLAUSES" title="(defun pattern-match-list-clauses (term-list clauses action)
  (if (atom clauses)
      nil
      (mv-let (patterns test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-list-clauses</a>
  (term-list clauses action)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> clauses)
    nil
    (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (patterns test-decl final-tests body-decl <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>)
      (<a class="sym-link local-def" href="#def-slice-clause" data-sym="SLICE-CLAUSE" title="(defun slice-clause (clause)
  (case (len clause)
    (0 (mv (er hard &#39;top-level &quot;Empty clause&quot;) nil nil nil nil))
    (1 (mv (er hard &#39;top-level &quot;Pattern needs a body&quot;) nil nil nil nil))
    (2 (mv (car clause) nil nil nil (cadr clause)))
...">slice-clause</a> (car clauses))
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> patterns '&amp;) (<a class="sym-link system" href="../../axioms.html#def-null" data-sym="NULL">null</a> final-tests)) <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>)
        ((<a class="sym-link system" href="../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> patterns) (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> term-list)) (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> patterns
            term-list
            nil
            nil
            (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> test-decl
              final-tests
              body-decl
              <a class="sym-link system" href="../../basis-b.html#def-body" data-sym="BODY">body</a>
              `(<a class="sym-link local-def" href="#def-pattern-match-list" data-sym="PATTERN-MATCH-LIST" title="(defmacro pattern-match-list (term-list &amp;rest clauses)
  (pattern-match-list-clauses term-list clauses &#39;execute-patmatch))">pattern-match-list</a> ,TERM-LIST ,@(CDR CLAUSES))
              action)))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
            'top-level
            <span class="string">"Lengths of term list ~x0 and pattern list ~x1 are unequal"</span>
            term-list
            patterns))))))</pre>
  </div>

<div class="form-block macro" id="def-pattern-match-list" data-defines="PATTERN-MATCH-LIST" data-references="EXECUTE-PATMATCH,QUOTE,PATTERN-MATCH-LIST-CLAUSES,CLAUSES,&REST,TERM-LIST,DEFMACRO" data-used-by="PATTERN-MATCH-LIST-CLAUSES" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATTERN-MATCH-LIST">pattern-match-list</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pattern-match-list" data-sym="PATTERN-MATCH-LIST" title="(defmacro pattern-match-list (term-list &amp;rest clauses)
  (pattern-match-list-clauses term-list clauses &#39;execute-patmatch))">pattern-match-list</a>
  (term-list &amp;rest clauses)
  (<a class="sym-link local-def" href="#def-pattern-match-list-clauses" data-sym="PATTERN-MATCH-LIST-CLAUSES" title="(defun pattern-match-list-clauses (term-list clauses action)
  (if (atom clauses)
      nil
      (mv-let (patterns test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-list-clauses</a> term-list
    clauses
    '<a class="sym-link local-def" href="#def-execute-patmatch" data-sym="EXECUTE-PATMATCH" title="(defmacro execute-patmatch (testclause bindings-and-body nextcall)
  (if testclause
      `(if ,testclause
           ,bindings-and-body
           ,nextcall)">execute-patmatch</a>))</pre>
  </div>

<div class="form-block other" id="form-15" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> pml
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"@(&#39;pml&#39;) is an abbreviation for @(&#39;pattern-match-list&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"@(def pml)"</span>
  (<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> pml
    (term-list &amp;rest clauses)
    `(<a class="sym-link local-def" href="#def-pattern-match-list" data-sym="PATTERN-MATCH-LIST" title="(defmacro pattern-match-list (term-list &amp;rest clauses)
  (pattern-match-list-clauses term-list clauses &#39;execute-patmatch))">pattern-match-list</a> ,TERM-LIST . ,CLAUSES)))</pre>
  </div>

<div class="form-block other" id="form-16" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> pattern-matches-list
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"Check that a list of terms matches a list of patterns."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example&lt;/p&gt;

@({
  (pattern-matches-list
     (a b c)
     (x (cons x y) y))
})

&lt;p&gt;The example returns:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@(&#39;t&#39;)  &amp;mdash;  if @(&#39;b&#39;) equals the @(see cons) of @(&#39;a&#39;) and @(&#39;c&#39;), or,&lt;/li&gt;
&lt;li&gt;@(&#39;nil&#39;) &amp;mdash; otherwise.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See @(see pattern-match) and @(see pattern-match-list).&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> pattern-matches-list
    (term-list pattern-list)
    (<a class="sym-link local-def" href="#def-pattern-match-list-clauses" data-sym="PATTERN-MATCH-LIST-CLAUSES" title="(defun pattern-match-list-clauses (term-list clauses action)
  (if (atom clauses)
      nil
      (mv-let (patterns test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-list-clauses</a> term-list
      `((,PATTERN-LIST <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
      '<a class="sym-link local-def" href="#def-check-pattern-matches" data-sym="CHECK-PATTERN-MATCHES" title="(defmacro check-pattern-matches (testclause bindings-and-body nextcall)
  (declare (ignore bindings-and-body nextcall))
  (or testclause t))">check-pattern-matches</a>)))</pre>
  </div>

<div class="form-block macro" id="def-pattern-match" data-defines="PATTERN-MATCH" data-references="EXECUTE-PATMATCH,QUOTE,PATTERN-MATCH-CLAUSES,CLAUSES,&REST,TERM,DEFMACRO" data-used-by="PATTERN-MATCH-CLAUSES" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATTERN-MATCH">pattern-match</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>
  (term &amp;rest clauses)
  (<a class="sym-link local-def" href="#def-pattern-match-clauses" data-sym="PATTERN-MATCH-CLAUSES" title="(defun pattern-match-clauses (term clauses action)
  (if (atom clauses)
      nil
      (mv-let (pattern test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-clauses</a> term clauses '<a class="sym-link local-def" href="#def-execute-patmatch" data-sym="EXECUTE-PATMATCH" title="(defmacro execute-patmatch (testclause bindings-and-body nextcall)
  (if testclause
      `(if ,testclause
           ,bindings-and-body
           ,nextcall)">execute-patmatch</a>))</pre>
  </div>

<div class="form-block other" id="form-18" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> pm
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"@(&#39;pm&#39;) is an abbreviation for @(&#39;pattern-match&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"@(def pm)"</span>
  (<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> pm
    (term &amp;rest clauses)
    `(<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a> ,TERM . ,CLAUSES)))</pre>
  </div>

<div class="form-block other" id="form-19" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> pattern-matches
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"Check whether a term matches a pattern."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

@({
    (pattern-matches x (cons a (cons b a)))
})

&lt;p&gt;The example is equivalent to the test&lt;/p&gt;

@({
    (and (consp x)
         (consp (cdr x))
         (equal (car x) (cddr x)))
})

&lt;p&gt;See @(see pattern-match) and @(see pattern-match-list).&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> pattern-matches
    (term pattern)
    (<a class="sym-link local-def" href="#def-pattern-match-clauses" data-sym="PATTERN-MATCH-CLAUSES" title="(defun pattern-match-clauses (term clauses action)
  (if (atom clauses)
      nil
      (mv-let (pattern test-decl final-tests body-decl body)
              (slice-clause (car clauses))
...">pattern-match-clauses</a> term
      `((,PATTERN <a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a>))
      '<a class="sym-link local-def" href="#def-check-pattern-matches" data-sym="CHECK-PATTERN-MATCHES" title="(defmacro check-pattern-matches (testclause bindings-and-body nextcall)
  (declare (ignore bindings-and-body nextcall))
  (or testclause t))">check-pattern-matches</a>)))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-explode-term" data-defines="EXPLODE-TERM" data-references="CDR,CONS,ATOM,EXPLODE-LIST,QUASIQUOTE,LIST,QUOTE,CAR,EQ,CONSP,IF,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="DEF-PATTERN-MATCH-CONSTRUCTOR,DESTRUCTOR-SUBST-LIST,EXPL" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPLODE-TERM">explode-term</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-explode-term" data-sym="EXPLODE-TERM" title="(mutual-recursion
 (defun explode-term (term)
   (if (consp term)
       (if (eq (car term) &#39;quote)
           (list &#39;quote term)
...">explode-term</a>
    (term)
    (if (consp term)
      (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (car term) 'quote)
        (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> 'quote term)
        `(<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ',(CAR TERM) ,@(EXPLODE-LIST (CDR TERM))))
      term))
  (<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> explode-list
    (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
    (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
      nil
      (cons (<a class="sym-link local-def" href="#def-explode-term" data-sym="EXPLODE-TERM" title="(mutual-recursion
 (defun explode-term (term)
   (if (consp term)
       (if (eq (car term) &#39;quote)
           (list &#39;quote term)
...">explode-term</a> (car <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)) (explode-list (cdr <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>))))))</pre>
  </div>

<div class="form-block macro" id="def-expl" data-defines="EXPL" data-references="EXPLODE-TERM,TM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPL">expl</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-expl" data-sym="EXPL" title="(defmacro expl (tm) (explode-term tm))">expl</a> (tm) (<a class="sym-link local-def" href="#def-explode-term" data-sym="EXPLODE-TERM" title="(mutual-recursion
 (defun explode-term (term)
   (if (consp term)
       (if (eq (car term) &#39;quote)
           (list &#39;quote term)
...">explode-term</a> tm))</pre>
  </div>

<div class="form-block function" id="def-destructor-subst-list" data-defines="DESTRUCTOR-SUBST-LIST" data-references="CDR,LIST,QUASIQUOTE,EXPLODE-TERM,QUOTE,SUBST,CAR,CONSP,CONS,ATOM,IF,DESTRUCTORS,TERM,DEFUN" data-used-by="DEF-PATTERN-MATCH-CONSTRUCTOR" data-part-name="DESTRUCTOR-SUBST-LIST" data-part-args="DESTRUCTORS,TERM" data-part-body="CDR,DESTRUCTOR-SUBST-LIST,LIST,QUASIQUOTE,EXPLODE-TERM,TERM,QUOTE,SUBST,CAR,CONSP,CONS,DESTRUCTORS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DESTRUCTOR-SUBST-LIST">destructor-subst-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-destructor-subst-list" data-sym="DESTRUCTOR-SUBST-LIST" title="(defun destructor-subst-list (term destructors)
  (if (atom destructors)
      nil
      (cons
       (if (consp (car destructors))
...">destructor-subst-list</a>
  (term <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)
    nil
    (cons (if (consp (car <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>))
        (<a class="sym-link system" href="../../axioms.html#def-subst" data-sym="SUBST">subst</a> 'term term (<a class="sym-link local-def" href="#def-explode-term" data-sym="EXPLODE-TERM" title="(mutual-recursion
 (defun explode-term (term)
   (if (consp term)
       (if (eq (car term) &#39;quote)
           (list &#39;quote term)
...">explode-term</a> (car <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)))
        `(<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ',(CAR DESTRUCTORS) term))
      (<a class="sym-link local-def" href="#def-destructor-subst-list" data-sym="DESTRUCTOR-SUBST-LIST" title="(defun destructor-subst-list (term destructors)
  (if (atom destructors)
      nil
      (cons
       (if (consp (car destructors))
...">destructor-subst-list</a> term (cdr <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)))))</pre>
  </div>

<div class="form-block function" id="def-destructor-list" data-defines="DESTRUCTOR-LIST" data-references="TERM,QUOTE,LIST,QUASIQUOTE,ATOM,IF,DESTRUCTORS,DEFUN" data-used-by="DEF-PATTERN-MATCH-CONSTRUCTOR" data-part-name="DESTRUCTOR-LIST" data-part-args="DESTRUCTORS" data-part-body="TERM,QUOTE,LIST,QUASIQUOTE,DESTRUCTORS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DESTRUCTOR-LIST">destructor-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-destructor-list" data-sym="DESTRUCTOR-LIST" title="(defun destructor-list (destructors)
  (if (atom destructors)
      nil
      `((list &#39;,(car destructors) term) ,@(destructor-list (cdr destructors)))))">destructor-list</a>
  (<a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)
    nil
    `((<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ',(CAR DESTRUCTORS) term) ,@(DESTRUCTOR-LIST (CDR DESTRUCTORS)))))</pre>
  </div>

<div class="form-block other" id="form-24" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> <a class="sym-link local-def" href="#def-def-pattern-match-constructor" data-sym="DEF-PATTERN-MATCH-CONSTRUCTOR" title="(defmacro def-pattern-match-constructor (&amp;rest args)
  (let* ((term
          (if (consp (car args))
              (caar args)
              nil))
...">def-pattern-match-constructor</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"Allow pattern-match to recognize a constructor."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

@({
    (def-pattern-match-constructor cons consp (car cdr))
})

&lt;p&gt;For a constructor @(&#39;cname&#39;), defines a macro named
@(&#39;cname-pattern-matcher&#39;) which will allow constructs using @(&#39;cname&#39;) to be
recognized by the pattern-match macro; see @(see pattern-match).  This macro
takes three arguments: the name of the constructor, which is the symbol that
pattern-match will recognize; the name of a recognizer function which returns
@(&#39;t&#39;) on objects produced by the constructor; and an ordered list of
destructor function names, which when applied to the constructed object return
the arguments to the constructor.&lt;/p&gt;

&lt;p&gt;For example, say we define a function cons3 that combines three objects into
a triple.  We define a recognizer, cons3-p, for correctly-formed triples as
created by cons3, as well as three accessors, cons3-first, cons3-second,
cons3-third.  Now we&#39;d like to have a pattern match expression like this&lt;/p&gt;

@({
  (pattern-match x
         ((cons3 a b c) ... body ..)
         ... other clauses ...)
})

&lt;p&gt;resolve to this:&lt;/p&gt;

@({
  (if (cons3-p x)
      (let ((a (cons3-first x))
            (b (cons3-second x))
            (c (cons3-third x)))
        ... body ...)
    ... other conditions ...)
})

&lt;p&gt;Therefore the pattern match macro must know that the recognizer for a cons3
object is cons3-p, and that the destructors are cons3-first, etc - we don&#39;t
want to have to write out those names anywhere in the untranslated body.  Our
solution is that when pattern-match sees a function symbol fun, it returns a
call to a macro named fun-pattern-matcher.  If this macro does not exist,
pattern-match will fail.  To easily define such macros, we provide
def-pattern-match-constructor, which takes as arguments the constructor name,
the recognizer name, and the ordered list of destructors.  For example, to
allow pattern-match to deal with cons3, we&#39;d call&lt;/p&gt;

@({
    (def-pattern-match-constructor cons3 cons3-p
      (cons3-first cons3-second cons3-third))
})

&lt;p&gt;Similarly for cons, the call would be&lt;/p&gt;

@({
     (def-pattern-match-constructor cons consp (car cdr))
})

&lt;p&gt;but this is built into the pattern match book.&lt;/p&gt;

&lt;p&gt;Pattern-matcher macros may be defined more flexibly without using
@(&#39;def-pattern-match-constructor&#39;) in order to support, for example, macros
with variable numbers of arguments; see @(see
constructor-pattern-match-macros).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block macro" id="def-def-pattern-match-constructor" data-defines="DEF-PATTERN-MATCH-CONSTRUCTOR" data-references="PATTERN-BINDINGS-LIST,APPEND,LET,T,LEN,=,TOP-LEVEL,HARD,ER,TRUE-LISTP,NOT,COND,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ERR-STRING-TRUELIST,SYMBOL-NAME,STRING,CONCATENATE,ERR-STRING-NARGS,DESTRUCTOR-LIST,CADDDR,DESTRUCTOR-SUBST-LIST,CONS,DESTRUCTORS,LIST,QUASIQUOTE,EXPLODE-TERM,QUOTE,SUBST,CADDR,EQ,RECOGNIZER,CADR,CONSTRUCTOR,CAAR,CAR,CONSP,IF,TERM,LET*,ARGS,&REST,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-PATTERN-MATCH-CONSTRUCTOR">def-pattern-match-constructor</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-def-pattern-match-constructor" data-sym="DEF-PATTERN-MATCH-CONSTRUCTOR" title="(defmacro def-pattern-match-constructor (&amp;rest args)
  (let* ((term
          (if (consp (car args))
              (caar args)
              nil))
...">def-pattern-match-constructor</a>
  (&amp;rest <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (<a class="sym-link system" href="../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((term (if (consp (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
         (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
         nil)) (constructor (if term
          (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
          (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
      (recognizer (if term
          (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="keyword">:unconditional</span>)
            nil
            (if (consp (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
              (<a class="sym-link system" href="../../axioms.html#def-subst" data-sym="SUBST">subst</a> 'term term (<a class="sym-link local-def" href="#def-explode-term" data-sym="EXPLODE-TERM" title="(mutual-recursion
 (defun explode-term (term)
   (if (consp term)
       (if (eq (car term) &#39;quote)
           (list &#39;quote term)
...">explode-term</a> (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
              `(<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ',(CADDR ARGS) term)))
          (if (<a class="sym-link system" href="../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="keyword">:unconditional</span>)
            nil
            `(<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> ',(CADR ARGS) term))))
      (<a class="sym-link system" href="../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a> (if term
          (cons '<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link local-def" href="#def-destructor-subst-list" data-sym="DESTRUCTOR-SUBST-LIST" title="(defun destructor-subst-list (term destructors)
  (if (atom destructors)
      nil
      (cons
       (if (consp (car destructors))
...">destructor-subst-list</a> term (<a class="sym-link system" href="../../axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
          (cons '<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link local-def" href="#def-destructor-list" data-sym="DESTRUCTOR-LIST" title="(defun destructor-list (destructors)
  (if (atom destructors)
      nil
      `((list &#39;,(car destructors) term) ,@(destructor-list (cdr destructors)))))">destructor-list</a> (<a class="sym-link system" href="../../axioms.html#def-caddr" data-sym="CADDR">caddr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))))
      (err-string-nargs (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a>
          <span class="string">"Wrong number of arguments to "</span>
          (symbol-name constructor)
          <span class="string">" in pattern matching: ~x0~%"</span>))
      (err-string-truelist (<a class="sym-link system" href="../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"Badly formed expression: ~x0~%"</span>)))
    `(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,(INTERN-IN-PACKAGE-OF-SYMBOL
  (CONCATENATE &#39;STRING (SYMBOL-NAME CONSTRUCTOR) &quot;-PATTERN-MATCHER&quot;)
  (IF (EQUAL (SYMBOL-PACKAGE-NAME CONSTRUCTOR) &quot;COMMON-LISP&quot;)
      &#39;BLA
      CONSTRUCTOR))
      (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
      (<a class="sym-link system" href="../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
            'top-level
            ,ERR-STRING-TRUELIST
            (cons ',CONSTRUCTOR <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
        ((<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) ,(1- (LEN DESTRUCTORS)))) (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
            'top-level
            ,ERR-STRING-NARGS
            (cons ',CONSTRUCTOR <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))
        (<a class="sym-link system" href="../../axioms.html#def-t" data-sym="T">t</a> (let ((rhses (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> ,DESTRUCTORS rhses)) ,@(IF RECOGNIZER
      `((TESTS (CONS ,RECOGNIZER TESTS)))
      NIL)
              (lhses (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> lhses)))
            (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate)))))))</pre>
  </div>

<div class="form-block other" id="form-26" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../xdoc/top.html#def-defsection" data-sym="DEFSECTION">defsection</a> constructor-pattern-match-macros
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-pattern-match" data-sym="PATTERN-MATCH" title="(defmacro pattern-match (term &amp;rest clauses)
  (pattern-match-clauses term clauses &#39;execute-patmatch))">pattern-match</a>)
  <span class="keyword">:short</span> <span class="string">"How to write pattern-match macros for custom constructors."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Here we discuss how constructor @(see pattern-match) macros work in
conjunction with pattern-match.  In most cases the user does not need to be
concerned with the internals discussed here; see @(see
def-pattern-match-constructor) for an easy way to get pattern-match to
recognize a user-defined form.&lt;/p&gt;

&lt;p&gt;The trick behind pattern-match is that whenever a constructor @(&#39;cname&#39;) is
seen in a pattern, a call to the macro named @(&#39;cname-pattern-matcher&#39;) is
returned and macro expansion continues by expanding that macro.  Because of
this, all the unprocessed parts of the original pattern-match call must be
passed through that macro.  By the design of the framework, the constructor
macro will only operate on a few of the arguments given to it, passing the rest
through to the main function that performs pattern matching,
@(&#39;pattern-bindings-list&#39;).&lt;/p&gt;

&lt;p&gt;The arguments given to the constructor&#39;s macro are&lt;/p&gt;

@({
    (term args tests bindings lhses rhses pmstate)
})

&lt;p&gt;The arguments that @(&#39;pattern-bindings-list&#39;) takes are&lt;/p&gt;

@({
    (lhses rhses tests bindings pmstate)
})

&lt;p&gt;The argument list of @(&#39;pattern-bindings-list&#39;) is a subset of that of the
constructor&#39;s macro.  We will discuss how to form the arguments for
@(&#39;pattern-bindings-list&#39;) from those given to the constructor macro.&lt;/p&gt;

&lt;p&gt;The constructor macro is responsible for error handling in the case of a
nonsensical invocation of the constructor (primarily, one with the wrong number
of arguments), adding appropriate tests to determine whether @(&#39;term&#39;) can
match the pattern, and ``lining up&#39;&#39; the arguments given to the constructor in
the pattern with the appropriate destructors applied to the term in
question.&lt;/p&gt;

&lt;p&gt;We will go through the arguments given to the macro and outline what needs
to be done with them to fulfill the above obligations.&lt;/p&gt;

&lt;p&gt;@(&#39;term&#39;) is a term which should evaluate to the current part of the input
that we are trying to match.  If the original term given as input to pattern
match was x, then term may be something like @(&#39;(car (nth 4 (cdr x)))&#39;).
Therefore we need to add tests to determine whether this is of the correct form
to be matched to something created by our constructor, and we need to apply the
correct destructors to it to break it down for further matching.&lt;/p&gt;

&lt;p&gt;@(&#39;args&#39;) is the list of arguments given to the constructor in the pattern
that we&#39;re matching to.  The whole pattern that @(&#39;term&#39;) is supporsed to match
is our constructor @(&#39;cname&#39;) applied to @(&#39;args&#39;).  For error checking we need
to ensure that @(&#39;args&#39;) is the correct length for the call to our constructor
to make sense.  It is also helpful to ensure that @(&#39;args&#39;) is a true-list and
issue a helpful error message if not.  Each element of @(&#39;args&#39;) must also be
paired with an application of a destructor to @(&#39;term&#39;) to continue pattern
matching.  If, as is usually the case, the arguments we&#39;re expecting are to be
read as subpatterns, the best approach is not to examine them individually but
to let pattern-bindings-list do the real work.&lt;/p&gt;

&lt;p&gt;@(&#39;tests&#39;) is an accumulated list of tests to be applied to the input to
determine whether it matches the pattern.  We need to prepend to this list any
necessary tests on @(&#39;term&#39;) so as to determine whether it could be formed by
our constructor.&lt;/p&gt;

&lt;p&gt;@(&#39;bindings&#39;) is an accumulated list of variables that will be bound to
applications of destructors to the input term.  While the results of the
processing that our macro does will have a direct effect on this list, most of
the time it should be passed through to @(&#39;pattern-bindings-list&#39;) and we
should instead manipulate @(&#39;lhses&#39;) and @(&#39;rhses&#39;):&lt;/p&gt;

&lt;p&gt;@(&#39;lhses&#39;) and @(&#39;rhses&#39;) are lists of, respectively, subpatterns of the
top-level pattern that we&#39;re processing and corresponding subterms of the input
term that will be matched to the patterns.  In most cases what we&#39;ll do is
prepent @(&#39;args&#39;) to @(&#39;lhses&#39;) while prepending a list of each of our
destructors applied to @(&#39;term&#39;) to @(&#39;rhses&#39;).  @(&#39;pattern-bindings-list&#39;)
will then handle the details of variable bindings and recursive subpattern
matching as determined by the contents of @(&#39;lhses&#39;).  Each macro must maintain
the invariant that @(&#39;lhses&#39;) and @(&#39;rhses&#39;) are the same length; if this isn&#39;t
the case there are probably other things going wrong as well.  The intuition
behind these names is that eventually patterns in @(&#39;lhses&#39;) break down to
variables, which are bound to corresponding subterms broken down from elements
of @(&#39;rhses&#39;).  We&#39;re using LHS and RHS here as in an assignment statement in
some imperative language, as opposed to the sense used when talking about a
rewrite rule.&lt;/p&gt;

&lt;p&gt;@(&#39;pmstate&#39;) contains the expression to be evaluated if the pattern matches,
the list of tests to be tried before confirming a match, declarations, the rest
of the clauses to match to in case this match fails, and the name of the macro
to pass the final results to.  These are grouped together specifically because
they don&#39;t have to do with the actual pattern-matching but must be kept intact
through the various iterations of macro expansion.  This argument should
*always* be passed through intact to pattern-bindings-list unless you&#39;re trying
to really confuse your users.&lt;/p&gt;

&lt;p&gt;An example of a very typical constructor macro is the one for cons, which is
automatically generated by @(&#39;def-pattern-match-constructor&#39;):&lt;/p&gt;

 @({
 (defmacro
   cons-pattern-matcher
   (term args tests bindings lhses rhses pmstate)
   (cond
    ;; First check args for well-formedness: it should always be a true-list of
    ;; length 2, since any other argument list to cons is ill-formed.
    ((not (true-listp args))
     (er hard &#39;top-level ``badly formed expression: ~~x0~~%&#39;&#39;
         (cons &#39;cons args)))
    ((not (= (len args) 2))
     (er hard &#39;top-level
         ``Wrong number of arguments to CONS in pattern matching: ~~x0~~%&#39;&#39;
         (CONS &#39;CONS ARGS)))
    (t (let
        ;; Push destructor applications (car term) and (cdr term) onto rhses
        ((rhses (append (list (list &#39;car term) (list &#39;cdr term)) rhses))
         ;; Push the args onto lhses (they must occur in the order corresponding
         ;; to the order of the destructor calls pushed onto rhses.)
         (lhses (append args lhses))
         ;; Push a test that term is consp onto tests
         (tests (cons (list &#39;consp term) tests)))
        ;; Finally call pattern-bindings-list again.
        (pattern-bindings-list lhses rhses tests bindings pmstate)))))
 })

&lt;p&gt;If there are no errors, this simply makes three changes to the existing
arguments: it prepends the two subterms @(&#39;(car term)&#39;) and @(&#39;(cdr term)&#39;)
onto @(&#39;rhses&#39;) and the list of arguments to @(&#39;lhses&#39;) and adds the test
@(&#39;(consp term)&#39;) to tests.  It then calls pattern-bindings-list.&lt;/p&gt;

&lt;p&gt;The macro for list works the same way, but could not have been generated by
@(&#39;def-pattern-match-constructor&#39;) because it handles variable length argument
lists.  It again simply prepends all arguments to @(&#39;lhses&#39;), prepends a list
of applications of destructors to the input term to rhses (try evaluating
@(&#39;(list-of-nths 0 5 &#39;x)&#39;) to see the resulting form), and tests whether the
input term is of a suitable form, in this case whether it is a true-list of the
same length as the argument list.&lt;/p&gt;

 @({
 (defmacro list-pattern-matcher
   (term args tests bindings lhses rhses pmstate)
   ;; Ensure that args is a true-list; it may be any length.
   (if (not (true-listp args))
       (er hard &#39;top-level ``Badly formed expression: ~~x0~~%&#39;&#39;
           (cons &#39;list args))
     (let
         ;; list-of-nths produces a list of calls to nth, from (nth 0 term) up
         ;; to (nth (- (length args) 1) term).
         ((rhses (append (list-of-nths 0 (length args) term) rhses))
          ;; push args onto lhses
          (lhses (append args lhses))
          ;; Require that term is a true-list with length corresponding to that
          ;; of args.
          (tests (append `((true-listp ,term)
                           (= (len ,term) ,(length args)))
                         tests)))
       (pattern-bindings-list lhses rhses tests bindings pmstate))))
 })

&lt;p&gt;A nonstandard, but still correct, example is the one for list*, which
instead of doing the processing itself replaces its pattern with an equivalent
cons structure so that the cons macro will do all the work: to illustrate what
is prepended to @(&#39;lhses&#39;), try running @(&#39;(list*-macro (list &#39;a &#39;b &#39;c &#39;d))&#39;).
In this case no test needs to be added because the cons macro takes care of it.
Note that we could easily cause an infinite loop in macro expansion by abusing
this type of thing and, for example, pushing a new @(&#39;list*&#39;) pattern onto
lhses.&lt;/p&gt;

 @({
 (defmacro list*-pattern-matcher
   (term args tests bindings lhses rhses pmstate)
   ;; Check that args is a true-listp.
   ;; If this is counterintuitive, consider that this would suggest syntax such
   ;; as (list* a b . c).
   (if (not (true-listp args))
       (er hard &#39;top-level ``Badly formed expression: ~~x0~~%&#39;&#39;
           (cons &#39;list* args))
     (let
         ;; Just push term onto rhses
         ((rhses (cons term rhses))
          ;; list*-macro is the very function that list* uses to expand an
          ;; invocation into a nest of conses.  Since we have a cons pattern
          ;; matcher already, we just take advantage of this.
          (lhses (cons (list*-macro args) lhses)))
       ;; No additional tests are necessary - we trust in cons-pattern-matcher
       ;; to take care of that.
       (pattern-bindings-list lhses rhses tests bindings pmstate))))
 })

&lt;p&gt;Another nonstandard example is raw-pattern-matcher, which reverts the
behavior of pattern-match to that of case-match for the term inside; in fact,
it just calls the function that does the work for case-match -
@(&#39;match-tests-and-bindings&#39;) - and uses its results.  In this case, since the
argument to our constructor is not taken to be a subpattern of the form handled
by @(&#39;pattern-bindings-list&#39;), we manipulate @(&#39;bindings&#39;) directly rather than
dealing with @(&#39;lhses&#39;) and @(&#39;rhses&#39;).  It is fortunate that the form of the
tests and bindings variables for @(&#39;match-tests-and-bindings&#39;) is the same as
ours or we would need to do more processing of them.&lt;/p&gt;

 @({
 (defmacro raw-pattern-matcher
   (term args tests bindings lhses rhses pmstate)
   ;; Args should be a list of length 1 - just a pattern.
   (if (or (atom args)
           (cdr args))
       (er hard &#39;top-level ``Badly formed expression: ~~x0~~%&#39;&#39;
           (cons &#39;raw args))
     ;; match-tests-and-bindings takes a term, a case-match pattern, and a list
     ;; of tests and bindings; it returns a new version of tests and bindings
     ;; including the ones necessary to match the term to the pattern.
; Matt K. mod, 4/2024: Account for new dups argument and return value.
     (mv-let (tests bindings dups)
             (match-tests-and-bindings term (car args) tests bindings nil)
             (declare (ignore dups))
             ;; We then pass the new tests and bindings to
             ;; pattern-bindings-list.
             (pattern-bindings-list lhses rhses tests bindings pmstate))))
  })

&lt;p&gt;Also try looking at the definitions for @(&#39;bind-pattern-matcher&#39;),
@(&#39;any-pattern-matcher&#39;), and both @(&#39;force-pattern-matcher&#39;) and
@(&#39;force-match-remove-tests-pattern-matcher&#39;) as further nonstandard
examples.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-27" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-pattern-match-constructor" data-sym="DEF-PATTERN-MATCH-CONSTRUCTOR" title="(defmacro def-pattern-match-constructor (&amp;rest args)
  (let* ((term
          (if (consp (car args))
              (caar args)
              nil))
...">def-pattern-match-constructor</a> cons consp (car cdr))</pre>
  </div>

<div class="form-block function" id="def-list-of-nths" data-defines="LIST-OF-NTHS" data-references="NTH,QUASIQUOTE,=,IF,TERM,LEN,N,DEFUN" data-used-by="LIST-PATTERN-MATCHER" data-part-name="LIST-OF-NTHS" data-part-args="TERM,LEN,N" data-part-body="NTH,QUASIQUOTE,LEN,N,=,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIST-OF-NTHS">list-of-nths</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-list-of-nths" data-sym="LIST-OF-NTHS" title="(defun list-of-nths (n len term)
  (if (= n len)
      nil
      `((nth ,n ,term) ,@(list-of-nths (1+ n) len term))))">list-of-nths</a>
  (n <a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> term)
  (if (<a class="sym-link system" href="../../axioms.html#def-_3D" data-sym="=">=</a> n <a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a>)
    nil
    `((<a class="sym-link system" href="../../axioms.html#def-nth" data-sym="NTH">nth</a> ,N ,TERM) ,@(LIST-OF-NTHS (1+ N) LEN TERM))))</pre>
  </div>

<div class="form-block macro" id="def-list-pattern-matcher" data-defines="LIST-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,LEN,=,QUASIQUOTE,LENGTH,LIST-OF-NTHS,APPEND,LET,LIST,CONS,TOP-LEVEL,QUOTE,HARD,ER,TRUE-LISTP,NOT,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIST-PATTERN-MATCHER">list-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-list-pattern-matcher" data-sym="LIST-PATTERN-MATCHER" title="(defmacro list-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (not (true-listp args))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;list args))
      (let ((rhses (append (list-of-nths 0 (length args) term) rhses))
            (lhses (append args lhses))
...">list-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons '<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (let ((rhses (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-list-of-nths" data-sym="LIST-OF-NTHS" title="(defun list-of-nths (n len term)
  (if (= n len)
      nil
      `((nth ,n ,term) ,@(list-of-nths (1+ n) len term))))">list-of-nths</a> <span class="number">0</span> (<a class="sym-link system" href="../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) term) rhses)) (lhses (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> lhses))
        (tests (<a class="sym-link system" href="../../axioms.html#def-append" data-sym="APPEND">append</a> `((<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> ,TERM) (<a class="sym-link system" href="../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> ,TERM) ,(LENGTH ARGS)))
            tests)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block macro" id="def-list_2A-pattern-matcher" data-defines="LIST*-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,LIST*-MACRO,LET,LIST*,CONS,TOP-LEVEL,QUOTE,HARD,ER,TRUE-LISTP,NOT,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIST*-PATTERN-MATCHER">list*-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-list_2A-pattern-matcher" data-sym="LIST*-PATTERN-MATCHER" title="(defmacro list*-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (not (true-listp args))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;list* args))
      (let ((rhses (cons term rhses)) (lhses (cons (list*-macro args) lhses)))
        (pattern-bindings-list lhses rhses tests bindings pmstate))))">list*-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons '<a class="sym-link system" href="../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (let ((rhses (cons term rhses)) (lhses (cons (<a class="sym-link system" href="../../axioms.html#def-list_2A-macro" data-sym="LIST*-MACRO">list*-macro</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) lhses)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block macro" id="def-raw-pattern-matcher" data-defines="RAW-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,IGNORE,DECLARE,CAR,MATCH-TESTS-AND-BINDINGS,DUPS,MV-LET,RAW,CONS,TOP-LEVEL,QUOTE,HARD,ER,CDR,ATOM,OR,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="RAW-PATTERN-MATCHER">raw-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-raw-pattern-matcher" data-sym="RAW-PATTERN-MATCHER" title="(defmacro raw-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (or (atom args) (cdr args))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;raw args))
      (mv-let (tests bindings dups)
              (match-tests-and-bindings term (car args) tests bindings nil)
...">raw-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) (cdr <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons 'raw <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (tests bindings dups)
      (<a class="sym-link system" href="../../basis-a.html#def-match-tests-and-bindings" data-sym="MATCH-TESTS-AND-BINDINGS">match-tests-and-bindings</a> term
        (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
        tests
        bindings
        nil)
      (declare (ignore dups))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block macro" id="def-bind-pattern-matcher" data-defines="BIND-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,LIST,CADR,LET,BIND,CONS,TOP-LEVEL,QUOTE,HARD,ER,CAR,SYMBOLP,LEN,EQUAL,TRUE-LISTP,AND,NOT,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BIND-PATTERN-MATCHER">bind-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-bind-pattern-matcher" data-sym="BIND-PATTERN-MATCHER" title="(defmacro bind-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (not (and (true-listp args) (equal (len args) 2) (symbolp (car args))))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;bind args))
      (let ((rhses (cons term rhses))
            (lhses (cons (cadr args) lhses))
...">bind-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
        (equal (<a class="sym-link system" href="../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">2</span>)
        (symbolp (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons 'bind <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (let ((rhses (cons term rhses)) (lhses (cons (<a class="sym-link system" href="../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) lhses))
        (bindings (cons (<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) term) bindings)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block function" id="def-equal-any-list" data-defines="EQUAL-ANY-LIST" data-references="CDR,EQUAL,QUASIQUOTE,CONS,ENDP,IF,ARGS,TERM,DEFUN" data-part-name="EQUAL-ANY-LIST" data-part-args="ARGS,TERM" data-part-body="CDR,TERM,EQUAL-ANY-LIST,EQUAL,QUASIQUOTE,CONS,ARGS,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-ANY-LIST">equal-any-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-equal-any-list" data-sym="EQUAL-ANY-LIST" title="(defun equal-any-list (term args)
  (if (endp args)
      nil
      (cons `(equal ,term ,(car args)) (equal-any-list term (cdr args)))))">equal-any-list</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (if (<a class="sym-link system" href="../../axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)
    nil
    (cons `(equal ,TERM ,(CAR ARGS))
      (<a class="sym-link local-def" href="#def-equal-any-list" data-sym="EQUAL-ANY-LIST" title="(defun equal-any-list (term args)
  (if (endp args)
      nil
      (cons `(equal ,term ,(car args)) (equal-any-list term (cdr args)))))">equal-any-list</a> term (cdr <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>)))))</pre>
  </div>

<div class="form-block macro" id="def-any-pattern-matcher" data-defines="ANY-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,OR,QUASIQUOTE,LET,ANY,CONS,TOP-LEVEL,QUOTE,HARD,ER,TRUE-LISTP,NOT,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANY-PATTERN-MATCHER">any-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-any-pattern-matcher" data-sym="ANY-PATTERN-MATCHER" title="(defmacro any-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (not (true-listp args))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;any args))
      (let ((tests (cons `(or ,@(equal-any-list term args)) tests)))
        (pattern-bindings-list lhses rhses tests bindings pmstate))))">any-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons 'any <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (let ((tests (cons `(<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> ,@(EQUAL-ANY-LIST TERM ARGS)) tests)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block other" id="form-35" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-pattern-match-constructor" data-sym="DEF-PATTERN-MATCH-CONSTRUCTOR" title="(defmacro def-pattern-match-constructor (&amp;rest args)
  (let* ((term
          (if (consp (car args))
              (caar args)
              nil))
...">def-pattern-match-constructor</a> (x)
  <a class="sym-link system" href="../../axioms.html#def-acons" data-sym="ACONS">acons</a>
  (<a class="sym-link system" href="../../axioms.html#def-and" data-sym="AND">and</a> (consp x) (consp (car x)))
  (<a class="sym-link system" href="../../axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="../../axioms.html#def-cdar" data-sym="CDAR">cdar</a> cdr))</pre>
  </div>

<div class="form-block macro" id="def-force-pattern-matcher" data-defines="FORCE-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,FORCE-MATCH-REMOVE-TESTS,CAR,LET,LIST,CONS,TOP-LEVEL,QUOTE,HARD,ER,TRUE-LISTP,NOT,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORCE-PATTERN-MATCHER">force-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-force-pattern-matcher" data-sym="FORCE-PATTERN-MATCHER" title="(defmacro force-pattern-matcher (term args tests bindings lhses rhses pmstate)
  (if (not (true-listp args))
      (er hard &#39;top-level &quot;Badly formed expression: ~x0~%&quot; (cons &#39;list args))
      (let ((lhses (cons (car args) (cons &#39;(force-match-remove-tests) lhses)))
            (rhses (cons term (cons &#39;(force-match-remove-tests) rhses)))
...">force-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Badly formed expression: ~x0~%"</span>
      (cons '<a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (let ((lhses (cons (car <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a>) (cons '(force-match-remove-tests) lhses))) (rhses (cons term (cons '(force-match-remove-tests) rhses)))
        (tests (cons '(nil . force-match-remove-tests) tests)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>

<div class="form-block function" id="def-remove-up-to" data-defines="REMOVE-UP-TO" data-references="CDR,CAR,EQUAL,ATOM,IF,LIST,ITEM,DEFUN" data-used-by="FORCE-MATCH-REMOVE-TESTS-PATTERN-MATCHER" data-part-name="REMOVE-UP-TO" data-part-args="LIST,ITEM" data-part-body="REMOVE-UP-TO,CDR,ITEM,CAR,EQUAL,LIST,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-UP-TO">remove-up-to</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-up-to" data-sym="REMOVE-UP-TO" title="(defun remove-up-to (item list)
  (if (atom list)
      nil
      (if (equal (car list) item)
          (cdr list)">remove-up-to</a>
  (item <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
  (if (<a class="sym-link system" href="../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
    nil
    (if (equal (car <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>) item)
      (cdr <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)
      (<a class="sym-link local-def" href="#def-remove-up-to" data-sym="REMOVE-UP-TO" title="(defun remove-up-to (item list)
  (if (atom list)
      nil
      (if (equal (car list) item)
          (cdr list)">remove-up-to</a> item (cdr <a class="sym-link system" href="../../axioms.html#def-list" data-sym="LIST">list</a>)))))</pre>
  </div>

<div class="form-block macro" id="def-force-match-remove-tests-pattern-matcher" data-defines="FORCE-MATCH-REMOVE-TESTS-PATTERN-MATCHER" data-references="PATTERN-BINDINGS-LIST,REMOVE-UP-TO,LET,TOP-LEVEL,HARD,ER,FORCE-MATCH-REMOVE-TESTS,QUOTE,EQUAL,NOT,OR,IF,PMSTATE,RHSES,LHSES,BINDINGS,TESTS,ARGS,TERM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORCE-MATCH-REMOVE-TESTS-PATTERN-MATCHER">force-match-remove-tests-pattern-matcher</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-force-match-remove-tests-pattern-matcher" data-sym="FORCE-MATCH-REMOVE-TESTS-PATTERN-MATCHER" title="(defmacro force-match-remove-tests-pattern-matcher
          (term args tests bindings lhses rhses pmstate)
  (if (or args (not (equal term &#39;(force-match-remove-tests))))
      (er hard &#39;top-level &quot;Don&#39;t use force-match-remove-tests manually!~%&quot;)
      (let ((tests (remove-up-to &#39;(nil . force-match-remove-tests) tests)))">force-match-remove-tests-pattern-matcher</a>
  (term <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> tests bindings lhses rhses pmstate)
  (if (<a class="sym-link system" href="../../axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="../../defuns.html#def-args" data-sym="ARGS">args</a> (<a class="sym-link system" href="../../axioms.html#def-not" data-sym="NOT">not</a> (equal term '(force-match-remove-tests))))
    (<a class="sym-link system" href="../../axioms.html#def-er" data-sym="ER">er</a> hard
      'top-level
      <span class="string">"Don&#39;t use force-match-remove-tests manually!~%"</span>)
    (let ((tests (<a class="sym-link local-def" href="#def-remove-up-to" data-sym="REMOVE-UP-TO" title="(defun remove-up-to (item list)
  (if (atom list)
      nil
      (if (equal (car list) item)
          (cdr list)">remove-up-to</a> '(nil . force-match-remove-tests) tests)))
      (<a class="sym-link local-def" href="#def-pattern-bindings-list" data-sym="PATTERN-BINDINGS-LIST" title="(defun pattern-bindings-list (lhses rhses tests bindings pmstate)
  (if (or (atom lhses) (atom rhses))
      (let* ((tests-declare (nth 0 pmstate))
             (final-tests (nth 1 pmstate))
             (declare (nth 2 pmstate))
...">pattern-bindings-list</a> lhses rhses tests bindings pmstate))))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>