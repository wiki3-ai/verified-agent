<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>bstar - ACL2 Book</title>
  <meta property="name" content="bstar">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">bstar</h1>
    <div class="path"><a href="bstar.lisp" class="source-link">books/std/util/bstar</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../../xdoc/base.html" title="xdoc/base">base</a>
      <a class="include-link" href="../../xdoc/full-escape-symbol.html" title="xdoc/full-escape-symbol">full-escape-symbol</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/base.html" title="Open xdoc/base">"xdoc/base"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/full-escape-symbol.html" title="Open xdoc/full-escape-symbol">"xdoc/full-escape-symbol"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../../xdoc/base.html#def-defxdoc" data-sym="DEFXDOC">defxdoc</a> <a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
  <span class="keyword">:parents</span> (macro-libraries)
  <span class="keyword">:short</span> <span class="string">"The @(&#39;b*&#39;) macro is a replacement for @(see let*) that adds support
for multiple return values, mixing control flow with binding, causing side
effects, introducing type declarations, and doing other kinds of custom pattern
matching."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;To use @(&#39;b*&#39;) you will need to load the following book:&lt;/p&gt;

@({
    (include-book &quot;std/util/bstar&quot; :dir :system)
})

&lt;p&gt;In its most basic form, the @(&#39;b*&#39;) macro is nearly a drop-in replacement
for @(see let*).  For instance, these are equivalent:&lt;/p&gt;

@({
    (let* ((x 1)               (b* ((x 1)
           (y 2)          ==        (y 2)
           (z (+ x y)))             (z (+ x y)))
      (list x y z))              (list x y z))
})

&lt;p&gt;But beyond simple variable bindings, @(&#39;b*&#39;) provides many useful, extended
@(see b*-binders).  A simple example is the &lt;see topic=&#39;@(url patbind-mv)&#39;&gt;mv
binder&lt;/see&gt;, which can nicely avoid switching between @(see let*) and @(see
mv-let).  For instance:&lt;/p&gt;

@({
   (let* ((parts (get-parts args)))            (b* ((parts (get-parts args))
     (mv-let (good bad)                   ==       ((mv good bad) (split-parts parts))
       (split-parts parts)                         (new-good (mark-good good))
       (let* ((new-good (mark-good good))          (new-bad  (mark-bad bad)))
              (new-bad  (mark-bad bad)))         (append new-good new-bad))
         (append new-good new-bad))))
})

&lt;p&gt;Another example is the &lt;see topic=&#39;@(url patbind-when)&#39;&gt;when
binder&lt;/see&gt;, which allows for a sort of &quot;early exit&quot; from the @(&#39;b*&#39;) form
without needing to alternate between @(&#39;let*&#39;) and @(&#39;if&#39;).  For instance:&lt;/p&gt;

@({
  (let* ((sum (get-sum (car x))))       (b* ((sum (get-sum (car x)))
    (if (&lt; sum limit)               ==       ((when (&lt; sum limit))
        ans                                   ans)
      (let* ((ans   (+ ans sum))             (ans   (+ ans sum))
             (limit (+ limit 1)))            (limit (+ limit 1)))
        (fn (cdr x) ans limit))))         (fn (cdr x) ans limit))
})

&lt;p&gt;The only part of the @(&#39;let*&#39;) syntax that is not available in @(&#39;b*&#39;) is
the @(see declare) syntax.  However, @(&#39;ignore&#39;)/@(&#39;ignorable&#39;) declarations
are available using a different syntax (see below), and @(see type-spec)
declarations are available using the &lt;see topic=&#39;@(url patbind-the)&#39;&gt;the
binder.&lt;/see&gt;&lt;/p&gt;


&lt;h3&gt;General Form&lt;/h3&gt;

&lt;p&gt;The general syntax of b* is:&lt;/p&gt;

@({
     (b* &lt;list-of-bindings&gt; . &lt;list-of-result-forms&gt;)
})

&lt;p&gt;where a &lt;i&gt;result form&lt;/i&gt; is any ACL2 term, and a &lt;i&gt;binding&lt;/i&gt; is&lt;/p&gt;

@({
     (&lt;binder-form&gt; [&lt;expression&gt;])
})

&lt;p&gt;Depending on the binder form, it may be that multiple expressions are
allowed or only a single one.&lt;/p&gt;

&lt;p&gt;The @(&#39;std/util/bstar&#39;) book comes with several useful b* binders already
defined, which we describe below.  You can also define your own, custom binder
forms to extend the syntax of @(&#39;b*&#39;) to provide additional kinds of pattern
matching or to implement common coding patterns.  For example, the @(see
std::defaggregate) macro automatically introduces new @(&#39;b*&#39;) binders that let
you access the fields of structures using a C-like @(&#39;employee.name&#39;) style
syntax.&lt;/p&gt;

&lt;p&gt;Note: One difference between @(&#39;let*&#39;) and @(&#39;b*&#39;) is that @(&#39;b*&#39;) allows
multiple forms to occur in the body, and returns the value of the last form.
For example:&lt;/p&gt;

@({
    (b* ((x 1)
         (y 2)
         (z (+ x y)))
      (cw &quot;Hello, &quot;)
      (cw &quot; world!~%&quot;)
      (list x y z))
})

&lt;p&gt;Will print @(&#39;Hello, world!&#39;) before returning @(&#39;(1 2 3)&#39;), whereas putting
these @(see cw) statements into a @(see let*) form would be a syntax error.&lt;/p&gt;


&lt;h3&gt;Built-In B* Binders&lt;/h3&gt;

&lt;p&gt;Here is a nonsensical example that gives a flavor for the kind of b* binders
that are available &quot;out of the box.&quot;&lt;/p&gt;

@({
 (b* ( ;; don&#39;t forget the first open paren! (like with let*)

      ;; let*-like binding to a single variable:
      (x (cons &#39;a &#39;b))

      ;; mv binding
      ((mv y z) (return-two-values x x))

      ;; No binding: expression evaluated for side effects
      (- (cw &quot;Hello&quot;)) ;; prints &quot;Hello&quot;

      ;; Binding with type declaration:
      ((the (integer 0 100) n) (foo z))

      ;; MV which ignores a value:
      ((mv &amp; a) (return-garbage-in-first-mv y z))

      ;; Binds value 0 to C and value 1 to D,
      ;; declares (ignorable C) and (ignore D)
      ((mv ?c ?!d) (another-mv a z))

      ;; Bind V to the middle value of an error triple,
      ;; quitting if there is an error condition (a la er-let*)
      ((er v) (trans-eval &#39;(len (list &#39;a 1 2 3)) &#39;foo state))

      ;; The WHEN, IF, and UNLESS constructs insert an IF in the
      ;; binding stream.  WHEN and IF are equivalent.
      ((when v) (finish-early-because-of v))
      ((if v)   (finish-early-because-of v))
      ((unless c) (finish-early-unless c))

      ;; Pattern-based binding using cons, where D is ignorable
      ((cons (cons b c) ?d) (must-return-nested-conses a))

      ;; Patterns based on LIST and LIST* are also supported:
      ((list a b) &#39;((1 2) (3 4)))
      ((list* a (the string b) c) &#39;((1 2) &quot;foo&quot; 5 6 7))

      ;; Alternate form of pattern binding with cons nests, where G is
      ;; ignored and F has a type declaration:
      (`(,e (,(the (signed-byte 8) f) . ,?!g))
       (makes-a-list-of-conses b))

      ;; Pattern with user-defined constructor:
      ((my-tuple foo bar hum) (something-of-type-my-tuple e c g))

      ;; Don&#39;t-cares with pattern bindings:
      ((my-tuple &amp; (cons carbar &amp;) hum) (something-else foo f hum))

      ;; Pattern inside an mv:
      ((mv a (cons &amp; c)) (make-mv-with-cons))

      ) ;; also don&#39;t forget the close-paren after the binder list

   ;; the body (after the binder list) is an implicit PROGN$
   (run-this-for-side-effects ...)
   (return-this-expression .....))
})

&lt;p&gt;Note: The built-in binders are all defined in the ACL2 package, and can be
used (without package prefix) in any other package that imports the binder
symbol, or with the @(&#39;acl2::&#39;) packge prefix anywhere. See also the note about
packages under user-defined binders below.&lt;/p&gt;

&lt;p&gt;We now give some additional details about these built-in binders.  Since
users can also define their own @(&#39;b*&#39;) binders, you may wish to see @(see
b*-binders) for a more comprehensive list of available binder forms.&lt;/p&gt;

&lt;dl&gt;

&lt;dt&gt;@(&#39;(mv a b ...)&#39;)&lt;/dt&gt;
&lt;dd&gt;Produces an @(see mv-let) binding.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(cons a b)&#39;)&lt;/dt&gt;
&lt;dd&gt;Binds @(&#39;a&#39;) and @(&#39;b&#39;) to @(&#39;(car val)&#39;) and @(&#39;(cdr val)&#39;), respectively,
where @(&#39;val&#39;) is the result of the corresponding expression.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(er a)&#39;)&lt;/dt&gt;
&lt;dd&gt;Produces an ER-LET* binding.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(list a b ...)&#39;)&lt;/dt&gt;
&lt;dd&gt;Binds @(&#39;a&#39;), @(&#39;b&#39;), ... to @(&#39;(car val)&#39;), @(&#39;(cadr val)&#39;), etc., where
@(&#39;val&#39;) is the result of the corresponding expression.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(nths a b ...)&#39;)&lt;/dt&gt;
&lt;dd&gt;Binds @(&#39;a&#39;), @(&#39;b&#39;), ... to @(&#39;(nth 0 val)&#39;), @(&#39;(nth 1 val)&#39;), etc.,
where @(&#39;val&#39;) is the result of the corresponding expression.  This is very
much like @(&#39;list&#39;), but may be useful when @(see nth) is disabled.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(list* a b)&#39;)&lt;br/&gt;
    @(&#39;`(,a . ,b)&#39;)&lt;/dt&gt;
&lt;dd&gt;Alternatives to the @(&#39;cons&#39;) binder.&lt;/dd&gt;

&lt;dt&gt;@(&#39;(the type-spec var)&#39;)&lt;/dt&gt;
&lt;dd&gt;Binds @(&#39;var&#39;) to the result of the corresponding expression, and adds
a @(see declare) form saying that @(&#39;var&#39;) is of the given @(see type-spec).
You can nest @(&#39;the&#39;) patterns inside other patterns, but @(&#39;var&#39;) must itself
be a symbol instead of a nested pattern, and @(&#39;type-spec&#39;) must be a valid
@(see type-spec).&lt;/dd&gt;

&lt;dt&gt;@(&#39;(if test)&#39;)&lt;br/&gt;
@(&#39;(when test)&#39;)&lt;br/&gt;
@(&#39;(unless test)&#39;)&lt;/dt&gt;

&lt;dd&gt;These forms don&#39;t actually produce bindings at all.  Instead, they insert
an @(see if) where one branch is the rest of the @(&#39;B*&#39;) form and the other is
the &quot;bound&quot; expression.  For example,
@({
    (b* (((if (atom a)) 0)
         (rest (of-bindings)))
      final-expr)
})
expands to something like this:
@({
    (if (atom a)
        0
      (b* ((rest (of-bindings)))
        final-expr))
})
These forms can also create an &quot;implicit progn&quot; with multiple expressions,
like this:
@({
   (b* (((if (atom a))
         (cw &quot;a is an atom, returning 0&quot;)
         0)
        ...)
     ...)
})
&lt;/dd&gt;

&lt;/dl&gt;


&lt;p&gt;Note that the @(&#39;cons&#39;), @(&#39;list&#39;), @(&#39;list*&#39;), and backtick binders may be
nested arbitrarily inside other binders.  User-defined binders may often be
arbitrarily nested.  For example,&lt;/p&gt;

@({
     ((mv (list `(,a . ,b)) (cons c d)) &lt;form&gt;)
})

&lt;p&gt;will result in the following (logical) bindings:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@(&#39;a&#39;) bound to @(&#39;(car (nth 0 (mv-nth 0 &lt;form&gt;)))&#39;)&lt;/li&gt;
&lt;li&gt;@(&#39;b&#39;) bound to @(&#39;(cdr (nth 0 (mv-nth 0 &lt;form&gt;)))&#39;)&lt;/li&gt;
&lt;li&gt;@(&#39;c&#39;) bound to @(&#39;(car (mv-nth 1 &lt;form&gt;))&#39;)&lt;/li&gt;
&lt;li&gt;@(&#39;d&#39;) bound to @(&#39;(cdr (mv-nth 1 &lt;form&gt;))&#39;)&lt;/li&gt;
&lt;/ul&gt;



&lt;h3&gt;Side Effects and Ignoring Variables&lt;/h3&gt;

&lt;p&gt;The following constructs may be used in place of variables&lt;/p&gt;

&lt;table&gt;

&lt;tr&gt;
&lt;th&gt;@(&#39;-&#39;)&lt;/th&gt;
&lt;td&gt;Dash (@(&#39;-&#39;)), used as a top-level binding form, will run the corresponding
expressions (in an implicit progn) for side-effects without binding its value.
Used as a lower-level binding form, it will cause the binding to be ignored or
not created.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;th&gt;@(&#39;&amp;&#39;)&lt;/th&gt;
&lt;td&gt;Ampersand (@(&#39;&amp;&#39;)), used as a top-level binding form, will cause the
corresponding expression to be ignored and not run at all.  Used as a
lower-level binding form, it will cause the binding to be ignored or not
created.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;th&gt;@(&#39;?!&#39;)&lt;/th&gt;
&lt;td&gt;Any symbol beginning with @(&#39;?!&#39;) works similarly to the @(&#39;&amp;&#39;) form.  It
is @(see declare)d ignored or not evaluated at all.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;th&gt;@(&#39;?&#39;)&lt;/th&gt;
&lt;td&gt;Any symbol beginning with @(&#39;?&#39;) but not @(&#39;?!&#39;) will make a binding of the symbol
obtained by removing the @(&#39;?&#39;), and will make an @(&#39;ignorable&#39;) declaration for this
variable.&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;


&lt;h3&gt;User-Defined Binders&lt;/h3&gt;

&lt;p&gt;B* expands to multiple nestings of another macro, @(&#39;PATBIND&#39;), analogously
to how LET* expands to multiple nestings of LET.&lt;/p&gt;

&lt;p&gt;New b* binders may be created by defining a macro named @(&#39;PATBIND-&lt;name&gt;&#39;).
We discuss the detailed interface of user-defined binders below.  But first,
note that @(&#39;def-patbind-macro&#39;) provides a simple way to define certain user binders.
For example, this form is used to define the binder for CONS:&lt;/p&gt;

@({
    (def-patbind-macro cons (car cdr))
})

&lt;p&gt;This defines a binder macro, @(&#39;patbind-cons&#39;), which enables @(&#39;(cons a
b)&#39;) to be used as a binder form.  This binder form must take two arguments
since two destructor functions, @(&#39;(car cdr)&#39;), are given to
@(&#39;def-patbind-macro&#39;).  The destructor functions are each applied to the form
to produce the bindings for the corresponding arguments of the binder.&lt;/p&gt;

&lt;p&gt;There are many cases in which @(&#39;def-patbind-macro&#39;) is not powerful enough.
For example, a binder produced by @(&#39;def-patbind-macro&#39;) may only take a fixed
number of arguments.  More flexible operations may be defined by hand-defining
the binder macro using the form @(see def-b*-binder).&lt;/p&gt;

&lt;p&gt;A binder macro, @(&#39;patbind-&lt;name&gt;&#39;) must take three arguments: @(&#39;args&#39;),
@(&#39;forms&#39;), and @(&#39;rest-expr&#39;).  The form&lt;/p&gt;

@({
    (b* (((foo arg1 arg2) binding1 binding2))
      expr)
})

&lt;p&gt;translates to a macro call&lt;/p&gt;

@({
     (patbind-foo (arg1 arg2) (binding1 binding2) expr)
})

&lt;p&gt;That is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@(&#39;args&#39;) is the list of arguments given to the binder form,&lt;/li&gt;
&lt;li&gt;@(&#39;bindings&#39;) is the list of expressions bound to them, and&lt;/li&gt;
&lt;li&gt;@(&#39;expr&#39;) is the result expression to be run once the bindings are in place.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The definition of the @(&#39;patbind-foo&#39;) macro determines how this gets
further expanded.  Some informative examples of these binder macros may be
found in @(&#39;std/util/bstar.lisp&#39;); simply search for uses of @(see
def-b*-binder).&lt;/p&gt;

&lt;p&gt;Here are some further notes on defining binder macros.&lt;/p&gt;

&lt;p&gt;Interaction with packages: The macro @(&#39;patbind-foo&#39;) is derived from a use
of the @(&#39;foo&#39;) binder using @(&#39;intern-in-package-of-symbol&#39;) with @(&#39;foo&#39;) as
the package witness.  Practially speaking, this means that you can use a binder
from a different package (without any package prefix) if either the binder name
@(&#39;foo&#39;) or the macro @(&#39;patbind-foo&#39;) is imported into your package.
Additionally, if @(&#39;foo&#39;) was defined as a binder in the @(&#39;bar&#39;) package and
not imported into your current package, it can still be invoked as
@(&#39;bar::foo&#39;).  Note also that when defining a binder using @(&#39;def-b*-binder&#39;),
the @(&#39;args&#39;), @(&#39;forms&#39;), and @(&#39;rest-expr&#39;) formals are always in the ACL2
package.&lt;/p&gt;

&lt;p&gt;Often the simplest way to accomplish the intended effect of a patbind macro
is to have it construct another @(&#39;b*&#39;) form to be recursively expanded, or to
call other patbind macros.  See, for example, the definition of
@(&#39;patbind-list&#39;).&lt;/p&gt;

&lt;p&gt;Patbind macros for forms that are truly creating bindings should indeed use
@(&#39;b*&#39;) (or @(&#39;patbind&#39;), which is what @(&#39;b*&#39;) expands to) to create these
bindings, so that ignores and nestings are dealt with uniformly.  See, for
example, the definition of @(&#39;patbind-nths&#39;).&lt;/p&gt;

&lt;p&gt;In order to get good performance, destructuring binders such as are produced
by @(&#39;def-patbind-macro&#39;) bind a variable to any binding that isn&#39;t already a
variable or quoted constant.  This is important so that in the following form,
@(&#39;(foo x y)&#39;) is run only once:&lt;/p&gt;

@({
    (b* (((cons a b) (foo x y))) ...)
})

&lt;p&gt;In these cases, it is good discipline to check the new variables introduced
using the macro @(&#39;check-vars-not-free&#39;); since ACL2 does not have gensym, this
is the best option we have. See any definition produced by
@(&#39;def-patbind-macro&#39;) for examples, and additionally @(&#39;patbind-nths&#39;),
@(&#39;patbind-er&#39;), and so forth.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../../xdoc/base.html#def-defxdoc" data-sym="DEFXDOC">defxdoc</a> b*-binders
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>)
  <span class="keyword">:short</span> <span class="string">"List of the available directives usable in @(&#39;b*&#39;)"</span>)</pre>
  </div>

<div class="form-block local" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> character-listp-of-explode-nonnegative-integer
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> acc)
      (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link system" href="../../../axioms.html#def-explode-nonnegative-integer" data-sym="EXPLODE-NONNEGATIVE-INTEGER">explode-nonnegative-integer</a> n <span class="number">10</span> acc)))))</pre>
  </div>

<div class="form-block local" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> character-listp-of-explode-atom
    (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link system" href="../../../axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> x <span class="number">10</span>))))</pre>
  </div>

<div class="form-block local" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> character-listp-of-append
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> x) (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> y))
      (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> x y)))))</pre>
  </div>

<div class="form-block local" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">local</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> character-listp-of-make-character-list
    (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link system" href="../../../axioms.html#def-make-character-list" data-sym="MAKE-CHARACTER-LIST">make-character-list</a> x))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-pack-list" data-defines="PACK-LIST" data-references="LIST,QUOTE,EXPLODE-ATOM,SYMBOLP,STRINGP,CHARACTERP,ACL2-NUMBERP,OR,IF,TREE,CONS,APPEND,CAR,PACK-TREE,CDR,ATOM,COND,T,ACL2-COUNT,XARGS,DECLARE,ARGS,DEFUN,MUTUAL-RECURSION" data-used-by="PACK-TERM,CHARACTER-LISTP-OF-PACK-LIST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PACK-LIST">pack-list</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a>
    (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (declare (xargs <span class="keyword">:measure</span> (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (pack-tree (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (pack-tree (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
          (cons #\  (<a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> pack-tree
    (tree)
    (declare (xargs <span class="keyword">:measure</span> (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> tree) <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
    (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> tree)
      (if (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (acl2-numberp tree)
          (characterp tree)
          (stringp tree)
          (symbolp tree))
        (<a class="sym-link system" href="../../../axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> tree <span class="number">10</span>)
        '(#\ ))
      (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (cons #\( (pack-tree (car tree)))
        (cons #\  (<a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a> (cdr tree)))
        (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> #\))))))</pre>
  </div>

<div class="form-block encapsulate" id="def-character-listp-of-pack-list" data-defines="CHARACTER-LISTP-OF-PACK-LIST" data-references="CHARACTER-LISTP-OF-PACK-TREE,PACK-TREE,PACK-LIST,CHARACTER-LISTP,LEMMA,DEFTHM,T,CAR,TREE,CDR,ATOM,COND,LIST,QUOTE,EQUAL,IF,X,FLAG,MY-INDUCT,DEFUN,LOCAL,ENCAPSULATE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHARACTER-LISTP-OF-PACK-LIST">character-listp-of-pack-list</span><span class="form-type">encapsulate</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> my-induct
      (flag x)
      (if (equal flag '<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a>)
        (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x) nil)
          ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr x)) (my-induct 'tree (car x)))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (my-induct 'tree (car x)) (my-induct '<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cdr x)))))
        (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
          nil
          (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (my-induct 'tree (car x)) (my-induct '<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cdr x)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma
      (if (equal flag '<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a>)
        (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a> x))
        (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (pack-tree x)))
      <span class="keyword">:rule-classes</span> nil
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:induct</span> (my-induct flag x)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> <a class="sym-link local-def" href="#def-character-listp-of-pack-list" data-sym="CHARACTER-LISTP-OF-PACK-LIST" title="(encapsulate nil
             (local
              (defun my-induct (flag x)
                (if (equal flag &#39;list)
                    (cond ((atom x) nil)
...">character-listp-of-pack-list</a>
    (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (<a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a> x))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:use</span> ((<span class="keyword">:instance</span> lemma (flag '<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a>))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> character-listp-of-pack-tree
    (<a class="sym-link system" href="../../../axioms.html#def-character-listp" data-sym="CHARACTER-LISTP">character-listp</a> (pack-tree x))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:use</span> ((<span class="keyword">:instance</span> lemma (flag 'tree)))))))</pre>
  </div>

<div class="form-block function" id="def-pack-term" data-defines="PACK-TERM" data-references="STRING,QUOTE,PACK-LIST,COERCE,INTERN,T,XARGS,DECLARE,ARGS,DEFUN" data-used-by="PACK" data-part-name="PACK-TERM" data-part-args="ARGS" data-part-declare="T,XARGS,DECLARE" data-part-body="STRING,QUOTE,ARGS,PACK-LIST,COERCE,INTERN" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PACK-TERM">pack-term</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pack-term" data-sym="PACK-TERM" title="(defun pack-term (args)
  (declare (xargs :guard t))
  (intern (coerce (pack-list args) &#39;string) &quot;ACL2&quot;))">pack-term</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="../../../axioms.html#def-intern" data-sym="INTERN">intern</a> (coerce (<a class="sym-link local-def" href="#def-pack-list" data-sym="PACK-LIST" title="(mutual-recursion
 (defun pack-list (args)
   (declare (xargs :measure (acl2-count args) :guard t))
   (cond ((atom args) nil) ((atom (cdr args)) (pack-tree (car args)))
         (t
...">pack-list</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>) <span class="string">"ACL2"</span>))</pre>
  </div>

<div class="form-block macro" id="def-pack" data-defines="PACK" data-references="LIST,PACK-TERM,QUASIQUOTE,ARGS,&REST,DEFMACRO" data-used-by="VAR-IGNORE-LIST-FOR-PATBIND-MV,DEF-PATBIND-MACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PACK">pack</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pack" data-sym="PACK" title="(defmacro pack (&amp;rest args) `(pack-term (list ,@args)))">pack</a> (&amp;rest <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) `(<a class="sym-link local-def" href="#def-pack-term" data-sym="PACK-TERM" title="(defun pack-term (args)
  (declare (xargs :guard t))
  (intern (coerce (pack-list args) &#39;string) &quot;ACL2&quot;))">pack-term</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> ,@ARGS)))</pre>
  </div>

<div class="form-block function" id="def-macro-name-for-patbind" data-defines="MACRO-NAME-FOR-PATBIND" data-references="FOO,SYMBOL-PACKAGE-NAME,EQUAL,IF,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL,SYMBOLP,XARGS,DECLARE,BINDER,DEFUN" data-used-by="DEF-B*-BINDER,PATBINDFN" data-part-name="MACRO-NAME-FOR-PATBIND" data-part-args="BINDER" data-part-declare="BINDER,SYMBOLP,XARGS,DECLARE" data-part-body="FOO,SYMBOL-PACKAGE-NAME,EQUAL,IF,BINDER,SYMBOL-NAME,STRING,QUOTE,CONCATENATE,INTERN-IN-PACKAGE-OF-SYMBOL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MACRO-NAME-FOR-PATBIND">macro-name-for-patbind</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-macro-name-for-patbind" data-sym="MACRO-NAME-FOR-PATBIND" title="(defun macro-name-for-patbind (binder)
  (declare (xargs :guard (symbolp binder)))
  (intern-in-package-of-symbol
   (concatenate &#39;string &quot;PATBIND-&quot; (symbol-name binder))
   (if (equal (symbol-package-name binder) &quot;COMMON-LISP&quot;)
...">macro-name-for-patbind</a>
  (binder)
  (declare (xargs <span class="keyword">:guard</span> (symbolp binder)))
  (intern-in-package-of-symbol (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"PATBIND-"</span> (symbol-name binder))
    (if (equal (symbol-package-name binder) <span class="string">"COMMON-LISP"</span>)
      'foo
      binder)))</pre>
  </div>

<div class="form-block constant" id="def-_2Apatbind-special-syms_2A" data-defines="*PATBIND-SPECIAL-SYMS*" data-references="-,&,QUOTE,DEFCONST" data-used-by="VAR-IGNORE-LIST-FOR-PATBIND-MV" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*PATBIND-SPECIAL-SYMS*">*patbind-special-syms*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Apatbind-special-syms_2A" data-sym="*PATBIND-SPECIAL-SYMS*" title="(defconst *patbind-special-syms* &#39;(&amp; -))">*patbind-special-syms*</a> '(&amp; <a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a>))</pre>
  </div>

<div class="form-block function" id="def-int-string" data-defines="INT-STRING" data-references="STRING,QUOTE,EXPLODE-NONNEGATIVE-INTEGER,COERCE,NATP,XARGS,DECLARE,N,DEFUN" data-used-by="STR-NUM-SYM" data-part-name="INT-STRING" data-part-args="N" data-part-declare="N,NATP,XARGS,DECLARE" data-part-body="STRING,QUOTE,N,EXPLODE-NONNEGATIVE-INTEGER,COERCE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INT-STRING">int-string</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-int-string" data-sym="INT-STRING" title="(defun int-string (n)
  (declare (xargs :guard (natp n)))
  (coerce (explode-nonnegative-integer n 10 nil) &#39;string))">int-string</a>
  (n)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-natp" data-sym="NATP">natp</a> n)))
  (coerce (<a class="sym-link system" href="../../../axioms.html#def-explode-nonnegative-integer" data-sym="EXPLODE-NONNEGATIVE-INTEGER">explode-nonnegative-integer</a> n <span class="number">10</span> nil) '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>))</pre>
  </div>

<div class="form-block function" id="def-str-num-sym" data-defines="STR-NUM-SYM" data-references="INT-STRING,STRING,QUOTE,CONCATENATE,INTERN,NATP,STRINGP,AND,XARGS,DECLARE,N,STR,DEFUN" data-used-by="IGNORE-VAR-NAME" data-part-name="STR-NUM-SYM" data-part-args="N,STR" data-part-declare="N,NATP,STR,STRINGP,AND,XARGS,DECLARE" data-part-body="N,INT-STRING,STR,STRING,QUOTE,CONCATENATE,INTERN" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STR-NUM-SYM">str-num-sym</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-str-num-sym" data-sym="STR-NUM-SYM" title="(defun str-num-sym (str n)
  (declare (xargs :guard (and (stringp str) (natp n))))
  (intern (concatenate &#39;string str (int-string n)) &quot;ACL2&quot;))">str-num-sym</a>
  (str n)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (stringp str) (<a class="sym-link system" href="../../../axioms.html#def-natp" data-sym="NATP">natp</a> n))))
  (<a class="sym-link system" href="../../../axioms.html#def-intern" data-sym="INTERN">intern</a> (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a> str (<a class="sym-link local-def" href="#def-int-string" data-sym="INT-STRING" title="(defun int-string (n)
  (declare (xargs :guard (natp n)))
  (coerce (explode-nonnegative-integer n 10 nil) &#39;string))">int-string</a> n)) <span class="string">"ACL2"</span>))</pre>
  </div>

<div class="form-block function" id="def-ignore-var-name" data-defines="IGNORE-VAR-NAME" data-references="STR-NUM-SYM,NATP,XARGS,DECLARE,N,DEFUN" data-used-by="VAR-IGNORE-LIST-FOR-PATBIND-MV" data-part-name="IGNORE-VAR-NAME" data-part-args="N" data-part-declare="N,NATP,XARGS,DECLARE" data-part-body="N,STR-NUM-SYM" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IGNORE-VAR-NAME">ignore-var-name</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ignore-var-name" data-sym="IGNORE-VAR-NAME" title="(defun ignore-var-name (n)
  (declare (xargs :guard (natp n)))
  (str-num-sym &quot;IGNORE-&quot; n))">ignore-var-name</a>
  (n)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-natp" data-sym="NATP">natp</a> n)))
  (<a class="sym-link local-def" href="#def-str-num-sym" data-sym="STR-NUM-SYM" title="(defun str-num-sym (str n)
  (declare (xargs :guard (and (stringp str) (natp n))))
  (intern (concatenate &#39;string str (int-string n)) &quot;ACL2&quot;))">str-num-sym</a> <span class="string">"IGNORE-"</span> n))</pre>
  </div>

<div class="form-block function" id="def-debuggable-binder-list-p" data-defines="DEBUGGABLE-BINDER-LIST-P" data-references="CDR,CAR,CONSP,CW,EQUAL,OR,ATOM,COND,T,XARGS,DECLARE,X,DEFUN" data-part-name="DEBUGGABLE-BINDER-LIST-P" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="T,CDR,DEBUGGABLE-BINDER-LIST-P,CAR,CONSP,CW,EQUAL,OR,X,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEBUGGABLE-BINDER-LIST-P">debuggable-binder-list-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-debuggable-binder-list-p" data-sym="DEBUGGABLE-BINDER-LIST-P" title="(defun debuggable-binder-list-p (x)
  (declare (xargs :guard t))
  (cond
   ((atom x)
    (or (equal x nil)
...">debuggable-binder-list-p</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal x nil)
        (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"; Not a binder list; ends with ~x0, instead of nil.~%"</span>
          x)))
    ((consp (car x)) (<a class="sym-link local-def" href="#def-debuggable-binder-list-p" data-sym="DEBUGGABLE-BINDER-LIST-P" title="(defun debuggable-binder-list-p (x)
  (declare (xargs :guard t))
  (cond
   ((atom x)
    (or (equal x nil)
...">debuggable-binder-list-p</a> (cdr x)))
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"; Not a binder list; first bad entry is ~x0.~%"</span>
        (car x)))))</pre>
  </div>

<div class="form-block function" id="def-debuggable-binders-p" data-defines="DEBUGGABLE-BINDERS-P" data-references="CAR,CONSP,CW,EQUAL,OR,ATOM,COND,T,XARGS,DECLARE,X,DEFUN" data-used-by="B*,B*-FN" data-part-name="DEBUGGABLE-BINDERS-P" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="T,CAR,CONSP,CW,EQUAL,OR,X,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEBUGGABLE-BINDERS-P">debuggable-binders-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-debuggable-binders-p" data-sym="DEBUGGABLE-BINDERS-P" title="(defun debuggable-binders-p (x)
  (declare (xargs :guard t))
  (cond
   ((atom x)
    (or (equal x nil)
...">debuggable-binders-p</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal x nil)
        (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"; Not a binder list; ends with ~x0, instead of nil.~%"</span>
          x)))
    ((consp (car x)) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"; Not a binder list; first bad entry is ~x0.~%"</span>
        (car x)))))</pre>
  </div>

<div class="form-block function" id="def-decode-varname-for-patbind" data-defines="DECODE-VARNAME-FOR-PATBIND" data-references="MV,IGNORABLE,IGNORE,QUOTE,IGNOREP,T,SUBSEQ,INTERN-IN-PACKAGE-OF-SYMBOL,COND,SYM,?!P,CHAR,EQL,<=,AND,?P,LENGTH,LEN,SYMBOL-NAME,NAME,LET*,SYMBOLP,XARGS,DECLARE,PATTERN,DEFUN" data-used-by="ASSIGNS-FOR-ASSOCS,VAR-IGNORE-LIST-FOR-PATBIND-MV,PATBINDFN" data-part-name="DECODE-VARNAME-FOR-PATBIND" data-part-args="PATTERN" data-part-declare="PATTERN,SYMBOLP,XARGS,DECLARE" data-part-body="MV,IGNORABLE,IGNORE,QUOTE,IGNOREP,T,SUBSEQ,INTERN-IN-PACKAGE-OF-SYMBOL,COND,SYM,?!P,CHAR,EQL,<=,AND,?P,LENGTH,LEN,PATTERN,SYMBOL-NAME,NAME,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECODE-VARNAME-FOR-PATBIND">decode-varname-for-patbind</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-decode-varname-for-patbind" data-sym="DECODE-VARNAME-FOR-PATBIND" title="(defun decode-varname-for-patbind (pattern)
  (declare (xargs :guard (symbolp pattern)))
  (let* ((name (symbol-name pattern))
         (len (length name))
         (?p (and (&lt;= 1 len) (eql (char name 0) #\?)))
...">decode-varname-for-patbind</a>
  (pattern)
  (declare (xargs <span class="keyword">:guard</span> (symbolp pattern)))
  (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((name (symbol-name pattern)) (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> name))
      (?p (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">1</span> <a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a>) (<a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../../axioms.html#def-char" data-sym="CHAR">char</a> name <span class="number">0</span>) #\?)))
      (?!p (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> ?p (<a class="sym-link system" href="../../../axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">2</span> <a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a>) (<a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../../axioms.html#def-char" data-sym="CHAR">char</a> name <span class="number">1</span>) #\!)))
      (sym (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (?!p (intern-in-package-of-symbol (<a class="sym-link system" href="../../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> name <span class="number">2</span> nil) pattern))
          (?p (intern-in-package-of-symbol (<a class="sym-link system" href="../../../axioms.html#def-subseq" data-sym="SUBSEQ">subseq</a> name <span class="number">1</span> nil) pattern))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> pattern)))
      (ignorep (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (?!p 'ignore) (?p 'ignorable))))
    (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> sym ignorep)))</pre>
  </div>

<div class="form-block function" id="def-patbindfn" data-defines="PATBINDFN" data-references="ARGS,MACRO-NAME-FOR-PATBIND,PATBIND-MACRO,BINDER,LET*,CAR,LET,IGNORE,IF,DECODE-VARNAME-FOR-PATBIND,IGNOREP,SYM,MV-LET,CDR,CONSP,AND,B*,HARD?,ER,KEYWORDP,SYMBOLP,NOT,OR,ATOM,&,PROGN$,PROG2$,QUASIQUOTE,-,QUOTE,EQ,COND,T,XARGS,DECLARE,NESTED-EXPR,ASSIGN-EXPRS,PATTERN,DEFUN" data-used-by="PATBIND" data-part-name="PATBINDFN" data-part-args="NESTED-EXPR,ASSIGN-EXPRS,PATTERN" data-part-declare="T,XARGS,DECLARE" data-part-body="ARGS,MACRO-NAME-FOR-PATBIND,PATBIND-MACRO,BINDER,LET*,CAR,LET,IGNORE,IF,DECODE-VARNAME-FOR-PATBIND,IGNOREP,SYM,MV-LET,CDR,CONSP,AND,ASSIGN-EXPRS,B*,HARD?,ER,T,KEYWORDP,SYMBOLP,NOT,OR,ATOM,NESTED-EXPR,&,PROGN$,PROG2$,QUASIQUOTE,-,QUOTE,PATTERN,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATBINDFN">patbindfn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-patbindfn" data-sym="PATBINDFN" title="(defun patbindfn (pattern assign-exprs nested-expr)
  (declare (xargs :guard t))
  (cond ((eq pattern &#39;-) `(prog2$ (progn$ . ,assign-exprs) ,nested-expr))
        ((eq pattern &#39;&amp;) nested-expr)
        ((atom pattern)
...">patbindfn</a>
  (pattern assign-exprs nested-expr)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> pattern '<a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a>) `(<a class="sym-link system" href="../../../axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,ASSIGN-EXPRS) ,NESTED-EXPR))
    ((<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> pattern '&amp;) nested-expr)
    ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> pattern) (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp pattern))
           (<a class="sym-link system" href="../../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> pattern)
           (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> pattern <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
           (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> pattern nil)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
            '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
            <span class="string">"Invalid left-hand side: trying to bind ~x0 to ~x1.~%"</span>
            pattern
            assign-exprs))
        ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> assign-exprs) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
            '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
            <span class="string">"Invalid attempt to bind of ~x0 to nothing."</span>
            pattern))
        ((<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> assign-exprs) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
            '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
            <span class="string">"Invalid attempt to bind ~x0 to atom ~x1."</span>
            pattern
            assign-exprs))
        ((<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp assign-exprs) (cdr assign-exprs)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
            '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
            <span class="string">"Too many right-hand side terms: trying to bind ~x0 to ~x1.~%"</span>
            pattern
            assign-exprs))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (sym ignorep)
            (<a class="sym-link local-def" href="#def-decode-varname-for-patbind" data-sym="DECODE-VARNAME-FOR-PATBIND" title="(defun decode-varname-for-patbind (pattern)
  (declare (xargs :guard (symbolp pattern)))
  (let* ((name (symbol-name pattern))
         (len (length name))
         (?p (and (&lt;= 1 len) (eql (char name 0) #\?)))
...">decode-varname-for-patbind</a> pattern)
            (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> ignorep 'ignore)
              nested-expr
              `(let ((,SYM ,(CAR ASSIGN-EXPRS)))
                ,@(AND IGNOREP `((DECLARE (,IGNOREP ,SYM))))
                ,NESTED-EXPR))))))
    ((<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car pattern) 'quote) nested-expr)
    ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp (car pattern))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
        '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
        <span class="string">"~
The B* binding of ~x0 to ~x1 isn&#39;t allowed."</span>
        pattern
        assign-exprs))
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((binder (car pattern)) (patbind-macro (<a class="sym-link local-def" href="#def-macro-name-for-patbind" data-sym="MACRO-NAME-FOR-PATBIND" title="(defun macro-name-for-patbind (binder)
  (declare (xargs :guard (symbolp binder)))
  (intern-in-package-of-symbol
   (concatenate &#39;string &quot;PATBIND-&quot; (symbol-name binder))
   (if (equal (symbol-package-name binder) &quot;COMMON-LISP&quot;)
...">macro-name-for-patbind</a> binder))
          (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> (cdr pattern)))
        `(,PATBIND-MACRO ,ARGS ,ASSIGN-EXPRS ,NESTED-EXPR)))))</pre>
  </div>

<div class="form-block macro" id="def-patbind" data-defines="PATBIND" data-references="PATBINDFN,NESTED-EXPR,ASSIGN-EXPRS,PATTERN,DEFMACRO" data-used-by="B*-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATBIND">patbind</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-patbind" data-sym="PATBIND" title="(defmacro patbind (pattern assign-exprs nested-expr)
  (patbindfn pattern assign-exprs nested-expr))">patbind</a>
  (pattern assign-exprs nested-expr)
  (<a class="sym-link local-def" href="#def-patbindfn" data-sym="PATBINDFN" title="(defun patbindfn (pattern assign-exprs nested-expr)
  (declare (xargs :guard t))
  (cond ((eq pattern &#39;-) `(prog2$ (progn$ . ,assign-exprs) ,nested-expr))
        ((eq pattern &#39;&amp;) nested-expr)
        ((atom pattern)
...">patbindfn</a> pattern assign-exprs nested-expr))</pre>
  </div>

<div class="form-block function" id="def-b_2A-fn" data-defines="B*-FN" data-references="B*,PATBIND,QUASIQUOTE,PROGN$,QUOTE,CONS,ATOM,IF,CONSP,DEBUGGABLE-BINDERS-P,AND,XARGS,DECLARE,EXPRS,BINDLIST,DEFUN" data-used-by="B*" data-part-name="B*-FN" data-part-args="EXPRS,BINDLIST" data-part-declare="EXPRS,CONSP,BINDLIST,DEBUGGABLE-BINDERS-P,AND,XARGS,DECLARE" data-part-body="B*,PATBIND,QUASIQUOTE,EXPRS,PROGN$,QUOTE,CONS,BINDLIST,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*-FN">b*-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-b_2A-fn" data-sym="B*-FN" title="(defun b*-fn (bindlist exprs)
  (declare (xargs :guard (and (debuggable-binders-p bindlist) (consp exprs))))
  (if (atom bindlist)
      (cons &#39;progn$ exprs)
      `(patbind ,(caar bindlist) ,(cdar bindlist)">b*-fn</a>
  (bindlist exprs)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-debuggable-binders-p" data-sym="DEBUGGABLE-BINDERS-P" title="(defun debuggable-binders-p (x)
  (declare (xargs :guard t))
  (cond
   ((atom x)
    (or (equal x nil)
...">debuggable-binders-p</a> bindlist) (consp exprs))))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> bindlist)
    (cons '<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> exprs)
    `(<a class="sym-link local-def" href="#def-patbind" data-sym="PATBIND" title="(defmacro patbind (pattern assign-exprs nested-expr)
  (patbindfn pattern assign-exprs nested-expr))">patbind</a> ,(CAAR BINDLIST)
      ,(CDAR BINDLIST)
      (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,(CDR BINDLIST) . ,EXPRS))))</pre>
  </div>

<div class="form-block macro" id="def-b_2A" data-defines="B*" data-references="CONS,B*-FN,DEBUGGABLE-BINDERS-P,XARGS,DECLARE,EXPRS,&REST,EXPR,BINDLIST,DEFMACRO" data-used-by="PATBIND-LOCAL-STOBJS-FN,B*-DECOMP-FN,B*-DECOMP-BINDINGS,BODY-FOR-ASSOCS,DEF-PATBIND-MACRO,B*-FN,PATBINDFN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*">b*</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
  (bindlist expr &amp;rest exprs)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-debuggable-binders-p" data-sym="DEBUGGABLE-BINDERS-P" title="(defun debuggable-binders-p (x)
  (declare (xargs :guard t))
  (cond
   ((atom x)
    (or (equal x nil)
...">debuggable-binders-p</a> bindlist)))
  (<a class="sym-link local-def" href="#def-b_2A-fn" data-sym="B*-FN" title="(defun b*-fn (bindlist exprs)
  (declare (xargs :guard (and (debuggable-binders-p bindlist) (consp exprs))))
  (if (atom bindlist)
      (cons &#39;progn$ exprs)
      `(patbind ,(caar bindlist) ,(cdar bindlist)">b*-fn</a> bindlist (cons expr exprs)))</pre>
  </div>

<div class="form-block other" id="form-25" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> ppr-special-syms '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> <span class="number">1</span>)</pre>
  </div>

<div class="form-block other" id="form-26" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../../xdoc/base.html#def-defxdoc" data-sym="DEFXDOC">defxdoc</a> <a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>)
  <span class="keyword">:short</span> <span class="string">"Introduce a new form usable inside @(see b*)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (def-b*-binder name
      [:parents parents]   ;; default: (b*-binders)
      [:short short]
      [:long long]
      :decls declare-forms
      :body body)
})

&lt;p&gt;Introduces a B* binder form of the given name.  The given @(&#39;body&#39;) may use
the variables @(&#39;args&#39;), @(&#39;forms&#39;), and @(&#39;rest-expr&#39;), and will control how
to macroexpand a form like the following:&lt;/p&gt;

@({
 (b* (((&lt;name&gt; . &lt;args&gt;) . &lt;forms&gt;)) &lt;rest-expr&gt;)
})

&lt;p&gt;The documentation forms are optional, and placeholder documentation will be
generated if none is provided.  It is recommended that the parents include
@(see b*-binders) since this provides a single location where the user may see
all of the available binder forms.&lt;/p&gt;

&lt;p&gt;This works by introducing a macro named @(&#39;patbind-name&#39;).  See @(see b*)
for more details.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block macro" id="def-def-b_2A-binder" data-defines="DEF-B*-BINDER" data-references="B*-BINDER-TABLE,TABLE,REST-EXPR,FORMS,ARGS,PROGN,QUASIQUOTE,FULL-ESCAPE-SYMBOL,SYMBOL-NAME,STRING,CONCATENATE,AND,IF,B*-BINDERS,OR,DOC-P,MACRO-NAME-FOR-PATBIND,MACRO-NAME,LET*,BODY,DECLS,LONG-P,LONG,SHORT-P,SHORT,PARENTS-P,QUOTE,PARENTS,&KEY,NAME,DEFMACRO" data-used-by="DEF-B*-DECOMP,DEF-PATBIND-MACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-B*-BINDER">def-b*-binder</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a>
  (name &amp;key
    (parents 'nil parents-p)
    (short 'nil short-p)
    (long 'nil long-p)
    decls
    <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
  (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((macro-name (<a class="sym-link local-def" href="#def-macro-name-for-patbind" data-sym="MACRO-NAME-FOR-PATBIND" title="(defun macro-name-for-patbind (binder)
  (declare (xargs :guard (symbolp binder)))
  (intern-in-package-of-symbol
   (concatenate &#39;string &quot;PATBIND-&quot; (symbol-name binder))
   (if (equal (symbol-package-name binder) &quot;COMMON-LISP&quot;)
...">macro-name-for-patbind</a> name)) (doc-p (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> parents-p short-p long-p))
      (parents (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> parents '(b*-binders)))
      (short (if short-p
          short
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> doc-p
            (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>
              <span class="string">"@(see acl2::b*) binder form @(&#39;"</span>
              (symbol-name name)
              <span class="string">"&#39;) (placeholder)."</span>))))
      (long (if long-p
          long
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> doc-p
            (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>
              <span class="string">"&lt;p&gt;This is a b* binder introduced with @(see acl2::def-b*-binder).&lt;/p&gt;
                                     @(def "</span>
              (<a class="sym-link external" href="../../xdoc/full-escape-symbol.html#def-full-escape-symbol" data-sym="FULL-ESCAPE-SYMBOL">full-escape-symbol</a> macro-name)
              <span class="string">")"</span>)))))
    `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> ,@(IF DOC-P
      `((DEFXDOC ,MACRO-NAME :PARENTS ,PARENTS :SHORT ,SHORT :LONG ,LONG))
      NIL)
      (<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> ,MACRO-NAME (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr) ,@DECLS ,BODY)
      (<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> b*-binder-table ',NAME ',MACRO-NAME))))</pre>
  </div>

<div class="form-block macro" id="def-destructure-guard" data-defines="DESTRUCTURE-GUARD" data-references="CDR,EQ,CONSP,QUOTE,CW,TRUE-LISTP,OR,AND,QUASIQUOTE,LEN,BINDINGS,ARGS,BINDER,DEFMACRO" data-used-by="DEF-PATBIND-MACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DESTRUCTURE-GUARD">destructure-guard</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a>
  (binder <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> bindings <a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a>)
  `(<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> ,ARGS) . ,(AND LEN `((= (LENGTH ,ARGS) ,LEN))))
      (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%"</span>
        ',BINDER
        ,(IF LEN
     `(MSG &quot;~x0 &quot; ,LEN)
     &quot;&quot;)
        ,ARGS))
    (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp ,BINDINGS) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr ,BINDINGS) nil))
      (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****
Pattern constructor ~x0 needs exactly one binding expression, but was given ~x1~%~%"</span>
        ',BINDER
        ,BINDINGS))))</pre>
  </div>

<div class="form-block function" id="def-destructor-binding-list" data-defines="DESTRUCTOR-BINDING-LIST" data-references="CDR,CAR,LIST,CONS,ATOM,OR,IF,T,XARGS,DECLARE,BINDING,DESTRUCTORS,ARGS,DEFUN" data-used-by="DEF-PATBIND-MACRO" data-part-name="DESTRUCTOR-BINDING-LIST" data-part-args="BINDING,DESTRUCTORS,ARGS" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,DESTRUCTOR-BINDING-LIST,BINDING,CAR,LIST,CONS,DESTRUCTORS,ARGS,ATOM,OR,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DESTRUCTOR-BINDING-LIST">destructor-binding-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-destructor-binding-list" data-sym="DESTRUCTOR-BINDING-LIST" title="(defun destructor-binding-list (args destructors binding)
  (declare (xargs :guard t))
  (if (or (atom args) (atom destructors))
      nil
      (cons (list (car args) (list (car destructors) binding))">destructor-binding-list</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> <a class="sym-link system" href="../../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a> binding)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>))
    nil
    (cons (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (car <a class="sym-link system" href="../../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>) binding))
      (<a class="sym-link local-def" href="#def-destructor-binding-list" data-sym="DESTRUCTOR-BINDING-LIST" title="(defun destructor-binding-list (args destructors binding)
  (declare (xargs :guard t))
  (if (or (atom args) (atom destructors))
      nil
      (cons (list (car args) (list (car destructors) binding))">destructor-binding-list</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
        (cdr <a class="sym-link system" href="../../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>)
        binding))))</pre>
  </div>

<div class="form-block macro" id="def-def-patbind-macro" data-defines="DEF-PATBIND-MACRO" data-references="CHECK-VARS-NOT-FREE,IGNORABLE,LET,B*,DESTRUCTOR-BINDING-LIST,BINDERS,PACK,IF,BEXPR,EQ,ATOM,OR,COMPUTEDP,CAR,BINDING,LET*,FORMS,ARGS,DESTRUCTURE-GUARD,XARGS,DECLARE,DEF-B*-BINDER,QUASIQUOTE,LONG-P,LONG,SHORT-P,SHORT,B*-BINDERS,QUOTE,PARENTS,&KEY,DESTRUCTORS,BINDER,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-PATBIND-MACRO">def-patbind-macro</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-def-patbind-macro" data-sym="DEF-PATBIND-MACRO" title="(defmacro def-patbind-macro
          (binder destructors
           &amp;key (parents &#39;(b*-binders)) (short &#39;nil short-p)
           (long &#39;nil long-p))
  `(def-b*-binder ,binder :parents ,parents ,@(and short-p `(:short ,short))
...">def-patbind-macro</a>
  (binder <a class="sym-link system" href="../../../defthm.html#def-destructors" data-sym="DESTRUCTORS">destructors</a>
    &amp;key
    (parents '(b*-binders))
    (short 'nil short-p)
    (long 'nil long-p))
  `(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> ,BINDER
    <span class="keyword">:parents</span> ,PARENTS
    ,@(AND SHORT-P `(:SHORT ,SHORT))
    ,@(AND LONG-P `(:LONG ,LONG))
    <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> ,BINDER <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms ,(LEN DESTRUCTORS)))))
    <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((binding (car forms)) (computedp (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> binding) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car binding) 'quote)))
        (bexpr (if computedp
            binding
            (<a class="sym-link local-def" href="#def-pack" data-sym="PACK" title="(defmacro pack (&amp;rest args) `(pack-term (list ,@args)))">pack</a> binding)))
        (binders (<a class="sym-link local-def" href="#def-destructor-binding-list" data-sym="DESTRUCTOR-BINDING-LIST" title="(defun destructor-binding-list (args destructors binding)
  (declare (xargs :guard t))
  (if (or (atom args) (atom destructors))
      nil
      (cons (list (car args) (list (car destructors) binding))">destructor-binding-list</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> ',DESTRUCTORS bexpr)))
      (if computedp
        `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS ,REST-EXPR)
        `(let ((,BEXPR ,BINDING))
          (declare (ignorable ,BEXPR))
          (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,BEXPR) ,REST-EXPR)))))))</pre>
  </div>

<div class="form-block function" id="def-var-ignore-list-for-patbind-mv" data-defines="VAR-IGNORE-LIST-FOR-PATBIND-MV" data-references="CONS,1+,EQ,CDR,LIST,PACK,T,IGNORABLE,CASE,DECODE-VARNAME-FOR-PATBIND,SYM,IGNORE,QUOTE,IGNORE-VAR-NAME,VAR,LET,SYMBOLP,NOT,QUOTEP,*PATBIND-SPECIAL-SYMS*,CAR,MEMBER,OR,COND,IGNOREP,FRESHP,BINDER,MV-VAR,MV-LET,REVERSE,MV,ATOM,IF,TRUE-LISTP,NATP,AND,XARGS,DECLARE,FRESHVARS,IGNORABLES,IGNORES,BINDERS,MV-VARS,IGCOUNT,ARGS,DEFUN" data-part-name="VAR-IGNORE-LIST-FOR-PATBIND-MV" data-part-args="FRESHVARS,IGNORABLES,IGNORES,BINDERS,MV-VARS,IGCOUNT,ARGS" data-part-declare="FRESHVARS,IGNORABLES,IGNORES,BINDERS,MV-VARS,TRUE-LISTP,IGCOUNT,NATP,AND,XARGS,DECLARE" data-part-body="CONS,1+,EQ,CDR,VAR-IGNORE-LIST-FOR-PATBIND-MV,LIST,PACK,T,IGNORABLE,CASE,DECODE-VARNAME-FOR-PATBIND,SYM,IGNORE,QUOTE,IGCOUNT,IGNORE-VAR-NAME,VAR,LET,SYMBOLP,NOT,AND,QUOTEP,*PATBIND-SPECIAL-SYMS*,CAR,MEMBER,OR,COND,IGNOREP,FRESHP,BINDER,MV-VAR,MV-LET,FRESHVARS,IGNORABLES,IGNORES,BINDERS,MV-VARS,REVERSE,MV,ARGS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="VAR-IGNORE-LIST-FOR-PATBIND-MV">var-ignore-list-for-patbind-mv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-var-ignore-list-for-patbind-mv" data-sym="VAR-IGNORE-LIST-FOR-PATBIND-MV" title="(defun var-ignore-list-for-patbind-mv
       (args igcount mv-vars binders ignores ignorables freshvars)
  (declare
   (xargs :guard
    (and (natp igcount) (true-listp mv-vars) (true-listp binders)
...">var-ignore-list-for-patbind-mv</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> igcount mv-vars binders ignores ignorables freshvars)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-natp" data-sym="NATP">natp</a> igcount)
        (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> mv-vars)
        (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> binders)
        (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> ignores)
        (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> ignorables)
        (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> freshvars))))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> mv-vars)
      (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> binders)
      (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> ignores)
      (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> ignorables)
      (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> freshvars))
    (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (mv-var binder freshp ignorep)
      (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) <a class="sym-link local-def" href="#def-_2Apatbind-special-syms_2A" data-sym="*PATBIND-SPECIAL-SYMS*" title="(defconst *patbind-special-syms* &#39;(&amp; -))">*patbind-special-syms*</a>)
           (<a class="sym-link system" href="../../../axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
           (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))))) (let ((var (<a class="sym-link local-def" href="#def-ignore-var-name" data-sym="IGNORE-VAR-NAME" title="(defun ignore-var-name (n)
  (declare (xargs :guard (natp n)))
  (str-num-sym &quot;IGNORE-&quot; n))">ignore-var-name</a> igcount)))
            (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> var nil nil 'ignore)))
        ((symbolp (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (sym ignorep)
            (<a class="sym-link local-def" href="#def-decode-varname-for-patbind" data-sym="DECODE-VARNAME-FOR-PATBIND" title="(defun decode-varname-for-patbind (pattern)
  (declare (xargs :guard (symbolp pattern)))
  (let* ((name (symbol-name pattern))
         (len (length name))
         (?p (and (&lt;= 1 len) (eql (char name 0) #\?)))
...">decode-varname-for-patbind</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
            (<a class="sym-link system" href="../../../axioms.html#def-case" data-sym="CASE">case</a> ignorep
              (ignore (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> sym nil nil 'ignore))
              (ignorable (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> sym nil nil 'ignorable))
              (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> sym nil nil nil)))))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (let ((var (<a class="sym-link local-def" href="#def-pack" data-sym="PACK" title="(defmacro pack (&amp;rest args) `(pack-term (list ,@args)))">pack</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))))
            (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> var (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) var) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> nil))))
      (<a class="sym-link local-def" href="#def-var-ignore-list-for-patbind-mv" data-sym="VAR-IGNORE-LIST-FOR-PATBIND-MV" title="(defun var-ignore-list-for-patbind-mv
       (args igcount mv-vars binders ignores ignorables freshvars)
  (declare
   (xargs :guard
    (and (natp igcount) (true-listp mv-vars) (true-listp binders)
...">var-ignore-list-for-patbind-mv</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
        (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> ignorep 'ignore)
          (<a class="sym-link system" href="../../../axioms.html#def-1_2B" data-sym="1+">1+</a> igcount)
          igcount)
        (cons mv-var mv-vars)
        (if binder
          (cons binder binders)
          binders)
        (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> ignorep 'ignore)
          (cons mv-var ignores)
          ignores)
        (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> ignorep 'ignorable)
          (cons mv-var ignorables)
          ignorables)
        (if freshp
          (cons mv-var freshvars)
          freshvars)))))</pre>
  </div>

<div class="form-block other" id="form-32" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a>
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for multiple values."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

@({
    (b* (((mv a b c) (form-returning-three-values)))
      form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (mv-let (a b c)
      (form-returning-three-values)
      form)
})

&lt;p&gt;The @(&#39;mv&#39;) binder only makes sense as a top-level binding, but each of its
arguments may be a recursive binding.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> <a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms nil))))
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (vars binders ignores ignorables freshvars)
    (<a class="sym-link local-def" href="#def-var-ignore-list-for-patbind-mv" data-sym="VAR-IGNORE-LIST-FOR-PATBIND-MV" title="(defun var-ignore-list-for-patbind-mv
       (args igcount mv-vars binders ignores ignorables freshvars)
  (declare
   (xargs :guard
    (and (natp igcount) (true-listp mv-vars) (true-listp binders)
...">var-ignore-list-for-patbind-mv</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> <span class="number">0</span> nil nil nil nil nil)
    `(<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> ,VARS
      ,(CAR FORMS)
      (declare (ignore . ,IGNORES))
      (declare (ignorable . ,IGNORABLES))
      (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> ,IGNORES
        (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> ,FRESHVARS ,REST-EXPR))))))</pre>
  </div>

<div class="form-block other" id="form-33" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-patbind-macro" data-sym="DEF-PATBIND-MACRO" title="(defmacro def-patbind-macro
          (binder destructors
           &amp;key (parents &#39;(b*-binders)) (short &#39;nil short-p)
           (long &#39;nil long-p))
  `(def-b*-binder ,binder :parents ,parents ,@(and short-p `(:short ,short))
...">def-patbind-macro</a> cons
  (car cdr)
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for decomposing a @(see cons) into its @(see car)
and @(see cdr)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;

@({
     (b* (((cons a b) (binding-form)))
       (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (let* ((tmp (binding-form))
           (a   (car tmp))
           (b   (cdr tmp)))
      (result-form))
})

&lt;p&gt;Each of the arguments to the @(&#39;cons&#39;) binder may be a recursive binder, and
@(&#39;cons&#39;) may be nested inside other bindings.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block function" id="def-nths-binding-list" data-defines="NTHS-BINDING-LIST" data-references="1+,CDR,NTH,QUASIQUOTE,CAR,LIST,CONS,ATOM,IF,NATP,XARGS,DECLARE,FORM,N,ARGS,DEFUN" data-part-name="NTHS-BINDING-LIST" data-part-args="FORM,N,ARGS" data-part-declare="N,NATP,XARGS,DECLARE" data-part-body="FORM,N,1+,CDR,NTHS-BINDING-LIST,NTH,QUASIQUOTE,CAR,LIST,CONS,ARGS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NTHS-BINDING-LIST">nths-binding-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-nths-binding-list" data-sym="NTHS-BINDING-LIST" title="(defun nths-binding-list (args n form)
  (declare (xargs :guard (natp n)))
  (if (atom args)
      nil
      (cons (list (car args) `(nth ,n ,form))">nths-binding-list</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> n form)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-natp" data-sym="NATP">natp</a> n)))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    nil
    (cons (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) `(<a class="sym-link system" href="../../../axioms.html#def-nth" data-sym="NTH">nth</a> ,N ,FORM))
      (<a class="sym-link local-def" href="#def-nths-binding-list" data-sym="NTHS-BINDING-LIST" title="(defun nths-binding-list (args n form)
  (declare (xargs :guard (natp n)))
  (if (atom args)
      nil
      (cons (list (car args) `(nth ,n ,form))">nths-binding-list</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-1_2B" data-sym="1+">1+</a> n) form))))</pre>
  </div>

<div class="form-block other" id="form-35" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> nths
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for list decomposition, using @(see nth)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((nths a b c) (list-fn ...)))
      form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (b* ((tmp (list-fn ...))
         (a   (nth 0 tmp))
         (b   (nth 1 tmp))
         (c   (nth 2 tmp)))
      form)
})

&lt;p&gt;Each of the arguments to the @(&#39;nths&#39;) binder may be a recursive binder, and
@(&#39;nths&#39;) may be nested inside other bindings.&lt;/p&gt;

&lt;p&gt;This binder is very similar to the @(&#39;list&#39;) binder, see @(see
patbind-list).  However, here we put in explicit calls of @(&#39;nth&#39;), whereas the
@(&#39;list&#39;) binder will put in, e.g., @(&#39;car&#39;), @(&#39;cadr&#39;), etc.  The @(&#39;list&#39;)
binder is likely to be more efficient in general, but the @(&#39;nths&#39;) binder may
occasionally be useful when you have @(&#39;nth&#39;) disabled.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> nths <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms nil))))
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((binding (car forms)) (evaledp (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> binding) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car binding) 'quote)))
      (form (if evaledp
          binding
          (<a class="sym-link local-def" href="#def-pack" data-sym="PACK" title="(defmacro pack (&amp;rest args) `(pack-term (list ,@args)))">pack</a> binding)))
      (binders (<a class="sym-link local-def" href="#def-nths-binding-list" data-sym="NTHS-BINDING-LIST" title="(defun nths-binding-list (args n form)
  (declare (xargs :guard (natp n)))
  (if (atom args)
      nil
      (cons (list (car args) `(nth ,n ,form))">nths-binding-list</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> <span class="number">0</span> form)))
    (if evaledp
      `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS ,REST-EXPR)
      `(let ((,FORM ,BINDING))
        (declare (ignorable ,FORM))
        (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,FORM) ,REST-EXPR))))))</pre>
  </div>

<div class="form-block other" id="form-36" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> nths*
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for list decomposition, using @(see nth), with one
final @(see nthcdr)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((nths* a b c d) (list-fn ...)))
      form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (b* ((tmp (list-fn ...))
         (a   (nth 0 tmp))
         (b   (nth 1 tmp))
         (c   (nth 2 tmp))
         (d   (nthcdr 3 tmp)))
      form)
})

&lt;p&gt;Each of the arguments to the @(&#39;nths*&#39;) binder may be a recursive binder,
and @(&#39;nths*&#39;) may be nested inside other bindings.&lt;/p&gt;

&lt;p&gt;This binder is very similar to the @(&#39;list*&#39;) binder, see @(see
patbind-list*).  However, here we put in explicit calls of @(&#39;nth&#39;) and
@(&#39;nthcdr&#39;), whereas the @(&#39;list*&#39;) binder will put in, e.g., @(&#39;car&#39;),
@(&#39;cadr&#39;), etc.  The @(&#39;list*&#39;) binder is likely to be more efficient in
general, but the @(&#39;nths*&#39;) binder may occasionally be useful when you have
@(&#39;nth&#39;) disabled.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> nths <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms nil)
         (&lt; <span class="number">0</span> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))))))
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((binding (car forms)) (evaledp (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> binding) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car binding) 'quote)))
      (form (if evaledp
          binding
          (<a class="sym-link local-def" href="#def-pack" data-sym="PACK" title="(defmacro pack (&amp;rest args) `(pack-term (list ,@args)))">pack</a> binding)))
      (binders (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-nths-binding-list" data-sym="NTHS-BINDING-LIST" title="(defun nths-binding-list (args n form)
  (declare (xargs :guard (natp n)))
  (if (atom args)
      nil
      (cons (list (car args) `(nth ,n ,form))">nths-binding-list</a> (<a class="sym-link system" href="../../../axioms.html#def-butlast" data-sym="BUTLAST">butlast</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> <span class="number">1</span>) <span class="number">0</span> form)
          `((,(CAR (LAST ARGS)) (<a class="sym-link system" href="../../../axioms.html#def-nthcdr" data-sym="NTHCDR">nthcdr</a> ,(1- (LEN ARGS)) ,FORM))))))
    (if evaledp
      `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS ,REST-EXPR)
      `(let ((,FORM ,BINDING))
        (declare (ignorable ,FORM))
        (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,BINDERS (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (,FORM) ,REST-EXPR))))))</pre>
  </div>

<div class="form-block other" id="form-37" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a>
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for list decomposition, using @(see car)/@(see cdr)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
     (b* (((list a b c) lst))
       form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (b* ((a (car lst))
         (tmp1 (cdr lst))
         (b (car tmp1))
         (tmp2 (cdr tmp1))
         (c (car tmp2)))
      form)
})

&lt;p&gt;Each of the arguments to the @(&#39;list&#39;) binder may be a recursive binder, and
@(&#39;list&#39;) may be nested inside other bindings.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> <a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms nil))))
  <span class="keyword">:body</span> (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    rest-expr
    `(patbind-cons (,(CAR ARGS) (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> . ,(CDR ARGS)))
      ,FORMS
      ,REST-EXPR)))</pre>
  </div>

<div class="form-block other" id="form-38" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a>
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for @(&#39;list*&#39;) decomposition using @(see car)/@(see cdr)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((list* a b c) lst)) form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (b* ((a (car lst))
         (tmp1 (cdr lst))
         (b (car tmp1))
         (c (cdr tmp1)))
      form)
})

&lt;p&gt;Each of the arguments to the @(&#39;list*&#39;) binder may be a recursive binder,
and @(&#39;list*&#39;) may be nested inside other bindings.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> <a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms nil)))))
  <span class="keyword">:body</span> (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
    `(<a class="sym-link local-def" href="#def-patbind" data-sym="PATBIND" title="(defmacro patbind (pattern assign-exprs nested-expr)
  (patbindfn pattern assign-exprs nested-expr))">patbind</a> ,(CAR ARGS) ,FORMS ,REST-EXPR)
    `(patbind-cons (,(CAR ARGS) (<a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> . ,(CDR ARGS)))
      ,FORMS
      ,REST-EXPR)))</pre>
  </div>

<div class="form-block function" id="def-assocs-binder-element-p" data-defines="ASSOCS-BINDER-ELEMENT-P" data-references="CDDR,EQUAL,CDR,CONSP,AND,OR,SYMBOLP,ATOM,IF,T,XARGS,DECLARE,ELE,DEFUN" data-used-by="ASSOCS-BINDER-LISTP" data-part-name="ASSOCS-BINDER-ELEMENT-P" data-part-args="ELE" data-part-declare="T,XARGS,DECLARE" data-part-body="CDDR,EQUAL,CDR,CONSP,AND,OR,SYMBOLP,ELE,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOCS-BINDER-ELEMENT-P">assocs-binder-element-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assocs-binder-element-p" data-sym="ASSOCS-BINDER-ELEMENT-P" title="(defun assocs-binder-element-p (ele)
  (declare (xargs :guard t))
  (if (atom ele)
      (symbolp ele)
      (or (and (consp (cdr ele)) (equal (cddr ele) nil))">assocs-binder-element-p</a>
  (ele)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> ele)
    (symbolp ele)
    (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp (cdr ele)) (equal (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> ele) nil))
      (equal (cdr ele) nil))))</pre>
  </div>

<div class="form-block function" id="def-assocs-binder-listp" data-defines="ASSOCS-BINDER-LISTP" data-references="CDR,ASSOCS-BINDER-ELEMENT-P,AND,CAR,L,LET,NULL,ATOM,IF,T,XARGS,DECLARE,LST,DEFUN" data-used-by="BODY-FOR-ASSOCS,ASSIGNS-FOR-ASSOCS" data-part-name="ASSOCS-BINDER-LISTP" data-part-args="LST" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,ASSOCS-BINDER-LISTP,ASSOCS-BINDER-ELEMENT-P,AND,CAR,L,LET,NULL,LST,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOCS-BINDER-LISTP">assocs-binder-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assocs-binder-listp" data-sym="ASSOCS-BINDER-LISTP" title="(defun assocs-binder-listp (lst)
  (declare (xargs :guard t))
  (if (atom lst)
      (null lst)
      (let ((l (car lst)))">assocs-binder-listp</a>
  (lst)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> lst)
    (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> lst)
    (let ((l (car lst)))
      (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-assocs-binder-element-p" data-sym="ASSOCS-BINDER-ELEMENT-P" title="(defun assocs-binder-element-p (ele)
  (declare (xargs :guard t))
  (if (atom ele)
      (symbolp ele)
      (or (and (consp (cdr ele)) (equal (cddr ele) nil))">assocs-binder-element-p</a> l)
        (<a class="sym-link local-def" href="#def-assocs-binder-listp" data-sym="ASSOCS-BINDER-LISTP" title="(defun assocs-binder-listp (lst)
  (declare (xargs :guard t))
  (if (atom lst)
      (null lst)
      (let ((l (car lst)))">assocs-binder-listp</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-assigns-for-assocs" data-defines="ASSIGNS-FOR-ASSOCS" data-references="QUOTE,IGNORE,DECODE-VARNAME-FOR-PATBIND,IGN,SYM,MV-LET,CDR,QUASIQUOTE,CAR,CONSP,CONS,ATOM,IF,ASSOCS-BINDER-LISTP,XARGS,DECLARE,ALIST,ARGS,GETTER,DEFUN" data-part-name="ASSIGNS-FOR-ASSOCS" data-part-args="ALIST,ARGS,GETTER" data-part-declare="ARGS,ASSOCS-BINDER-LISTP,XARGS,DECLARE" data-part-body="ALIST,GETTER,ASSIGNS-FOR-ASSOCS,QUOTE,IGNORE,DECLARE,DECODE-VARNAME-FOR-PATBIND,IGN,SYM,MV-LET,CDR,QUASIQUOTE,CAR,CONSP,CONS,ARGS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSIGNS-FOR-ASSOCS">assigns-for-assocs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assigns-for-assocs" data-sym="ASSIGNS-FOR-ASSOCS" title="(defun assigns-for-assocs (getter args alist)
  (declare (xargs :guard (assocs-binder-listp args)))
  (if (atom args)
      nil
      (cons
...">assigns-for-assocs</a>
  (getter <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-assocs-binder-listp" data-sym="ASSOCS-BINDER-LISTP" title="(defun assocs-binder-listp (lst)
  (declare (xargs :guard t))
  (if (atom lst)
      (null lst)
      (let ((l (car lst)))">assocs-binder-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    nil
    (cons (if (consp (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
        `(,(CAAR ARGS) (cdr (,GETTER ,(CADAR ARGS) ,ALIST)))
        (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (sym ign)
          (<a class="sym-link local-def" href="#def-decode-varname-for-patbind" data-sym="DECODE-VARNAME-FOR-PATBIND" title="(defun decode-varname-for-patbind (pattern)
  (declare (xargs :guard (symbolp pattern)))
  (let* ((name (symbol-name pattern))
         (len (length name))
         (?p (and (&lt;= 1 len) (eql (char name 0) #\?)))
...">decode-varname-for-patbind</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
          (declare (ignore ign))
          `(,(CAR ARGS) (cdr (,GETTER ',SYM ,ALIST)))))
      (<a class="sym-link local-def" href="#def-assigns-for-assocs" data-sym="ASSIGNS-FOR-ASSOCS" title="(defun assigns-for-assocs (getter args alist)
  (declare (xargs :guard (assocs-binder-listp args)))
  (if (atom args)
      nil
      (cons
...">assigns-for-assocs</a> getter (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) alist))))</pre>
  </div>

<div class="form-block function" id="def-body-for-assocs" data-defines="BODY-FOR-ASSOCS" data-references="B*,CHECK-VARS-NOT-FREE,TMP-FOR-ASSOCS,?TMP-FOR-ASSOCS,QUASIQUOTE,MV,QUOTE,CAAR,EQ,NOT,CAR,IF,REST,NAME,PRE-BINDINGS,MV-LET,ASSOCS-BINDER-LISTP,CONSP,AND,XARGS,DECLARE,REST-EXPR,FORMS,ARGS,GETTER,DEFUN" data-part-name="BODY-FOR-ASSOCS" data-part-args="REST-EXPR,FORMS,ARGS,GETTER" data-part-declare="ARGS,ASSOCS-BINDER-LISTP,FORMS,CONSP,AND,XARGS,DECLARE" data-part-body="B*,REST-EXPR,CHECK-VARS-NOT-FREE,TMP-FOR-ASSOCS,?TMP-FOR-ASSOCS,QUASIQUOTE,MV,QUOTE,CAAR,EQ,NOT,FORMS,CAR,CONSP,AND,IF,REST,NAME,PRE-BINDINGS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BODY-FOR-ASSOCS">body-for-assocs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-body-for-assocs" data-sym="BODY-FOR-ASSOCS" title="(defun body-for-assocs (getter args forms rest-expr)
  (declare (xargs :guard (and (consp forms) (assocs-binder-listp args))))
  (mv-let (pre-bindings name rest)
          (if (and (consp (car forms)) (not (eq (caar forms) &#39;quote)))
              (mv `((?tmp-for-assocs ,(car forms))) &#39;tmp-for-assocs
...">body-for-assocs</a>
  (getter <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp forms) (<a class="sym-link local-def" href="#def-assocs-binder-listp" data-sym="ASSOCS-BINDER-LISTP" title="(defun assocs-binder-listp (lst)
  (declare (xargs :guard t))
  (if (atom lst)
      (null lst)
      (let ((l (car lst)))">assocs-binder-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))))
  (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (pre-bindings name <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>)
    (if (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp (car forms)) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> forms) 'quote)))
      (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> `((?tmp-for-assocs ,(CAR FORMS)))
        'tmp-for-assocs
        `(<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (tmp-for-assocs) ,REST-EXPR))
      (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> nil (car forms) rest-expr))
    `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> (,@PRE-BINDINGS . ,(ASSIGNS-FOR-ASSOCS GETTER ARGS NAME))
      ,REST)))</pre>
  </div>

<div class="form-block other" id="form-43" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> assocs
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for extracting particular values from an alist."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((assocs (a akey) b (c &#39;foo)) alst))
      form)
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (b* ((a (cdr (assoc akey alst)))
         (b (cdr (assoc &#39;b alst)))
         (c (cdr (assoc &#39;foo alst))))
      form)
})

&lt;p&gt;The arguments to the @(&#39;assocs&#39;) binder should be either single symbols or
pairs of the form @(&#39;(var key)&#39;):&lt;/p&gt;

&lt;ul&gt;

&lt;li&gt;In the pair form, @(&#39;var&#39;) is the variable that will be bound to the
associated value of @(&#39;key&#39;) in the bound object, which should be an alist.
Note that @(&#39;key&#39;) &lt;i&gt;does not get quoted&lt;/i&gt;; it may itself be some
expression.&lt;/li&gt;

&lt;li&gt;An argument consisting of the single symbol, @(&#39;var&#39;), is equivalent
to the pair @(&#39;(var &#39;var)&#39;).&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;Each of the arguments in the @(&#39;var&#39;) position of the pair form may be a
recursive binder, and @(&#39;assocs&#39;) may be nested inside other bindings.&lt;/p&gt;"</span>
  <span class="keyword">:body</span> (<a class="sym-link local-def" href="#def-body-for-assocs" data-sym="BODY-FOR-ASSOCS" title="(defun body-for-assocs (getter args forms rest-expr)
  (declare (xargs :guard (and (consp forms) (assocs-binder-listp args))))
  (mv-let (pre-bindings name rest)
          (if (and (consp (car forms)) (not (eq (caar forms) &#39;quote)))
              (mv `((?tmp-for-assocs ,(car forms))) &#39;tmp-for-assocs
...">body-for-assocs</a> '<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr))</pre>
  </div>

<div class="form-block other" id="form-44" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a>
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for error triples."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((er x) (error-triple-form)))
      (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
     (er-let* ((x (error-triple-form)))
       (result-form))
})

&lt;p&gt;which itself is approximately equivalent to&lt;/p&gt;

@({
    (mv-let (erp val state)
            (error-triple-form)
       (if erp
           (mv erp val state)
         (result-form)))
})

&lt;p&gt;The @(&#39;er&#39;) binder only makes sense as a top-level binding, but its argument
may be a recursive binding.&lt;/p&gt;

&lt;p&gt;To return a different value in case of error,
the different value can be specified via @(&#39;:iferr&#39;):&lt;/p&gt;

@({
    (b* (((er x :iferr eval) (error-triple-form)))
      (result-form))
})

&lt;p&gt;which is approximately equivalent to&lt;/p&gt;

@({
    (mv-let (erp val state)
            (error-triple-form)
       (if erp
           (mv erp eval state) ; note eval instead of val
         (result-form)))
})"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
             (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">1</span>)
               (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">3</span>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) <span class="keyword">:iferr</span>))))
           (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****~%~
                                       Pattern constructor ER needs ~
                                       either a true list of 1 argument ~
                                       or a true list of 3 arguments ~
                                       whose second argument is :IFERR,
                                       but was given ~x0~%~%"</span>
             <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
         (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp forms) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr forms) nil))
           (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****~%~
                                       Pattern constructor ER needs ~
                                       exactly one binding expression, ~
                                       but was given ~x0~%~%"</span>
             forms))))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (patbind-er-fresh-variable-for-erp patbind-er-fresh-variable-for-val
      state)
    ,(CAR FORMS)
    (declare (ignorable patbind-er-fresh-variable-for-val))
    (if patbind-er-fresh-variable-for-erp
      (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> patbind-er-fresh-variable-for-erp
        ,(IF (EQL (LEN ARGS) 1)
     &#39;PATBIND-ER-FRESH-VARIABLE-FOR-VAL
     (CADDR ARGS))
        state)
      (<a class="sym-link local-def" href="#def-patbind" data-sym="PATBIND" title="(defmacro patbind (pattern assign-exprs nested-expr)
  (patbindfn pattern assign-exprs nested-expr))">patbind</a> ,(CAR ARGS)
        (patbind-er-fresh-variable-for-val)
        (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (patbind-er-fresh-variable-for-val patbind-er-fresh-variable-for-erp)
          ,REST-EXPR)))))</pre>
  </div>

<div class="form-block other" id="form-45" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> cmp
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for context-message pairs."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((cmp x) (cmp-returning-form)))
      (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (er-let*-cmp ((x (cmp-returning-form)))
      (result-form))
})

&lt;p&gt;which itself is approximately equivalent to&lt;/p&gt;

@({
    (mv-let (ctx x)
            (cmp-returning-form)
       (if ctx
           (mv ctx x)
         (result-form)))
})

&lt;p&gt;The @(&#39;cmp&#39;) binder only makes sense as a top-level binding, but its
argument may be a recursive binding.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> cmp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms <span class="number">1</span>))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (patbind-cmp-fresh-variable-for-ctx patbind-cmp-fresh-variable-for-val)
    ,(CAR FORMS)
    (if patbind-cmp-fresh-variable-for-ctx
      (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> patbind-cmp-fresh-variable-for-ctx
        patbind-cmp-fresh-variable-for-val)
      (<a class="sym-link local-def" href="#def-patbind" data-sym="PATBIND" title="(defmacro patbind (pattern assign-exprs nested-expr)
  (patbindfn pattern assign-exprs nested-expr))">patbind</a> ,(CAR ARGS)
        (patbind-cmp-fresh-variable-for-val)
        (<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (patbind-cmp-fresh-variable-for-val patbind-cmp-fresh-variable-for-ctx)
          ,REST-EXPR)))))</pre>
  </div>

<div class="form-block other" id="form-46" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> state-global
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for accessing state globals."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Usage:&lt;/p&gt;
@({
    (b* (((state-global x) (value-form)))
      (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (state-global-let* ((x (value-form)))
      (result-form))
})"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> state-global <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms <span class="number">1</span>)
         (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (symbolp (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
           (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****
Pattern constructor ~x0 needs a single argument which is a symbol, but got ~x1~%~%"</span>
             'state-global
             <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-state-global-let_2A" data-sym="STATE-GLOBAL-LET*">state-global-let*</a> ((,(CAR ARGS) ,(CAR FORMS))) ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-47" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> when
  <span class="keyword">:short</span> <span class="string">"@(see b*) control flow operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The @(&#39;when&#39;) binder provides a way to exit early from the sequence
of computations represented by a list of @(see b*) binders.&lt;/p&gt;

&lt;h5&gt;Typical example:&lt;/h5&gt;

@({
    (b* ((lst (some-computation arg1 arg2 ...))
         ((when (atom lst))
          ;; No entries to process, nothing to do, so just return
          ;; nil without building the expensive tbl.
          nil)
         (tbl (build-expensive-table ...)))
      (compute-expensive-result lst tbl ...))
})

&lt;h5&gt;General Form:&lt;/h5&gt;

@({
    (b* (((when (condition-form))
          (early-form1)
          ...
          (early-formN))

         ... rest of bindings ...)
      (late-result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (if (condition-form)
        (progn$ (early-form1)
                ...
                (early-formN))
      (b* (... rest of bindings ...)
        (late-result-form)))
})

&lt;h5&gt;Special Case&lt;/h5&gt;

&lt;p&gt;In the special case where no early-forms are provided, the condition itself
is returned.  I.e.,&lt;/p&gt;

@({
    (b* (((when (condition-form)))
          ... rest of bindings)
      (late-result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (or (condition-form)
        (b* (... rest of bindings ...)
          (late-result-form)))
})"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> (if forms
    `(if ,(CAR ARGS)
      (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)
      ,REST-EXPR)
    `(<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> ,(CAR ARGS) ,REST-EXPR)))</pre>
  </div>

<div class="form-block other" id="form-48" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> if
  <span class="keyword">:short</span> <span class="string">"@(see b*) control flow operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The B* binders @(&#39;if&#39;) and @(&#39;when&#39;) are exactly equivalent.  See
@(see patbind-when) for documentation.  We generally prefer to use @(&#39;when&#39;)
instead of @(&#39;if&#39;).&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> (if forms
    `(if ,(CAR ARGS)
      (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)
      ,REST-EXPR)
    `(<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> ,(CAR ARGS) ,REST-EXPR)))</pre>
  </div>

<div class="form-block other" id="form-49" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> unless
  <span class="keyword">:short</span> <span class="string">"@(see b*) control flow operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see patbind-when).  The B* binder @(&#39;unless&#39;) is identical
except that it negates the condition, so that the early exit is taken when the
condition is false.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> `(if ,(CAR ARGS)
    ,REST-EXPR
    (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)))</pre>
  </div>

<div class="form-block other" id="form-50" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> run-when
  <span class="keyword">:short</span> <span class="string">"@(see b*) conditional execution operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Typical example: this always returns @(&#39;ans&#39;), but sometimes prints
out warning messages:&lt;/p&gt;

@({
     (b* ((ans (some-computation arg1 ... argn))
          ((run-when (&lt; ans 0))
           (cw &quot;Warning: answer was negative?~%&quot;)
           (cw &quot;Args were ~x0, ~x1, ...&quot; arg1 arg2 ...)))
       ans)
})

&lt;p&gt;Usage:&lt;/p&gt;

@({
    (b* (((run-when (condition-form))
          (run-form1)
          ...
          (run-formn)))
      (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (prog2$ (and (condition-form)
                 (progn$ (run-form1)
                         ...
                         (run-formn)))
            (result-form))
})"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> ,(CAR ARGS) (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)) ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-51" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> run-if
  <span class="keyword">:short</span> <span class="string">"@(see b*) conditional execution operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see patbind-run-when).  The B* binders @(&#39;run-if&#39;) and
@(&#39;run-when&#39;) are exactly equivalent.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> ,(CAR ARGS) (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)) ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-52" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> run-unless
  <span class="keyword">:short</span> <span class="string">"@(see b*) conditional execution operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see patbind-run-when).  The B* binder @(&#39;run-unless&#39;) is
exactly like @(&#39;run-when&#39;), except that it negates the condition so that the
extra forms are run when the condition is false.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) nil)))))
  <span class="keyword">:body</span> `(<a class="sym-link system" href="../../../axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> ,(CAR ARGS) (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)) ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-53" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-the" data-sym="THE">the</a>
  <span class="keyword">:parents</span> (b*-binders <a class="sym-link system" href="../../../axioms.html#def-the" data-sym="THE">the</a>)
  <span class="keyword">:short</span> <span class="string">"@(see b*) type declaration operator."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This b* binder provides a concise syntax for type declarations,
which can sometimes improve the efficiency of Common Lisp code.  See the
documentation for @(see declare) and @(see type-spec) for more information
about type declarations.&lt;/p&gt;

&lt;p&gt;Usage example:&lt;/p&gt;

@({
    (b* (((the integer x) (form)))
      (result-form))
})

&lt;p&gt;is equivalent to&lt;/p&gt;

@({
    (let ((x (form)))
      (declare (type integer x))
      (result-form))
})

&lt;p&gt;The @(&#39;the&#39;) binder form only makes sense on variables, though those
variables may be prefixed with the @(&#39;?&#39;) or @(&#39;?!&#39;) to make them ignorable or
ignored.  It may be nested within other binder forms.&lt;/p&gt;"</span>
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-destructure-guard" data-sym="DESTRUCTURE-GUARD" title="(defmacro destructure-guard (binder args bindings len)
  `(and
    (or (and (true-listp ,args) . ,(and len `((= (length ,args) ,len))))
        (cw &quot;~%~%**** ERROR ****
Pattern constructor ~x0 needs a true-list of ~@1arguments, but was given ~x2~%~%&quot;
...">destructure-guard</a> <a class="sym-link system" href="../../../axioms.html#def-the" data-sym="THE">the</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms <span class="number">2</span>)
         (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-translate-declaration-to-guard" data-sym="TRANSLATE-DECLARATION-TO-GUARD">translate-declaration-to-guard</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) 'var nil)
           (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****
The first argument to pattern constructor ~x0 must be a type-spec, but is ~x1~%~%"</span>
             '<a class="sym-link system" href="../../../axioms.html#def-the" data-sym="THE">the</a>
             (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
         (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (symbolp (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
           (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****
The second argument to pattern constructor ~x0 must be a symbol, but is ~x1~%~%"</span>
             '<a class="sym-link system" href="../../../axioms.html#def-the" data-sym="THE">the</a>
             (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))))))
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (sym ignorep)
    (<a class="sym-link local-def" href="#def-decode-varname-for-patbind" data-sym="DECODE-VARNAME-FOR-PATBIND" title="(defun decode-varname-for-patbind (pattern)
  (declare (xargs :guard (symbolp pattern)))
  (let* ((name (symbol-name pattern))
         (len (length name))
         (?p (and (&lt;= 1 len) (eql (char name 0) #\?)))
...">decode-varname-for-patbind</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
    (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> ignorep 'ignore)
      rest-expr
      `(let ((,SYM ,(CAR FORMS)))
        ,@(AND IGNOREP `((DECLARE (IGNORABLE ,SYM))))
        (declare (type ,(CAR ARGS) ,SYM))
        ,REST-EXPR))))</pre>
  </div>

<div class="form-block function" id="def-b_2A-assoc-symbol-name" data-defines="B*-ASSOC-SYMBOL-NAME" data-references="CDR,CAAR,SYMBOL-NAME,EQUAL,CAR,CONSP,ATOM,IF,SYMBOL-ALISTP,STRINGP,AND,XARGS,DECLARE,ALIST,STR,DEFUN" data-used-by="B*-DECOMP-BINDINGS" data-part-name="B*-ASSOC-SYMBOL-NAME" data-part-args="ALIST,STR" data-part-declare="ALIST,SYMBOL-ALISTP,STR,STRINGP,AND,XARGS,DECLARE" data-part-body="CDR,B*-ASSOC-SYMBOL-NAME,CAAR,SYMBOL-NAME,STR,EQUAL,CAR,CONSP,AND,ALIST,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*-ASSOC-SYMBOL-NAME">b*-assoc-symbol-name</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-b_2A-assoc-symbol-name" data-sym="B*-ASSOC-SYMBOL-NAME" title="(defun b*-assoc-symbol-name (str alist)
  (declare (xargs :guard (and (stringp str) (symbol-alistp alist))))
  (if (atom alist)
      nil
      (if (and (consp (car alist)) (equal str (symbol-name (caar alist))))
...">b*-assoc-symbol-name</a>
  (str alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (stringp str) (<a class="sym-link system" href="../../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist))))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> alist)
    nil
    (if (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp (car alist))
        (equal str (symbol-name (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> alist))))
      (car alist)
      (<a class="sym-link local-def" href="#def-b_2A-assoc-symbol-name" data-sym="B*-ASSOC-SYMBOL-NAME" title="(defun b*-assoc-symbol-name (str alist)
  (declare (xargs :guard (and (stringp str) (symbol-alistp alist))))
  (if (atom alist)
      nil
      (if (and (consp (car alist)) (equal str (symbol-name (caar alist))))
...">b*-assoc-symbol-name</a> str (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-b_2A-decomp-err" data-defines="B*-DECOMP-ERR" data-references="STRIP-CARS,B*-DECOMP-BINDINGS,QUOTE,HARD?,ER,ALISTP,XARGS,DECLARE,COMPONENT-ALIST,BINDER,ARG,DEFUN" data-used-by="B*-DECOMP-BINDINGS" data-part-name="B*-DECOMP-ERR" data-part-args="COMPONENT-ALIST,BINDER,ARG" data-part-declare="COMPONENT-ALIST,ALISTP,XARGS,DECLARE" data-part-body="ARG,COMPONENT-ALIST,STRIP-CARS,BINDER,B*-DECOMP-BINDINGS,QUOTE,HARD?,ER" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*-DECOMP-ERR">b*-decomp-err</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a>
  (arg binder component-alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> component-alist)))
  (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
    '<a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a>
    <span class="string">"Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
       name-only where the variable bound is the same as a field name, ~
       or parenthseized (binder :field).  The possible fields are ~v1."</span>
    binder
    (<a class="sym-link system" href="../../../axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> component-alist)
    arg))</pre>
  </div>

<div class="form-block function" id="def-b_2A-decomp-bindings" data-defines="B*-DECOMP-BINDINGS" data-references="CADAR,LENGTH,EQUAL,TRUE-LISTP,AND,SYMBOLP,CDDR,QUASIQUOTE,CONS,CDR,CONSP,B*-DECOMP-ERR,UNLESS,SYMBOL-NAME,B*-ASSOC-SYMBOL-NAME,LOOK,CAR,KEYWORDP,ATOM,WHEN,B*,SYMBOL-ALISTP,XARGS,DECLARE,VAR,COMPONENT-ALIST,BINDER,ARGS,DEFUN" data-used-by="B*-DECOMP-FN,B*-DECOMP-ERR" data-part-name="B*-DECOMP-BINDINGS" data-part-args="VAR,COMPONENT-ALIST,BINDER,ARGS" data-part-declare="COMPONENT-ALIST,SYMBOL-ALISTP,XARGS,DECLARE" data-part-body="CADAR,LENGTH,EQUAL,TRUE-LISTP,AND,SYMBOLP,VAR,CDDR,B*-DECOMP-BINDINGS,QUASIQUOTE,CONS,CDR,CONSP,BINDER,B*-DECOMP-ERR,UNLESS,COMPONENT-ALIST,SYMBOL-NAME,B*-ASSOC-SYMBOL-NAME,LOOK,CAR,KEYWORDP,ARGS,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*-DECOMP-BINDINGS">b*-decomp-bindings</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> binder component-alist var)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> component-alist)))
  (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> (((when (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) nil) ((when (<a class="sym-link system" href="../../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))) (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ((look (<a class="sym-link local-def" href="#def-b_2A-assoc-symbol-name" data-sym="B*-ASSOC-SYMBOL-NAME" title="(defun b*-assoc-symbol-name (str alist)
  (declare (xargs :guard (and (stringp str) (symbol-alistp alist))))
  (if (atom alist)
      nil
      (if (and (consp (car alist)) (equal str (symbol-name (caar alist))))
...">b*-assoc-symbol-name</a> (symbol-name (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
               component-alist)) ((unless look) (<a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist))
            ((unless (consp (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))) (<a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> binder component-alist)))
          (cons `(,(CADR ARGS) (,(CDR LOOK) ,VAR))
            (<a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a> (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist var))))
      ((when (symbolp (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))) (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ((look (<a class="sym-link local-def" href="#def-b_2A-assoc-symbol-name" data-sym="B*-ASSOC-SYMBOL-NAME" title="(defun b*-assoc-symbol-name (str alist)
  (declare (xargs :guard (and (stringp str) (symbol-alistp alist))))
  (if (atom alist)
      nil
      (if (and (consp (car alist)) (equal str (symbol-name (caar alist))))
...">b*-assoc-symbol-name</a> (symbol-name (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
               component-alist)) ((unless look) (<a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist)))
          (cons `(,(CAR ARGS) (,(CDR LOOK) ,VAR))
            (<a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist var))))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
           (equal (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) <span class="number">2</span>)
           (symbolp (<a class="sym-link system" href="../../../axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))) (<a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist))
      (look (<a class="sym-link local-def" href="#def-b_2A-assoc-symbol-name" data-sym="B*-ASSOC-SYMBOL-NAME" title="(defun b*-assoc-symbol-name (str alist)
  (declare (xargs :guard (and (stringp str) (symbol-alistp alist))))
  (if (atom alist)
      nil
      (if (and (consp (car alist)) (equal str (symbol-name (caar alist))))
...">b*-assoc-symbol-name</a> (symbol-name (<a class="sym-link system" href="../../../axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
          component-alist))
      ((unless look) (<a class="sym-link local-def" href="#def-b_2A-decomp-err" data-sym="B*-DECOMP-ERR" title="(defun b*-decomp-err (arg binder component-alist)
  (declare (xargs :guard (alistp component-alist)))
  (er hard? &#39;b*-decomp-bindings
      &quot;Bad ~s0 binding: ~x2.~%For a ~s0 binding you may use the following ~
       kinds of arguments: keyword/value list form :field binder ..., ~
...">b*-decomp-err</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist)))
    (cons `(,(CAAR ARGS) (,(CDR LOOK) ,VAR))
      (<a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) binder component-alist var))))</pre>
  </div>

<div class="form-block function" id="def-b_2A-decomp-fn" data-defines="B*-DECOMP-FN" data-references="QUASIQUOTE,B*-DECOMP-BINDINGS,BINDINGS,B*-DECOMP-TEMP-VAR,SYMBOLP,IF,VAR,CAR,RHS,QUOTE,HARD?,ER,LENGTH,=,TRUE-LISTP,AND,UNLESS,B*,SYMBOL-ALISTP,XARGS,DECLARE,COMPONENT-ALIST,BINDER,REST-EXPR,FORMS,ARGS,DEFUN" data-used-by="DEF-B*-DECOMP" data-part-name="B*-DECOMP-FN" data-part-args="COMPONENT-ALIST,BINDER,REST-EXPR,FORMS,ARGS" data-part-declare="COMPONENT-ALIST,SYMBOL-ALISTP,XARGS,DECLARE" data-part-body="QUASIQUOTE,COMPONENT-ALIST,ARGS,B*-DECOMP-BINDINGS,BINDINGS,B*-DECOMP-TEMP-VAR,SYMBOLP,IF,VAR,CAR,RHS,BINDER,B*-DECOMP-FN,QUOTE,HARD?,ER,LENGTH,=,FORMS,TRUE-LISTP,AND,UNLESS,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="B*-DECOMP-FN">b*-decomp-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-b_2A-decomp-fn" data-sym="B*-DECOMP-FN" title="(defun b*-decomp-fn (args forms rest-expr binder component-alist)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((unless (and (true-listp forms) (= (length forms) 1)))
     (er hard? &#39;b*-decomp-fn &quot;Too many RHS forms in ~x0 binder: ~x1~%&quot; binder
...">b*-decomp-fn</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr binder component-alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> component-alist)))
  (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> (((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> forms) (<a class="sym-link system" href="../../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> forms) <span class="number">1</span>))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
         '<a class="sym-link local-def" href="#def-b_2A-decomp-fn" data-sym="B*-DECOMP-FN" title="(defun b*-decomp-fn (args forms rest-expr binder component-alist)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((unless (and (true-listp forms) (= (length forms) 1)))
     (er hard? &#39;b*-decomp-fn &quot;Too many RHS forms in ~x0 binder: ~x1~%&quot; binder
...">b*-decomp-fn</a>
         <span class="string">"Too many RHS forms in ~x0 binder: ~x1~%"</span>
         binder
         forms)) (rhs (car forms))
      (var (if (symbolp rhs)
          rhs
          'b*-decomp-temp-var))
      (bindings (<a class="sym-link local-def" href="#def-b_2A-decomp-bindings" data-sym="B*-DECOMP-BINDINGS" title="(defun b*-decomp-bindings (args binder component-alist var)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((when (atom args)) nil)
    ((when (keywordp (car args)))
...">b*-decomp-bindings</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> binder component-alist var)))
    `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,(IF (SYMBOLP RHS)
     BINDINGS
     (CONS `(,VAR ,RHS) BINDINGS))
      ,REST-EXPR)))</pre>
  </div>

<div class="form-block macro" id="def-def-b_2A-decomp" data-defines="DEF-B*-DECOMP" data-references="QUOTE,REST-EXPR,FORMS,ARGS,B*-DECOMP-FN,DEF-B*-BINDER,QUASIQUOTE,COMPONENT-ALIST,&REST,NAME,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEF-B*-DECOMP">def-b*-decomp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-def-b_2A-decomp" data-sym="DEF-B*-DECOMP" title="(defmacro def-b*-decomp (name &amp;rest component-alist)
  `(def-b*-binder ,name :body
    (b*-decomp-fn args forms rest-expr &#39;,name &#39;,component-alist)))">def-b*-decomp</a>
  (name &amp;rest component-alist)
  `(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> ,NAME
    <span class="keyword">:body</span> (<a class="sym-link local-def" href="#def-b_2A-decomp-fn" data-sym="B*-DECOMP-FN" title="(defun b*-decomp-fn (args forms rest-expr binder component-alist)
  (declare (xargs :guard (symbol-alistp component-alist)))
  (b*
   (((unless (and (true-listp forms) (= (length forms) 1)))
     (er hard? &#39;b*-decomp-fn &quot;Too many RHS forms in ~x0 binder: ~x1~%&quot; binder
...">b*-decomp-fn</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr ',NAME ',COMPONENT-ALIST)))</pre>
  </div>

<div class="form-block function" id="def-patbind-local-stobjs-helper" data-defines="PATBIND-LOCAL-STOBJS-HELPER" data-references="MV-LET,WITH-LOCAL-STOBJ,QUASIQUOTE,CDR,REMOVE-EQ,REST-RETVALS,CAAR,CAR,CONSP,STOBJ,LET*,ATOM,IF,XARGS,DECLARE,FORM,RETVALS,STOBJS,DEFUN" data-used-by="PATBIND-LOCAL-STOBJS-FN" data-part-name="PATBIND-LOCAL-STOBJS-HELPER" data-part-args="FORM,RETVALS,STOBJS" data-part-declare="XARGS,DECLARE" data-part-body="MV-LET,WITH-LOCAL-STOBJ,QUASIQUOTE,CDR,PATBIND-LOCAL-STOBJS-HELPER,RETVALS,REMOVE-EQ,REST-RETVALS,CAAR,CAR,CONSP,STOBJ,LET*,FORM,STOBJS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATBIND-LOCAL-STOBJS-HELPER">patbind-local-stobjs-helper</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-patbind-local-stobjs-helper" data-sym="PATBIND-LOCAL-STOBJS-HELPER" title="(defun patbind-local-stobjs-helper (stobjs retvals form)
  (declare (xargs :mode :program))
  (if (atom stobjs)
      form
      (let* ((stobj
...">patbind-local-stobjs-helper</a>
  (stobjs retvals form)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> stobjs)
    form
    (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((stobj (if (consp (car stobjs))
           (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> stobjs)
           (car stobjs))) (rest-retvals (<a class="sym-link system" href="../../../axioms.html#def-remove-eq" data-sym="REMOVE-EQ">remove-eq</a> stobj retvals)))
      (<a class="sym-link local-def" href="#def-patbind-local-stobjs-helper" data-sym="PATBIND-LOCAL-STOBJS-HELPER" title="(defun patbind-local-stobjs-helper (stobjs retvals form)
  (declare (xargs :mode :program))
  (if (atom stobjs)
      form
      (let* ((stobj
...">patbind-local-stobjs-helper</a> (cdr stobjs)
        rest-retvals
        `(with-local-stobj ,STOBJ
          (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> ,RETVALS
            ,FORM
            ,(IF (CONSP (CDR REST-RETVALS))
     `(MV . ,REST-RETVALS)
     (CAR REST-RETVALS))) . ,(AND (CONSP (CAR STOBJS)) (CDAR STOBJS)))))))</pre>
  </div>

<div class="form-block function" id="def-patbind-local-stobj-arglistp" data-defines="PATBIND-LOCAL-STOBJ-ARGLISTP" data-references="CDR,CREATOR,STOBJ,CASE-MATCH,SYMBOLP,OR,CAR,X,LET,AND,EQ,ATOM,IF,XARGS,DECLARE,ARGS,DEFUN" data-used-by="PATBIND-LOCAL-STOBJS-FN" data-part-name="PATBIND-LOCAL-STOBJ-ARGLISTP" data-part-args="ARGS" data-part-declare="XARGS,DECLARE" data-part-body="CDR,PATBIND-LOCAL-STOBJ-ARGLISTP,CREATOR,STOBJ,CASE-MATCH,SYMBOLP,OR,CAR,X,LET,AND,EQ,ARGS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATBIND-LOCAL-STOBJ-ARGLISTP">patbind-local-stobj-arglistp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-patbind-local-stobj-arglistp" data-sym="PATBIND-LOCAL-STOBJ-ARGLISTP" title="(defun patbind-local-stobj-arglistp (args)
  (declare (xargs :mode :program))
  (if (atom args)
      (eq args nil)
      (and
...">patbind-local-stobj-arglistp</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> nil)
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (let ((x (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
        (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (symbolp x)
          (<a class="sym-link system" href="../../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> x
            ((stobj creator) (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (symbolp stobj) (symbolp creator))))))
      (<a class="sym-link local-def" href="#def-patbind-local-stobj-arglistp" data-sym="PATBIND-LOCAL-STOBJ-ARGLISTP" title="(defun patbind-local-stobj-arglistp (args)
  (declare (xargs :mode :program))
  (if (atom args)
      (eq args nil)
      (and
...">patbind-local-stobj-arglistp</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))))</pre>
  </div>

<div class="form-block function" id="def-patbind-local-stobjs-fn" data-defines="PATBIND-LOCAL-STOBJS-FN" data-references="PATBIND-LOCAL-STOBJS-HELPER,CDAR,RETVALS,MV,CAAR,EQ,CAR,SYMBOL-LISTP,LEN,=,AND,QUOTE,HARD?,ER,PATBIND-LOCAL-STOBJ-ARGLISTP,UNLESS,B*,XARGS,DECLARE,REST-EXPR,FORMS,ARGS,DEFUN" data-part-name="PATBIND-LOCAL-STOBJS-FN" data-part-args="REST-EXPR,FORMS,ARGS" data-part-declare="XARGS,DECLARE" data-part-body="REST-EXPR,PATBIND-LOCAL-STOBJS-HELPER,CDAR,RETVALS,MV,CAAR,EQ,CAR,SYMBOL-LISTP,FORMS,LEN,=,AND,PATBIND-LOCAL-STOBJS-FN,QUOTE,HARD?,ER,ARGS,PATBIND-LOCAL-STOBJ-ARGLISTP,UNLESS,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PATBIND-LOCAL-STOBJS-FN">patbind-local-stobjs-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-patbind-local-stobjs-fn" data-sym="PATBIND-LOCAL-STOBJS-FN" title="(defun patbind-local-stobjs-fn (args forms rest-expr)
  (declare (xargs :mode :program))
  (b*
   (((unless (patbind-local-stobj-arglistp args))
     (er hard? &#39;patbind-local-stobjs-fn
...">patbind-local-stobjs-fn</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> (((unless (<a class="sym-link local-def" href="#def-patbind-local-stobj-arglistp" data-sym="PATBIND-LOCAL-STOBJ-ARGLISTP" title="(defun patbind-local-stobj-arglistp (args)
  (declare (xargs :mode :program))
  (if (atom args)
      (eq args nil)
      (and
...">patbind-local-stobj-arglistp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
         '<a class="sym-link local-def" href="#def-patbind-local-stobjs-fn" data-sym="PATBIND-LOCAL-STOBJS-FN" title="(defun patbind-local-stobjs-fn (args forms rest-expr)
  (declare (xargs :mode :program))
  (b*
   (((unless (patbind-local-stobj-arglistp args))
     (er hard? &#39;patbind-local-stobjs-fn
...">patbind-local-stobjs-fn</a>
         <span class="string">"In local-stobjs b* binder, arguments must be symbols or
      (stobj creator) pairs"</span>)) ((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> forms) <span class="number">1</span>)
           (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> (car forms))
           (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> forms) '<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a>))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-patbind-local-stobjs-fn" data-sym="PATBIND-LOCAL-STOBJS-FN" title="(defun patbind-local-stobjs-fn (args forms rest-expr)
  (declare (xargs :mode :program))
  (b*
   (((unless (patbind-local-stobj-arglistp args))
     (er hard? &#39;patbind-local-stobjs-fn
...">patbind-local-stobjs-fn</a>
          <span class="string">"In local-stobjs b* binder, bound form must be an MV
              of some symbols, giving the return values"</span>))
      (retvals (<a class="sym-link system" href="../../../axioms.html#def-cdar" data-sym="CDAR">cdar</a> forms)))
    (<a class="sym-link local-def" href="#def-patbind-local-stobjs-helper" data-sym="PATBIND-LOCAL-STOBJS-HELPER" title="(defun patbind-local-stobjs-helper (stobjs retvals form)
  (declare (xargs :mode :program))
  (if (atom stobjs)
      form
      (let* ((stobj
...">patbind-local-stobjs-helper</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> retvals rest-expr)))</pre>
  </div>

<div class="form-block other" id="form-62" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> local-stobjs
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for @(see with-local-stobj) declarations."</span>
  <span class="keyword">:body</span> (<a class="sym-link local-def" href="#def-patbind-local-stobjs-fn" data-sym="PATBIND-LOCAL-STOBJS-FN" title="(defun patbind-local-stobjs-fn (args forms rest-expr)
  (declare (xargs :mode :program))
  (b*
   (((unless (patbind-local-stobj-arglistp args))
     (er hard? &#39;patbind-local-stobjs-fn
...">patbind-local-stobjs-fn</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> forms rest-expr))</pre>
  </div>

<div class="form-block function" id="def-match-b_2A-fun-args" data-defines="MATCH-B*-FUN-ARGS" data-references="QUASIQUOTE,COND,DECLS,ARGS,CAR,FN,LET*,SECOND,CDDR,NOT,CDR,CONSP,NOTINLINE,INLINE,QUOTE,FIRST,EQ,OR,AND,FN/ARGS-PART,LET,MV,ATOM,IF,T,XARGS,DECLARE,X,DEFUN" data-part-name="MATCH-B*-FUN-ARGS" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="T,DECLARE,QUASIQUOTE,COND,DECLS,ARGS,CAR,FN,LET*,SECOND,CDDR,NOT,CDR,CONSP,NOTINLINE,INLINE,QUOTE,FIRST,EQ,OR,AND,FN/ARGS-PART,LET,MV,X,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCH-B*-FUN-ARGS">match-b*-fun-args</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-match-b_2A-fun-args" data-sym="MATCH-B*-FUN-ARGS" title="(defun match-b*-fun-args (x)
  (declare (xargs :guard t))
  (if (atom x)
      (mv nil nil nil nil)
      (let ((fn/args-part
...">match-b*-fun-args</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)
    (let ((fn/args-part (if (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-first" data-sym="FIRST">first</a> x) 'inline) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-first" data-sym="FIRST">first</a> x) 'notinline))
             (consp (cdr x))
             (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> x)))
           (<a class="sym-link system" href="../../../axioms.html#def-second" data-sym="SECOND">second</a> x)
           (<a class="sym-link system" href="../../../axioms.html#def-first" data-sym="FIRST">first</a> x))))
      (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> fn/args-part)
        (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil)
        (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (car fn/args-part)) (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> (cdr fn/args-part))
            (decls (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car x) 'inline) `((declare (inline ,FN))))
                ((<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car x) 'notinline) `((declare (notinline ,FN))))
                (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> nil))))
          (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> fn <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> decls))))))</pre>
  </div>

<div class="form-block other" id="form-64" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> fun
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder to produce @(see flet) forms."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

@({
    (b* (((fun (add a b)) (+ a b)))
      (add 3 4))
})

&lt;p&gt;More generally,&lt;/p&gt;

@({
    (b* (((fun (name arg1 ... argn)) body-form))
      result-form)
})

&lt;p&gt;expands to&lt;/p&gt;

@({
    (flet ((name (arg1 ... argn) body-form))
      result-form)
})

&lt;p&gt;You can also provide an @(&#39;inline&#39;) or @(&#39;notinline&#39;) suggestion, e.g.,:&lt;/p&gt;

@({
    (b* (((fun inline (add a b)) (+ a b)))
      (add 3 4))

    (b* (((fun notinline (add a b)) (+ a b)))
      (add 3 4))
})

&lt;p&gt;Either of these results in a suitable @(see declare) form for the function;
see @(see flet) for more discussion.&lt;/p&gt;"</span>
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (okp fn <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> decls)
    (<a class="sym-link local-def" href="#def-match-b_2A-fun-args" data-sym="MATCH-B*-FUN-ARGS" title="(defun match-b*-fun-args (x)
  (declare (xargs :guard t))
  (if (atom x)
      (mv nil nil nil nil)
      (let ((fn/args-part
...">match-b*-fun-args</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> okp) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid b* binder FUN binder (see :doc patbind-fun): ~x0~%"</span>
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp fn)) (<a class="sym-link system" href="../../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> fn) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> fn <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> fn nil)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid function name ~x0 in b* FUN binder: ~x1~%"</span>
          fn
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid formals for b* FUN binder of ~x0: ~x1~%"</span>
          fn
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> `(flet ((,FN ,ARGS (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)))
          ,@DECLS
          ,REST-EXPR)))))</pre>
  </div>

<div class="form-block other" id="form-65" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> macro
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder to produce @(see macrolet) forms."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Example:&lt;/p&gt;

@({
    (b* (((macro (add a b)) `(+ ,a ,b)))
      (add x y))
})

&lt;p&gt;More generally,&lt;/p&gt;

@({
    (b* (((macro (name arg1 ... argn)) body-form))
      result-form)
})

&lt;p&gt;expands to&lt;/p&gt;

@({
    (macrolet ((name (arg1 ... argn) body-form))
      result-form)
})

&lt;p&gt;You can also provide an @(&#39;inline&#39;) or @(&#39;notinline&#39;) suggestion, e.g.,:&lt;/p&gt;

@({
    (b* (((macro inline (add a b)) `(+ ,a ,b)))
      (add 3 4))

    (b* (((macro notinline (add a b)) `(+ ,a ,b)))
      (add 3 4))
})

&lt;p&gt;Either of these results in a suitable @(see declare) form for the macro,
although these are unlikely to have any effect (see @(see macrolet)).&lt;/p&gt;"</span>
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (okp fn <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> decls)
    (<a class="sym-link local-def" href="#def-match-b_2A-fun-args" data-sym="MATCH-B*-FUN-ARGS" title="(defun match-b*-fun-args (x)
  (declare (xargs :guard t))
  (if (atom x)
      (mv nil nil nil nil)
      (let ((fn/args-part
...">match-b*-fun-args</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> okp) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid b* binder MACRO binder (see :doc patbind-macro): ~x0~%"</span>
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (symbolp fn)) (<a class="sym-link system" href="../../../axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> fn) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> fn <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> fn nil)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid macro name ~x0 in b* MACRO binder: ~x1~%"</span>
          fn
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a>
          <span class="string">"Invalid formals for b* MACRO binder of ~x0: ~x1~%"</span>
          fn
          <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> `(macrolet ((,FN ,ARGS (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS)))
          ,@DECLS
          ,REST-EXPR)))))</pre>
  </div>

<div class="form-block function" id="def-access-binder-element-p" data-defines="ACCESS-BINDER-ELEMENT-P" data-references="CDDR,NOT,CADR,CAR,CDR,CONSP,AND,SYMBOLP,OR,T,XARGS,DECLARE,X,DEFUN" data-used-by="ACCESS-BINDER-LISTP" data-part-name="ACCESS-BINDER-ELEMENT-P" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="CDDR,NOT,CADR,CAR,CDR,CONSP,AND,X,SYMBOLP,OR" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCESS-BINDER-ELEMENT-P">access-binder-element-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-access-binder-element-p" data-sym="ACCESS-BINDER-ELEMENT-P" title="(defun access-binder-element-p (x)
  (declare (xargs :guard t))
  (or (symbolp x)
      (and (consp x) (consp (cdr x)) (symbolp (car x)) (symbolp (cadr x))
           (not (cddr x)))))">access-binder-element-p</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (symbolp x)
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
      (consp (cdr x))
      (symbolp (car x))
      (symbolp (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> x)))))</pre>
  </div>

<div class="form-block function" id="def-access-binder-listp" data-defines="ACCESS-BINDER-LISTP" data-references="CDR,CAR,ACCESS-BINDER-ELEMENT-P,AND,EQ,ATOM,IF,T,XARGS,DECLARE,X,DEFUN" data-used-by="ACCESS-B*-BINDINGS" data-part-name="ACCESS-BINDER-LISTP" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,ACCESS-BINDER-LISTP,CAR,ACCESS-BINDER-ELEMENT-P,AND,EQ,X,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCESS-BINDER-LISTP">access-binder-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-access-binder-listp" data-sym="ACCESS-BINDER-LISTP" title="(defun access-binder-listp (x)
  (declare (xargs :guard t))
  (if (atom x)
      (eq x nil)
      (and (access-binder-element-p (car x)) (access-binder-listp (cdr x)))))">access-binder-listp</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> x nil)
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-access-binder-element-p" data-sym="ACCESS-BINDER-ELEMENT-P" title="(defun access-binder-element-p (x)
  (declare (xargs :guard t))
  (or (symbolp x)
      (and (consp x) (consp (cdr x)) (symbolp (car x)) (symbolp (cadr x))
           (not (cddr x)))))">access-binder-element-p</a> (car x))
      (<a class="sym-link local-def" href="#def-access-binder-listp" data-sym="ACCESS-BINDER-LISTP" title="(defun access-binder-listp (x)
  (declare (xargs :guard t))
  (if (atom x)
      (eq x nil)
      (and (access-binder-element-p (car x)) (access-binder-listp (cdr x)))))">access-binder-listp</a> (cdr x)))))</pre>
  </div>

<div class="form-block function" id="def-access-b_2A-bindings" data-defines="ACCESS-B*-BINDINGS" data-references="CDR,CAAR,ACCESS,QUASIQUOTE,LIST,CAR,CONS,ATOM,IF,ACCESS-BINDER-LISTP,SYMBOLP,AND,XARGS,DECLARE,PAIRS,VAR,RECNAME,DEFUN" data-part-name="ACCESS-B*-BINDINGS" data-part-args="PAIRS,VAR,RECNAME" data-part-declare="PAIRS,ACCESS-BINDER-LISTP,RECNAME,SYMBOLP,AND,XARGS,DECLARE" data-part-body="CDR,VAR,RECNAME,ACCESS-B*-BINDINGS,CAAR,ACCESS,QUASIQUOTE,LIST,CAR,CONS,PAIRS,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCESS-B*-BINDINGS">access-b*-bindings</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-access-b_2A-bindings" data-sym="ACCESS-B*-BINDINGS" title="(defun access-b*-bindings (recname var pairs)
  (declare (xargs :guard (and (symbolp recname) (access-binder-listp pairs))))
  (if (atom pairs)
      nil
      (cons
...">access-b*-bindings</a>
  (recname var pairs)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (symbolp recname) (<a class="sym-link local-def" href="#def-access-binder-listp" data-sym="ACCESS-BINDER-LISTP" title="(defun access-binder-listp (x)
  (declare (xargs :guard t))
  (if (atom x)
      (eq x nil)
      (and (access-binder-element-p (car x)) (access-binder-listp (cdr x)))))">access-binder-listp</a> pairs))))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> pairs)
    nil
    (cons (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (car pairs))
        (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (car pairs)
          `(<a class="sym-link system" href="../../../axioms.html#def-access" data-sym="ACCESS">access</a> ,RECNAME
            ,VAR
            ,(INTERN-IN-PACKAGE-OF-SYMBOL (SYMBOL-NAME (CAR PAIRS)) :KEYWORD)))
        (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> pairs)
          `(<a class="sym-link system" href="../../../axioms.html#def-access" data-sym="ACCESS">access</a> ,RECNAME
            ,VAR
            ,(INTERN-IN-PACKAGE-OF-SYMBOL (SYMBOL-NAME (CADAR PAIRS)) :KEYWORD))))
      (<a class="sym-link local-def" href="#def-access-b_2A-bindings" data-sym="ACCESS-B*-BINDINGS" title="(defun access-b*-bindings (recname var pairs)
  (declare (xargs :guard (and (symbolp recname) (access-binder-listp pairs))))
  (if (atom pairs)
      nil
      (cons
...">access-b*-bindings</a> recname var (cdr pairs)))))</pre>
  </div>

<div class="form-block other" id="form-69" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> <a class="sym-link system" href="../../../axioms.html#def-access" data-sym="ACCESS">access</a>
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for accessing record structure fields introduced
  with ACL2&#39;s @(&#39;defrec&#39;)."</span>
  <span class="keyword">:body</span> `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,(ACCESS-B*-BINDINGS (CAR ARGS) (CAR FORMS) (CDR ARGS))
    ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-70" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link local-def" href="#def-def-b_2A-binder" data-sym="DEF-B*-BINDER" title="(defmacro def-b*-binder
          (name
           &amp;key (parents &#39;nil parents-p) (short &#39;nil short-p)
           (long &#39;nil long-p) decls body)
  (let* ((macro-name (macro-name-for-patbind name))
...">def-b*-binder</a> unless-casematch
  <span class="keyword">:short</span> <span class="string">"@(see b*) binder for using @(see case-match) against a single pattern."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The following example shows the usage of @(&#39;unless-casematch&#39;)
inside a @(see b*) form.  @(&#39;pattern&#39;) is a pattern for @(see case-match).&lt;/p&gt;
@({
 (b* (((unless-casematch obj (a . b))
       (er hard? &#39;my-form &quot;Expected obj to match (a . b) but it didn&#39;t&quot;)))
    (cw &quot;The car is ~x0 and the cdr is ~x1~%&quot; a b))
 })
&lt;p&gt;This expands to:&lt;/p&gt;
@({
 (case-match obj
   ((a . b) (cw &quot;The car is ~x0 and the cdr is ~x1~%&quot; a b))
   (&amp; (er hard? &#39;my-form &quot;Expected obj to match (a . b) but it didn&#39;t&quot;)))
 })
"</span>
  <span class="keyword">:body</span> (<a class="sym-link system" href="../../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>
    ((form pattern) (<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> (((<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> pre-bindings var <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>) (if (symbolp form)
             (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> nil form rest-expr)
             (<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> `((?__tmp-for-unless-casematch ,FORM))
               '__tmp-for-unless-casematch
               `(<a class="sym-link system" href="../../../axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (__tmp-for-unless-casematch)
                 ,REST-EXPR)))))
        `(<a class="sym-link local-def" href="#def-b_2A" data-sym="B*" title="(defmacro b* (bindlist expr &amp;rest exprs)
  (declare (xargs :guard (debuggable-binders-p bindlist)))
  (b*-fn bindlist (cons expr exprs)))">b*</a> ,PRE-BINDINGS
          (<a class="sym-link system" href="../../../basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> ,VAR (,PATTERN ,REST) (&amp; (<a class="sym-link system" href="../../../axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> . ,FORMS))))))
    (&amp; (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
        'unless-casematch
        <span class="string">"Unless-casematch takes two args: ~x0"</span>
        '(unless-casematch form pattern)))))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>