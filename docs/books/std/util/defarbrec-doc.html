<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>defarbrec-doc - ACL2 Book</title>
  <meta property="name" content="defarbrec-doc">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">‚òÄÔ∏è</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">defarbrec-doc</h1>
    <div class="path"><a href="defarbrec-doc.lisp" class="source-link">books/std/util/defarbrec-doc</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../../kestrel/event-macros/xdoc-constructors.html" title="kestrel/event-macros/xdoc-constructors">xdoc-constructors</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../kestrel/event-macros/xdoc-constructors.html" title="Open kestrel/event-macros/xdoc-constructors">"kestrel/event-macros/xdoc-constructors"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block constant" id="def-_2Adefarbrec-design-notes_2A" data-defines="*DEFARBREC-DESIGN-NOTES*" data-references="AHREF,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*DEFARBREC-DESIGN-NOTES*">*defarbrec-design-notes*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
  (ahref <span class="string">"res/std-util-design-notes/defarbrec.pdf"</span>
    <span class="string">"design notes"</span>))</pre>
  </div>

<div class="form-block constant" id="def-_2Anotation-design-notes_2A" data-defines="*NOTATION-DESIGN-NOTES*" data-references="AHREF,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*NOTATION-DESIGN-NOTES*">*notation-design-notes*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Anotation-design-notes_2A" data-sym="*NOTATION-DESIGN-NOTES*" title="(defconst *notation-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/notation.pdf&quot; &quot;notation&quot;))">*notation-design-notes*</a>
  (ahref <span class="string">"res/std-util-design-notes/notation.pdf"</span>
    <span class="string">"notation"</span>))</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc defarbrec
  <span class="keyword">:parents</span> (std/util)
  <span class="keyword">:short</span> <span class="string">"Introduce an arbitrarily recursive function."</span>
  <span class="keyword">:long</span> (topstring (evmac-section-intro (p <span class="string">"Given a recursive program-mode function
      that only calls logic-mode functions (besides calling itself)
      and that may not terminate,
      it is possible (under some conditions)
      to construct a logic-mode ``version&#39;&#39; of that function
      by explicitly testing for termination, via a non-executable predicate.
      The resulting logic-mode function is ``equivalent&#39;&#39;
      to the program-mode function when the latter terminates."</span>)
      (p <span class="string">"The resulting logic-mode function can be subjected to
      formal verification and "</span>
        (seetopic <span class="string">"apt::apt"</span> <span class="string">"transformation"</span>)
        <span class="string">". In particular, if it can be proved that
      the termination test holds on every argument value,
      then the termination test can be transformed away
      (e.g. via a simplification transformation),
      obtaining a simpler, provably equivalent logic-mode function,
      which may be executable
      if the initial program-mode function was executable.
      If termination can be proved only on some argument values instead,
      the domain of the function can be restricted to those values
      (e.g. via @(tsee apt::restrict)),
      and then the termination test can be transformed away
      in the restricted domain."</span>)
      (p <span class="string">"Constructing the logic-mode function with the explicit termination test
      may be useful in program verification.
      The starting program-mode function could be the object of verification,
      or it may represent, in ACL2,
      a recursive or iterative program (fragment), in some programming language,
      that is the object of verification.
      Instead of having to prove termination right away
      in order to make the function amenable to any formal verification in ACL2,
      constructing a logic-mode function with an explicit termination test
      enables the ``deferral&#39;&#39; of the termination proof.
      The termination of certain programs may depend on
      fairly deep semantic properties of the programs
      (to the point of being inter-related with functional correctness):
      in these cases,
      it may be natural to prove these properties along with termination,
      instead of having to prove termination alone first."</span>)
      (p <span class="string">"The @(&#39;defarbrec&#39;) macro
      (for `&lt;b&gt;def&lt;/b&gt;ine &lt;b&gt;arb&lt;/b&gt;itrary &lt;b&gt;rec&lt;/b&gt;ursion&#39;)
      constructs the logic-mode function with the explicit termination test,
      from a specified program-mode function.
      The program-mode function is specified as
      a name, a list of arguments, and a body (as in @(tsee defun)):
      @(&#39;defarbrec&#39;) constructs the program-mode function on the fly,
      uses it to construct the logic-mode function,
      which has the same name and arguments,
      discards the program-mode function
      (absent from the @(see world) after @(&#39;defarbrec&#39;) completes),
      and retains the logic-mode function
      (present in the @(see world) after @(&#39;defarbrec&#39;) completes)."</span>)
      (p <span class="string">"The current implementation only works
      with program-mode functions that make one recursive call
      (so in this sense it does not support truly arbitrary recursion,
      but the `arbitrary&#39; here refers to avoiding to prove termination),
      but it should be possible to extend the macro to handle functions that
      make multiple different recursive calls.
      The current implementation does not support guards yet,
      but it should be possible to add suitable support."</span>)
      (p <span class="string">"The fact that the program-mode function is constructed by @(&#39;defarbrec&#39;)
      ensures that it satisfies certain well-formedness constraints,
      e.g. calling only existing functions
      with arguments whose numbers match the functions&#39; arities.
      This ensures that the generated logic-mode function
      satisfies the same well-formedness constraints."</span>)
      (p <span class="string">"These "</span>
        <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
        <span class="string">", which use this "</span>
        <a class="sym-link local-def" href="#def-_2Anotation-design-notes_2A" data-sym="*NOTATION-DESIGN-NOTES*" title="(defconst *notation-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/notation.pdf&quot; &quot;notation&quot;))">*notation-design-notes*</a>
        <span class="string">", provide the mathematical concepts and template proofs
      upon which this tool is based.
      These notes should be read alongside this reference documentation,
      which refers to the them in numerous places."</span>))
    (evmac-section-form (codeblock <span class="string">"(defarbrec fn (x1 ... xn)"</span>
        <span class="string">"  body"</span>
        <span class="string">"  :update-names    ...  ; default nil"</span>
        <span class="string">"  :terminates-name ...  ; default nil"</span>
        <span class="string">"  :measure-name    ...  ; default nil"</span>
        <span class="string">"  :nonterminating  ...  ; default :nonterminating"</span>
        <span class="string">"  :print           ...  ; default :result"</span>
        <span class="string">"  :show-only       ...  ; default nil"</span>
        <span class="string">"  )"</span>))
    (evmac-section-inputs (desc <span class="string">"@(&#39;fn&#39;)"</span>
        (p <span class="string">"Name of the function to introduce."</span>)
        (p <span class="string">"This is as in @(tsee defun)."</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       the program-mode @(&#39;fn&#39;) is denoted by @($f$),
       while the logic-mode @(&#39;fn&#39;) is denoted by @($\hat{f}$)."</span>))
      (desc <span class="string">"@(&#39;x1 ... xn&#39;)"</span>
        (p <span class="string">"Formal arguments of the function to introduce."</span>)
        (p <span class="string">"These are as in @(tsee defun),
       but in addition they must not include any"</span>
          (seetopic <span class="string">"acl2::stobj"</span> <span class="string">"stobjs"</span>)
          <span class="string">"."</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       @(&#39;x1&#39;), ..., @(&#39;xn&#39;) are denoted by @($x_1,\ldots,x_n$),
       or @($\overline{x}$) as a whole."</span>))
      (desc <span class="string">"@(&#39;body&#39;)"</span>
        (p <span class="string">"Body of the program-mode function;
       the logic-mode function has a body based on this one."</span>)
        (p <span class="string">"This is as in @(tsee defun),
       but with the following additional constraints."</span>)
        (p <span class="string">"The program-mode function must
       contain a single recursive call,
       only call logic-mode functions (besides itself),
       return a non-"</span>
          (seetopic <span class="string">"mv"</span> <span class="string">"multiple"</span>)
          <span class="string">" value, and
       have no input or output "</span>
          (seetopic <span class="string">"acl2::stobj"</span> <span class="string">"stobjs"</span>)
          <span class="string">"."</span>)
        (p <span class="string">"In the rest of this documentation page, for expository convenience,
       it is assumed that the program-mode function has the following form:"</span>)
        (codeblock <span class="string">"(defun fn (x1 ... xn)"</span>
          <span class="string">"  (if test&lt;x1,...,xn&gt;"</span>
          <span class="string">"      base&lt;x1,...,xn&gt;"</span>
          <span class="string">"    combine&lt;x1,...,xn,(fn update-x1&lt;x1,...,xn&gt;"</span>
          <span class="string">"                          ..."</span>
          <span class="string">"                          update-xn&lt;x1,...,xn&gt;)&gt;))"</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       @(&#39;test&lt;x1,...,xn&gt;&#39;) is denoted by @($a(\overline{x})$),
       @(&#39;base&lt;x1,...,xn&gt;&#39;) is denoted by @($b(\overline{x})$),
       @(&#39;combine&lt;x1,...,xn,y&gt;&#39;) is denoted by @($c(\overline{x},y)$), and
       each @(&#39;update-xi&lt;x1,...,xn&gt;&#39;) is denoted by @($d_i(\overline{x})$)
       for @($1 \leq i \leq n$)."</span>))
      (desc <span class="string">"@(&#39;:update-names&#39;) &amp;mdash; default @(&#39;nil&#39;)"</span>
        (p <span class="string">"Determines the names of the generated iterated argument update functions,
       i.e. the functions that iterate the updates of the arguments
       in the recursive call of the program-mode function
       (see the `Generated Functions&#39; section below)."</span>)
        (p <span class="string">"It must be one of the following:"</span>)
        (ul (li <span class="string">"@(&#39;nil&#39;), to use, for each argument @(&#39;xi&#39;):
        @(&#39;fn&#39;),
        followed by @(&#39;-&#39;),
        followed by @(&#39;xi&#39;),
        followed by @(&#39;*&#39;);
        the symbols are in the same package as @(&#39;fn&#39;)."</span>)
          (li <span class="string">"A @(&#39;nil&#39;)-terminated list of @(&#39;n&#39;) distinct symbols
        (that are not in the main Lisp package and that are not keywords),
        to use as the names of the functions."</span>))
        (p <span class="string">"In the rest of this documentation page,
       let @(&#39;update*-x1&#39;), ..., @(&#39;update*-xn&#39;) be
       the names of these functions."</span>))
      (desc <span class="string">"@(&#39;:terminates-name&#39;) &amp;mdash; default @(&#39;nil&#39;)"</span>
        (p <span class="string">"Determines the name of the generated predicate
       that tests whether the program-mode function terminates."</span>)
        (p <span class="string">"It must be one of the following:"</span>)
        (ul (li <span class="string">"@(&#39;nil&#39;), to use @(&#39;fn&#39;) followed by @(&#39;-terminates&#39;);
        the symbol is in the same package as @(&#39;fn&#39;)."</span>)
          (li <span class="string">"Any other symbol
        (that is not in the main Lisp package and that is not a keyword),
        to use as the name of the predicate."</span>))
        (p <span class="string">"In the rest of this documentation page,
       let @(&#39;terminates&#39;) be the name of this predicate."</span>))
      (desc <span class="string">"@(&#39;:measure-name&#39;) &amp;mdash; default @(&#39;nil&#39;)"</span>
        (p <span class="string">"Determines the name of the generated measure function
       of the logic-mode function."</span>)
        (p <span class="string">"It must be one of the following:"</span>)
        (ul (li <span class="string">"@(&#39;nil&#39;), to use @(&#39;fn&#39;) followed by @(&#39;-measure&#39;);
        the symbol is in the same package as @(&#39;fn&#39;)."</span>)
          (li <span class="string">"Any other symbol
        (that is not in the main Lisp package and that is not a keyword),
        to use as the name of the measure function."</span>))
        (p <span class="string">"In the rest of this documentation page,
       let @(&#39;measure&#39;) be the name of this function."</span>))
      (desc <span class="string">"@(&#39;:nonterminating&#39;) &amp;mdash; default @(&#39;:nonterminating&#39;)"</span>
        (p <span class="string">"Specifies the value that the logic-mode function returns
       when the program-mode function does not terminate."</span>)
        (p <span class="string">"It must be a term
       that includes no free variables other than @(&#39;x1&#39;), ..., @(&#39;xn&#39;),
       that only calls logic-mode functions,
       that returns a non-"</span>
          (seetopic <span class="string">"mv"</span> <span class="string">"multiple"</span>)
          <span class="string">" value,
       and that has no output "</span>
          (seetopic <span class="string">"acl2::stobj"</span> <span class="string">"stobjs"</span>)
          <span class="string">"."</span>)
        (p <span class="string">"In the rest of this documentation page,
       let @(&#39;nonterminating&#39;) be this term."</span>))
      (desc <span class="string">"@(&#39;:print&#39;) &amp;mdash; default @(&#39;:result&#39;)"</span>
        (p <span class="string">"Customizes the screen output."</span>)
        (p <span class="string">"It must be one of the following:"</span>)
        (ul (li <span class="string">"@(&#39;nil&#39;), to print nothing."</span>)
          (li <span class="string">"@(&#39;:error&#39;), to print only error output."</span>)
          (li <span class="string">"@(&#39;:result&#39;), to print, besides error output,
        the functions described in the `Generated Functions&#39; section below,
        i.e. the result of @(&#39;defarbrec&#39;)."</span>)
          (li <span class="string">"@(&#39;:all&#39;), to print,
        besides error output and the result (see @(&#39;:result&#39;) above),
        ACL2&#39;s output in response to all the submitted events
        (the ones that form the result as well as some ancillary ones)."</span>))
        (p <span class="string">"If the call to @(&#39;defarbrec&#39;) is redundant
       (see the `Redundancy&#39; section below),
       a message to that effect is printed on the screen,
       unless @(&#39;:print&#39;) is @(&#39;nil&#39;)."</span>))
      (desc <span class="string">"@(&#39;:show-only&#39;) &amp;mdash; default @(&#39;nil&#39;)"</span>
        (p <span class="string">"Determines whether the event expansion of @(&#39;defarbrec&#39;)
      is submitted to ACL2 or printed on the screen:"</span>)
        (ul (li <span class="string">"@(&#39;nil&#39;), to submit it."</span>)
          (li <span class="string">"@(&#39;t&#39;), to print it.
        In this case:
        the event expansion is printed even if @(&#39;:print&#39;) is @(&#39;nil&#39;);
        the generated functions are not printed separately
        (other than their appearance in the event expansion),
        even if @(&#39;:print&#39;) is @(&#39;:result&#39;) or @(&#39;:all&#39;);
        no ACL2 output is printed even if @(&#39;:print&#39;) is @(&#39;:all&#39;)
        (because the event expansion is not submitted).
        If the call to @(&#39;defarbrec&#39;) is redundant
        (see the `Redundancy&#39; section below),
        the event expansion generated by the existing call is printed."</span>))))
    (evmac-section-generated (desc <span class="string">"@(&#39;update*-x1&#39;), ..., @(&#39;update*-xn&#39;)"</span>
        (p <span class="string">"The iterated argument update functions:"</span>)
        (codeblock <span class="string">"(defun update*-xi (k x1 ... xn)"</span>
          <span class="string">"  (if (zp k)"</span>
          <span class="string">"      xi"</span>
          <span class="string">"    (update*-xi (1- k)"</span>
          <span class="string">"                update-x1&lt;x1,...,xn&gt;"</span>
          <span class="string">"                ..."</span>
          <span class="string">"                update-xn&lt;x1,...,xn&gt;)))"</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       @(&#39;(update*-xi k x1 ... xn)&#39;) is denoted by @($d_i^{k}(\overline{x})$)
       for @($1 \leq i \leq n$)."</span>))
      (desc <span class="string">"@(&#39;terminates&#39;)"</span>
        (p <span class="string">"The predicate that tests the termination of the program-mode function:"</span>)
        (codeblock <span class="string">"(defun-sk terminates (x1 ... xn)"</span>
          <span class="string">"  (exists k test&lt;(update*-x1 k x1 ... xn),"</span>
          <span class="string">"                 ..."</span>
          <span class="string">"                 (update*-xn k x1 ... xn)&gt;))"</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       @(&#39;terminates&#39;) is denoted by @($t$),
       and @(&#39;terminates-witness&#39;) is denoted by @($\epsilon_t$)."</span>))
      (desc <span class="string">"@(&#39;measure&#39;)"</span>
        (p <span class="string">"The measure function for the logic-mode function:"</span>)
        (codeblock <span class="string">"(defun measure (x1 ... xn k)"</span>
          <span class="string">"  (declare (xargs :measure (nfix (- (terminates-witness x1 ... xn)"</span>
          <span class="string">"                                    (nfix k)))))"</span>
          <span class="string">"  (let ((k (nfix k)))"</span>
          <span class="string">"    (if (or test&lt;(update*-x1 k x1 ... xn),"</span>
          <span class="string">"                 ...,"</span>
          <span class="string">"                 (update*-xn k x1 ... xn)&gt;"</span>
          <span class="string">"            (&gt;= k (nfix (terminates-witness x1 ... xn))))"</span>
          <span class="string">"        k"</span>
          <span class="string">"      (measure x1 ... xn (1+ k)))))"</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       @(&#39;measure&#39;) is denoted by @($\nu$),
       and @(&#39;nfix&#39;) is denoted by @($\phi$)."</span>))
      (desc <span class="string">"@(&#39;fn&#39;)"</span>
        (p <span class="string">"The logic-mode function:"</span>)
        (codeblock <span class="string">"(defun fn (x1 ... xn)"</span>
          <span class="string">"  (declare (xargs :measure (measure x1 ... xn 0)"</span>
          <span class="string">"                  :well-founded-relation o&lt;))"</span>
          <span class="string">"  (if (terminates x1 ... xn)"</span>
          <span class="string">"      (if test&lt;x1,...,xn&gt;"</span>
          <span class="string">"          base&lt;x1,...,xn&gt;"</span>
          <span class="string">"        combine&lt;x1,...,xn,(fn update-x1&lt;x1,...,xn&gt;"</span>
          <span class="string">"                              ..."</span>
          <span class="string">"                              update-xn&lt;x1,...,xn&gt;)&gt;)"</span>
          <span class="string">"    nonterminating))"</span>)
        (p <span class="string">"In the "</span>
          <a class="sym-link local-def" href="#def-_2Adefarbrec-design-notes_2A" data-sym="*DEFARBREC-DESIGN-NOTES*" title="(defconst *defarbrec-design-notes*
          (xdoc::ahref &quot;res/std-util-design-notes/defarbrec.pdf&quot;
           &quot;design notes&quot;))">*defarbrec-design-notes*</a>
          <span class="string">",
       this logic-mode function @(&#39;fn&#39;) is denoted by @($\hat{f}$)."</span>)))
    (h3 <span class="string">"Redundancy"</span>)
    (p <span class="string">"A call of @(&#39;defarbrec&#39;) is redundant if and only if
     it is identical to a previous successful call of @(&#39;defarbrec&#39;)
     whose @(&#39;:show-only&#39;) is not @(&#39;t&#39;),
     except that the two calls may differ in
     their @(&#39;:print&#39;) and @(&#39;:show-only&#39;) options.
     These options do not affect the generated events,
     and thus they are ignored for the purpose of redundancy."</span>)
    (p <span class="string">"A call to @(&#39;defarbrec&#39;) whose @(&#39;:show-only&#39;) is @(&#39;t&#39;)
     does not generate any event.
     No successive call may be redundant with such a call."</span>)
    (p <span class="string">"If a call to @(&#39;defarbrec&#39;) has the same @(&#39;fn&#39;)
     as a previous call whose @(&#39;:show-only&#39;) is not @(&#39;t&#39;),
     but the two calls are not identical
     (ignoring the @(&#39;:print&#39;) and @(&#39;:show-only&#39;) options),
     the second call causes an error."</span>)
    (h3 <span class="string">"Related Tools"</span>)
    (p <span class="string">"@(&#39;defarbrec&#39;) is related to the tools listed below,
     which also allow the introduction of functions in logic mode
     that may not terminate for all argument values.
     For the use case described in the `Introduction&#39; section above
     (namely, verification via transformation),
     @(&#39;defarbrec&#39;) seems preferable to the existing tools, as explained below.
     However, for different use cases,
     some of the existing tools may be preferable to @(&#39;defarbrec&#39;).
     In particular, the function generated by @(&#39;defarbrec&#39;)
     is not executable due to the termination test;
     it may be transformed into an executable function
     by transforming away the termination test (possibly in a restricted domain)
     as explained in the `Introduction&#39; section,
     but some of the existing tools
     immediately produce executable functions instead."</span>)
    (p <span class="string">"@(tsee defpun) produces a constrained (not defined) function.
     Since APT transformations operate on defined functions,
     having @(&#39;defarbrec&#39;) generate a defined function
     makes the function amenable to transformations.
     @(tsee defpun) produces only tail-recursive functions,
     while @(&#39;defarbrec&#39;) can produce non-tail-recursive functions."</span>)
    (p <span class="string">"@(&#39;defp&#39;) (see the final part of the @(tsee defpun) documentation)
     is a generalization of @(tsee defpun),
     but it still produces
     a constrained (not defined) tail-recursive-only function."</span>)
    (p <span class="string">"@(&#39;defpun-exec&#39;) (see the final part of the @(tsee defpun) documentation)
     extends @(tsee defpun) with executability,
     but its use of @(tsee defexec) requires
     that the domain over which the function terminates be provided right away,
     and that the termination be proved right away.
     Both things are deferred with @(&#39;defarbrec&#39;)."</span>)
    (p <span class="string">"@(tsee defpm) produces a measure, termination predicate, and some theorems
     that can be used to introduce a tail-recursive logic-mode function
     similar to the one produced by @(&#39;defarbrec&#39;);
     the companion tool @(tsee defthm-domain) serves to show that
     the termination predicate holds in suitable domains.
     However, the  termination predicate generated by @(tsee defpm)
     is constrained, not defined;
     in constrast,
     the termination predicate generated by @(&#39;defarbrec&#39;) is defined,
     and thus amenable to APT transformations.
     @(&#39;defarbrec&#39;) generates the recursive function,
     while @(tsee defpm) provides the components for defining it manually."</span>)
    (p <span class="string">"@(&#39;def::ung&#39;) (see the final part of the @(tsee defpm) documentation),
     which supersedes @(&#39;def::un&#39;) in @(&#39;books/coi/termination/assuming&#39;),
     produces a logic-mode defined function that may be even reflexive
     (i.e. it may have recursive calls like @(&#39;(mc91 (mc91 (+ n 11)))&#39;)),
     while the current implementation of @(&#39;defarbrec&#39;)
     does not support reflexive functions.
     The function produced by @(&#39;def::ung&#39;) has a more complex definition
     than the function produced by @(&#39;defarbrec&#39;):
     the former has several ``layers&#39;&#39; of sub-functions,
     while the latter has just the form shown
     in the `Generated Functions&#39; section above.
     The simpler definition eases the application of transformations to it,
     as opposed to transforming several sub-functions."</span>)))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = 'üåô';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>