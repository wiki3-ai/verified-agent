<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>error-value-tuples - ACL2 Book</title>
  <meta property="name" content="error-value-tuples">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">‚òÄÔ∏è</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">error-value-tuples</h1>
    <div class="path"><a href="error-value-tuples.lisp" class="source-link">books/std/util/error-value-tuples</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../../kestrel/event-macros/xdoc-constructors.html" title="kestrel/event-macros/xdoc-constructors">xdoc-constructors</a>
      <a class="include-link" href="../../std/util/bstar.html" title="std/util/bstar">bstar</a>
      <a class="include-link" href="../../std/util/defmacro-plus.html" title="std/util/defmacro-plus">defmacro-plus</a>
      <a class="include-link" href="../../xdoc/defxdoc-plus.html" title="xdoc/defxdoc-plus">defxdoc-plus</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../kestrel/event-macros/xdoc-constructors.html" title="Open kestrel/event-macros/xdoc-constructors">"kestrel/event-macros/xdoc-constructors"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../std/util/bstar.html" title="Open std/util/bstar">"std/util/bstar"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../std/util/defmacro-plus.html" title="Open std/util/defmacro-plus">"std/util/defmacro-plus"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/defxdoc-plus.html" title="Open xdoc/defxdoc-plus">"xdoc/defxdoc-plus"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc+ error-value-tuples
  <span class="keyword">:parents</span> (std/util)
  <span class="keyword">:short</span> <span class="string">"Utilities for error-value tuples."</span>
  <span class="keyword">:long</span> (topstring (p <span class="string">"These are experimental utilities for now."</span>)
    (section <span class="string">"Motivation"</span>
      (p <span class="string">"Sometimes execution runs into exceptional conditions
      that warrant returning error indications,
      which are propagated through the callers up the stack,
      and may or may not be caught, and recovered from, at some point;
      if they are not caught, execution terminates,
      with some kind of error message."</span>)
      (p <span class="string">"Some languages like Java provide exception mechanisms for this.
      ACL2 does not have a full exception mechanism,
      but it has some built-in facilities,
      as well as the ability to build facilities,
      to approximate that."</span>))
    (section <span class="string">"Error-Value Tuples"</span>
      (p <span class="string">"An &lt;i&gt;error-value tuple&lt;/i&gt; is a list consisting of
      an &lt;i&gt;error component&lt;/i&gt; @(&#39;erp&#39;)
      followed by
      zero or more &lt;i&gt;value components&lt;/i&gt; @(&#39;val1&#39;), ..., @(&#39;valN&#39;),
      where @(&#39;N&#39;) &amp;ge; 0.
      An ACL2 function can return an error-value tuple
      to indicate possible errors:
      if no error occurs,
      @(&#39;erp&#39;) is @(&#39;nil&#39;)
      and @(&#39;val1&#39;), ..., @(&#39;valN&#39;) are the normal results of the function;
      if an error occurs,
      @(&#39;erp&#39;) contains non-@(&#39;nil&#39;) information about the error
      and @(&#39;val1&#39;), ..., @(&#39;valN&#39;) contain irrelevant values."</span>)
      (p <span class="string">"There is no strict requirements on the type of @(&#39;erp&#39;),
      but it should be, or include, an optional "</span>
        (seetopic <span class="string">"msg"</span> <span class="string">"message"</span>)
        <span class="string">" that describes the error in human-readable terms;
      for instance, an error could be a @(tsee cons) pair
      whose @(tsee car) is a machine-oriented error code or structure,
      and whose @(tsee cdr) is a human-readable message.
      When writing code in a statically strongly typed style,
      particularly using @(tsee define) with argument and result types
      (the latter in @(&#39;:returns&#39;)),
      it may be better to leave @(&#39;erp&#39;) untyped for future extensibility,
      while @(&#39;val1&#39;), ..., @(&#39;valN&#39;) should have types
      that make sense when no error occurs.
      If a type for @(&#39;erp&#39;) is used, e.g. @(tsee maybe-msgp),
      it should be the same for all the functions that call each other,
      so that the same type of errors can be propagated (see below)."</span>)
      (p <span class="string">"We provide utilities, described below,
      to facilitate the use of error-value tuples.
      More utilities may be added in the future,
      particularly for richer forms of @(&#39;erp&#39;),
      which for now is assumed to be an optional message."</span>)
      (p <span class="string">"This is not a new idea, but just a variation of existing ideas.
      A comparison with these related approaches is given below,
      after describing the utilities for error-value tuples."</span>))
    (section <span class="string">"Utilities for Error-Value Tuples"</span>
      (subsection <span class="string">"Returning Errors"</span>
        (p <span class="string">"When there is an error,
       an ACL2 function can return
       @(&#39;(mv erp irr-val1 ... irr-valN)&#39;) if @(&#39;N&#39;) &amp;gt; 0,
       or just @(&#39;erp&#39;) if @(&#39;N&#39;) is 0,
       where @(&#39;erp&#39;) is a non-@(&#39;nil&#39;) error indication,
       such as a message of the form @(&#39;(msg ...)&#39;),
       and where @(&#39;irr-val1&#39;), ..., @(&#39;irr-valN&#39;)
       are terms that evaluate to irrelevant values of appropriate types.
       In a statically strongly typed style,
       the values should have the same types
       that they have when no error occurs,
       so that the @(&#39;:returns&#39;) theorems apply uniformly
       to the error and non-error cases,
       without the need of conditions on the @(&#39;erp&#39;) results."</span>)
        (p <span class="string">"To return errors more clearly and concisely,
       we provide a @(tsee b*) binder @(tsee patbind-reterr)
       that defines the irrelevant values once,
       and that makes it possible for the rest of the code in the function
       to mention just @(&#39;erp&#39;) when returning an error.
       The binder is used, generally at the beginning of a function, as"</span>
          (codeblock <span class="string">"((reterr) irr-val1 ... irr-valN)"</span>)
          (p <span class="string">"where the symbol @(&#39;reterr&#39;) is in the @(&#39;ACL2&#39;) package,
        but can be of course imported in the application package of interest,
        and where @(&#39;irr-val1&#39;), ..., @(&#39;irr-valN&#39;) are
        irrelevant values of appropriate types,
        to be returned along with a non-@(&#39;nil&#39;) @(&#39;erp&#39;).
        If @(&#39;N&#39;) is 0, the binding is just @(&#39;((reterr))&#39;),
        but must still be provided."</span>))
        (p <span class="string">"The binding expands to a local macro (in the @(tsee macrolet) sense),
       also named @(&#39;reterr&#39;) in the @(&#39;ACL2&#39;) package,
       that takes one argument @(&#39;erp&#39;)
       and extends it to an error-value tuple with the irrelevant values.
       This way, code in the function can return an error as"</span>
          (codeblock <span class="string">"(reterr erp)"</span>)
          (p <span class="string">"where @(&#39;erp&#39;) is the desired error, e.g. @(&#39;(msg ...)&#39;).
        This not only makes the call more clear and compact,
        by hiding the irrelevant values,
        but also avoids repeating the irrelevant values
        as many times as there are points in the code that return errors.
        It makes it easier to change the code
        if the numbers or types of the values change."</span>))
        (p <span class="string">"The practice of causing "</span>
          (seetopic <span class="string">"hard-error"</span> <span class="string">"hard errors"</span>)
          <span class="string">" when an unrecoverable internal condition arises
       (e.g. reaching a state that should never be reached)
       can be integrated with error-value tuples by doing something like"</span>)
        (codeblock <span class="string">"(reterr (hard-error ...))"</span>)
        (p <span class="string">"or perhaps using the more convenient @(tsee raise)
       when using @(tsee define).
       Technically @(tsee hard-error) returns @(&#39;nil&#39;),
       which would mean no error in an error-value tuple,
       but such (non-)error is never returned,
       because @(tsee hard-error) stops execution.
       The advantage of using @(tsee hard-error) (or similar)
       inside @(&#39;reterr&#39;) is that logically the ACL2 function
       still returns results of the appropriate number and type,
       without the need to follow @(tsee hard-error)
       by an explicit dummy term to return irrelevant results."</span>)
        (p <span class="string">"The terms denoting the irrelevant values do not need to be ground,
       because this binder expands into a @(tsee macrolet),
       which can introduce variables in the expansion.
       This is useful to return stobj results, including state,
       as value components of error-value tuples."</span>))
      (subsection <span class="string">"Returning Non-Errors"</span>
        (p <span class="string">"When there is no error,
       an ACL2 function can return
       @(&#39;(mv nil val1 ... valN)&#39;) if @(&#39;N&#39;) &amp;gt; 0,
       or just @(&#39;nil&#39;) if @(&#39;N&#39;) is 0,
       where @(&#39;val1&#39;), ..., @(&#39;valN&#39;) are appropriate relevant values."</span>)
        (p <span class="string">"We provide a macro @(&#39;retok&#39;),
       in the @(&#39;ACL2&#39;) package
       (from where it can be imported in an application package),
       to make this slightly more clear and compact.
       The use of this macro hides the @(&#39;nil&#39;) @(&#39;erp&#39;),
       and just takes the values, as"</span>)
        (codeblock <span class="string">"(retok val1 ... valN)"</span>)
        (p <span class="string">"If @(&#39;N&#39;) is 0, it is writte as @(&#39;(retok)&#39;),
       which in a way may be more clear than @(&#39;nil&#39;)
       in saying that things are okay, i.e. no error occurred.
       It is also symmetric with @(&#39;reterr&#39;).
       However, admittedly this does not provide huge advantages
       over just @(&#39;(mv nil val1 .. valN)&#39;) or @(&#39;nil&#39;)."</span>)
        (p <span class="string">"Note that while @(&#39;reterr&#39;) is local to a function,
       and must be introduced via the homonymous binder,
       @(&#39;retok&#39;) is a global macro,
       which takes a variable number of arguments."</span>))
      (subsection <span class="string">"Propagating Errors"</span>
        (p <span class="string">"To propagate an error from a called ACL2 function,
       a caller ACL2 function can use a binder for the call,
       check the @(&#39;erp&#39;) result,
       and return an error with the same @(&#39;erp&#39;)
       and with its own irrelevant values, as"</span>)
        (codeblock <span class="string">"((mv erp val1 ... valN) (f ...))"</span>
          <span class="string">"((when erp) (reterr erp))"</span>)
        (p <span class="string">"or, if @(&#39;N&#39;) is 0, as"</span>)
        (codeblock <span class="string">"(erp (f ...))"</span>
          <span class="string">"((when erp) (reterr erp))"</span>)
        (p <span class="string">"We provide a @(tsee b*) binder @(tsee patbind-erp)
       that expands to the code shown just above.
       This is used as"</span>)
        (codeblock <span class="string">"((erp val1 ... valN) (f ...))"</span>)
        (p <span class="string">"where @(&#39;erp&#39;) is in the @(&#39;ACL2&#39;) package
       (but can imported into the package of interest).
       If @(&#39;N&#39;) is 0, the binding is @(&#39;((erp) (f ...))&#39;).
       The @(&#39;val1&#39;), ..., @(&#39;valN&#39;) may be @(tsee b*) patterns
       that can be used as components of the @(tsee patbind-mv) binder."</span>)
        (p <span class="string">"This binder assumes that @(&#39;reterr&#39;) is a local macro
       introduced by a preceding @(&#39;reterr&#39;) binder (described above)."</span>)
        (p <span class="string">"This binder has an option to change the error to be returned.
       Only the error component can be changed;
       the irrelevant values are always the same, from @(&#39;reterr&#39;).
       The option is used as"</span>)
        (codeblock <span class="string">"((erp val1 ... valN) (f ...) :iferr erp1)"</span>)
        (p <span class="string">"where @(&#39;erp1&#39;) is a term that evaluates to the error to be returned.
       This term may reference the variable @(&#39;erp&#39;)
       as containing the error returned by the called function,
       so that it can build
       a new error component that depends on the old one.
       When @(&#39;:iferr&#39;) is present, the binding expands to"</span>)
        (codeblock <span class="string">"((mv erp val1 ... valN) (f ...))"</span>
          <span class="string">"((when erp) (reterr erp1))"</span>)
        (p <span class="string">"or, if @(&#39;N&#39;) is 0, to"</span>)
        (codeblock <span class="string">"(erp (f ...))"</span>
          <span class="string">"((when erp) (reterr erp1))"</span>)
        (p <span class="string">"We expect that this option may be used less often than not."</span>)
        (p <span class="string">"Because on the restriction on stobj results with @(&#39;reterr&#39;),
       this binder cannot be currently used when
       the values of error-value triples include stobjs.
       In this case, errors must be checked and propagated explicitly."</span>))
      (subsection <span class="string">"Catching Errors"</span>
        (p <span class="string">"To catch (i.e not propagate) an error from a called ACL2 function,
       a caller ACL2 function can use an @(&#39;mv&#39;) binder for the call,
       check the @(&#39;erp&#39;) result,
       and continue its computation if an error occurs,
       presumably to recover from the error somehow.
       If the called function does not return an error,
       presumably the caller function
       will continue computation in some other way."</span>)
        (p <span class="string">"At this point we do not provide any general utilities
       for the case in which the error is caught.
       The reason is that the actions to take when catching the error
       are application-specific.
       Furthermore, we expect that this kind of errors
       will be propagated more often than caught.
       Error-value tuples are intended for when execution
       runs into exceptional conditions,
       similarly to the situations in which languages with exceptions
       would throw exceptions."</span>)))
    (section <span class="string">"Related Ideas"</span>
      (subsection <span class="string">"Hard Errors"</span>
        (p <span class="string">"A "</span>
          (seetopic <span class="string">"er"</span> <span class="string">"hard error"</span>)
          <span class="string">" is a bit like an exception.
       When a hard error occurs,
       it print a message to ACL2&#39;s error output,
       and it stops execution.
       A hard error is automatically propagated
       through the callers up the stack.
       However, a hard error cannot be caught: it always stops execution."</span>)
        (p <span class="string">"Since logically a hard error returns @(&#39;nil&#39;),
       when a function returns a hard error,
       unless it has one result whose type includes @(&#39;nil&#39;),
       one must add code to return an appropriate number and type of results,
       in order to maintain a statically strongly typed style.
       This is equivalent in effort to writing the @(&#39;reterr&#39;) binder,
       and the hard error call, which contains just a message,
       is equivalent in effort to writing a @(&#39;reterr&#39;) call with the message.
       Hard error propagation is fully automatic,
       but writing the @(&#39;erp&#39;) binder is equivalent in effort
       to writing an @(&#39;mv&#39;) or a single-variable binder
       for a call of a function that may return a hard error
       (such a function needs not return an error result).
       Thus, all in all, using error-value tuples,
       with the utilities provided here,
       takes about the same amount of code as using hard errors,
       with the advantage that errors can be potentially caught,
       which is useful for using tools programmatically besides interactively.
       The only extra effort required for error-value tuples is that,
       if the error is not caught,
       there must be some code, near the top level,
       to actually print the message on the screen,
       perhaps using a hard or soft error."</span>))
      (subsection <span class="string">"Soft Errors"</span>
        (p <span class="string">"A "</span>
          (seetopic <span class="string">"er"</span> <span class="string">"soft error"</span>)
          <span class="string">" print a message to ACL2&#39;s error output,
       but does not stop execution.
       It causes the current function to return an "</span>
          (seetopic <span class="string">"error-triple"</span> <span class="string">"error triple"</span>)
          <span class="string">", which the function&#39;s caller can treat just like any other result.
       The caller can catch it and continue execution,
       or it can propagate it up to the caller.
       The propagation is not automatic,
       but it is facilitated by macros like the built-in @(tsee er-let*)
       or the @(tsee b*) binder "</span>
          (seetopic <span class="string">"patbind-er"</span> <span class="string">"@(&#39;er&#39;)"</span>)
          <span class="string">", which is similar to the @(&#39;erp&#39;) binder for error-value tuples."</span>)
        (p <span class="string">"Soft errors are used when "</span>
          (seetopic <span class="string">"programming-with-state"</span>
            <span class="string">"programming with state"</span>)
          <span class="string">". They need @(see state) to be available
       (i.e. to be passed to the function that throws the soft error).
       They also require the function that throws the soft error
       to return state, in the form of an error triple.
       Taking, and even more returning state, is sometimes inconvenient,
       namely when there is otherwise no reason to take or return it."</span>)
        (p <span class="string">"If a function that could naturally return multiple results
       needs to throw soft errors,
       the multiple results must be aggregated into
       the value component of the error triple,
       because @(tsee mv) cannot be nested.
       This aggregation is slightly inconvenient,
       especially when writing code in a statically strongly typed style,
       in which every argument and result has a clear type.
       A possible aggregation is a tuple (i.e. list),
       which means that the multiple results in the value
       must be accessed as elements of the list,
       which is not as direct
       (see @(tsee std::tuple) for a macro to facilitate
       the declaration of multiple value reuslts
       in @(tsee define) return specifiers).
       Another possible aggregation is a user-defined product type
       (e.g. @(tsee std::defaggregate) or @(tsee fty::defprod)),
       but that requires such a type to be explicitly defined.
       Neither approach is as convenient as just returning multiple results,
       but that is not possible if the function
       already returns an error triple due to soft errors."</span>)
        (p <span class="string">"For the above reason, it seems that,
       unless error triples are needed for some other reason,
       error-value tuples may be more flexible."</span>))
      (subsection <span class="string">"Context-Message Pairs"</span>
        (p <span class="string">"A "</span>
          (seetopic <span class="string">"context-message-pair"</span>
            <span class="string">"context-message pair"</span>)
          <span class="string">" is a bit like an error triple without state.
       Another difference with soft errors is that,
       instead of printing an error message,
       it returns a "</span>
          (seetopic <span class="string">"msg"</span> <span class="string">"message"</span>)
          <span class="string">", which a (direct or indirect) caller can print."</span>)
        (p <span class="string">"A context-message pair can be caught or propagated.
       The propagation is not automatic,
       but it is facilitated by macros like the built-in @(tsee er-let*-cmp).
       Since there is no automatic printing,
       if the error is not caught,
       the message should be explicitly printed,
       which makes context-message pairs
       slightly less convenient than hard and soft errors in this respect.
       However, an advantage is that state
       does not need not be taken and returned."</span>)
        (p <span class="string">"Note that,
       if the first component of a context-message pair is non-@(&#39;nil&#39;),
       the error message is the second component of the context-message pair.
       This nicely solves the issue of which value to return
       when there is an error;
       in a soft error, some value must be picked for the second component,
       even though it is often irrelevant.
       However, the fact that the second component of a context-message pair
       may be either a message or an application-specific value
       goes a bit against a statically strongly typed style of coding,
       in which ideally every result of a function has a clear type.
       If the value may be a message,
       its type is the union of the ``real&#39;&#39; type and the type of messages,
       which is a little more complicated than just using the ``real&#39;&#39;type,
       and makes it necessary to create a type for the union."</span>)
        (p <span class="string">"Context-message pairs are thus quite similar to error-value tuples,
       and are sometimes used as context-message tuples
       (i.e. with more than one value).
       The difference is that, in error-message pairs,
       we put the message in the error,
       so that values have more uniform types.
       The error-value tuple utilities are also tailored to this."</span>))
      (subsection <span class="string">"Result Types"</span>
        (p <span class="string">"A different approach to errors is that of "</span>
          (seetopic <span class="string">"fty::defresult"</span> <span class="string">"result types"</span>)
          <span class="string">", in which a function returns either a good result or an error result.
       See the discussion in the documentation of result types
       for a comparison with the approach of
       returning a possibly @(&#39;nil&#39;) error and some values,
       as done with error-value tuples, soft errors, and context-message pairs.
       In short, the advantage of result types is that
       they avoid the issue of irrelevant values when the error is non-@(&#39;nil&#39;),
       and prevent any accidental use of such irrelevant values.
       The disadvantage is that functions that return multiple results
       must return one aggregate result
       (whose type can be defined
       via @(tsee std::defaggregate) or @(tsee fty::defprod),
       for example),
       and also that the code may be less efficient
       due to the construction and deconstruction
       of aggregations of multiple results."</span>)
        (p <span class="string">"Result types may be more appropriate for development
       in which ACL2 is used as a logical language,
       e.g. in a formalization,
       where clarity has paramount importance,
       and efficiency, or the need to define additional aggregate types,
       is a secondary concern.
       Error-value tuples, like soft errors and context-message pairs,
       may be more appropriate for programs,
       where ACL2 is used as a programming language,
       e.g. in a tool implementation,
       where expediency and efficiency may be more important
       than extreme conceptual clarity."</span>))))
  <span class="keyword">:order-subtopics</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="bstar.html#def-def-b_2A-binder" data-sym="DEF-B*-BINDER">def-b*-binder</a> reterr
  <span class="keyword">:parents</span> (error-value-tuples)
  <span class="keyword">:short</span> <span class="string">"Binder to introduce a local function that returns
          an error-value tuple with certain irrelevant values."</span>
  <span class="keyword">:long</span> (topstring (p <span class="string">"See @(see error-value-tuples) for details."</span>))
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
         (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****~%~
                                          The RETERR binder ~
                                          takes no arguments, ~
                                          but the arguments ~x0 ~
                                          were supplied instead.~%~%"</span>
           <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))) (declare (ignore <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
  <span class="keyword">:body</span> `(macrolet ((reterr (erp)
       ,(IF (CONSP FORMS)
     `(LIST* &#39;MV ERP &#39;,FORMS)
     &#39;ERP)))
    ,REST-EXPR))</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defmacro+ retok
  (&amp;rest <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
  <span class="keyword">:parents</span> (error-value-tuples)
  <span class="keyword">:short</span> <span class="string">"Macro to return an error-value tuple with no error."</span>
  <span class="keyword">:long</span> (topstring (p <span class="string">"See @(see error-value-tuples) for details."</span>))
  (if (consp <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
    `(<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> nil ,@ARGS)
    nil))</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="bstar.html#def-def-b_2A-binder" data-sym="DEF-B*-BINDER">def-b*-binder</a> erp
  <span class="keyword">:parents</span> (error-value-tuples)
  <span class="keyword">:short</span> <span class="string">"Binder to propagate errors from error-value tuples."</span>
  <span class="keyword">:long</span> (topstring (p <span class="string">"See @(see error-value-tuples) for details."</span>))
  <span class="keyword">:decls</span> ((declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp forms) (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> (cdr forms)))
         (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp forms)
           (consp (cdr forms))
           (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> forms) <span class="keyword">:iferr</span>)
           (consp (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> forms))
           (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="../../../axioms.html#def-cdddr" data-sym="CDDDR">cdddr</a> forms)))
         (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~%**** ERROR ****~%~
                                          The ERP binder ~
                                          must be followed by ~
                                          exactly one form,
                                          optionally followed by ~
                                          :IFERR and a form, ~
                                          but instead this ERP binder ~
                                          is followed by the forms ~x0.~%~%"</span>
           forms)))))
  <span class="keyword">:body</span> `(<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((,(IF (CONSP ARGS)
     `(MV ERP ,@ARGS)
     &#39;ERP) ,(CAR FORMS)))
    (if erp
      ,(IF (CONSP (CDR FORMS))
     `(RETERR ,(CADDR FORMS))
     &#39;(RETERR ERP))
      ,REST-EXPR)))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = 'üåô';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>