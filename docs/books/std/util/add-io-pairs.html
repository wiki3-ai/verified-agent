<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>add-io-pairs - ACL2 Book</title>
  <meta property="name" content="add-io-pairs">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">add-io-pairs</h1>
    <div class="path"><a href="add-io-pairs.lisp" class="source-link">books/std/util/add-io-pairs</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../../xdoc/top.html" title="xdoc/top">top</a>
      <a class="include-link" href="../../std/util/bstar.html" title="std/util/bstar">bstar</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/top.html" title="Open xdoc/top">"xdoc/top"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block include-book" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../std/util/bstar.html" title="Open std/util/bstar">"std/util/bstar"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-set-state-ok" data-sym="SET-STATE-OK">set-state-ok</a> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-program" data-sym="PROGRAM">program</a>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-add-io-pair" data-sym="ADD-IO-PAIR" title="(defmacro add-io-pair (fn/input output &amp;key hints debug test verbose)
  `(add-io-pairs ((,fn/input ,output)) ,@(and hints `(:hints ,hints))
    ,@(and debug `(:debug ,debug)) ,@(and test `(:test ,test))
    ,@(and verbose `(:verbose ,verbose))))">add-io-pair</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Speed up a function using a verified input-output pair"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;@(&#39;Add-io-pair&#39;) is just a convenient abbreviation for @(tsee
 add-io-pairs) in the case of a single input-output pair.  See @(see
 add-io-pairs).&lt;/p&gt;

 @({
 Examples:
 (add-io-pair (f 3) &#39;(3 . 3))

 (add-io-pair (g 3 4) (mv 30 40))

 (add-io-pair
  (primep (primes::bn-254-group-prime)) t
  :test eql
  :hints ((&quot;Goal&quot;
           :in-theory
           (enable primes::primep-of-bn-254-group-prime-constant))))

 General Form:
 (add-io-pair fn input output &amp;key hints test debug verbose)
 })

 &lt;p&gt;where @(&#39;fn&#39;) is a @(see guard)-verified function symbol whose arguments do
 not include @(tsee state) or any user-defined @(tsee stobj).  The arguments to
 the macro are not evaluated.&lt;/p&gt;

 &lt;p&gt;@(&#39;Add-io-pair&#39;) is merely a convenient way to invoke the utility @(see
 add-io-pairs) when there is a single input/output pair; see @(see
 add-io-pairs) for further documentation, including discussion of the
 keywords (which are optional).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>
  <span class="keyword">:parents</span> (std/util)
  <span class="keyword">:short</span> <span class="string">"Speed up a function using verified input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;For examples, see the book @(&#39;std/util/add-io-pairs-tests.lisp&#39;) in
 @(see community-books).  Also see @(see add-io-pair) for an equivalent utility
 with slightly simpler syntax that can add a single input-output pair.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Summary&lt;/b&gt;.  This utility provides a way to redefine a function so that
 it can quickly look up a function call @(&#39;(fn i1 ... ik)&#39;) to produce its
 output, @(&#39;val&#39;), thus avoiding its usual computation.  We call such a pair
 @(&#39;((fn i1 ... ik) val)&#39;) an ``I/O pair&#39;&#39; (for @(&#39;fn&#39;)).  Each I/O pair is
 ``verified&#39;&#39;: a proof obligation has been met showing that the input list is
 indeed mapped to the corresponding output.  The (verified) I/O pairs are
 stored efficiently in a @(see table).  See @(tsee show-io-pairs) for how to
 print the current I/O pairs.  The present utility, @(&#39;add-io-pairs&#39;), extends
 the table by adding the specified I/O pairs and also redefines the specified
 function to take advantage of the updated table.&lt;/p&gt;

 @({
 Examples (see std/util/add-io-pairs-tests.lisp):

 (add-io-pairs (((f 3) &#39;(3 . 3))))

 (add-io-pairs (((g 3 6) (mv (* 3 10) (* 6 10)))
                ((g (/ 40 10) (/ 50 10)) (mv 40 50))))

 (add-io-pairs
  (((primep (primes::secp256k1-field-prime)) t)
   ((primep (primes::bn-254-group-prime)) t)
   ((primep (primes::baby-jubjub-subgroup-prime)) t))
  :debug t
  :hints ((&quot;Goal&quot;
           :in-theory
           (enable primes::primep-of-baby-jubjub-subgroup-prime-constant
                   primes::primep-of-bn-254-group-prime-constant
                   primes::primep-of-secp256k1-field-prime-constant))))

 General Form:
 (add-io-pairs tuples &amp;key hints debug test verbose)
 })

 &lt;p&gt;where the arguments, which are not evaluated, are described below and the
 keyword arguments are optional.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;@(&#39;Tuples&#39;) is a list of I/O pairs, each of the form @(&#39;((fn i_1 ... i_k)
 val)&#39;) where @(&#39;fn&#39;) is a @(see guard)-verified function symbol, each @(&#39;i_n&#39;)
 is a term, and @(&#39;val&#39;) is a term.  (The @(see term)s need not be translated.)
 @(&#39;Fn&#39;) must be the same in each of these I/O pairs, and must not take @(see
 state) or any user-defined @(see stobj) as an argument.  All @(&#39;i_n&#39;) and
 @(&#39;val&#39;) are evaluated to produce values used as inputs and corresponding
 output; therefore, these terms should not contain any free variables.&lt;/li&gt;

 &lt;li&gt;@(&#39;Hints&#39;) (optional, default @(&#39;nil&#39;)), when non-@(&#39;nil&#39;), is used as the
 @(&#39;:&#39;)@(tsee hints) argument for the theorem discussed below.&lt;/li&gt;

 &lt;li&gt;@(&#39;Test&#39;) (optional, default @(&#39;equal&#39;)) is the equality variant &amp;mdash;
 @(tsee eq), @(tsee eql), or @(tsee equal) &amp;mdash; used for testing equality of
 each input of @(&#39;fn&#39;) to a corresponding input of an I/O pair; or, @(&#39;test&#39;)
 can be a true-list of such equality variants, as described in the concluding
 remarks below.&lt;/li&gt;

 &lt;li&gt;@(&#39;Debug&#39;) (optional, default @(&#39;nil&#39;)), when non-@(&#39;nil&#39;), causes @(tsee
 cw) to print a message to the terminal when an I/O pair is being used during
 evaluation (thus avoiding the usual computation for @(&#39;fn&#39;)).&lt;/li&gt;

 &lt;li&gt;@(&#39;Verbose&#39;) (optional, default @(&#39;nil&#39;)), when non-@(&#39;nil&#39;), avoids
 suppressing output (other than what is currently globally suppressed; see
 @(see set-inhibit-output-lst)).  This argument may be particularly useful when
 the proof fails for the theorem, described below, that equates @(&#39;fn&#39;) to the
 corresponding new function (that looks up inputs from a table of all verified
 I/O pairs).&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;If @(&#39;tuples&#39;) is @(&#39;nil&#39;) then the call of @(&#39;add-io-pairs&#39;) is a no-op.
 Otherwise, as noted above, the function symbol (@(&#39;fn&#39;), above) must be the
 same for each I/O pair.&lt;/p&gt;

 &lt;p&gt;This event defines a new function, denoted @(&#39;new-fn&#39;) below (the actual
 name is generated automatically), to compute as follows.  First, the inputs
 @(&#39;i_n&#39;) and corresponding output @(&#39;val&#39;) of an I/O pair @(&#39;((fn i_1 ... i_k)
 val)&#39;) are evaluated to produce a corresponding ``evaluated I/O pair&#39;&#39; @(&#39;((fn
 j_1 ... j_k) v)&#39;), where the values of @(&#39;i_n&#39;) and @(&#39;val&#39;) are @(&#39;j_n&#39;) and
 @(&#39;v&#39;), respectively.  Then @(&#39;new-fn&#39;) is defined so that @(&#39;(fn j_1
 ... j_k)&#39;) is computed by finding that evaluated I/O pair and returning
 @(&#39;v&#39;), thus avoiding the usual computation for @(&#39;fn&#39;).  That is: a call of
 @(&#39;new-fn&#39;) considers every evaluated I/O pair @(&#39;((fn j_1 ... j_k) val)&#39;),
 whether added by this call of @(&#39;add-io-pairs&#39;) or a previous such call,
 searching for one whose inputs @(&#39;(j_1 ... j_k)&#39;) equal that call&#39;s actual
 parameters, and returning the corresponding output @(&#39;v&#39;) in that case; if no
 such evaluated I/O pair is found, then @(&#39;new-fn&#39;) just calls @(&#39;fn&#39;).  This
 description is accurate if @(&#39;fn&#39;) returns a single value; otherwise, if
 @(&#39;fn&#39;) returns @(&#39;n&#39;) values where @(&#39;n&#39;) is greater than 1, @(&#39;val&#39;) should
 evaluate to multiple values @(&#39;(mv v_1 .... v_n)&#39;), in which case the multiple
 values returned by @(&#39;new-fn&#39;) are @(&#39;v_1&#39;) through @(&#39;v_n&#39;).  The definition
 of @(&#39;new-fn&#39;) thus has roughly the following form, where: @(&#39;IO-LOOKUP&#39;)
 denotes a lookup utility that searches for the given inputs among evaluated
 I/O pairs, returning the one-element list containing the value associated with
 those inputs, if found; @(&#39;TEST&#39;) is the value for @(&#39;:test&#39;) discussed
 above (defaulting to @(&#39;equal&#39;)); and @(&#39;IO-PAIRS&#39;) is the extension of the
 existing evaluated I/O pairs for @(&#39;fn&#39;) by the current call of
 @(&#39;add-io-pairs&#39;), as described above.&lt;/p&gt;

 @({
 (defun new-fn (x1 ... xk) ; same formals as for fn
   (declare (xargs :guard t)) ; ensure guard-verified
   &lt;declare_forms&gt; ; same declare forms as for fn
   (let ((pair &lt;&lt;IO-LOOKUP (x1 ... xk) in &#39;IO-PAIRS using &#39;TEST&gt;&gt;))
     (if pair
         (car pair)
       (fn x))))
 })

 &lt;p&gt;The event displayed above is approximate.  One can see the precise
 definition produced by evaluating a call of @(&#39;add-io-pairs&#39;) and using
 @(&#39;:&#39;)@(tsee pcb!)@(&#39; :x&#39;) to see what has been generated.  Alternatively, run
 @(&#39;add-io-pairs&#39;) using option @(&#39;:verbose t&#39;) and peruse the log.&lt;/p&gt;

 &lt;p&gt;In the underlying Common Lisp, @(&#39;fn&#39;) is redefined to be @(&#39;new-fn&#39;), but
 with a twist: once control passes from @(&#39;fn&#39;) to @(&#39;new-fn&#39;), all recursive
 calls of @(&#39;fn&#39;) will be calls of the old version of @(&#39;fn&#39;), without
 re-entering @(&#39;new-fn&#39;).  Note that when @(&#39;new-fn&#39;) is called on an input
 list that has an associated I/O pair, the corresponding output is returned
 immediately without calling @(&#39;fn&#39;) (which of course is the point of this
 tool); thus, in particular, side effects from @(&#39;fn&#39;) such as printing with
 @(tsee cw) will not take place for such an input list.&lt;/p&gt;

 &lt;p&gt;A generated proof obligation has the following form, where @(&#39;HINTS&#39;) below
 is the non-@(&#39;nil&#39;) @(&#39;:hints&#39;) keyword if supplied by @(&#39;add-io-pairs&#39;);
 otherwise the @(&#39;:hints&#39;) keyword below is omitted.&lt;/p&gt;

 @({
 (defthm &lt;generated_name&gt;
   (equal (fn x1 ... xk)
          (new-fn x1 ... xk))
   :hints HINTS ; omitted if the given :hints is nil or omitted
   :rule-classes nil)
 })

 &lt;p&gt;We conclude with a few remarks.&lt;/p&gt;

 &lt;p&gt;Remark 1.  When the value @(&#39;:test&#39;) is a non-@(&#39;nil&#39;) list, its length
 should be the number of inputs of @(&#39;fn&#39;) and each member should be @(&#39;eq&#39;),
 @(&#39;eql&#39;), or @(&#39;equal&#39;), indicating the test used when comparing an input at
 that position to an input specified in an evaluated I/O pairs for @(&#39;fn&#39;).&lt;/p&gt;

 &lt;p&gt;Remark 2.  Evaluation of input and output terms in an I/O pair is performed
 with guard-checking set to @(&#39;nil&#39;) (see @(see set-guard-checking)) and
 attachments allowed (see @(see defattach)).&lt;/p&gt;

 &lt;p&gt;Remark 3.  Although @(&#39;fn&#39;) is required to be @(see guard)-verified, one
 may be able to avoid most of the effort of guard verification by using @(tsee
 ec-call).  Here is a trivial example that illustrates the technique.&lt;/p&gt;

 @({
 ACL2 !&gt;(defun h (x)
          (declare (xargs :guard t))
          (ec-call (car x)))

 Since H is non-recursive, its admission is trivial.  We could deduce
 no constraints on the type of H.

 Computing the guard conjecture for H....

 The guard conjecture for H is trivial to prove.  H is compliant with
 Common Lisp.

 Summary
 Form:  ( DEFUN H ...)
 Rules: NIL
 Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
  H
 ACL2 !&gt;(add-io-pairs (((h 3) nil) ((h &#39;(a b c)) &#39;a)) :debug t)
  H
 ACL2 !&gt;(h 3)
 ; DEBUG: Found io-pair for input list (3).
 NIL
 ACL2 !&gt;(h &#39;(a b c))
 ; DEBUG: Found io-pair for input list ((A B C)).
 A
 ACL2 !&gt;(h &#39;(e f))
 E
 ACL2 !&gt;(h 7)


 ACL2 Error in TOP-LEVEL:  The guard for the function call (CAR X),
 which is (OR (CONSP X) (EQUAL X NIL)), is violated by the arguments
 in the call (CAR 7).
 See :DOC set-guard-checking for information about suppressing this
 check with (set-guard-checking :none), as recommended for new users.
 To debug see :DOC print-gv, see :DOC trace, and see :DOC wet.

 ACL2 !&gt;(add-io-pair (h 7) nil)
  H
 ACL2 !&gt;(h 7)
 NIL
 ACL2 !&gt;(h &#39;(a b c))
 A
 ACL2 !&gt;
 })

 &lt;p&gt;Note that there is no debug printing in the final two calls.  This isn&#39;t
 surprising for @(&#39;(h 7)&#39;), since the call of @(&#39;add-io-pair&#39;) for @(&#39;(h 7)&#39;)
 did not specify keyword argument @(&#39;:debug&#39;).  It may be more surprising that
 debug printing no longer occurs for @(&#39;(h &#39;(a b c))&#39;).  The reason is that
 each invocation of @(&#39;add-io-pair&#39;) or @(&#39;add-io-pairs&#39;) defines a new
 replacement function (denoted @(&#39;new-fn&#39;) in the discussions above), which is
 based on the updated table of evaluated I/O pairs and the @(&#39;:debug&#39;) option
 provided to the new invocation.&lt;/p&gt;

 &lt;p&gt;Remark 4.  A more general utility, which allows the substitution of one
 function for another during execution, is available with the @(&#39;:invoke&#39;)
 argument of @(tsee memoize).  Indeed, @(&#39;add-io-pairs&#39;) actually works by
 invoking @(&#39;(memoize &#39;fn :invoke &#39;new-fn)&#39;), where @(&#39;new-fn&#39;) is as above.
 Note that this memoization does not perform @(&#39;memoize&#39;)&#39;s usual function of
 saving computational results.&lt;/p&gt;

 &lt;p&gt;Remark 5.  If you include a book with an @(&#39;add-io-pairs&#39;) form for a
 function symbol, @(&#39;fn&#39;), to which you have already added I/O pairs in the
 current session, then by default an error will occur.  The key relevant
 observation is that during book certification, when @(&#39;add-io-pairs&#39;) defines
 @(&#39;new-fn&#39;) as discussed above, that definition is saved in the book&#39;s @(see
 certificate).  (Technical note: This is a consequence of the use of @(tsee
 make-event) in the implementation of @(&#39;add-io-pairs&#39;).)  Without an error,
 ACL2 would simply use that saved definition of @(&#39;new-fn&#39;), discarding the I/O
 pairs previously added in the current session.&lt;/p&gt;

 &lt;p&gt;The error message explains how to allow the @(tsee include-book) to
 complete without error, merging in all I/O pairs from the current session and
 included books by wrapping it in a call of the macro, @(tsee merge-io-pairs),
 whose first argument is @(&#39;fn&#39;).  So a sequence of events might look like
 this.&lt;/p&gt;

 @({
 (defun f (x)
   (declare (xargs :guard t))
   (cons x x))
 (include-book &quot;book1&quot;) ; has calls of add-io-pair(s) for f
 (merge-io-pairs
   f
   (include-book &quot;book2&quot;) ; has calls of add-io-pair(s) for f
   )
 })

 &lt;p&gt;An analogous problem occurs with @(tsee encapsulate), when there are @(see
 local) calls of @(&#39;add-io-pairs&#39;) followed by non-local calls.  Much as
 @(&#39;certify-book&#39;) saves the definition of @(&#39;new-fn&#39;) in the book&#39;s
 certificate, ACL2 saves such a definition from the first pass of the
 @(&#39;encapsulate&#39;) and detects missing I/O pairs (the local ones) in the second
 pass.  We expect local calls of @(&#39;add-io-pairs&#39;) inside @(&#39;encapsulate&#39;) to
 be rare, so we do not discuss them further.&lt;/p&gt;

 &lt;p&gt;Although the discussion above and the error message should suffice, you can
 get more understanding by looking at examples in the section ``Including a
 book&#39;&#39; in @(see community-book) @(&#39;std/util/add-io-pairs-tests.lisp&#39;).  For
 technical details (probably not necessary), you are also welcome to see @(see
 add-io-pairs-details).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc add-io-pairs-details
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Details about @(tsee add-io-pairs)"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This rather technical topic is intended for those who have read the
 documentation for @(tsee add-io-pairs) and related topics but would like a
 more complete understanding of how @(tsee add-io-pairs) works.  Our hope is
 that very few will have any reason to read the present topic!&lt;/p&gt;

 &lt;p&gt;A key aspect of the implementation of @(&#39;add-io-pairs&#39;) is the use of a
 @(see table), @(&#39;io-pairs-table&#39;), to store all I/O pairs.  Indeed, the
 utilities @(tsee show-io-pairs) and @(tsee get-io-pairs) retrieve I/O pairs
 from this table.  When @(&#39;add-io-pairs&#39;) is invoked on I/O pairs for a
 function symbol, @(&#39;fn&#39;), it extends that table with those I/O pairs and then
 generates a @(tsee defun) event for a new function.  The documentation topic
 @(see add-io-pairs) explains that this new function, @(&#39;new-fn&#39;), computes by
 looking up the inputs in the available I/O pairs to get the result immediately
 if possible, otherwise calling @(&#39;fn&#39;).  Finally, it uses a special form of
 @(see memoization) to compute calls of @(&#39;fn&#39;) by calling @(&#39;new-fn&#39;).&lt;/p&gt;

 &lt;p&gt;The following log fleshes out the explanation above.  It shows that
 @(&#39;add-io-pairs&#39;) generates a call of @(tsee make-event), which we expand
 below to see the events created by that @(&#39;make-event&#39;) invocation.  Comments
 have been inserted in lower case into the final output below.&lt;/p&gt;

 @({
 ACL2 !&gt;(defun f (x)
          (declare (xargs :guard t))
          (cons x x))
 [[.. output elided ..]]
  F
 ACL2 !&gt;:trans1 (add-io-pair (f 3) (cons 3 (/ 6 2)))
  (ADD-IO-PAIRS (((F 3) (CONS 3 (/ 6 2)))))
 ACL2 !&gt;:trans1 (add-io-pairs (((f 3) (cons 3 (/ 6 2)))))
  (WITH-OUTPUT
   :OFF :ALL :ON ERROR :GAG-MODE NIL
   (MAKE-EVENT
     (B* ((TUPLES &#39;(((F 3) (CONS 3 (/ 6 2)))))
          (HINTS &#39;NIL)
          (DEBUG &#39;NIL)
          (TEST &#39;EQUAL)
          (WRLD (W STATE))
          ((WHEN (NULL TUPLES))
           (VALUE &#39;(VALUE-TRIPLE :EMPTY-IO-PAIRS)))
          (CTX &#39;ADD-IO-PAIRS)
          ((ER IO-DOUBLET-LST)
           (ADD-IO-PAIRS-TRANSLATE-TUPLES TUPLES CTX WRLD STATE))
          (FN (CAAR (CAR TUPLES)))
          (EVENTS (ADD-IO-PAIRS-EVENTS FN
                                       IO-DOUBLET-LST HINTS DEBUG TEST WRLD)))
         (VALUE (CONS &#39;PROGN EVENTS)))
     :ON-BEHALF-OF :QUIET!))
 ACL2 !&gt;(b* ((tuples &#39;(((f 3) (cons 3 (/ 6 2)))))
             (hints &#39;nil)
             (debug &#39;nil)
             (test &#39;equal)
             (wrld (w state))
             ((when (null tuples))
              (value &#39;(value-triple :empty-io-pairs)))
             (ctx &#39;add-io-pairs)
             ((er io-doublet-lst)
              (add-io-pairs-translate-tuples tuples ctx wrld state))
             (fn (caar (car tuples)))
             (events (add-io-pairs-events fn io-doublet-lst hints debug
                                          test wrld)))
          (value (cons &#39;progn events)))
  (PROGN

  ; Cause an error when including a book or running the second pass of an
  ; encapsulate, if the I/O pairs for F in the io-pairs table do not match
  ; those in the table from a previous invocation -- unless we are in the
  ; scope of merge-io-pairs for F.
   (CHECK-IO-PAIRS-LENIENCE F NIL ADD-IO-PAIRS)

  ; Update the I/O pairs for F in the io-pairs-table.
   (TABLE
       IO-PAIRS-TABLE &#39;F
       (LET ((OLD-ENTRY (CDR (ASSOC-EQ &#39;F
                                       (TABLE-ALIST &#39;IO-PAIRS-TABLE WORLD)))))
            (UPDATE-IO-LOOKUP-LST &#39;(((3) (3 . 3)))
                                  OLD-ENTRY)))

  ; Define the new-fn for F.
   (DEFUN F29623679 (X)
          (DECLARE (XARGS :VERIFY-GUARDS T))
          (DECLARE (XARGS :GUARD T))
          (LET* ((IO-LOOKUP-VAR0 &#39;((3 (3 . 3))))
                 (IO-LOOKUP-VAR0 (IO-LOOKUP IO-LOOKUP-VAR0 EQUAL X)))
                (IF IO-LOOKUP-VAR0 (CAR IO-LOOKUP-VAR0)
                    (F X))))

  ; Prove that F equals its new-fn, as required by the memoize call below.
   (DEFTHM F52318143 (EQUAL (F X) (F29623679 X))
           :RULE-CLASSES NIL)

  ; Remove any existing memoization of F (redundant if F is not memoized).
   (UNMEMOIZE &#39;F)

  ; Arrange for F to call its new-fn.
   (MEMOIZE &#39;F :INVOKE &#39;F29623679))
 ACL2 !&gt;
 })

 &lt;p&gt;It is also instructive to look at the implementation of @(tsee
 merge-io-pairs).  We can see what is going on by using single-step
 macroexpansion, below: first, @(&#39;push-io-pairs-lenience&#39;) removes any
 @(&#39;check-io-pairs-lenience&#39;) checks discussed above for the indicated function
 symbols; next, the books are included; then, @(tsee install-io-pairs) merges
 all I/O pairs for each function (as discussed below); and finally, the
 @(&#39;pop-io-pairs-lenience&#39;) call undoes the effect of the
 @(&#39;push-io-pairs-lenience&#39;) call.&lt;/p&gt;

 @({
 ACL2 !&gt;:trans1 (merge-io-pairs (f g h)
                                (include-book &quot;book1&quot;)
                                (include-book &quot;book2&quot;))
  (PROGN (PUSH-IO-PAIRS-LENIENCE F G H)
         (INCLUDE-BOOK &quot;book1&quot;)
         (INCLUDE-BOOK &quot;book2&quot;)
         (INSTALL-IO-PAIRS F)
         (INSTALL-IO-PAIRS G)
         (INSTALL-IO-PAIRS H)
         (POP-IO-PAIRS-LENIENCE F G H))
 ACL2 !&gt;
 })

 &lt;p&gt;The discussion above leads us to look at the implementation of @(tsee
 install-io-pairs), again using a log (below).  Notice that the events are
 essentially the same as for @(&#39;add-io-pairs&#39;), except that the table is not
 changed.  In particular, there is still a call of
 @(&#39;check-io-pairs-lenience&#39;), for essentially the same reason: imagine if
 @(&#39;(install-io-pairs f)&#39;) is in a certified book that is included after having
 added I/O pairs for @(&#39;f&#39;) in the current session.&lt;/p&gt;

 @({
 ACL2 !&gt;:trans1 (install-io-pairs f)
  (WITH-OUTPUT
   :OFF :ALL :ON ERROR :GAG-MODE NIL
   (MAKE-EVENT
     (B* ((FN &#39;F)
          (HINTS &#39;NIL)
          (DEBUG &#39;NIL)
          (TEST &#39;EQUAL)
          (WRLD (W STATE))
          (IO-DOUBLET-LST :SKIP)
          (EVENTS (ADD-IO-PAIRS-EVENTS FN
                                       IO-DOUBLET-LST HINTS DEBUG TEST WRLD)))
         (VALUE (CONS &#39;PROGN EVENTS)))
     :ON-BEHALF-OF :QUIET!))
 ACL2 !&gt;(b* ((fn &#39;f)
             (hints &#39;nil)
             (debug &#39;nil)
             (test &#39;equal)
             (wrld (w state))
             (io-doublet-lst :skip)
             (events (add-io-pairs-events fn io-doublet-lst hints debug
                                          test wrld)))
          (value (cons &#39;progn events)))
  (PROGN (CHECK-IO-PAIRS-LENIENCE F NIL INSTALL-IO-PAIRS)
         (DEFUN F1824557376 (X)
                (DECLARE (XARGS :VERIFY-GUARDS T))
                (DECLARE (XARGS :GUARD T))
                (LET* ((IO-LOOKUP-VAR0 &#39;NIL)
                       (IO-LOOKUP-VAR0 (IO-LOOKUP IO-LOOKUP-VAR0 EQUAL X)))
                      (IF IO-LOOKUP-VAR0 (CAR IO-LOOKUP-VAR0)
                          (F X))))
         (DEFTHM F1847247744
                 (EQUAL (F X) (F1824557376 X))
                 :RULE-CLASSES NIL)
         (UNMEMOIZE &#39;F)
         (MEMOIZE &#39;F :INVOKE &#39;F1824557376))
 ACL2 !&gt;
 })

 &lt;p&gt;We conclude by noting that @(tsee remove-io-pairs) not only removes all I/O
 pairs for the indicated function symbols from the @(&#39;io-pairs-table&#39;), but
 also unmemoizes those function symbols.  By contrast, @(tsee
 deinstall-io-pairs) leaves the @(&#39;io-pairs-table&#39;) unchanged, merely
 unmemoizing the indicated function.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-merge-io-pairs" data-sym="MERGE-IO-PAIRS" title="(defmacro merge-io-pairs (x &amp;rest events)
  (declare
   (xargs :guard
    (or (symbolp x) (and (symbol-listp x) (no-duplicatesp-eq x)))))
  (merge-io-pairs-fn
...">merge-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Incorporate I/O pairs from different sources"</span>
  <span class="keyword">:long</span> <span class="string">"@({
 General Forms:
 (merge-io-pairs fn event_1 ... event_n)
 (merge-io-pairs (fn_1 ... fn_k) event_1 ... event_n)
 })

 &lt;p&gt;where @(&#39;fn&#39;) and each @(&#39;fn_i&#39;) are symbols and each @(&#39;event_i&#39;) is an
 @(see event) form.&lt;/p&gt;

 @({
 Example Forms:
 (merge-io-pairs f (include-book &quot;my-book&quot;))
 (merge-io-pairs (f g h) (include-book &quot;book1&quot;) (include-book &quot;book2&quot;))
 })

 &lt;p&gt;The second General Form above, @(&#39;(merge-io-pairs (fn_1 ... fn_k) event_1
 ... event_n)&#39;), has an effect equivalent to iterating the first general form
 as follows.&lt;/p&gt;

 @({
 (merge-io-pairs fn_1
  (merge-io-pairs fn_2
   ...
   (merge-io-pairs fn_{k-1}
    (merge-io-pairs fn_k event_1 ... event_n))))
 })

 &lt;p&gt;So we focus below on the first General Form.&lt;/p&gt;

 &lt;p&gt;Normally you will use @(&#39;merge-io-pairs&#39;) when an error occurs in
 @(&#39;add-io-pairs&#39;) while including a book; see Remark 5 of the documentation
 for @(see add-io-pairs) for explanation.  In short: by wrapping
 @(&#39;(merge-io-pairs fn ...)&#39;) around one or more @(tsee include-book) events,
 as illustrated in the Example Forms above, you allow all @(&#39;add-io-pairs&#39;)
 forms in the books to complete in a manner that merges together all the I/O
 pairs for @(&#39;fn&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Remove input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;For relevant background, see @(see add-io-pairs), which modifies a
 function by looking up the result for specified input-output pairs.  The
 utility @(&#39;remove-io-pairs&#39;) removes all such pairs for the specified function
 symbols.&lt;/p&gt;

 @({
 General Forms:
 (remove-io-pairs fn1 ... fnk)
 (remove-io-pairs :all)
 })

 &lt;p&gt;where the arguments are not evaluated.  The use of @(&#39;:all&#39;) specifies that
 all I/O pairs are to be removed for all function symbols; otherwise, all I/O
 pairs are removed only for the specified function symbols.  A warning is
 printed for each input @(&#39;fni&#39;) that does not currently have any I/O
 pairs.&lt;/p&gt;

 &lt;p&gt;Remark.  As @(tsee add-io-pairs) actually memoizes functions,
 @(&#39;remove-io-pairs&#39;) unmemoizes the specified functions.  For a utility that
 unmemoizes while preserving I/O pairs for possible re-installation later, see
 @(see deinstall-io-pairs).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-10" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Return a list of verified input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see show-io-pairs) for a more user-friendly display of the
 current I/O pairs.  See @(see add-io-pairs) for relevant background.&lt;/p&gt;

 &lt;p&gt;@(&#39;Get-io-pairs&#39;) returns all evaluated I/O pairs for the specified
 function symbols.&lt;/p&gt;

 @({
 General Form:
 (get-io-pairs :all)
 (get-io-pairs fn1 ... fnk)
 })

 &lt;p&gt;where the arguments are not evaluated.  The use of @(&#39;:all&#39;) specifies that
 all I/O pairs are to be returned; otherwise, all I/O pairs are returned only
 for the specified functions, and a warning is printed for those that do not
 currently have any I/O pairs.&lt;/p&gt;

 &lt;p&gt;A single value is returned, which is a list representing all evaluated I/O
 pairs for the indicated function symbols.  Each member of the list has the
 form @(&#39;((fn j_1 ... j_k) v)&#39;), where @(&#39;v&#39;) results from the application of
 @(&#39;fn&#39;) to the input list @(&#39;(j_1 ... j_k)&#39;) &amp;mdash; where in the case that
 @(&#39;fn&#39;) returns multiple values @(&#39;v_1&#39;), ..., @(&#39;v_n&#39;), then @(&#39;v&#39;) is
 actually the list @(&#39;(mv v_1 .. v_n)&#39;), and otherwise @(&#39;v&#39;) is just the
 result.&lt;/p&gt;

 &lt;p&gt;A warning is printed for each @(&#39;fni&#39;) that has no associated I/O
 pairs.&lt;/p&gt;

 &lt;p&gt;Note that unlike @(tsee show-io-pairs), the form @(&#39;(get-io-pairs)&#39;) simply
 returns @(&#39;nil&#39;), i.e., @(&#39;:all&#39;) is not implicit when no arguments are
 supplied.  The reason is that @(&#39;get-io-pairs&#39;) is intended primarily for use
 in programs, where the list of function symbols might be computed.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-11" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Display verified input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;See @(see add-io-pairs) for relevant background.
 @(&#39;Show-io-pairs&#39;) prints I/O pairs in a pleasant format, each starting on a
 new line.  It is evaluated only for its side effect of printing.  See @(see
 get-io-pairs) for a related utility, which returns a list of evaluated I/O
 pairs.&lt;/p&gt;

 &lt;p&gt;@(&#39;Show-io-pairs&#39;) displays all (verified) I/O pairs for the specified
 function symbols.  Normally printing goes to the terminal, but more generally
 it goes to @(tsee standard-co).&lt;/p&gt;

 @({
 General Forms:
 (show-io-pairs :all)
 (show-io-pairs) ; same as above
 (show-io-pairs fn1 ... fnk) ; k &gt; 0
 })

 &lt;p&gt;where the arguments are not evaluated.  If no arguments are supplied, or
 equivalently there is a single argument, @(&#39;:all&#39;), then all I/O pairs are to
 be printed; otherwise, all I/O pairs are printed only for the specified
 function symbols.&lt;/p&gt;

 &lt;p&gt;Each I/O pair is printed in the format expected as input to @(tsee
 add-io-pairs), that is, the inputs and result are terms.  In other words,
 @(&#39;add-io-pairs&#39;) prints I/O pairs, not evaluated I/O pairs (again, see @(see
 add-io-pairs) for relevant background).  Moreover, @(&#39;show-io-pairs&#39;) displays
 the inputs and result as quoted terms, such as @(&#39;&#39;abc&#39;), even when they
 result from a call of @(&#39;add-io-pairs&#39;) in which the terms were not all
 quoted, e.g., @(&#39;(car &#39;(abc def))&#39;).&lt;/p&gt;

 &lt;p&gt;A warning is printed for each @(&#39;fni&#39;) that has no associated I/O
 pairs.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-12" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-install-io-pairs" data-sym="INSTALL-IO-PAIRS" title="(defmacro install-io-pairs (fn &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((fn &#39;,fn) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state)) (io-doublet-lst :skip)
...">install-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Install input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">"@({
 General Form:
 (install-io-pairs fn &amp;key hints debug (test &#39;equal) verbose)
 })

 &lt;p&gt;where the keywords have the same function as for @(tsee add-io-pairs).&lt;/p&gt;

 &lt;p&gt;For relevant background, see @(see add-io-pairs).  Evaluate
 @(&#39;(install-io-pairs fn)&#39;) to undo the effect of @(tsee
 deinstall-io-pairs).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-13" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-deinstall-io-pairs" data-sym="DEINSTALL-IO-PAIRS" title="(defmacro deinstall-io-pairs (fn) `(unmemoize &#39;,fn))">deinstall-io-pairs</a>
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
  <span class="keyword">:short</span> <span class="string">"Deinstall input-output pairs"</span>
  <span class="keyword">:long</span> <span class="string">" @({
 General Form:
 (deinstall-io-pairs fn)
 })

 &lt;p&gt;For relevant background, see @(see add-io-pairs).  This is just an alias
 for @(tsee unmemoize), thus causing evaluation to use the original definition
 of the given function symbol, @(&#39;fn&#39;).  The I/O pairs for @(&#39;fn&#39;) are still
 stored, unlike @(tsee remove-io-pairs); thus, you can later evaluate
 @(&#39;(install-io-pairs fn)&#39;) to restore the use of I/O pairs in the evaluation
 of @(&#39;fn&#39;).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block macro" id="def-add-io-pair" data-defines="ADD-IO-PAIR" data-references="ADD-IO-PAIRS,QUASIQUOTE,VERBOSE,TEST,DEBUG,HINTS,&KEY,OUTPUT,FN/INPUT,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIR">add-io-pair</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-add-io-pair" data-sym="ADD-IO-PAIR" title="(defmacro add-io-pair (fn/input output &amp;key hints debug test verbose)
  `(add-io-pairs ((,fn/input ,output)) ,@(and hints `(:hints ,hints))
    ,@(and debug `(:debug ,debug)) ,@(and test `(:test ,test))
    ,@(and verbose `(:verbose ,verbose))))">add-io-pair</a>
  (fn/input output &amp;key hints debug test verbose)
  `(<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a> ((,FN/INPUT ,OUTPUT))
    ,@(AND HINTS `(:HINTS ,HINTS))
    ,@(AND DEBUG `(:DEBUG ,DEBUG))
    ,@(AND TEST `(:TEST ,TEST))
    ,@(AND VERBOSE `(:VERBOSE ,VERBOSE))))</pre>
  </div>

<div class="form-block other" id="form-15" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> io-pairs-table
  nil
  nil
  <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> key world))</pre>
  </div>

<div class="form-block other" id="form-16" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> io-pairs-lenience-table
  nil
  nil
  <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (symbolp key) (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> val)))</pre>
  </div>

<div class="form-block function" id="def-update-io-lookup-init" data-defines="UPDATE-IO-LOOKUP-INIT" data-references="CDR,CAR,ACONS,T,ENDP,COND,TRUE-LISTP,XARGS,DECLARE,VAL,ARGS,DEFUN" data-used-by="UPDATE-IO-LOOKUP" data-part-name="UPDATE-IO-LOOKUP-INIT" data-part-args="VAL,ARGS" data-part-declare="ARGS,TRUE-LISTP,XARGS,DECLARE" data-part-body="CDR,UPDATE-IO-LOOKUP-INIT,CAR,ACONS,T,VAL,ARGS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-IO-LOOKUP-INIT">update-io-lookup-init</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-io-lookup-init" data-sym="UPDATE-IO-LOOKUP-INIT" title="(defun update-io-lookup-init (args val)
  (declare (xargs :guard (true-listp args)))
  (cond ((endp args) val)
        (t (acons (car args) (update-io-lookup-init (cdr args) val) nil))))">update-io-lookup-init</a>
  (<a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a> val)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) val)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-acons" data-sym="ACONS">acons</a> (car <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
        (<a class="sym-link local-def" href="#def-update-io-lookup-init" data-sym="UPDATE-IO-LOOKUP-INIT" title="(defun update-io-lookup-init (args val)
  (declare (xargs :guard (true-listp args)))
  (cond ((endp args) val)
        (t (acons (car args) (update-io-lookup-init (cdr args) val) nil))))">update-io-lookup-init</a> (cdr <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>) val)
        nil))))</pre>
  </div>

<div class="form-block function" id="def-update-io-lookup" data-defines="UPDATE-IO-LOOKUP" data-references="UPDATE-IO-LOOKUP-INIT,ACONS,CDR,PUT-ASSOC-EQUAL,CAR,ASSOC-EQUAL,PAIR,LET,T,ENDP,COND,X,VAL,KEYS,DEFUN" data-used-by="UPDATE-IO-LOOKUP-LST" data-part-name="UPDATE-IO-LOOKUP" data-part-args="X,VAL,KEYS" data-part-body="UPDATE-IO-LOOKUP-INIT,ACONS,CDR,UPDATE-IO-LOOKUP,PUT-ASSOC-EQUAL,X,CAR,ASSOC-EQUAL,PAIR,LET,T,VAL,KEYS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-IO-LOOKUP">update-io-lookup</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-io-lookup" data-sym="UPDATE-IO-LOOKUP" title="(defun update-io-lookup (keys val x)
  (cond ((endp keys) val)
        (t
         (let ((pair (assoc-equal (car keys) x)))
           (cond
...">update-io-lookup</a>
  (keys val x)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> keys) val)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (let ((pair (<a class="sym-link system" href="../../../axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (car keys) x)))
        (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (pair (<a class="sym-link system" href="../../../axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> (car keys)
              (<a class="sym-link local-def" href="#def-update-io-lookup" data-sym="UPDATE-IO-LOOKUP" title="(defun update-io-lookup (keys val x)
  (cond ((endp keys) val)
        (t
         (let ((pair (assoc-equal (car keys) x)))
           (cond
...">update-io-lookup</a> (cdr keys) val (cdr pair))
              x))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-acons" data-sym="ACONS">acons</a> (car keys) (<a class="sym-link local-def" href="#def-update-io-lookup-init" data-sym="UPDATE-IO-LOOKUP-INIT" title="(defun update-io-lookup-init (args val)
  (declare (xargs :guard (true-listp args)))
  (cond ((endp args) val)
        (t (acons (car args) (update-io-lookup-init (cdr args) val) nil))))">update-io-lookup-init</a> (cdr keys) val) x)))))))</pre>
  </div>

<div class="form-block function" id="def-update-io-lookup-lst" data-defines="UPDATE-IO-LOOKUP-LST" data-references="UPDATE-IO-LOOKUP,VAL,KEYS,CAR,PAIR,LET*,CDR,T,ENDP,COND,X,LST,DEFUN" data-used-by="ADD-IO-PAIRS-EVENTS" data-part-name="UPDATE-IO-LOOKUP-LST" data-part-args="X,LST" data-part-body="UPDATE-IO-LOOKUP,VAL,KEYS,CAR,PAIR,LET*,CDR,UPDATE-IO-LOOKUP-LST,T,X,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-IO-LOOKUP-LST">update-io-lookup-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-io-lookup-lst" data-sym="UPDATE-IO-LOOKUP-LST" title="(defun update-io-lookup-lst (lst x)
  (cond ((endp lst) x)
        (t
         (update-io-lookup-lst (cdr lst)
          (let* ((pair (car lst)) (keys (car pair)) (val (cdr pair)))">update-io-lookup-lst</a>
  (lst x)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> lst) x)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-update-io-lookup-lst" data-sym="UPDATE-IO-LOOKUP-LST" title="(defun update-io-lookup-lst (lst x)
  (cond ((endp lst) x)
        (t
         (update-io-lookup-lst (cdr lst)
          (let* ((pair (car lst)) (keys (car pair)) (val (cdr pair)))">update-io-lookup-lst</a> (cdr lst)
        (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pair (car lst)) (keys (car pair)) (val (cdr pair)))
          (<a class="sym-link local-def" href="#def-update-io-lookup" data-sym="UPDATE-IO-LOOKUP" title="(defun update-io-lookup (keys val x)
  (cond ((endp keys) val)
        (t
         (let ((pair (assoc-equal (car keys) x)))
           (cond
...">update-io-lookup</a> keys val x))))))</pre>
  </div>

<div class="form-block function" id="def-io-lookup-fn" data-defines="IO-LOOKUP-FN" data-references="QUOTE,ASSOC,CDR,LET,QUASIQUOTE,T,ENDP,COND,TRUE-LISTP,XARGS,DECLARE,TESTS,KEYS,VAR,DEFUN" data-used-by="IO-LOOKUP" data-part-name="IO-LOOKUP-FN" data-part-args="TESTS,KEYS,VAR" data-part-declare="KEYS,TRUE-LISTP,XARGS,DECLARE" data-part-body="QUOTE,ASSOC,CDR,LET,QUASIQUOTE,T,VAR,KEYS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IO-LOOKUP-FN">io-lookup-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-io-lookup-fn" data-sym="IO-LOOKUP-FN" title="(defun io-lookup-fn (var keys tests)
  (declare (xargs :guard (true-listp keys)))
  (cond ((endp keys) var)
        (t
         `(let ((,var (cdr (assoc ,(car keys) ,var :test &#39;,(car tests)))))">io-lookup-fn</a>
  (var keys tests)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> keys)))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> keys) var)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> `(let ((,VAR (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> ,(CAR KEYS) ,VAR <span class="keyword">:test</span> ',(CAR TESTS)))))
        ,(IO-LOOKUP-FN VAR (CDR KEYS) (CDR TESTS))))))</pre>
  </div>

<div class="form-block macro" id="def-io-lookup" data-defines="IO-LOOKUP" data-references="MAKE-LIST,ATOM,IF,IO-LOOKUP-FN,SUBSETP-EQ,LENGTH,TRUE-LISTP,AND,EQL,EQ,EQUAL,QUOTE,MEMBER-EQ,OR,XARGS,DECLARE,KEYS,&REST,TESTS,VAR,DEFMACRO" data-used-by="ADD-IO-PAIRS-EVENTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="IO-LOOKUP">io-lookup</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-io-lookup" data-sym="IO-LOOKUP" title="(defmacro io-lookup (var tests &amp;rest keys)
  (declare
   (xargs :guard
    (or (member-eq tests (quote (equal eq eql)))
        (and (true-listp tests) (equal (length tests) (length keys))
...">io-lookup</a>
  (var tests &amp;rest keys)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> tests '(equal <a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a>))
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> tests)
          (equal (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> tests) (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> keys))
          (<a class="sym-link system" href="../../../axioms.html#def-subsetp-eq" data-sym="SUBSETP-EQ">subsetp-eq</a> tests '(equal <a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a>))))))
  (<a class="sym-link local-def" href="#def-io-lookup-fn" data-sym="IO-LOOKUP-FN" title="(defun io-lookup-fn (var keys tests)
  (declare (xargs :guard (true-listp keys)))
  (cond ((endp keys) var)
        (t
         `(let ((,var (cdr (assoc ,(car keys) ,var :test &#39;,(car tests)))))">io-lookup-fn</a> var
    keys
    (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> tests)
      (<a class="sym-link system" href="../../../axioms.html#def-make-list" data-sym="MAKE-LIST">make-list</a> (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> keys) <span class="keyword">:initial-element</span> tests)
      tests)))</pre>
  </div>

<div class="form-block function" id="def-io-pairs-add-input" data-defines="IO-PAIRS-ADD-INPUT" data-references="REST,RESULT,INPUTS,LIST,CONS,B*,T,ENDP,COND,LST,INPUT,DEFUN" data-used-by="GET-IO-PAIRS-FN1,GET-IO-PAIRS-FN2-LST" data-part-name="IO-PAIRS-ADD-INPUT" data-part-args="LST,INPUT" data-part-body="IO-PAIRS-ADD-INPUT,INPUT,REST,RESULT,INPUTS,LIST,CONS,B*,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IO-PAIRS-ADD-INPUT">io-pairs-add-input</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-io-pairs-add-input" data-sym="IO-PAIRS-ADD-INPUT" title="(defun io-pairs-add-input (input lst)
  (cond ((endp lst) nil)
        (t
         (b* (((cons (list inputs result) rest) lst))
          (cons (list (cons input inputs) result)">io-pairs-add-input</a>
  (input lst)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((cons (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> inputs result) <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>) lst))
        (cons (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cons input inputs) result)
          (<a class="sym-link local-def" href="#def-io-pairs-add-input" data-sym="IO-PAIRS-ADD-INPUT" title="(defun io-pairs-add-input (input lst)
  (cond ((endp lst) nil)
        (t
         (b* (((cons (list inputs result) rest) lst))
          (cons (list (cons input inputs) result)">io-pairs-add-input</a> input <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-get-io-pairs-fn2-lst" data-defines="GET-IO-PAIRS-FN2-LST" data-references="IO-PAIRS-ADD-INPUT,MV,QUOTE,CONS,IF,LIST,NULL,X,CDR,CAR,GET-IO-PAIRS-FN2,APPEND,T,ENDP,COND,MVP,LST,FORMALS,DEFUN,MUTUAL-RECURSION" data-used-by="GET-IO-PAIRS-FN1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-IO-PAIRS-FN2-LST">get-io-pairs-fn2-lst</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-io-pairs-fn2-lst" data-sym="GET-IO-PAIRS-FN2-LST" title="(mutual-recursion
 (defun get-io-pairs-fn2-lst (formals lst mvp)
   (cond ((endp lst) nil)
         (t
          (append (get-io-pairs-fn2 formals (car lst) mvp)
...">get-io-pairs-fn2-lst</a>
    (<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> lst mvp)
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (get-io-pairs-fn2 <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> (car lst) mvp)
          (<a class="sym-link local-def" href="#def-get-io-pairs-fn2-lst" data-sym="GET-IO-PAIRS-FN2-LST" title="(mutual-recursion
 (defun get-io-pairs-fn2-lst (formals lst mvp)
   (cond ((endp lst) nil)
         (t
          (append (get-io-pairs-fn2 formals (car lst) mvp)
...">get-io-pairs-fn2-lst</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> (cdr lst) mvp)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> get-io-pairs-fn2
    (<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> x mvp)
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>) (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> nil
            (if mvp
              (cons '<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> x)
              x))))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-io-pairs-add-input" data-sym="IO-PAIRS-ADD-INPUT" title="(defun io-pairs-add-input (input lst)
  (cond ((endp lst) nil)
        (t
         (b* (((cons (list inputs result) rest) lst))
          (cons (list (cons input inputs) result)">io-pairs-add-input</a> (car x)
          (<a class="sym-link local-def" href="#def-get-io-pairs-fn2-lst" data-sym="GET-IO-PAIRS-FN2-LST" title="(mutual-recursion
 (defun get-io-pairs-fn2-lst (formals lst mvp)
   (cond ((endp lst) nil)
         (t
          (append (get-io-pairs-fn2 formals (car lst) mvp)
...">get-io-pairs-fn2-lst</a> (cdr <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>) (cdr x) mvp))))))</pre>
  </div>

<div class="form-block function" id="def-get-io-pairs-fn1" data-defines="GET-IO-PAIRS-FN1" data-references="STOBJS-OUT,CONSP,ASSOC-EQ,CDR,FORMALS,GET-IO-PAIRS-FN2-LST,IO-PAIRS-ADD-INPUT,CAR,FN,LET,APPEND,T,ENDP,COND,WRLD,TBL,FNS,DEFUN" data-used-by="GET-IO-PAIRS-FN" data-part-name="GET-IO-PAIRS-FN1" data-part-args="WRLD,TBL,FNS" data-part-body="GET-IO-PAIRS-FN1,STOBJS-OUT,CONSP,TBL,ASSOC-EQ,CDR,WRLD,FORMALS,GET-IO-PAIRS-FN2-LST,IO-PAIRS-ADD-INPUT,CAR,FN,LET,APPEND,T,FNS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-IO-PAIRS-FN1">get-io-pairs-fn1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-io-pairs-fn1" data-sym="GET-IO-PAIRS-FN1" title="(defun get-io-pairs-fn1 (fns tbl wrld)
  (cond ((endp fns) nil)
        (t
         (append
          (let ((fn (car fns)))
...">get-io-pairs-fn1</a>
  (fns tbl wrld)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> fns) nil)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (let ((fn (car fns)))
          (<a class="sym-link local-def" href="#def-io-pairs-add-input" data-sym="IO-PAIRS-ADD-INPUT" title="(defun io-pairs-add-input (input lst)
  (cond ((endp lst) nil)
        (t
         (b* (((cons (list inputs result) rest) lst))
          (cons (list (cons input inputs) result)">io-pairs-add-input</a> fn
            (<a class="sym-link local-def" href="#def-get-io-pairs-fn2-lst" data-sym="GET-IO-PAIRS-FN2-LST" title="(mutual-recursion
 (defun get-io-pairs-fn2-lst (formals lst mvp)
   (cond ((endp lst) nil)
         (t
          (append (get-io-pairs-fn2 formals (car lst) mvp)
...">get-io-pairs-fn2-lst</a> (<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> fn wrld)
              (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> fn tbl))
              (consp (cdr (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> fn wrld))))))
        (<a class="sym-link local-def" href="#def-get-io-pairs-fn1" data-sym="GET-IO-PAIRS-FN1" title="(defun get-io-pairs-fn1 (fns tbl wrld)
  (cond ((endp fns) nil)
        (t
         (append
          (let ((fn (car fns)))
...">get-io-pairs-fn1</a> (cdr fns) tbl wrld)))))</pre>
  </div>

<div class="form-block function" id="def-get-io-pairs-fn" data-defines="GET-IO-PAIRS-FN" data-references="GET-IO-PAIRS-FN1,DEFAULT-STATE-VARS,GET-IO-PAIRS,WARNING$-CW0,-,T,INTERSECTION-EQ,COND,SET-DIFFERENCE-EQ,NOT,AND,BAD,EQUAL,ALLP,STRIP-CARS,TBL-FNS,IO-PAIRS-TABLE,QUOTE,TABLE-ALIST,TBL,B*,STATE,WARNP,WRLD,FNS,DEFUN" data-used-by="SHOW-IO-PAIRS-FN,GET-IO-PAIRS" data-part-name="GET-IO-PAIRS-FN" data-part-args="STATE,WARNP,WRLD,FNS" data-part-body="GET-IO-PAIRS-FN1,DEFAULT-STATE-VARS,GET-IO-PAIRS,WARNING$-CW0,WARNP,-,T,INTERSECTION-EQ,COND,SET-DIFFERENCE-EQ,NOT,AND,BAD,FNS,EQUAL,ALLP,STRIP-CARS,TBL-FNS,WRLD,IO-PAIRS-TABLE,QUOTE,TABLE-ALIST,TBL,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-IO-PAIRS-FN">get-io-pairs-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-io-pairs-fn" data-sym="GET-IO-PAIRS-FN" title="(defun get-io-pairs-fn (fns wrld warnp state)
  (b*
   ((tbl (table-alist &#39;io-pairs-table wrld)) (tbl-fns (strip-cars tbl))
    (allp (equal fns &#39;(:all)))
    (bad (and (not allp) (set-difference-eq fns tbl-fns)))
...">get-io-pairs-fn</a>
  (fns wrld warnp state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((tbl (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-table wrld)) (tbl-fns (<a class="sym-link system" href="../../../axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> tbl))
      (allp (equal fns '(<span class="keyword">:all</span>)))
      (bad (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> allp) (<a class="sym-link system" href="../../../axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> fns tbl-fns)))
      (fns (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (allp tbl-fns)
          (bad (<a class="sym-link system" href="../../../axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> fns tbl-fns))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> fns)))
      (<a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> bad
          warnp
          (warning$-cw0 '<a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a>
            nil
            (<a class="sym-link system" href="../../../basis-a.html#def-default-state-vars" data-sym="DEFAULT-STATE-VARS">default-state-vars</a> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
            <span class="string">"There ~#0~[is no I/O pair for the symbol~/are ~
                              no I/O pairs for the symbols~] ~&amp;0."</span>
            bad))))
    (<a class="sym-link local-def" href="#def-get-io-pairs-fn1" data-sym="GET-IO-PAIRS-FN1" title="(defun get-io-pairs-fn1 (fns tbl wrld)
  (cond ((endp fns) nil)
        (t
         (append
          (let ((fn (car fns)))
...">get-io-pairs-fn1</a> fns tbl wrld)))</pre>
  </div>

<div class="form-block macro" id="def-get-io-pairs" data-defines="GET-IO-PAIRS" data-references="T,STATE,W,GET-IO-PAIRS-FN,QUASIQUOTE,SOFT,ER,QUOTE,EQUAL,NOT,MEMBER-EQ,AND,IF,SYMBOL-LISTP,XARGS,DECLARE,FNS,&REST,DEFMACRO" data-used-by="GET-IO-PAIRS-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-IO-PAIRS">get-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a>
  (&amp;rest fns)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> fns)))
  (if (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <span class="keyword">:all</span> fns) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal fns '(<span class="keyword">:all</span>))))
    '(<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
      '<a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a>
      <span class="string">"It is illegal to use :ALL with ~x0 except in the form ~x1."</span>
      '<a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a>
      '(<a class="sym-link local-def" href="#def-get-io-pairs" data-sym="GET-IO-PAIRS" title="(defmacro get-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  (if (and (member-eq :all fns) (not (equal fns &#39;(:all))))
      &#39;(er soft &#39;get-io-pairs
           &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">get-io-pairs</a> <span class="keyword">:all</span>))
    `(<a class="sym-link local-def" href="#def-get-io-pairs-fn" data-sym="GET-IO-PAIRS-FN" title="(defun get-io-pairs-fn (fns wrld warnp state)
  (b*
   ((tbl (table-alist &#39;io-pairs-table wrld)) (tbl-fns (strip-cars tbl))
    (allp (equal fns &#39;(:all)))
    (bad (and (not allp) (set-difference-eq fns tbl-fns)))
...">get-io-pairs-fn</a> ',FNS (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> state)))</pre>
  </div>

<div class="form-block function" id="def-maybe-kwote-lst" data-defines="MAYBE-KWOTE-LST" data-references="CDR,CAR,MAYBE-KWOTE,CONS,T,ENDP,COND,TRUE-LISTP,XARGS,DECLARE,X,DEFUN" data-used-by="SHOW-IO-PAIRS-LST" data-part-name="MAYBE-KWOTE-LST" data-part-args="X" data-part-declare="X,TRUE-LISTP,XARGS,DECLARE" data-part-body="CDR,MAYBE-KWOTE-LST,CAR,MAYBE-KWOTE,CONS,T,X,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAYBE-KWOTE-LST">maybe-kwote-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-maybe-kwote-lst" data-sym="MAYBE-KWOTE-LST" title="(defun maybe-kwote-lst (x)
  (declare (xargs :guard (true-listp x) :mode :logic))
  (cond ((endp x) nil)
        (t (cons (maybe-kwote (car x)) (maybe-kwote-lst (cdr x))))))">maybe-kwote-lst</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x) <span class="keyword">:mode</span> <span class="keyword">:logic</span>))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> x) nil)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="../../../axioms.html#def-maybe-kwote" data-sym="MAYBE-KWOTE">maybe-kwote</a> (car x)) (<a class="sym-link local-def" href="#def-maybe-kwote-lst" data-sym="MAYBE-KWOTE-LST" title="(defun maybe-kwote-lst (x)
  (declare (xargs :guard (true-listp x) :mode :logic))
  (cond ((endp x) nil)
        (t (cons (maybe-kwote (car x)) (maybe-kwote-lst (cdr x))))))">maybe-kwote-lst</a> (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-show-io-pairs-lst" data-defines="SHOW-IO-PAIRS-LST" data-references="LIST,FMS,QUASIQUOTE,IO-PAIR,MAYBE-KWOTE,CONS,MV,QUOTE,EQ,ASSERT$,IF,QRESULT,MAYBE-KWOTE-LST,QINPUTS,STOBJS-OUT,MVP,CADR,RESULT,CDR,INPUTS,FN,FN/INPUTS,CAR,PAIR,B*,PPROGN,T,NEWLINE,ENDP,COND,STATE,WRLD,CHAN,PAIRS,DEFUN" data-used-by="SHOW-IO-PAIRS-FN" data-part-name="SHOW-IO-PAIRS-LST" data-part-args="STATE,WRLD,CHAN,PAIRS" data-part-body="SHOW-IO-PAIRS-LST,LIST,FMS,QUASIQUOTE,IO-PAIR,MAYBE-KWOTE,CONS,MV,QUOTE,EQ,ASSERT$,IF,QRESULT,MAYBE-KWOTE-LST,QINPUTS,WRLD,STOBJS-OUT,MVP,CADR,RESULT,CDR,INPUTS,FN,FN/INPUTS,CAR,PAIR,B*,PPROGN,T,STATE,CHAN,NEWLINE,PAIRS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-IO-PAIRS-LST">show-io-pairs-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-io-pairs-lst" data-sym="SHOW-IO-PAIRS-LST" title="(defun show-io-pairs-lst (pairs chan wrld state)
  (cond ((endp pairs) (newline chan state))
        (t
         (pprogn
          (b*
...">show-io-pairs-lst</a>
  (pairs chan wrld state)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> pairs) (<a class="sym-link system" href="../../../basis-a.html#def-newline" data-sym="NEWLINE">newline</a> chan state))
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((pair (car pairs)) (fn/inputs (car pair))
            (fn (car fn/inputs))
            (inputs (cdr fn/inputs))
            (result (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> pair))
            (mvp (cdr (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> fn wrld)))
            (qinputs (<a class="sym-link local-def" href="#def-maybe-kwote-lst" data-sym="MAYBE-KWOTE-LST" title="(defun maybe-kwote-lst (x)
  (declare (xargs :guard (true-listp x) :mode :logic))
  (cond ((endp x) nil)
        (t (cons (maybe-kwote (car x)) (maybe-kwote-lst (cdr x))))))">maybe-kwote-lst</a> inputs))
            (qresult (if mvp
                (<a class="sym-link system" href="../../../axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (car result) '<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a>)
                  (cons '<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-maybe-kwote-lst" data-sym="MAYBE-KWOTE-LST" title="(defun maybe-kwote-lst (x)
  (declare (xargs :guard (true-listp x) :mode :logic))
  (cond ((endp x) nil)
        (t (cons (maybe-kwote (car x)) (maybe-kwote-lst (cdr x))))))">maybe-kwote-lst</a> (cdr result))))
                (<a class="sym-link system" href="../../../axioms.html#def-maybe-kwote" data-sym="MAYBE-KWOTE">maybe-kwote</a> result)))
            (io-pair `((,FN ,@QINPUTS) ,QRESULT)))
          (<a class="sym-link system" href="../../../basis-a.html#def-fms" data-sym="FMS">fms</a> <span class="string">"~x0"</span> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 io-pair)) chan state nil))
        (<a class="sym-link local-def" href="#def-show-io-pairs-lst" data-sym="SHOW-IO-PAIRS-LST" title="(defun show-io-pairs-lst (pairs chan wrld state)
  (cond ((endp pairs) (newline chan state))
        (t
         (pprogn
          (b*
...">show-io-pairs-lst</a> (cdr pairs) chan wrld state)))))</pre>
  </div>

<div class="form-block function" id="def-show-io-pairs-fn" data-defines="SHOW-IO-PAIRS-FN" data-references="VALUE,SHOW-IO-PAIRS-LST,T,ZERO-ONE-OR-MORE,CONS,LIST,FMS,NULL,COND,PPROGN,OR,GET-IO-PAIRS-FN,PAIRS,ALLP,STANDARD-CO,CHAN,W,WRLD,SHOW-IO-PAIRS,SOFT,ER,QUOTE,EQUAL,NOT,MEMBER-EQ,AND,WHEN,B*,STATE,FNS,DEFUN" data-used-by="SHOW-IO-PAIRS" data-part-name="SHOW-IO-PAIRS-FN" data-part-args="STATE,FNS" data-part-body="VALUE,SHOW-IO-PAIRS-LST,T,ZERO-ONE-OR-MORE,CONS,LIST,FMS,NULL,COND,PPROGN,OR,GET-IO-PAIRS-FN,PAIRS,ALLP,STANDARD-CO,CHAN,STATE,W,WRLD,SHOW-IO-PAIRS,SOFT,ER,QUOTE,EQUAL,NOT,FNS,MEMBER-EQ,AND,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-IO-PAIRS-FN">show-io-pairs-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-io-pairs-fn" data-sym="SHOW-IO-PAIRS-FN" title="(defun show-io-pairs-fn (fns state)
  (b*
   (((when (and (member-eq :all fns) (not (equal fns &#39;(:all)))))
     (er soft &#39;show-io-pairs
         &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">show-io-pairs-fn</a>
  (fns state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <span class="keyword">:all</span> fns) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal fns '(<span class="keyword">:all</span>))))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
         '<a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a>
         <span class="string">"It is illegal to use :ALL with ~x0 except in the form ~x1."</span>
         '<a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a>
         '(<a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a> <span class="keyword">:all</span>))) (wrld (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
      (chan (<a class="sym-link system" href="../../../basis-a.html#def-standard-co" data-sym="STANDARD-CO">standard-co</a> state))
      (allp (equal fns '(<span class="keyword">:all</span>)))
      (pairs (<a class="sym-link local-def" href="#def-get-io-pairs-fn" data-sym="GET-IO-PAIRS-FN" title="(defun get-io-pairs-fn (fns wrld warnp state)
  (b*
   ((tbl (table-alist &#39;io-pairs-table wrld)) (tbl-fns (strip-cars tbl))
    (allp (equal fns &#39;(:all)))
    (bad (and (not allp) (set-difference-eq fns tbl-fns)))
...">get-io-pairs-fn</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> fns '(<span class="keyword">:all</span>)) wrld nil state)))
    (<a class="sym-link system" href="../../../axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> pairs) (<a class="sym-link system" href="../../../basis-a.html#def-fms" data-sym="FMS">fms</a> <span class="string">"There are no verified I/O pairs to display~#0~[~/ for the symbol ~
             ~v1~/ for any of the symbols ~v1~].~|"</span>
            (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (<a class="sym-link system" href="../../../basis-a.html#def-zero-one-or-more" data-sym="ZERO-ONE-OR-MORE">zero-one-or-more</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> allp) fns)))
              (cons #\1 (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> allp) fns)))
            chan
            state
            nil))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="../../../basis-a.html#def-fms" data-sym="FMS">fms</a> <span class="string">"Verified I/O pairs ((fn arg1 .. argn) result):~|"</span>
              nil
              chan
              state
              nil)
            (<a class="sym-link local-def" href="#def-show-io-pairs-lst" data-sym="SHOW-IO-PAIRS-LST" title="(defun show-io-pairs-lst (pairs chan wrld state)
  (cond ((endp pairs) (newline chan state))
        (t
         (pprogn
          (b*
...">show-io-pairs-lst</a> pairs chan wrld state))))
      (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))</pre>
  </div>

<div class="form-block macro" id="def-show-io-pairs" data-defines="SHOW-IO-PAIRS" data-references="STATE,QUOTE,SHOW-IO-PAIRS-FN,QUASIQUOTE,SYMBOL-LISTP,XARGS,DECLARE,FNS,&REST,DEFMACRO" data-used-by="REMOVE-IO-PAIRS-EVENT,SHOW-IO-PAIRS-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-IO-PAIRS">show-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a>
  (&amp;rest fns)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> fns)))
  `(<a class="sym-link local-def" href="#def-show-io-pairs-fn" data-sym="SHOW-IO-PAIRS-FN" title="(defun show-io-pairs-fn (fns state)
  (b*
   (((when (and (member-eq :all fns) (not (equal fns &#39;(:all)))))
     (er soft &#39;show-io-pairs
         &quot;It is illegal to use :ALL with ~x0 except in the form ~x1.&quot;
...">show-io-pairs-fn</a> ',FNS state))</pre>
  </div>

<div class="form-block function" id="def-simple-trans-eval-lst" data-defines="SIMPLE-TRANS-EVAL-LST" data-references="1+,CDR,REST,T,LIST,MSG,SIMPLE-TRANSLATE-AND-EVAL,VAL,?TTERM,CONS,ER,CAR,TERM,VALUE,ENDP,WHEN,B*,STATE,WRLD,CTX,CALL,I,LST,DEFUN" data-used-by="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" data-part-name="SIMPLE-TRANS-EVAL-LST" data-part-args="STATE,WRLD,CTX,CALL,I,LST" data-part-body="1+,CDR,SIMPLE-TRANS-EVAL-LST,REST,T,STATE,WRLD,CTX,CALL,I,LIST,MSG,SIMPLE-TRANSLATE-AND-EVAL,VAL,?TTERM,CONS,ER,CAR,TERM,VALUE,LST,ENDP,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SIMPLE-TRANS-EVAL-LST">simple-trans-eval-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-simple-trans-eval-lst" data-sym="SIMPLE-TRANS-EVAL-LST" title="(defun simple-trans-eval-lst (lst i call ctx wrld state)
  (b*
   (((when (endp lst)) (value nil)) (term (car lst))
    ((er (cons ?tterm val))
     (simple-translate-and-eval term nil nil
...">simple-trans-eval-lst</a>
  (lst i call ctx wrld state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> lst)) (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil)) (term (car lst))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> (cons ?tterm val)) (simple-translate-and-eval term
          nil
          nil
          (<a class="sym-link system" href="../../../axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"The ~n0 argument of the call ~x1"</span> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> i) call)
          ctx
          wrld
          state
          <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>) (<a class="sym-link local-def" href="#def-simple-trans-eval-lst" data-sym="SIMPLE-TRANS-EVAL-LST" title="(defun simple-trans-eval-lst (lst i call ctx wrld state)
  (b*
   (((when (endp lst)) (value nil)) (term (car lst))
    ((er (cons ?tterm val))
     (simple-translate-and-eval term nil nil
...">simple-trans-eval-lst</a> (cdr lst) (<a class="sym-link system" href="../../../axioms.html#def-1_2B" data-sym="1+">1+</a> i) call ctx wrld state)))
    (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> (cons val <a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a>))))</pre>
  </div>

<div class="form-block function" id="def-add-io-pairs-translate-tuples-1" data-defines="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" data-references="IO-DOUBLET-LST,IO-DOUBLET,TRANS-EVAL,OUTPUT,?,EQUAL,TRANSLATE-DEREF,RESULT-STOBJS-OUT,SILENT-ERROR,T,QUOTE,TRANSLATE1,BINDINGS,?TRANS,ERP,MV,-,SIMPLE-TRANS-EVAL-LST,INPUTS,LENGTH,=,EQ,RESULT,ACTUALS,FN2,CONS,LIST,SOFT,ER,CDDR,CDR,CONSP,AND,NOT,CAR,TUPLE,VALUE,NULL,WHEN,B*,STATE,WRLD,CTX,STOBJS-OUT,ARITY-IN,FN,TUPLES,DEFUN" data-used-by="ADD-IO-PAIRS-TRANSLATE-TUPLES" data-part-name="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" data-part-args="STATE,WRLD,CTX,STOBJS-OUT,ARITY-IN,FN,TUPLES" data-part-body="ADD-IO-PAIRS-TRANSLATE-TUPLES-1,IO-DOUBLET-LST,IO-DOUBLET,TRANS-EVAL,OUTPUT,?,STOBJS-OUT,EQUAL,TRANSLATE-DEREF,RESULT-STOBJS-OUT,SILENT-ERROR,T,QUOTE,TRANSLATE1,BINDINGS,?TRANS,ERP,MV,-,STATE,WRLD,SIMPLE-TRANS-EVAL-LST,INPUTS,ARITY-IN,LENGTH,=,FN,EQ,RESULT,ACTUALS,FN2,CONS,LIST,CTX,SOFT,ER,CDDR,CDR,CONSP,AND,NOT,CAR,TUPLE,VALUE,TUPLES,NULL,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES-1">add-io-pairs-translate-tuples-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-io-pairs-translate-tuples-1" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" title="(defun add-io-pairs-translate-tuples-1
       (tuples fn arity-in stobjs-out ctx wrld state)
  (b*
   (((when (null tuples)) (value nil)) (tuple (car tuples))
    ((when
...">add-io-pairs-translate-tuples-1</a>
  (tuples fn arity-in <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> ctx wrld state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> tuples)) (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil)) (tuple (car tuples))
      ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp tuple)
             (consp (car tuple))
             (consp (cdr tuple))
             (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> tuple))))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
          ctx
          <span class="string">"An I/O tuple must be of the form ((fn x1 ... xk) result), but ~
             the following is not of that form:~|~x0"</span>
          tuple))
      ((<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (cons fn2 actuals) result) tuple)
      ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> fn2 fn))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
          ctx
          <span class="string">"It is illegal to specify more than one function symbol in a call ~
             of add-io-pairs, but both ~x0 and ~x1 were specified."</span>
          fn
          fn2))
      ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-_3D" data-sym="=">=</a> (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> actuals) arity-in))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
          ctx
          <span class="string">"The I/O pair ~x0 specifies ~x1 inputs, but the function symbol ~
             ~x2 expects ~x3 inputs."</span>
          tuple
          (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> actuals)
          fn
          arity-in))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> inputs) (<a class="sym-link local-def" href="#def-simple-trans-eval-lst" data-sym="SIMPLE-TRANS-EVAL-LST" title="(defun simple-trans-eval-lst (lst i call ctx wrld state)
  (b*
   (((when (endp lst)) (value nil)) (term (car lst))
    ((er (cons ?tterm val))
     (simple-translate-and-eval term nil nil
...">simple-trans-eval-lst</a> actuals
          <span class="number">1</span>
          (cons fn actuals)
          ctx
          wrld
          state))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> <a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a>) (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> erp ?trans bindings state) (translate1 result
               <span class="keyword">:stobjs-out</span> '((<span class="keyword">:stobjs-out</span> . <span class="keyword">:stobjs-out</span>))
               <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
               ctx
               wrld
               state)) ((when erp) (silent-error state))
            (result-stobjs-out (translate-deref <span class="keyword">:stobjs-out</span> bindings))
            ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> result-stobjs-out))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
                ctx
                <span class="string">"The I/O pair ~x0 specifies a return of ~x1 value~#2~[~/s~] ~
                   but the function ~x3 returns ~x4 value~#5~[~/s~]."</span>
                tuple
                (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> result-stobjs-out)
                result-stobjs-out
                fn
                (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>)
                <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>)))
          (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil)))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> (cons ? output)) (trans-eval result ctx state <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
      (io-doublet (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> inputs output))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> io-doublet-lst) (<a class="sym-link local-def" href="#def-add-io-pairs-translate-tuples-1" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" title="(defun add-io-pairs-translate-tuples-1
       (tuples fn arity-in stobjs-out ctx wrld state)
  (b*
   (((when (null tuples)) (value nil)) (tuple (car tuples))
    ((when
...">add-io-pairs-translate-tuples-1</a> (cdr tuples)
          fn
          arity-in
          <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>
          ctx
          wrld
          state)))
    (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> (cons io-doublet io-doublet-lst))))</pre>
  </div>

<div class="form-block function" id="def-add-io-pairs-translate-tuples" data-defines="ADD-IO-PAIRS-TRANSLATE-TUPLES" data-references="VALUE,HARD,PROG2$,T,ADD-IO-PAIRS-TRANSLATE-TUPLES-1,WITH-GUARD-CHECKING-ERROR-TRIPLE,REMOVE-EQ,UNION-EQ,STOBJS,STOBJS-OUT,*STOBJS-OUT-INVALID*,MEMBER-EQ,LENGTH,ARITY-IN,STOBJS-IN,SYMBOL-CLASS,EQ,FUNCTION-SYMBOLP,SYMBOLP,WHEN,CAAR,FN,CAR,TUPLE,B*,CONSP,MBT,SOFT,ER,STRIP-CARS,ALISTP,AND,NOT,COND,XARGS,DECLARE,STATE,WRLD,CTX,TUPLES,DEFUN" data-used-by="ADD-IO-PAIRS" data-part-name="ADD-IO-PAIRS-TRANSLATE-TUPLES" data-part-args="STATE,WRLD,CTX,TUPLES" data-part-declare="TUPLES,XARGS,DECLARE" data-part-body="VALUE,HARD,PROG2$,T,STATE,ADD-IO-PAIRS-TRANSLATE-TUPLES-1,WITH-GUARD-CHECKING-ERROR-TRIPLE,REMOVE-EQ,UNION-EQ,STOBJS,STOBJS-OUT,*STOBJS-OUT-INVALID*,MEMBER-EQ,LENGTH,ARITY-IN,STOBJS-IN,SYMBOL-CLASS,EQ,WRLD,FUNCTION-SYMBOLP,SYMBOLP,WHEN,CAAR,FN,CAR,TUPLE,B*,CONSP,MBT,CTX,SOFT,ER,STRIP-CARS,TUPLES,ALISTP,AND,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES">add-io-pairs-translate-tuples</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-io-pairs-translate-tuples" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES" title="(defun add-io-pairs-translate-tuples (tuples ctx wrld state)
  (declare (xargs :guard tuples))
  (cond
   ((not (and (alistp tuples) (alistp (strip-cars tuples))))
    (er soft ctx
...">add-io-pairs-translate-tuples</a>
  (tuples ctx wrld state)
  (declare (xargs <span class="keyword">:guard</span> tuples))
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> tuples) (<a class="sym-link system" href="../../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="../../../axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> tuples)))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
        ctx
        <span class="string">"The first argument of add-io-pairs must be a true list of pairs of ~
         the form ((fn arg1 ... argk) result).  The argument ~x0 is thus ~
         illegal."</span>
        tuples))
    ((<a class="sym-link system" href="../../../axioms.html#def-mbt" data-sym="MBT">mbt</a> (consp tuples)) (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((tuple (car tuples)) (fn (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> tuple))
          ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (symbolp fn)
                 (<a class="sym-link system" href="../../../axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> fn wrld)
                 (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../basis-b.html#def-symbol-class" data-sym="SYMBOL-CLASS">symbol-class</a> fn wrld) <span class="keyword">:common-lisp-compliant</span>)))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft ctx <span class="string">"Not a guard-verified function symbol: ~x0"</span> fn))
          (<a class="sym-link system" href="../../../axioms.html#def-stobjs-in" data-sym="STOBJS-IN">stobjs-in</a> (<a class="sym-link system" href="../../../axioms.html#def-stobjs-in" data-sym="STOBJS-IN">stobjs-in</a> fn wrld))
          (arity-in (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../../axioms.html#def-stobjs-in" data-sym="STOBJS-IN">stobjs-in</a>))
          ((when (<a class="sym-link system" href="../../../axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> fn <a class="sym-link system" href="../../../axioms.html#def-_2Astobjs-out-invalid_2A" data-sym="*STOBJS-OUT-INVALID*">*stobjs-out-invalid*</a>)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
              ctx
              <span class="string">"It is illegal to add I/O pairs for the function symbol ~x0."</span>
              fn))
          (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> fn wrld))
          (stobjs (<a class="sym-link system" href="../../../axioms.html#def-union-eq" data-sym="UNION-EQ">union-eq</a> (<a class="sym-link system" href="../../../axioms.html#def-remove-eq" data-sym="REMOVE-EQ">remove-eq</a> nil <a class="sym-link system" href="../../../axioms.html#def-stobjs-in" data-sym="STOBJS-IN">stobjs-in</a>)
              (<a class="sym-link system" href="../../../axioms.html#def-remove-eq" data-sym="REMOVE-EQ">remove-eq</a> nil <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>)))
          ((when stobjs) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
              ctx
              <span class="string">"It is illegal to call add-io-pairs for the function symbol ~
               ~x0, because it traffics in the stobj~#1~[~/s~] ~x1."</span>
              fn
              stobjs)))
        (<a class="sym-link system" href="../../../axioms.html#def-with-guard-checking-error-triple" data-sym="WITH-GUARD-CHECKING-ERROR-TRIPLE">with-guard-checking-error-triple</a> nil
          (<a class="sym-link local-def" href="#def-add-io-pairs-translate-tuples-1" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES-1" title="(defun add-io-pairs-translate-tuples-1
       (tuples fn arity-in stobjs-out ctx wrld state)
  (b*
   (((when (null tuples)) (value nil)) (tuple (car tuples))
    ((when
...">add-io-pairs-translate-tuples-1</a> tuples
            fn
            arity-in
            <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>
            ctx
            wrld
            state))))
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard ctx <span class="string">"Implementation error: Impossible case!"</span>)
        (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil)))))</pre>
  </div>

<div class="form-block function" id="def-add-io-pairs-dcls" data-defines="ADD-IO-PAIRS-DCLS" data-references="CDDR,BUTLAST,QUASIQUOTE,OTHERWISE,CLTL-DEF-FROM-NAME,VERIFY-TERMINATION-BOOT-STRAP,STRIP-CDRS,ASSOC-EQ,MUTUAL-RECURSION,CDR,CAR,CASE,DEF,GET-EVENT,EV,LET*,T,QUOTE,CONS,XARGS,DECLARE,WRLD,FN,DEFUN" data-part-name="ADD-IO-PAIRS-DCLS" data-part-args="WRLD,FN" data-part-declare="XARGS,DECLARE" data-part-body="CDDR,BUTLAST,QUASIQUOTE,OTHERWISE,CLTL-DEF-FROM-NAME,VERIFY-TERMINATION-BOOT-STRAP,STRIP-CDRS,ASSOC-EQ,MUTUAL-RECURSION,CDR,DEFUN,CAR,CASE,DEF,WRLD,FN,GET-EVENT,EV,LET*,T,XARGS,DECLARE,QUOTE,CONS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIRS-DCLS">add-io-pairs-dcls</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-io-pairs-dcls" data-sym="ADD-IO-PAIRS-DCLS" title="(defun add-io-pairs-dcls (fn wrld)
  (declare (xargs :mode :program))
  (cons &#39;(declare (xargs :verify-guards t))
        (let* ((ev (get-event fn wrld))
               (def
...">add-io-pairs-dcls</a>
  (fn wrld)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (cons '(declare (xargs <span class="keyword">:verify-guards</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
    (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ev (get-event fn wrld)) (def (<a class="sym-link system" href="../../../axioms.html#def-case" data-sym="CASE">case</a> (car ev)
            (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> (cdr ev))
            (<a class="sym-link system" href="../../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> fn (<a class="sym-link system" href="../../../axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> (cdr ev))))
            (<a class="sym-link system" href="../../../axioms.html#def-verify-termination-boot-strap" data-sym="VERIFY-TERMINATION-BOOT-STRAP">verify-termination-boot-strap</a> (cdr (cltl-def-from-name fn wrld)))
            (otherwise `(declare (xargs <span class="keyword">:guard</span> ,(GUARD FN NIL WRLD)))))))
      (<a class="sym-link system" href="../../../axioms.html#def-butlast" data-sym="BUTLAST">butlast</a> (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> def) <span class="number">1</span>))))</pre>
  </div>

<div class="form-block function" id="def-formal-mv" data-defines="FORMAL-MV" data-references="LIST*,CONS,1+,1-,CDR,NEXT-EXPR,CAR,AI-BINDING,A,AI,XI-BINDING,X,PACKN,XI,T,MV,QUASIQUOTE,REVERSE,LET*,QUOTE,LIST,ZP,COND,BINDINGS,VARS,I,EXPR,N,DEFUN" data-used-by="ADD-IO-PAIRS-EVENTS" data-part-name="FORMAL-MV" data-part-args="BINDINGS,VARS,I,EXPR,N" data-part-body="LIST*,VARS,CONS,1+,1-,FORMAL-MV,CDR,NEXT-EXPR,CAR,AI-BINDING,A,AI,EXPR,XI-BINDING,I,X,PACKN,XI,T,MV,QUASIQUOTE,BINDINGS,REVERSE,LET*,QUOTE,LIST,N,ZP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORMAL-MV">formal-mv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-formal-mv" data-sym="FORMAL-MV" title="(defun formal-mv (n expr i vars bindings)
  (cond ((zp n) (list &#39;let* (reverse bindings) `(mv ,@(reverse vars))))
        (t
         (let* ((xi (packn (list &#39;x i)))
                (xi-binding (list xi expr))
...">formal-mv</a>
  (n expr i vars bindings)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-zp" data-sym="ZP">zp</a> n) (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> bindings) `(<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> ,@(REVERSE VARS))))
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((xi (<a class="sym-link system" href="../../../basis-a.html#def-packn" data-sym="PACKN">packn</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> 'x i))) (xi-binding (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> xi expr))
          (ai (<a class="sym-link system" href="../../../basis-a.html#def-packn" data-sym="PACKN">packn</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> 'a i)))
          (ai-binding (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> ai (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> 'car xi)))
          (next-expr (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> 'cdr xi)))
        (<a class="sym-link local-def" href="#def-formal-mv" data-sym="FORMAL-MV" title="(defun formal-mv (n expr i vars bindings)
  (cond ((zp n) (list &#39;let* (reverse bindings) `(mv ,@(reverse vars))))
        (t
         (let* ((xi (packn (list &#39;x i)))
                (xi-binding (list xi expr))
...">formal-mv</a> (<a class="sym-link system" href="../../../axioms.html#def-1-" data-sym="1-">1-</a> n)
          next-expr
          (<a class="sym-link system" href="../../../axioms.html#def-1_2B" data-sym="1+">1+</a> i)
          (cons ai vars)
          (<a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> ai-binding xi-binding bindings))))))</pre>
  </div>

<div class="form-block function" id="def-push-io-pairs-lenience-fn" data-defines="PUSH-IO-PAIRS-LENIENCE-FN" data-references="WORLD,TABLE-ALIST,ASSOC-EQ,CDR,QUOTE,IO-PAIRS-LENIENCE-TABLE,TABLE,QUASIQUOTE,CONS,T,ENDP,COND,FNS,DEFUN" data-used-by="PUSH-IO-PAIRS-LENIENCE" data-part-name="PUSH-IO-PAIRS-LENIENCE-FN" data-part-args="FNS" data-part-body="PUSH-IO-PAIRS-LENIENCE-FN,WORLD,TABLE-ALIST,ASSOC-EQ,CDR,QUOTE,IO-PAIRS-LENIENCE-TABLE,TABLE,QUASIQUOTE,CONS,T,FNS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-IO-PAIRS-LENIENCE-FN">push-io-pairs-lenience-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-io-pairs-lenience-fn" data-sym="PUSH-IO-PAIRS-LENIENCE-FN" title="(defun push-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">push-io-pairs-lenience-fn</a>
  (fns)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> fns) nil)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (cons `(<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> io-pairs-lenience-table
          ',(CAR FNS)
          (cons nil
            (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> ',(CAR FNS)
                (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-lenience-table world)))))
        (<a class="sym-link local-def" href="#def-push-io-pairs-lenience-fn" data-sym="PUSH-IO-PAIRS-LENIENCE-FN" title="(defun push-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">push-io-pairs-lenience-fn</a> (cdr fns))))))</pre>
  </div>

<div class="form-block macro" id="def-push-io-pairs-lenience" data-defines="PUSH-IO-PAIRS-LENIENCE" data-references="PUSH-IO-PAIRS-LENIENCE-FN,PROGN,QUOTE,CONS,FNS,&REST,DEFMACRO" data-used-by="MERGE-IO-PAIRS-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-IO-PAIRS-LENIENCE">push-io-pairs-lenience</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-push-io-pairs-lenience" data-sym="PUSH-IO-PAIRS-LENIENCE" title="(defmacro push-io-pairs-lenience (&amp;rest fns)
  (cons &#39;progn (push-io-pairs-lenience-fn fns)))">push-io-pairs-lenience</a>
  (&amp;rest fns)
  (cons '<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link local-def" href="#def-push-io-pairs-lenience-fn" data-sym="PUSH-IO-PAIRS-LENIENCE-FN" title="(defun push-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">push-io-pairs-lenience-fn</a> fns)))</pre>
  </div>

<div class="form-block function" id="def-pop-io-pairs-lenience-fn" data-defines="POP-IO-PAIRS-LENIENCE-FN" data-references="WORLD,TABLE-ALIST,ASSOC-EQ,CDR,QUOTE,IO-PAIRS-LENIENCE-TABLE,TABLE,QUASIQUOTE,CONS,T,ENDP,COND,FNS,DEFUN" data-used-by="POP-IO-PAIRS-LENIENCE" data-part-name="POP-IO-PAIRS-LENIENCE-FN" data-part-args="FNS" data-part-body="POP-IO-PAIRS-LENIENCE-FN,WORLD,TABLE-ALIST,ASSOC-EQ,CDR,QUOTE,IO-PAIRS-LENIENCE-TABLE,TABLE,QUASIQUOTE,CONS,T,FNS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-IO-PAIRS-LENIENCE-FN">pop-io-pairs-lenience-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pop-io-pairs-lenience-fn" data-sym="POP-IO-PAIRS-LENIENCE-FN" title="(defun pop-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">pop-io-pairs-lenience-fn</a>
  (fns)
  (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-endp" data-sym="ENDP">endp</a> fns) nil)
    (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (cons `(<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> io-pairs-lenience-table
          ',(CAR FNS)
          (cdr (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> ',(CAR FNS)
                (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-lenience-table world)))))
        (<a class="sym-link local-def" href="#def-pop-io-pairs-lenience-fn" data-sym="POP-IO-PAIRS-LENIENCE-FN" title="(defun pop-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">pop-io-pairs-lenience-fn</a> (cdr fns))))))</pre>
  </div>

<div class="form-block macro" id="def-pop-io-pairs-lenience" data-defines="POP-IO-PAIRS-LENIENCE" data-references="POP-IO-PAIRS-LENIENCE-FN,PROGN,QUOTE,CONS,FNS,&REST,DEFMACRO" data-used-by="MERGE-IO-PAIRS-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-IO-PAIRS-LENIENCE">pop-io-pairs-lenience</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pop-io-pairs-lenience" data-sym="POP-IO-PAIRS-LENIENCE" title="(defmacro pop-io-pairs-lenience (&amp;rest fns)
  (cons &#39;progn (pop-io-pairs-lenience-fn fns)))">pop-io-pairs-lenience</a>
  (&amp;rest fns)
  (cons '<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link local-def" href="#def-pop-io-pairs-lenience-fn" data-sym="POP-IO-PAIRS-LENIENCE-FN" title="(defun pop-io-pairs-lenience-fn (fns)
  (cond ((endp fns) nil)
        (t
         (cons
          `(table io-pairs-lenience-table &#39;,(car fns)
...">pop-io-pairs-lenience-fn</a> fns)))</pre>
  </div>

<div class="form-block function" id="def-check-io-pairs-lenience-fn" data-defines="CHECK-IO-PAIRS-LENIENCE-FN" data-references="SOFT,ER,ERROR,WITH-OUTPUT!,STR4,IF,NUM2,STR,INCLUDE-BOOK-PATH,GLOBAL-VAL,CAR,BOOK,EQUAL,NOT,CTX,IO-PAIRS-TABLE,CURRENT-ENTRY,VALUE-TRIPLE,VALUE,WHEN,IO-PAIRS-LENIENCE-TABLE,QUOTE,TABLE-ALIST,ASSOC-EQ,CDR,LENIENCE,W,WRLD,B*,STATE,CALLER,OLD-ENTRY,FN,DEFUN" data-used-by="CHECK-IO-PAIRS-LENIENCE" data-part-name="CHECK-IO-PAIRS-LENIENCE-FN" data-part-args="STATE,CALLER,OLD-ENTRY,FN" data-part-body="SOFT,ER,ERROR,WITH-OUTPUT!,STR4,IF,NUM2,STR,INCLUDE-BOOK-PATH,GLOBAL-VAL,CAR,BOOK,OLD-ENTRY,EQUAL,NOT,CALLER,CTX,IO-PAIRS-TABLE,CURRENT-ENTRY,VALUE-TRIPLE,VALUE,WHEN,IO-PAIRS-LENIENCE-TABLE,QUOTE,TABLE-ALIST,FN,ASSOC-EQ,CDR,LENIENCE,STATE,W,WRLD,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHECK-IO-PAIRS-LENIENCE-FN">check-io-pairs-lenience-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-check-io-pairs-lenience-fn" data-sym="CHECK-IO-PAIRS-LENIENCE-FN" title="(defun check-io-pairs-lenience-fn (fn old-entry caller state)
  (b*
   ((wrld (w state))
    (lenience (cdr (assoc-eq fn (table-alist &#39;io-pairs-lenience-table wrld))))
    ((when lenience) (value &#39;(value-triple :invisible)))
...">check-io-pairs-lenience-fn</a>
  (fn old-entry caller state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((wrld (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state)) (lenience (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> fn (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-lenience-table wrld))))
      ((when lenience) (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> '(<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> <span class="keyword">:invisible</span>)))
      (current-entry (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> fn (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-table wrld))))
      (ctx caller)
      ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal old-entry current-entry))) (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((book (car (<a class="sym-link system" href="../../../axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'include-book-path wrld))) (str <span class="string">"ACL2 is encountering a call of ~x0 on function symbol ~
                    ~#2~[~x1 while attempting to include the book ~
                    ~x3.~|~/~x1.  ~]But the existing list of I/O pairs for ~
                    ~x1 is different from ~@4.  See :DOC merge-io-pairs for ~
                    how to avoid this ~@5."</span>)
            (num2 (if book
                <span class="number">0</span>
                <span class="number">1</span>))
            (str4 (if book
                <span class="string">"when that book was being certified"</span>
                <span class="string">"what it was previously at that point (perhaps during ~
                      the first pass of an encapsulate event)"</span>)))
          (<a class="sym-link system" href="../../../axioms.html#def-with-output_21" data-sym="WITH-OUTPUT!">with-output!</a> <span class="keyword">:on</span> error
            (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft ctx str caller fn num2 book str4 <span class="string">"error"</span>)))))
    (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> '(<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> <span class="keyword">:invisible</span>))))</pre>
  </div>

<div class="form-block macro" id="def-check-io-pairs-lenience" data-defines="CHECK-IO-PAIRS-LENIENCE" data-references="T,STATE,QUOTE,CHECK-IO-PAIRS-LENIENCE-FN,MAKE-EVENT,QUASIQUOTE,CALLER,OLD-ENTRY,FN,DEFMACRO" data-used-by="ADD-IO-PAIRS-EVENTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CHECK-IO-PAIRS-LENIENCE">check-io-pairs-lenience</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-check-io-pairs-lenience" data-sym="CHECK-IO-PAIRS-LENIENCE" title="(defmacro check-io-pairs-lenience (fn old-entry caller)
  `(make-event (check-io-pairs-lenience-fn &#39;,fn &#39;,old-entry &#39;,caller state)
               :check-expansion t :on-behalf-of :quiet!))">check-io-pairs-lenience</a>
  (fn old-entry caller)
  `(<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> (<a class="sym-link local-def" href="#def-check-io-pairs-lenience-fn" data-sym="CHECK-IO-PAIRS-LENIENCE-FN" title="(defun check-io-pairs-lenience-fn (fn old-entry caller state)
  (b*
   ((wrld (w state))
    (lenience (cdr (assoc-eq fn (table-alist &#39;io-pairs-lenience-table wrld))))
    ((when lenience) (value &#39;(value-triple :invisible)))
...">check-io-pairs-lenience-fn</a> ',FN ',OLD-ENTRY ',CALLER state)
    <span class="keyword">:check-expansion</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
    <span class="keyword">:on-behalf-of</span> <span class="keyword">:quiet!</span>))</pre>
  </div>

<div class="form-block function" id="def-add-io-pairs-events" data-defines="ADD-IO-PAIRS-EVENTS" data-references="MEMOIZE,UNMEMOIZE,EQUAL,ASSOC,ENABLE,IN-THEORY,LOCAL,ENCAPSULATE,IO-LOOKUP,LET*,CHECK-IO-PAIRS-LENIENCE,LENGTH,FORMAL-MV,LOOKUP-RESULT,STOBJS-OUT,CAR,QUASIQUOTE,LOOKUP-RESULT0,GENVAR,IO-LOOKUP-VAR,FORMALS,NEW-FN,SUFFIX2,STRING,EXPLODE-ATOM,COERCE,ADD-SUFFIX,THM-NAME,DEFTHM,LIST*,SUFFIX1,MAX-ABSOLUTE-EVENT-NUMBER,MAX,CHECK-SUM-OBJ,SUM,UPDATE-IO-LOOKUP-LST,EQ,IF,NEW-ENTRY,IO-PAIRS-TABLE,QUOTE,TABLE-ALIST,ASSOC-EQ,CDR,OLD-ENTRY,B*,WRLD,TEST,DEBUG,HINTS,IO-DOUBLET-LST,FN,DEFUN" data-used-by="INSTALL-IO-PAIRS,ADD-IO-PAIRS" data-part-name="ADD-IO-PAIRS-EVENTS" data-part-args="WRLD,TEST,DEBUG,HINTS,IO-DOUBLET-LST,FN" data-part-body="MEMOIZE,UNMEMOIZE,EQUAL,ASSOC,ENABLE,IN-THEORY,LOCAL,ENCAPSULATE,IO-LOOKUP,LET*,CHECK-IO-PAIRS-LENIENCE,LENGTH,FORMAL-MV,LOOKUP-RESULT,STOBJS-OUT,CAR,QUASIQUOTE,LOOKUP-RESULT0,GENVAR,IO-LOOKUP-VAR,FORMALS,NEW-FN,DEFUN,SUFFIX2,STRING,EXPLODE-ATOM,COERCE,ADD-SUFFIX,THM-NAME,DEFTHM,LIST*,SUFFIX1,MAX-ABSOLUTE-EVENT-NUMBER,MAX,CHECK-SUM-OBJ,SUM,UPDATE-IO-LOOKUP-LST,IO-DOUBLET-LST,EQ,IF,NEW-ENTRY,WRLD,IO-PAIRS-TABLE,QUOTE,TABLE-ALIST,FN,ASSOC-EQ,CDR,OLD-ENTRY,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIRS-EVENTS">add-io-pairs-events</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-io-pairs-events" data-sym="ADD-IO-PAIRS-EVENTS" title="(defun add-io-pairs-events (fn io-doublet-lst hints debug test wrld)
  (b*
   ((old-entry (cdr (assoc-eq fn (table-alist &#39;io-pairs-table wrld))))
    (new-entry
     (if (eq io-doublet-lst :skip)
...">add-io-pairs-events</a>
  (fn io-doublet-lst hints debug test wrld)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((old-entry (cdr (<a class="sym-link system" href="../../../axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> fn (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-table wrld)))) (new-entry (if (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> io-doublet-lst <span class="keyword">:skip</span>)
          old-entry
          (<a class="sym-link local-def" href="#def-update-io-lookup-lst" data-sym="UPDATE-IO-LOOKUP-LST" title="(defun update-io-lookup-lst (lst x)
  (cond ((endp lst) x)
        (t
         (update-io-lookup-lst (cdr lst)
          (let* ((pair (car lst)) (keys (car pair)) (val (cdr pair)))">update-io-lookup-lst</a> io-doublet-lst old-entry)))
      (sum (<a class="sym-link system" href="../../../basis-b.html#def-check-sum-obj" data-sym="CHECK-SUM-OBJ">check-sum-obj</a> new-entry))
      (max (max-absolute-event-number wrld))
      (suffix1 (<a class="sym-link system" href="../../../basis-b.html#def-check-sum-obj" data-sym="CHECK-SUM-OBJ">check-sum-obj</a> (<a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> '<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> fn sum max)))
      (thm-name (<a class="sym-link system" href="../../../axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> fn (coerce (<a class="sym-link system" href="../../../axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> suffix1 <span class="number">10</span>) '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>)))
      (suffix2 (<a class="sym-link system" href="../../../basis-b.html#def-check-sum-obj" data-sym="CHECK-SUM-OBJ">check-sum-obj</a> (<a class="sym-link system" href="../../../axioms.html#def-list_2A" data-sym="LIST*">list*</a> '<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> fn sum max)))
      (new-fn (<a class="sym-link system" href="../../../axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> fn (coerce (<a class="sym-link system" href="../../../axioms.html#def-explode-atom" data-sym="EXPLODE-ATOM">explode-atom</a> suffix2 <span class="number">10</span>) '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>)))
      (<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> fn wrld))
      (io-lookup-var (<a class="sym-link system" href="../../../basis-b.html#def-genvar" data-sym="GENVAR">genvar</a> fn <span class="string">"IO-LOOKUP-VAR"</span> <span class="number">0</span> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
      (lookup-result0 `(car ,IO-LOOKUP-VAR))
      (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> (<a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> fn wrld))
      (lookup-result (if (cdr <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>)
          (<a class="sym-link local-def" href="#def-formal-mv" data-sym="FORMAL-MV" title="(defun formal-mv (n expr i vars bindings)
  (cond ((zp n) (list &#39;let* (reverse bindings) `(mv ,@(reverse vars))))
        (t
         (let* ((xi (packn (list &#39;x i)))
                (xi-binding (list xi expr))
...">formal-mv</a> (<a class="sym-link system" href="../../../axioms.html#def-length" data-sym="LENGTH">length</a> <a class="sym-link system" href="../../../axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a>) lookup-result0 <span class="number">0</span> nil nil)
          lookup-result0)))
    `((<a class="sym-link local-def" href="#def-check-io-pairs-lenience" data-sym="CHECK-IO-PAIRS-LENIENCE" title="(defmacro check-io-pairs-lenience (fn old-entry caller)
  `(make-event (check-io-pairs-lenience-fn &#39;,fn &#39;,old-entry &#39;,caller state)
               :check-expansion t :on-behalf-of :quiet!))">check-io-pairs-lenience</a> ,FN
       ,OLD-ENTRY
       ,(IF (EQ IO-DOUBLET-LST :SKIP)
     &#39;INSTALL-IO-PAIRS
     &#39;ADD-IO-PAIRS)) ,@(AND (NOT (EQ IO-DOUBLET-LST :SKIP))
       `((TABLE IO-PAIRS-TABLE &#39;,FN
                (LET ((OLD-ENTRY
                       (CDR
                        (ASSOC-EQ &#39;,FN (TABLE-ALIST &#39;IO-PAIRS-TABLE WORLD)))))
                  (UPDATE-IO-LOOKUP-LST &#39;,IO-DOUBLET-LST OLD-ENTRY)))))
      (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> ,NEW-FN
        ,FORMALS
        ,@(ADD-IO-PAIRS-DCLS FN WRLD)
        (<a class="sym-link system" href="../../../axioms.html#def-let_2A" data-sym="LET*">let*</a> ((,IO-LOOKUP-VAR ',NEW-ENTRY) (,IO-LOOKUP-VAR (<a class="sym-link local-def" href="#def-io-lookup" data-sym="IO-LOOKUP" title="(defmacro io-lookup (var tests &amp;rest keys)
  (declare
   (xargs :guard
    (or (member-eq tests (quote (equal eq eql)))
        (and (true-listp tests) (equal (length tests) (length keys))
...">io-lookup</a> ,IO-LOOKUP-VAR ,TEST ,@FORMALS)))
          (if ,IO-LOOKUP-VAR
            ,(IF DEBUG
     `(PROG2$
       (CW &quot;; DEBUG: Found io-pair for input list ~x0.~|&quot; (LIST ,@FORMALS))
       ,LOOKUP-RESULT)
     LOOKUP-RESULT)
            (,FN ,@FORMALS))))
      (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
        (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (enable <a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (<span class="keyword">:e</span> <a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a>))))
        (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,THM-NAME
          (equal (,FN ,@FORMALS) (,NEW-FN ,@FORMALS))
          ,@(AND HINTS `(:HINTS ,HINTS))
          <span class="keyword">:rule-classes</span> nil))
      (unmemoize ',FN)
      (memoize ',FN <span class="keyword">:invoke</span> ',NEW-FN))))</pre>
  </div>

<div class="form-block macro" id="def-add-io-pairs" data-defines="ADD-IO-PAIRS" data-references="ERROR,WITH-OUTPUT,T,MAKE-EVENT,COND,PROGN,CONS,ADD-IO-PAIRS-EVENTS,EVENTS,CAR,CAAR,FN,ADD-IO-PAIRS-TRANSLATE-TUPLES,IO-DOUBLET-LST,ER,CTX,VALUE-TRIPLE,VALUE,NULL,WHEN,STATE,W,WRLD,B*,QUASIQUOTE,FORM,LET,VERBOSE,EQUAL,QUOTE,TEST,DEBUG,HINTS,&KEY,TUPLES,DEFMACRO" data-used-by="ADD-IO-PAIR" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-IO-PAIRS">add-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>
  (tuples &amp;key hints debug (test 'equal) verbose)
  (let ((form `(<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((tuples ',TUPLES) (hints ',HINTS)
           (debug ',DEBUG)
           (test ',TEST)
           (wrld (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
           ((when (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> tuples)) (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> '(<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> <span class="keyword">:empty-io-pairs</span>)))
           (ctx '<a class="sym-link local-def" href="#def-add-io-pairs" data-sym="ADD-IO-PAIRS" title="(defmacro add-io-pairs (tuples &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((tuples &#39;,tuples) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state))
...">add-io-pairs</a>)
           ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> io-doublet-lst) (<a class="sym-link local-def" href="#def-add-io-pairs-translate-tuples" data-sym="ADD-IO-PAIRS-TRANSLATE-TUPLES" title="(defun add-io-pairs-translate-tuples (tuples ctx wrld state)
  (declare (xargs :guard tuples))
  (cond
   ((not (and (alistp tuples) (alistp (strip-cars tuples))))
    (er soft ctx
...">add-io-pairs-translate-tuples</a> tuples ctx wrld state))
           (fn (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> (car tuples)))
           (events (<a class="sym-link local-def" href="#def-add-io-pairs-events" data-sym="ADD-IO-PAIRS-EVENTS" title="(defun add-io-pairs-events (fn io-doublet-lst hints debug test wrld)
  (b*
   ((old-entry (cdr (assoc-eq fn (table-alist &#39;io-pairs-table wrld))))
    (new-entry
     (if (eq io-doublet-lst :skip)
...">add-io-pairs-events</a> fn
               io-doublet-lst
               hints
               debug
               test
               wrld)))
         (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> (cons '<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> events)))))
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (verbose `(<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> ,FORM))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link system" href="../../../axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:off</span> <span class="keyword">:all</span> <span class="keyword">:on</span> error
          <span class="keyword">:gag-mode</span> nil
          (<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> ,FORM <span class="keyword">:on-behalf-of</span> <span class="keyword">:quiet!</span>))))))</pre>
  </div>

<div class="form-block function" id="def-remove-assoc-eq-lst" data-defines="REMOVE-ASSOC-EQ-LST" data-references="CAR,REMOVE-ASSOC-EQ,CDR,ATOM,SYMBOL-ALISTP,ALISTP,SYMBOL-LISTP,IF,XARGS,DECLARE,ALIST,LST,DEFUN" data-used-by="REMOVE-IO-PAIRS-EVENT" data-part-name="REMOVE-ASSOC-EQ-LST" data-part-args="ALIST,LST" data-part-declare="SYMBOL-ALISTP,ALIST,ALISTP,LST,SYMBOL-LISTP,IF,XARGS,DECLARE" data-part-body="CAR,REMOVE-ASSOC-EQ,CDR,REMOVE-ASSOC-EQ-LST,ALIST,LST,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-ASSOC-EQ-LST">remove-assoc-eq-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-assoc-eq-lst" data-sym="REMOVE-ASSOC-EQ-LST" title="(defun remove-assoc-eq-lst (lst alist)
  (declare
   (xargs :guard
    (if (symbol-listp lst)
        (alistp alist)
...">remove-assoc-eq-lst</a>
  (lst alist)
  (declare (xargs <span class="keyword">:guard</span> (if (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> lst)
        (<a class="sym-link system" href="../../../axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist)
        (<a class="sym-link system" href="../../../axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist))))
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> lst)
    alist
    (<a class="sym-link local-def" href="#def-remove-assoc-eq-lst" data-sym="REMOVE-ASSOC-EQ-LST" title="(defun remove-assoc-eq-lst (lst alist)
  (declare
   (xargs :guard
    (if (symbol-listp lst)
        (alistp alist)
...">remove-assoc-eq-lst</a> (cdr lst)
      (<a class="sym-link system" href="../../../axioms.html#def-remove-assoc-eq" data-sym="REMOVE-ASSOC-EQ">remove-assoc-eq</a> (car lst) alist))))</pre>
  </div>

<div class="form-block function" id="def-remove-io-pairs-event" data-defines="REMOVE-IO-PAIRS-EVENT" data-references="WORLD,REMOVE-ASSOC-EQ-LST,TABLE,PROGN,QUASIQUOTE,VALUE,WARNING$,PPROGN,WITH-OUTPUT!,IF,-,T,INTERSECTION-EQ,COND,SET-DIFFERENCE-EQ,BAD,ALLP,STRIP-CARS,TBL-FNS,IO-PAIRS-TABLE,TABLE-ALIST,TBL,W,WRLD,SHOW-IO-PAIRS,EQUAL,NOT,MEMBER-EQ,AND,REMOVE-IO-PAIRS,QUOTE,SOFT,ER,NULL,WHEN,B*,STATE,CTX,FNS,DEFUN" data-used-by="REMOVE-IO-PAIRS" data-part-name="REMOVE-IO-PAIRS-EVENT" data-part-args="STATE,CTX,FNS" data-part-body="WORLD,REMOVE-ASSOC-EQ-LST,TABLE,PROGN,QUASIQUOTE,VALUE,WARNING$,PPROGN,WITH-OUTPUT!,IF,-,T,INTERSECTION-EQ,COND,SET-DIFFERENCE-EQ,BAD,ALLP,STRIP-CARS,TBL-FNS,IO-PAIRS-TABLE,TABLE-ALIST,TBL,STATE,W,WRLD,SHOW-IO-PAIRS,EQUAL,NOT,MEMBER-EQ,AND,REMOVE-IO-PAIRS,QUOTE,CTX,SOFT,ER,FNS,NULL,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-IO-PAIRS-EVENT">remove-io-pairs-event</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-io-pairs-event" data-sym="REMOVE-IO-PAIRS-EVENT" title="(defun remove-io-pairs-event (fns ctx state)
  (b*
   (((when (null fns))
     (er soft ctx
         &quot;~x0 requires at least one argument.  Perhaps you intended ~x1.&quot;
...">remove-io-pairs-event</a>
  (fns ctx state)
  (<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> (((when (<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> fns)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
         ctx
         <span class="string">"~x0 requires at least one argument.  Perhaps you intended ~x1."</span>
         '<a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a>
         '(<a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a> <span class="keyword">:all</span>))) ((when (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <span class="keyword">:all</span> fns) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal fns '(<span class="keyword">:all</span>))))) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> soft
          '<a class="sym-link local-def" href="#def-show-io-pairs" data-sym="SHOW-IO-PAIRS" title="(defmacro show-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(show-io-pairs-fn &#39;,fns state))">show-io-pairs</a>
          <span class="string">"It is illegal to use :ALL with ~x0 except in the form ~x1."</span>
          '<a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a>
          '(<a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a> <span class="keyword">:all</span>)))
      (wrld (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
      (tbl (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-table wrld))
      (tbl-fns (<a class="sym-link system" href="../../../axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> tbl))
      (allp (equal fns '(<span class="keyword">:all</span>)))
      (bad (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> allp) (<a class="sym-link system" href="../../../axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> fns tbl-fns)))
      (fns (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (allp tbl-fns)
          (bad (<a class="sym-link system" href="../../../axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> fns tbl-fns))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> fns)))
      ((<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> <a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a>) (if bad
          (<a class="sym-link system" href="../../../axioms.html#def-with-output_21" data-sym="WITH-OUTPUT!">with-output!</a> <span class="keyword">:stack</span> <span class="keyword">:pop</span> (<a class="sym-link system" href="../../../axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="../../../axioms.html#def-warning_24" data-sym="WARNING$">warning$</a> ctx
                <span class="string">"Add-io-pairs"</span>
                <span class="string">"There ~#0~[is no I/O pair for the ~
                                 symbol~/are no I/O pairs for the symbols~] ~
                                 ~&amp;0."</span>
                bad)
              (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil)))
          (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> nil))))
    (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> ,@(PAIRLIS-X1 &#39;UNMEMOIZE (PAIRLIS$ (KWOTE-LST FNS) NIL))
        (<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> io-pairs-table
          nil
          (<a class="sym-link local-def" href="#def-remove-assoc-eq-lst" data-sym="REMOVE-ASSOC-EQ-LST" title="(defun remove-assoc-eq-lst (lst alist)
  (declare
   (xargs :guard
    (if (symbol-listp lst)
        (alistp alist)
...">remove-assoc-eq-lst</a> ',FNS
            (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'io-pairs-table world))
          <span class="keyword">:clear</span>)))))</pre>
  </div>

<div class="form-block macro" id="def-remove-io-pairs" data-defines="REMOVE-IO-PAIRS" data-references="STATE,QUOTE,REMOVE-IO-PAIRS-EVENT,MAKE-EVENT,ERROR,WITH-OUTPUT,QUASIQUOTE,SYMBOL-LISTP,XARGS,DECLARE,FNS,&REST,DEFMACRO" data-used-by="REMOVE-IO-PAIRS-EVENT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-IO-PAIRS">remove-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a>
  (&amp;rest fns)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> fns)))
  `(<a class="sym-link system" href="../../../axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:stack</span> <span class="keyword">:push</span> <span class="keyword">:off</span> <span class="keyword">:all</span> <span class="keyword">:on</span> error
    <span class="keyword">:gag-mode</span> nil
    (<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> (<a class="sym-link local-def" href="#def-remove-io-pairs-event" data-sym="REMOVE-IO-PAIRS-EVENT" title="(defun remove-io-pairs-event (fns ctx state)
  (b*
   (((when (null fns))
     (er soft ctx
         &quot;~x0 requires at least one argument.  Perhaps you intended ~x1.&quot;
...">remove-io-pairs-event</a> ',FNS '<a class="sym-link local-def" href="#def-remove-io-pairs" data-sym="REMOVE-IO-PAIRS" title="(defmacro remove-io-pairs (&amp;rest fns)
  (declare (xargs :guard (symbol-listp fns)))
  `(with-output :stack :push :off :all :on error :gag-mode nil
                (make-event
                 (remove-io-pairs-event &#39;,fns &#39;remove-io-pairs state)">remove-io-pairs</a> state)
      <span class="keyword">:on-behalf-of</span> <span class="keyword">:quiet!</span>)))</pre>
  </div>

<div class="form-block macro" id="def-install-io-pairs" data-defines="INSTALL-IO-PAIRS" data-references="ERROR,WITH-OUTPUT,T,MAKE-EVENT,COND,PROGN,CONS,VALUE,ADD-IO-PAIRS-EVENTS,EVENTS,IO-DOUBLET-LST,STATE,W,WRLD,B*,QUASIQUOTE,FORM,LET,VERBOSE,EQUAL,QUOTE,TEST,DEBUG,HINTS,&KEY,FN,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="INSTALL-IO-PAIRS">install-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-install-io-pairs" data-sym="INSTALL-IO-PAIRS" title="(defmacro install-io-pairs (fn &amp;key hints debug (test &#39;equal) verbose)
  (let ((form
         `(b*
           ((fn &#39;,fn) (hints &#39;,hints) (debug &#39;,debug) (test &#39;,test)
            (wrld (w state)) (io-doublet-lst :skip)
...">install-io-pairs</a>
  (fn &amp;key hints debug (test 'equal) verbose)
  (let ((form `(<a class="sym-link external" href="bstar.html#def-b_2A" data-sym="B*">b*</a> ((fn ',FN) (hints ',HINTS)
           (debug ',DEBUG)
           (test ',TEST)
           (wrld (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
           (io-doublet-lst <span class="keyword">:skip</span>)
           (events (<a class="sym-link local-def" href="#def-add-io-pairs-events" data-sym="ADD-IO-PAIRS-EVENTS" title="(defun add-io-pairs-events (fn io-doublet-lst hints debug test wrld)
  (b*
   ((old-entry (cdr (assoc-eq fn (table-alist &#39;io-pairs-table wrld))))
    (new-entry
     (if (eq io-doublet-lst :skip)
...">add-io-pairs-events</a> fn
               io-doublet-lst
               hints
               debug
               test
               wrld)))
         (<a class="sym-link system" href="../../../axioms.html#def-value" data-sym="VALUE">value</a> (cons '<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> events)))))
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> (verbose `(<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> ,FORM))
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link system" href="../../../axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:off</span> <span class="keyword">:all</span> <span class="keyword">:on</span> error
          <span class="keyword">:gag-mode</span> nil
          (<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> ,FORM <span class="keyword">:on-behalf-of</span> <span class="keyword">:quiet!</span>))))))</pre>
  </div>

<div class="form-block macro" id="def-deinstall-io-pairs" data-defines="DEINSTALL-IO-PAIRS" data-references="QUOTE,UNMEMOIZE,QUASIQUOTE,FN,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEINSTALL-IO-PAIRS">deinstall-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-deinstall-io-pairs" data-sym="DEINSTALL-IO-PAIRS" title="(defmacro deinstall-io-pairs (fn) `(unmemoize &#39;,fn))">deinstall-io-pairs</a> (fn) `(unmemoize ',FN))</pre>
  </div>

<div class="form-block function" id="def-merge-io-pairs-fn" data-defines="MERGE-IO-PAIRS-FN" data-references="POP-IO-PAIRS-LENIENCE,PUSH-IO-PAIRS-LENIENCE,PROGN,QUASIQUOTE,TRUE-LISTP,SYMBOL-LISTP,AND,XARGS,DECLARE,EVENTS,FNS,DEFUN" data-used-by="MERGE-IO-PAIRS" data-part-name="MERGE-IO-PAIRS-FN" data-part-args="EVENTS,FNS" data-part-declare="EVENTS,TRUE-LISTP,FNS,SYMBOL-LISTP,AND,XARGS,DECLARE" data-part-body="POP-IO-PAIRS-LENIENCE,PUSH-IO-PAIRS-LENIENCE,PROGN,QUASIQUOTE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-IO-PAIRS-FN">merge-io-pairs-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-io-pairs-fn" data-sym="MERGE-IO-PAIRS-FN" title="(defun merge-io-pairs-fn (fns events)
  (declare (xargs :guard (and (symbol-listp fns) (true-listp events))))
  `(progn
    (push-io-pairs-lenience ,@fns)
    ,@events
...">merge-io-pairs-fn</a>
  (fns events)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> fns) (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> events))))
  `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link local-def" href="#def-push-io-pairs-lenience" data-sym="PUSH-IO-PAIRS-LENIENCE" title="(defmacro push-io-pairs-lenience (&amp;rest fns)
  (cons &#39;progn (push-io-pairs-lenience-fn fns)))">push-io-pairs-lenience</a> ,@FNS)
    ,@EVENTS
    ,@(PAIRLIS-X1 &#39;INSTALL-IO-PAIRS (PAIRLIS-X2 FNS NIL))
    (<a class="sym-link local-def" href="#def-pop-io-pairs-lenience" data-sym="POP-IO-PAIRS-LENIENCE" title="(defmacro pop-io-pairs-lenience (&amp;rest fns)
  (cons &#39;progn (pop-io-pairs-lenience-fn fns)))">pop-io-pairs-lenience</a> ,@FNS)))</pre>
  </div>

<div class="form-block macro" id="def-merge-io-pairs" data-defines="MERGE-IO-PAIRS" data-references="LIST,IF,MERGE-IO-PAIRS-FN,NO-DUPLICATESP-EQ,SYMBOL-LISTP,AND,SYMBOLP,OR,XARGS,DECLARE,EVENTS,&REST,X,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-IO-PAIRS">merge-io-pairs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-merge-io-pairs" data-sym="MERGE-IO-PAIRS" title="(defmacro merge-io-pairs (x &amp;rest events)
  (declare
   (xargs :guard
    (or (symbolp x) (and (symbol-listp x) (no-duplicatesp-eq x)))))
  (merge-io-pairs-fn
...">merge-io-pairs</a>
  (x &amp;rest events)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (symbolp x)
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> x) (<a class="sym-link system" href="../../../axioms.html#def-no-duplicatesp-eq" data-sym="NO-DUPLICATESP-EQ">no-duplicatesp-eq</a> x)))))
  (<a class="sym-link local-def" href="#def-merge-io-pairs-fn" data-sym="MERGE-IO-PAIRS-FN" title="(defun merge-io-pairs-fn (fns events)
  (declare (xargs :guard (and (symbol-listp fns) (true-listp events))))
  `(progn
    (push-io-pairs-lenience ,@fns)
    ,@events
...">merge-io-pairs-fn</a> (if (symbolp x)
      (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> x)
      x)
    events))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>