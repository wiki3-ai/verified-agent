<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>deflist-base - ACL2 Book</title>
  <meta property="name" content="deflist-base">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">deflist-base</h1>
    <div class="path"><a href="deflist-base.lisp" class="source-link">books/std/util/deflist-base</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"STD"</span>)</pre>
  </div>

<div class="form-block other" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="define.html" title="Open define">"define"</a>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="maybe-defthm.html" title="Open maybe-defthm">"maybe-defthm"</a>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../std/lists/abstract.html" title="Open std/lists/abstract">"std/lists/abstract"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-set-state-ok" data-sym="SET-STATE-OK">set-state-ok</a> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc <a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a>
  <span class="keyword">:parents</span> (std/util)
  <span class="keyword">:short</span> <span class="string">"Introduce a recognizer for a typed list."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Deflist lets you to quickly introduce recognizers for typed lists
like @(see nat-listp).  It defines the new recognizer function, sets up a basic
theory with rules about @(see len), @(see append), @(see member), etc., and
generates basic, automatic @(see xdoc) documentation.&lt;/p&gt;

&lt;h4&gt;General Form&lt;/h4&gt;

@({
 (deflist name formals
   element
   [keyword options]
   [/// other events]
   )

 Options                  Defaults
   :negatedp                nil
   :true-listp              nil
   :elementp-of-nil         :unknown
   :guard                   t
   :verify-guards           t
   :guard-hints             nil
   :guard-debug             nil
   :non-emptyp              nil
   :mode                    current defun-mode
   :cheap                   nil
   :verbosep                nil
   :parents                 nil
   :short                   nil
   :long                    nil
   :prepwork                nil
})

&lt;h4&gt;Basic Examples&lt;/h4&gt;

&lt;p&gt;The following introduces a new function, @(&#39;my-integer-listp&#39;), which
recognizes lists whose every element satisfies @(&#39;integerp&#39;), and also
introduces many theorems about this new function.&lt;/p&gt;

@({
 (deflist my-integer-listp (x)
   (integerp x))
})

&lt;p&gt;&lt;b&gt;&lt;color rgb=&#39;#ff0000&#39;&gt;Note&lt;/color&gt;&lt;/b&gt;: @(&#39;x&#39;) is treated in a special
way.  It refers to the whole list in formals and guards, but refers to
individual elements of the list in the @(&#39;element&#39;) portion.  This is similar
to how other macros like @(see defalist), @(see defprojection), and @(see
defmapappend) handle @(&#39;x&#39;).&lt;/p&gt;

&lt;p&gt;Here is a recognizer for lists with no natural numbers:&lt;/p&gt;

@({
 (deflist nat-free-listp (x)
   (natp x)
   :negatedp t)
})

&lt;p&gt;Here is a recognizer for lists whose elements must exceed some minimum:&lt;/p&gt;

@({
 (deflist all-greaterp (min x)
   (&gt; x min)
   :guard (and (natp min)
               (nat-listp x)))
})

&lt;h3&gt;Usage and Optional Arguments&lt;/h3&gt;

&lt;p&gt;Let @(&#39;pkg&#39;) be the package of @(&#39;name&#39;).  All functions, theorems, and
variables are created in this package.  One of the formals must be @(&#39;pkg::x&#39;),
and this argument represents the list to check.  Otherwise, the only
restriction on the formals is that you may not use the names @(&#39;pkg::a&#39;),
@(&#39;pkg::n&#39;), or @(&#39;pkg::y&#39;), because we use these variables in the theorems we
generate.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:negatedp&#39;) keyword can be used to recognize a list whose
every element does not satisfy elementp.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:true-listp&#39;) keyword can be used to require that the new
recognizer is &quot;strict&quot; and will only accept lists that are
@(&#39;nil&#39;)-terminated; by default the recognizer will be &quot;loose&quot; and will not
pay attention to the final @(&#39;cdr&#39;).  There are various reasons to prefer one
behavior or another; see @(see strict-list-recognizers) for details.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:elementp-of-nil&#39;) keyword can be used when @(&#39;(elementp nil
...)&#39;) is always known to be @(&#39;t&#39;) or @(&#39;nil&#39;).  When it is provided,
@(&#39;deflist&#39;) can generate slightly better theorems.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:guard&#39;), @(&#39;:verify-guards&#39;), @(&#39;:guard-debug&#39;), and
@(&#39;:guard-hints&#39;) are options for the @(see defun) we introduce.  These are for
the guards of the new list recognizer, not the element recognizer.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:mode&#39;) keyword can be set to @(&#39;:logic&#39;) or @(&#39;:program&#39;)
to introduce the recognizer in logic or program mode.  The default is whatever
the current default defun-mode is for ACL2, i.e., if you are already in program
mode, it will default to program mode, etc.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:verbosep&#39;) flag can be set to @(&#39;t&#39;) if you want deflist to
print everything it&#39;s doing.  This may be useful if you run into any failures,
or if you are simply curious about what is being introduced.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:cheap&#39;) flag can be set to @(&#39;t&#39;) to produce cheaper, less
effective rule-classes for some rules; this may be convenient when the element
type is a very common function such as @(&#39;consp&#39;), in which case adding
stronger rules might significantly slow down proofs.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:parents&#39;), @(&#39;:short&#39;), and @(&#39;:long&#39;) keywords are as in
@(see defxdoc).  Typically you only need to specify @(&#39;:parents&#39;), perhaps
implicitly with @(see xdoc::set-default-parents), and suitable documentation
will be automatically generated for @(&#39;:short&#39;) and @(&#39;:long&#39;).  If you don&#39;t
like this documentation, you can supply your own @(&#39;:short&#39;) and/or @(&#39;:long&#39;)
to override it.&lt;/p&gt;

&lt;p&gt;The optional @(&#39;:prepwork&#39;) may provide a list of event forms that are
submitted just before the generated events.  These are preparatory events,
e.g. local lemmas to help prove @(&#39;:elementp-of-nil&#39;).&lt;/p&gt;

&lt;h3&gt;Pluggable Architecture&lt;/h3&gt;

&lt;p&gt;Beginning in ACL2 6.5, deflist no longer hard-codes the set of theorems to
be produced about every list recognizer.  Instead, @(&#39;def-listp-rule&#39;) forms
pertaining to a generic list recognizer called @(&#39;element-list-p&#39;) are used as
templates and instantiated for each deflist invocation.  These forms may be
scattered throughout various libraries, so the set of books you have loaded
determines the set of rules produced by a deflist invocation.  See @(see
acl2::std/lists/abstract) for more information about these rules and how to
control what theorems are produced by deflist.&lt;/p&gt;

&lt;p&gt;&quot;std/util/deflist.lisp&quot; includes books that compose a set of rules to
instantiate that should be more or less backward compatible with the theorems
produced by deflist in ACL2 6.4 and previous.  &quot;std/util/deflist-base.lisp&quot;
includes a much more basic set of rules.&lt;/p&gt;

&lt;h3&gt;Support for Other Events&lt;/h3&gt;

&lt;p&gt;Deflist implements the same @(&#39;///&#39;) syntax as other macros like @(see
define).  This allows you to put related events near the definition and have
them included in the automatic documentation.  As with define, the new
recognizer is enabled during the @(&#39;///&#39;) section.  Here is an example:&lt;/p&gt;

@({
 (deflist even-integer-list-p (x)
   (even-integer-p x)
   :true-listp t
   ///
   (defthm integer-listp-when-even-integer-list-p
     (implies (even-integer-list-p x)
              (integer-listp x))))
})

&lt;p&gt;Deprecated.  The optional @(&#39;:rest&#39;) keyword was a precursor to @(&#39;///&#39;).
It is still implemented, but its use is now discouraged.  If both @(&#39;:rest&#39;)
and @(&#39;///&#39;) events are used, we arbitrarily put the @(&#39;:rest&#39;) events
first.&lt;/p&gt;

&lt;p&gt;Deprecated.  The optional @(&#39;:already-definedp&#39;) keyword can be set if you
have already defined the function.  This was previously useful when you wanted
to generate the ordinary @(&#39;deflist&#39;) theorems without generating a @(&#39;defund&#39;)
event, e.g., because you are dealing with mutually recursive recognizers.  We
still accept this option for backwards compatibility but it is useless, because
@(&#39;deflist&#39;) is now smart enough to notice that the function is already
defined.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc strict-list-recognizers
  <span class="keyword">:parents</span> (<a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a>)
  <span class="keyword">:short</span> <span class="string">"Should your list recognizers require @(&#39;nil&#39;)-terminated lists?"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Here are two ways that you could write a list recognizer:&lt;/p&gt;

&lt;p&gt;The &quot;strict&quot; way:&lt;/p&gt;

@({
   (defun foo-listp (x)
     (if (atom x)
         (not x)
       (and (foop (car x))
            (foo-listp (cdr x)))))
})

&lt;p&gt;The &quot;loose&quot; way:&lt;/p&gt;

@({
   (defun foo-listp (x)
     (if (atom x)
         t
       (and (foop (car x))
            (foo-listp (cdr x)))))
})

&lt;p&gt;The only difference is that in the base case, the strict recognizer requires
X to be NIL, whereas the loose recognizer allows X to be any atom.&lt;/p&gt;

&lt;p&gt;By default, the recognizers introduced by @(see deflist) follow the loose
approach.  You can use the @(&#39;:true-listp&#39;) option to change this behavior, and
instead introduce a strict recognizer.&lt;/p&gt;

&lt;p&gt;Why in the world would we use a loose recognizer?  Well, there are
advantages to either approach.&lt;/p&gt;

&lt;p&gt;The strict approach is certainly more clear and less weird.  It is nice that
a strict recognizer always implies @(see true-listp).  And it makes EQUAL more
meaningful when applied to FOO-LISTP objects.&lt;/p&gt;

&lt;p&gt;That is, when FOO-LISTP is strict, there is only one FOO-LISTP that has
length 3 and whose first three elements are (A B C).  However, when FOO-LISTP
is loose, there are infinitely many lists like this, and the only difference
between them is their final cdr.&lt;/p&gt;

&lt;p&gt;This nicer equality behavior makes the strict approach especially appealing
when you are building new data types that include FOO-LISTP components, and
you&#39;d like to just reuse EQUAL instead of having new equivalence relations for
each structure.&lt;/p&gt;

&lt;p&gt;But the loose approach more nicely follows the @(see list-fix) convention:
&quot;a function that takes a list as an argument should coerce the final-cdr to
NIL, and produce the same result regardless of the final cdr.&quot; More formally,
you might say that F respects the list-fix convention when you can prove&lt;/p&gt;

@({
   (defcong list-equiv equal (f ... x ...) n)
})

&lt;p&gt;Where list-equiv is equality up to the final cdr, e.g.,&lt;/p&gt;

@({
   (list-equiv x y) = (equal (list-fix x) (list-fix y))
})

&lt;p&gt;Many functions follow this convention or something similar to it, and
because of this there are sometimes nicer theorems about loose list recognizers
than about strict list recognizers.  For instance, consider @(see append).  In
the loose style, we can prove:&lt;/p&gt;

@({
   (equal (foo-listp (append x y))
          (and (foo-listp x)
               (foo-listp y)))
})

&lt;p&gt;In the strict style, we have to prove something uglier, e.g.,&lt;/p&gt;

@({
   (equal (foo-listp (append x y))
          (and (foo-listp (list-fix x))
               (foo-listp y)))
})

&lt;p&gt;There are many other nice theorems, but just as a few examples, each of
these theorems are very nice in the loose style, and are uglier in the strict
style:&lt;/p&gt;

@({
   (equal (foo-listp (list-fix x))
          (foo-listp x))

   (equal (foo-listp (rev x))
          (foo-listp x))

   (equal (foo-listp (mergesort x))
          (foo-listp x))

   (implies (and (subsetp-equal x y)
                 (foo-listp y))
            (foo-listp x))
})

&lt;p&gt;@(see deflist) originally came out of @(see acl2::milawa), where I
universally applied the loose approach, and in that context I think it is very
nice.  It&#39;s not entirely clear that loose recognizers are a good fit for ACL2.
Really one of the main objections to the loose style is: ACL2&#39;s built-in list
recognizers use the strict approach, and it can become irritating to keep track
of which recognizers require true-listp and which don&#39;t.&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> *deflist-valid-keywords*
  '(<span class="keyword">:negatedp</span> <span class="keyword">:cheap</span> <span class="keyword">:guard</span> <span class="keyword">:verify-guards</span> <span class="keyword">:guard-debug</span> <span class="keyword">:guard-hints</span> <span class="keyword">:already-definedp</span> <span class="keyword">:elementp-of-nil</span> <span class="keyword">:non-emptyp</span> <span class="keyword">:mode</span> <span class="keyword">:parents</span> <span class="keyword">:short</span> <span class="keyword">:long</span> <span class="keyword">:true-listp</span> <span class="keyword">:rest</span> <span class="keyword">:verbosep</span> <span class="keyword">:prepwork</span> <span class="keyword">:theory-hack</span>))</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-program" data-sym="PROGRAM">program</a>)</pre>
  </div>

<div class="form-block function" id="def-deflist-substitution" data-defines="DEFLIST-SUBSTITUTION" data-references="ELEMENT-LIST-FINAL-CDR-P,LAMBDA,NON-ELEMENT-P,ELEMENT-P,QUASIQUOTE,NON-EMPTYP,TRUE-LISTP,GETARG,NEGATEDP,B*,X,KWD-ALIST,ELEMENT,FORMALS,NAME,DEFUN" data-used-by="DEFLIST-INSTANTIATE-TABLE-THMS" data-part-name="DEFLIST-SUBSTITUTION" data-part-args="X,KWD-ALIST,ELEMENT,FORMALS,NAME" data-part-body="ELEMENT-LIST-FINAL-CDR-P,LAMBDA,NON-ELEMENT-P,ELEMENT-P,QUASIQUOTE,NON-EMPTYP,TRUE-LISTP,KWD-ALIST,GETARG,NEGATEDP,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-SUBSTITUTION">deflist-substitution</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-substitution" data-sym="DEFLIST-SUBSTITUTION" title="(defun std::deflist-substitution
       (std::name std::formals std::element std::kwd-alist std::x)
  (std::b*
   ((std::negatedp (std::getarg :negatedp nil std::kwd-alist))
    (std::true-listp (std::getarg :true-listp nil std::kwd-alist))
...">deflist-substitution</a>
  (name <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> element kwd-alist x)
  (b* ((negatedp (getarg <span class="keyword">:negatedp</span> nil kwd-alist)) (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (getarg <span class="keyword">:true-listp</span> nil kwd-alist))
      (non-emptyp (getarg <span class="keyword">:non-emptyp</span> nil kwd-alist)))
    `((element-p ,(IF STD::NEGATEDP
     `(LAMBDA (,STD::X) (NOT ,STD::ELEMENT))
     `(LAMBDA (,STD::X) ,STD::ELEMENT))) (non-element-p ,(IF STD::NEGATEDP
     `(LAMBDA (,STD::X) ,STD::ELEMENT)
     `(LAMBDA (,STD::X) (NOT ,STD::ELEMENT))))
      (,(IF STD::NON-EMPTYP
     &#39;ELEMENT-LIST-NONEMPTY-P
     &#39;ELEMENT-LIST-P) (lambda (,STD::X) (,STD::NAME . ,STD::FORMALS)))
      (element-list-final-cdr-p ,(IF STD::TRUE-LISTP
     &#39;NOT
     &#39;(LAMBDA (STD::X) T))))))</pre>
  </div>

<div class="form-block function" id="def-atom_2Fquote-listp" data-defines="ATOM/QUOTE-LISTP" data-references="CDR,QUOTE,CAAR,CAR,OR,AND,EQ,ATOM,IF,X,DEFUN" data-used-by="SIMPLE-FNCALL-P-HACK" data-part-name="ATOM/QUOTE-LISTP" data-part-args="X" data-part-body="CDR,ATOM/QUOTE-LISTP,QUOTE,CAAR,CAR,OR,AND,EQ,X,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ATOM/QUOTE-LISTP">atom/quote-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-atom_2Fquote-listp" data-sym="ATOM/QUOTE-LISTP" title="(defun std::atom/quote-listp (std::x)
  (if (atom std::x)
      (eq std::x nil)
      (and (or (atom (car std::x)) (eq (caar std::x) &#39;quote))
           (std::atom/quote-listp (cdr std::x)))))">atom/quote-listp</a>
  (x)
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> x)
    (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> x nil)
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> (car x)) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-caar" data-sym="CAAR">caar</a> x) 'quote))
      (<a class="sym-link local-def" href="#def-atom_2Fquote-listp" data-sym="ATOM/QUOTE-LISTP" title="(defun std::atom/quote-listp (std::x)
  (if (atom std::x)
      (eq std::x nil)
      (and (or (atom (car std::x)) (eq (caar std::x) &#39;quote))
           (std::atom/quote-listp (cdr std::x)))))">atom/quote-listp</a> (cdr x)))))</pre>
  </div>

<div class="form-block function" id="def-simple-fncall-p-hack" data-defines="SIMPLE-FNCALL-P-HACK" data-references="CDR,ATOM/QUOTE-LISTP,CAR,SYMBOLP,CONSP,AND,X,DEFUN" data-used-by="DEFLIST-REQUIREMENT-ALIST" data-part-name="SIMPLE-FNCALL-P-HACK" data-part-args="X" data-part-body="CDR,ATOM/QUOTE-LISTP,CAR,SYMBOLP,X,CONSP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SIMPLE-FNCALL-P-HACK">simple-fncall-p-hack</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-simple-fncall-p-hack" data-sym="SIMPLE-FNCALL-P-HACK" title="(defun std::simple-fncall-p-hack (std::x)
  (and (consp std::x) (symbolp (car std::x))
       (std::atom/quote-listp (cdr std::x))))">simple-fncall-p-hack</a>
  (x)
  (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp x)
    (symbolp (car x))
    (<a class="sym-link local-def" href="#def-atom_2Fquote-listp" data-sym="ATOM/QUOTE-LISTP" title="(defun std::atom/quote-listp (std::x)
  (if (atom std::x)
      (eq std::x nil)
      (and (or (atom (car std::x)) (eq (caar std::x) &#39;quote))
           (std::atom/quote-listp (cdr std::x)))))">atom/quote-listp</a> (cdr x))))</pre>
  </div>

<div class="form-block function" id="def-deflist-requirement-alist" data-defines="DEFLIST-REQUIREMENT-ALIST" data-references="SIMPLE,CHEAP,SINGLE-VAR,TRUE-LISTP,NEGATEDP,NOT-ELEMENT-P-OF-NIL,ELEMENT-P-OF-NIL,QUASIQUOTE,CHEAP,LEN,EQL,SINGLE-VAR,ELEMENTP-OF-NIL,TRUE-LISTP,SIMPLE-FNCALL-P-HACK,SIMPLE,GETARG,NEGATEDP,B*,ELEMENT,FORMALS,KWD-ALIST,DEFUN" data-used-by="DEFLIST-INSTANTIATE-TABLE-THMS" data-part-name="DEFLIST-REQUIREMENT-ALIST" data-part-args="ELEMENT,FORMALS,KWD-ALIST" data-part-body="SIMPLE,CHEAP,SINGLE-VAR,TRUE-LISTP,NEGATEDP,NOT-ELEMENT-P-OF-NIL,ELEMENT-P-OF-NIL,QUASIQUOTE,CHEAP,FORMALS,LEN,EQL,SINGLE-VAR,ELEMENTP-OF-NIL,TRUE-LISTP,ELEMENT,SIMPLE-FNCALL-P-HACK,SIMPLE,KWD-ALIST,GETARG,NEGATEDP,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-REQUIREMENT-ALIST">deflist-requirement-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-requirement-alist" data-sym="DEFLIST-REQUIREMENT-ALIST" title="(defun std::deflist-requirement-alist
       (std::kwd-alist std::formals std::element)
  (std::b*
   ((std::negatedp (std::getarg :negatedp nil std::kwd-alist))
    (std::simple (std::simple-fncall-p-hack std::element))
...">deflist-requirement-alist</a>
  (kwd-alist <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> element)
  (b* ((negatedp (getarg <span class="keyword">:negatedp</span> nil kwd-alist)) (simple (<a class="sym-link local-def" href="#def-simple-fncall-p-hack" data-sym="SIMPLE-FNCALL-P-HACK" title="(defun std::simple-fncall-p-hack (std::x)
  (and (consp std::x) (symbolp (car std::x))
       (std::atom/quote-listp (cdr std::x))))">simple-fncall-p-hack</a> element))
      (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (getarg <span class="keyword">:true-listp</span> nil kwd-alist))
      (elementp-of-nil (getarg <span class="keyword">:elementp-of-nil</span> <span class="keyword">:unknown</span> kwd-alist))
      (single-var (<a class="sym-link system" href="../../../axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>) <span class="number">1</span>))
      (cheap (getarg <span class="keyword">:cheap</span> nil kwd-alist)))
    `((element-p-of-nil . ,(EQ STD::ELEMENTP-OF-NIL (NOT STD::NEGATEDP))) (not-element-p-of-nil . ,(EQ STD::ELEMENTP-OF-NIL STD::NEGATEDP))
      (negatedp . ,STD::NEGATEDP)
      (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> . ,STD::TRUE-LISTP)
      (single-var . ,STD::SINGLE-VAR)
      (cheap . ,STD::CHEAP)
      (simple . ,STD::SIMPLE))))</pre>
  </div>

<div class="form-block other" id="form-13" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> deflist-thmbody-subst
    (<a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a> element
      name
      <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
      x
      negatedp)
    (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
      <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>
      (<a class="sym-link system" href="../../../axioms.html#def-case" data-sym="CASE">case</a> (car <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
        (element-p (let ((call (cons (car element)
                 (<a class="sym-link system" href="../../../axioms.html#def-subst" data-sym="SUBST">subst</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>) x (cdr element)))))
            (if negatedp
              (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> call)
              call)))
        (non-element-p (let ((call (cons (car element)
                 (<a class="sym-link system" href="../../../axioms.html#def-subst" data-sym="SUBST">subst</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>) x (cdr element)))))
            (if negatedp
              call
              (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> call))))
        (element-list-p (cons name
            (<a class="sym-link system" href="../../../axioms.html#def-subst" data-sym="SUBST">subst</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>) x <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>)))
        (element-list-nonempty-p (cons name
            (<a class="sym-link system" href="../../../axioms.html#def-subst" data-sym="SUBST">subst</a> (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>) x <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>)))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (if (symbolp (car <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>))
            (cons (car <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
              (deflist-thmbody-list-subst (cdr <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
                element
                name
                <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
                x
                negatedp))
            (deflist-thmbody-list-subst <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>
              element
              name
              <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
              x
              negatedp))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> deflist-thmbody-list-subst
    (<a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a> element
      name
      <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
      x
      negatedp)
    (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
      <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>
      (cons (deflist-thmbody-subst (car <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
          element
          name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          x
          negatedp)
        (deflist-thmbody-list-subst (cdr <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)
          element
          name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          x
          negatedp)))))</pre>
  </div>

<div class="form-block function" id="def-deflist-thmname-subst" data-defines="DEFLIST-THMNAME-SUBST" data-references="DUMB-STR-SUBLIS,INTERN-IN-PACKAGE-OF-SYMBOL,QUASIQUOTE,SUBST-LIST,SYMBOL-NAME,B*,ELEMENTP,LISTP-NAME,THMNAME,DEFUN" data-used-by="DEFLIST-INSTANTIATE" data-part-name="DEFLIST-THMNAME-SUBST" data-part-args="ELEMENTP,LISTP-NAME,THMNAME" data-part-body="LISTP-NAME,DUMB-STR-SUBLIS,INTERN-IN-PACKAGE-OF-SYMBOL,QUASIQUOTE,SUBST-LIST,SYMBOL-NAME,THMNAME,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-THMNAME-SUBST">deflist-thmname-subst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-thmname-subst" data-sym="DEFLIST-THMNAME-SUBST" title="(defun std::deflist-thmname-subst (std::thmname std::listp-name std::elementp)
  (std::b*
   ((std::thmname (symbol-name std::thmname))
    (std::subst-list
     `((&quot;ELEMENT-LIST-NONEMPTY-P&quot; . ,(symbol-name std::listp-name))
...">deflist-thmname-subst</a>
  (thmname listp-name elementp)
  (b* ((thmname (symbol-name thmname)) (subst-list `((<span class="string">"ELEMENT-LIST-NONEMPTY-P"</span> . ,(SYMBOL-NAME STD::LISTP-NAME)) (<span class="string">"ELEMENT-LIST-NONEMPTY"</span> . ,(SYMBOL-NAME STD::LISTP-NAME))
          (<span class="string">"ELEMENT-LIST-P"</span> . ,(SYMBOL-NAME STD::LISTP-NAME))
          (<span class="string">"ELEMENT-LIST"</span> . ,(SYMBOL-NAME STD::LISTP-NAME))
          (<span class="string">"ELEMENT-P"</span> . ,(SYMBOL-NAME STD::ELEMENTP))
          (<span class="string">"ELEMENT"</span> . ,(SYMBOL-NAME STD::ELEMENTP)))))
    (intern-in-package-of-symbol (dumb-str-sublis subst-list thmname)
      listp-name)))</pre>
  </div>

<div class="form-block function" id="def-deflist-ruleclasses-subst" data-defines="DEFLIST-RULECLASSES-SUBST" data-references="QUASIQUOTE,APPEND,CADR,DEFLIST-THMBODY-SUBST,COROLLARY-TERM,LEN,-,TAKE,PREFIX,UNLESS,ASSOC-KEYWORD,COROLLARY-LOOK,CDR,CONS,CAR,CLASS,ATOM,WHEN,B*,NEGATEDP,X,FORMALS,NAME,ELEMENT,RULE-CLASSES,DEFUN" data-used-by="DEFLIST-INSTANTIATE" data-part-name="DEFLIST-RULECLASSES-SUBST" data-part-args="NEGATEDP,X,FORMALS,NAME,ELEMENT,RULE-CLASSES" data-part-body="QUASIQUOTE,APPEND,CADR,DEFLIST-THMBODY-SUBST,COROLLARY-TERM,LEN,-,TAKE,PREFIX,UNLESS,ASSOC-KEYWORD,COROLLARY-LOOK,NEGATEDP,X,FORMALS,NAME,ELEMENT,CDR,DEFLIST-RULECLASSES-SUBST,CONS,CAR,CLASS,RULE-CLASSES,ATOM,WHEN,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-RULECLASSES-SUBST">deflist-ruleclasses-subst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-ruleclasses-subst" data-sym="DEFLIST-RULECLASSES-SUBST" title="(defun std::deflist-ruleclasses-subst
       (std::rule-classes std::element std::name std::formals std::x
        std::negatedp)
  (std::b*
   (((when (atom std::rule-classes)) std::rule-classes)
...">deflist-ruleclasses-subst</a>
  (rule-classes element
    name
    <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
    x
    negatedp)
  (b* (((when (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> rule-classes)) rule-classes) (class (car rule-classes))
      ((when (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> class)) (cons class
          (<a class="sym-link local-def" href="#def-deflist-ruleclasses-subst" data-sym="DEFLIST-RULECLASSES-SUBST" title="(defun std::deflist-ruleclasses-subst
       (std::rule-classes std::element std::name std::formals std::x
        std::negatedp)
  (std::b*
   (((when (atom std::rule-classes)) std::rule-classes)
...">deflist-ruleclasses-subst</a> (cdr rule-classes)
            element
            name
            <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
            x
            negatedp)))
      (corollary-look (<a class="sym-link system" href="../../../axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> <span class="keyword">:corollary</span> class))
      ((unless corollary-look) (cons class
          (<a class="sym-link local-def" href="#def-deflist-ruleclasses-subst" data-sym="DEFLIST-RULECLASSES-SUBST" title="(defun std::deflist-ruleclasses-subst
       (std::rule-classes std::element std::name std::formals std::x
        std::negatedp)
  (std::b*
   (((when (atom std::rule-classes)) std::rule-classes)
...">deflist-ruleclasses-subst</a> (cdr rule-classes)
            element
            name
            <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
            x
            negatedp)))
      (prefix (<a class="sym-link system" href="../../../axioms.html#def-take" data-sym="TAKE">take</a> (<a class="sym-link system" href="../../../axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> class) (<a class="sym-link system" href="../../../axioms.html#def-len" data-sym="LEN">len</a> corollary-look))
          class))
      (corollary-term (deflist-thmbody-subst (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> corollary-look)
          element
          name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          x
          negatedp)))
    (cons (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> prefix
        `(<span class="keyword">:corollary</span> ,STD::COROLLARY-TERM . ,(CDDR STD::COROLLARY-LOOK)))
      (<a class="sym-link local-def" href="#def-deflist-ruleclasses-subst" data-sym="DEFLIST-RULECLASSES-SUBST" title="(defun std::deflist-ruleclasses-subst
       (std::rule-classes std::element std::name std::formals std::x
        std::negatedp)
  (std::b*
   (((when (atom std::rule-classes)) std::rule-classes)
...">deflist-ruleclasses-subst</a> (cdr rule-classes)
        element
        name
        <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
        x
        negatedp))))</pre>
  </div>

<div class="form-block function" id="def-deflist-instantiate" data-defines="DEFLIST-INSTANTIATE" data-references="DEFTHM,QUASIQUOTE,DEFLIST-RULECLASSES-SUBST,NEGATEDP,CLASSES,GETARG,CHEAP-LOOK,RULE-CLASSES,HARD?,ER,UNTRANSLATED-THEOREM,QUOTE,FGETPROP,BODY,CAR,DEFLIST-THMNAME-SUBST,THMNAME,IF,LOOK,LET,THMNAME-BASE,UNLESS,CADR,GENERIC-EVAL-REQUIREMENT,OR,REQ-OK,ASSOC,REQ-LOOK,T,EQ,AND,NOT,WHEN,ALIST,INST-THM,CONS,B*,WORLD,FN-SUBST,REQ-ALIST,X,KWD-ALIST,FORMALS,NAME,ELEMENT,TABLE-ENTRY,DEFUN" data-used-by="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" data-part-name="DEFLIST-INSTANTIATE" data-part-args="WORLD,FN-SUBST,REQ-ALIST,X,KWD-ALIST,FORMALS,NAME,ELEMENT,TABLE-ENTRY" data-part-body="DEFTHM,QUASIQUOTE,X,FORMALS,DEFLIST-RULECLASSES-SUBST,NEGATEDP,CLASSES,KWD-ALIST,GETARG,CHEAP-LOOK,RULE-CLASSES,DEFLIST-INSTANTIATE,HARD?,ER,WORLD,UNTRANSLATED-THEOREM,QUOTE,FGETPROP,BODY,ELEMENT,CAR,NAME,DEFLIST-THMNAME-SUBST,THMNAME,IF,LOOK,LET,THMNAME-BASE,UNLESS,REQ-ALIST,CADR,GENERIC-EVAL-REQUIREMENT,OR,REQ-OK,ASSOC,REQ-LOOK,T,EQ,AND,NOT,WHEN,TABLE-ENTRY,ALIST,INST-THM,CONS,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-INSTANTIATE">deflist-instantiate</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-instantiate" data-sym="DEFLIST-INSTANTIATE" title="(defun std::deflist-instantiate
       (std::table-entry std::element std::name std::formals std::kwd-alist
        std::x std::req-alist std::fn-subst std::world)
  (std::b*
   (((cons std::inst-thm std::alist) std::table-entry)
...">deflist-instantiate</a>
  (table-entry element
    name
    <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
    kwd-alist
    x
    req-alist
    fn-subst
    world)
  (b* (((cons inst-thm alist) table-entry) ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> alist)) nil)
      (alist (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> alist <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)) alist))
      (req-look (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:requirement</span> alist))
      (req-ok (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> req-look)
          (generic-eval-requirement (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> req-look)
            req-alist)))
      ((unless req-ok) nil)
      (thmname-base (let ((look (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:name</span> alist)))
          (if look
            (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> look)
            inst-thm)))
      (thmname (<a class="sym-link local-def" href="#def-deflist-thmname-subst" data-sym="DEFLIST-THMNAME-SUBST" title="(defun std::deflist-thmname-subst (std::thmname std::listp-name std::elementp)
  (std::b*
   ((std::thmname (symbol-name std::thmname))
    (std::subst-list
     `((&quot;ELEMENT-LIST-NONEMPTY-P&quot; . ,(symbol-name std::listp-name))
...">deflist-thmname-subst</a> thmname-base
          name
          (car element)))
      (<a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a> (let ((look (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:body</span> alist)))
          (if look
            (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> look)
            (<a class="sym-link system" href="../../../axioms.html#def-fgetprop" data-sym="FGETPROP">fgetprop</a> inst-thm
              'untranslated-theorem
              nil
              world))))
      ((when (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link system" href="../../../basis-b.html#def-body" data-sym="BODY">body</a>)) (<a class="sym-link system" href="../../../axioms.html#def-er" data-sym="ER">er</a> hard?
          '<a class="sym-link local-def" href="#def-deflist-instantiate" data-sym="DEFLIST-INSTANTIATE" title="(defun std::deflist-instantiate
       (std::table-entry std::element std::name std::formals std::kwd-alist
        std::x std::req-alist std::fn-subst std::world)
  (std::b*
   (((cons std::inst-thm std::alist) std::table-entry)
...">deflist-instantiate</a>
          <span class="string">"Bad deflist table entry: ~x0~%"</span>
          inst-thm))
      (rule-classes (b* ((cheap-look (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (getarg <span class="keyword">:cheap</span> nil kwd-alist)
               (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:cheap-rule-classes</span> alist))) ((when cheap-look) (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> cheap-look))
            (look (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:rule-classes</span> alist)))
          (if look
            (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> look)
            (<a class="sym-link system" href="../../../axioms.html#def-fgetprop" data-sym="FGETPROP">fgetprop</a> inst-thm 'classes nil world))))
      (negatedp (getarg <span class="keyword">:negatedp</span> nil kwd-alist))
      (rule-classes (<a class="sym-link local-def" href="#def-deflist-ruleclasses-subst" data-sym="DEFLIST-RULECLASSES-SUBST" title="(defun std::deflist-ruleclasses-subst
       (std::rule-classes std::element std::name std::formals std::x
        std::negatedp)
  (std::b*
   (((when (atom std::rule-classes)) std::rule-classes)
...">deflist-ruleclasses-subst</a> rule-classes
          element
          name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          x
          negatedp)))
    `((<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ,STD::THMNAME
       ,(STD::DEFLIST-THMBODY-SUBST STD::BODY STD::ELEMENT STD::NAME STD::FORMALS
  STD::X STD::NEGATEDP)
       <span class="keyword">:hints</span> ((<span class="string">"goal"</span> <span class="keyword">:use</span> ((<span class="keyword">:functional-instance</span> ,STD::INST-THM . ,STD::FN-SUBST))))
       <span class="keyword">:rule-classes</span> ,STD::RULE-CLASSES))))</pre>
  </div>

<div class="form-block function" id="def-deflist-instantiate-table-thms-aux" data-defines="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" data-references="CDR,CAR,DEFLIST-INSTANTIATE,APPEND,ATOM,IF,WORLD,FN-SUBST,REQ-ALIST,X,KWD-ALIST,FORMALS,NAME,ELEMENT,TABLE,DEFUN" data-used-by="DEFLIST-INSTANTIATE-TABLE-THMS" data-part-name="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" data-part-args="WORLD,FN-SUBST,REQ-ALIST,X,KWD-ALIST,FORMALS,NAME,ELEMENT,TABLE" data-part-body="CDR,DEFLIST-INSTANTIATE-TABLE-THMS-AUX,WORLD,FN-SUBST,REQ-ALIST,X,KWD-ALIST,FORMALS,NAME,ELEMENT,CAR,DEFLIST-INSTANTIATE,APPEND,TABLE,ATOM,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS-AUX">deflist-instantiate-table-thms-aux</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-instantiate-table-thms-aux" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" title="(defun std::deflist-instantiate-table-thms-aux
       (std::table std::element std::name std::formals std::kwd-alist std::x
        std::req-alist std::fn-subst std::world)
  (if (atom std::table)
      nil
...">deflist-instantiate-table-thms-aux</a>
  (<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> element
    name
    <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
    kwd-alist
    x
    req-alist
    fn-subst
    world)
  (if (<a class="sym-link system" href="../../../axioms.html#def-atom" data-sym="ATOM">atom</a> <a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a>)
    nil
    (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-deflist-instantiate" data-sym="DEFLIST-INSTANTIATE" title="(defun std::deflist-instantiate
       (std::table-entry std::element std::name std::formals std::kwd-alist
        std::x std::req-alist std::fn-subst std::world)
  (std::b*
   (((cons std::inst-thm std::alist) std::table-entry)
...">deflist-instantiate</a> (car <a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a>)
        element
        name
        <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
        kwd-alist
        x
        req-alist
        fn-subst
        world)
      (<a class="sym-link local-def" href="#def-deflist-instantiate-table-thms-aux" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" title="(defun std::deflist-instantiate-table-thms-aux
       (std::table std::element std::name std::formals std::kwd-alist std::x
        std::req-alist std::fn-subst std::world)
  (if (atom std::table)
      nil
...">deflist-instantiate-table-thms-aux</a> (cdr <a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a>)
        element
        name
        <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
        kwd-alist
        x
        req-alist
        fn-subst
        world))))</pre>
  </div>

<div class="form-block function" id="def-deflist-instantiate-table-thms" data-defines="DEFLIST-INSTANTIATE-TABLE-THMS" data-references="DEFLIST-INSTANTIATE-TABLE-THMS-AUX,DEFLIST-REQUIREMENT-ALIST,REQ-ALIST,DEFLIST-SUBSTITUTION,FN-SUBST,LISTP-RULES,NONEMPTY-LISTP-RULES,QUOTE,IF,TABLE-ALIST,REVERSE,TABLE,GETARG,NON-EMPTYP,B*,WORLD,X,KWD-ALIST,ELEMENT,FORMALS,NAME,DEFUN" data-used-by="DEFLIST-FN" data-part-name="DEFLIST-INSTANTIATE-TABLE-THMS" data-part-args="WORLD,X,KWD-ALIST,ELEMENT,FORMALS,NAME" data-part-body="DEFLIST-INSTANTIATE-TABLE-THMS-AUX,DEFLIST-REQUIREMENT-ALIST,REQ-ALIST,X,ELEMENT,FORMALS,NAME,DEFLIST-SUBSTITUTION,FN-SUBST,WORLD,LISTP-RULES,NONEMPTY-LISTP-RULES,QUOTE,IF,TABLE-ALIST,REVERSE,TABLE,KWD-ALIST,GETARG,NON-EMPTYP,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS">deflist-instantiate-table-thms</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-instantiate-table-thms" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS" title="(defun std::deflist-instantiate-table-thms
       (std::name std::formals std::element std::kwd-alist std::x std::world)
  (std::b*
   ((std::non-emptyp (std::getarg :non-emptyp nil std::kwd-alist))
    (std::table
...">deflist-instantiate-table-thms</a>
  (name <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
    element
    kwd-alist
    x
    world)
  (b* ((non-emptyp (getarg <span class="keyword">:non-emptyp</span> nil kwd-alist)) (<a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a> (<a class="sym-link system" href="../../../axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="../../../axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> (if non-emptyp
              'nonempty-listp-rules
              'listp-rules)
            world)))
      (fn-subst (<a class="sym-link local-def" href="#def-deflist-substitution" data-sym="DEFLIST-SUBSTITUTION" title="(defun std::deflist-substitution
       (std::name std::formals std::element std::kwd-alist std::x)
  (std::b*
   ((std::negatedp (std::getarg :negatedp nil std::kwd-alist))
    (std::true-listp (std::getarg :true-listp nil std::kwd-alist))
...">deflist-substitution</a> name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          element
          kwd-alist
          x))
      (req-alist (<a class="sym-link local-def" href="#def-deflist-requirement-alist" data-sym="DEFLIST-REQUIREMENT-ALIST" title="(defun std::deflist-requirement-alist
       (std::kwd-alist std::formals std::element)
  (std::b*
   ((std::negatedp (std::getarg :negatedp nil std::kwd-alist))
    (std::simple (std::simple-fncall-p-hack std::element))
...">deflist-requirement-alist</a> kwd-alist
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          element)))
    (<a class="sym-link local-def" href="#def-deflist-instantiate-table-thms-aux" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS-AUX" title="(defun std::deflist-instantiate-table-thms-aux
       (std::table std::element std::name std::formals std::kwd-alist std::x
        std::req-alist std::fn-subst std::world)
  (if (atom std::table)
      nil
...">deflist-instantiate-table-thms-aux</a> <a class="sym-link system" href="../../../axioms.html#def-table" data-sym="TABLE">table</a>
      element
      name
      <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
      kwd-alist
      x
      req-alist
      fn-subst
      world)))</pre>
  </div>

<div class="form-block function" id="def-deflist-fn" data-defines="DEFLIST-FN" data-references="DEFLIST-LOCAL-ELEMENTP-OF-NIL-THM,ENABLE-IF-THEOREM,ENABLE,MINIMAL-THEORY,THEORY,IN-THEORY,EQUAL,DEFLIST-LOCAL-BOOLEANP-ELEMENT-THM,DEFTHM,LOCAL,OBSERVATION,SUMMARY,WITH-OUTPUT,CW,VALUE-TRIPLE,SET-INHIBIT-WARNINGS,LOGIC,EVENTS,DEFSECTION-PROGN,PROGN,GET-XDOC-TABLE,FIND-TOPIC,THMS-SECTION,SYMBOL-NAME,NAME-BASICS,DEFLIST-INSTANTIATE-TABLE-THMS,THMS,WANT-DOC-P,PROGRAM,ENCAPSULATE,WHEN,BOOL,DEFINE,DEFXDOC,DEF,NULL,END-TEST,QUASIQUOTE,CAR-TEST,FULL-ESCAPE-SYMBOL,STRING,CONCATENATE,BOOLEANP,UNDOCUMENTED,GET-DEFAULT-PARENTS,PARENTS,ASSOC,PARENTS-P,DEFAULT-DEFUN-MODE,MODE,APPEND,REST,PREPWORK,NON-EMPTYP,THEORY-HACK,LONG,SHORT,ELEMENTP-OF-NIL,GUARD-HINTS,GUARD-DEBUG,GUARD,T,VERIFY-GUARDS,TRUE-LISTP,NEGATEDP,IF,GETARG,ALREADY-DEFINEDP,MACRO-ARGS,W,CURRENT-ACL2-WORLD,FORMALS,GETPROP,EQ,OR,LOOKS-ALREADY-DEFINED-P,CDR,ELEM-FORMALS,ELEMENTP,CAR,SYMBOLP,CONSP,NOT,MEMBER,RAISE,NO-DUPLICATESP,SYMBOL-LISTP,AND,UNLESS,Y,N,A,INTERN-IN-PACKAGE-OF-SYMBOL,X,DEFLIST,QUOTE,__FUNCTION__,B*,XARGS,DECLARE,STATE,OTHER-EVENTS,KWD-ALIST,ELEMENT,FORMALS,NAME,DEFUN" data-part-name="DEFLIST-FN" data-part-args="STATE,OTHER-EVENTS,KWD-ALIST,ELEMENT,FORMALS,NAME" data-part-declare="XARGS,DECLARE" data-part-body="DEFLIST-LOCAL-ELEMENTP-OF-NIL-THM,ENABLE-IF-THEOREM,ENABLE,MINIMAL-THEORY,THEORY,IN-THEORY,EQUAL,DEFLIST-LOCAL-BOOLEANP-ELEMENT-THM,DEFTHM,LOCAL,OBSERVATION,SUMMARY,WITH-OUTPUT,CW,VALUE-TRIPLE,SET-INHIBIT-WARNINGS,LOGIC,EVENTS,DEFSECTION-PROGN,PROGN,GET-XDOC-TABLE,FIND-TOPIC,THMS-SECTION,SYMBOL-NAME,NAME-BASICS,DEFLIST-INSTANTIATE-TABLE-THMS,THMS,WANT-DOC-P,PROGRAM,ENCAPSULATE,WHEN,BOOL,DEFINE,DEFXDOC,DEF,NULL,END-TEST,QUASIQUOTE,CAR-TEST,FULL-ESCAPE-SYMBOL,STRING,CONCATENATE,BOOLEANP,UNDOCUMENTED,GET-DEFAULT-PARENTS,PARENTS,ASSOC,PARENTS-P,DEFAULT-DEFUN-MODE,MODE,OTHER-EVENTS,APPEND,REST,PREPWORK,NON-EMPTYP,THEORY-HACK,LONG,SHORT,ELEMENTP-OF-NIL,GUARD-HINTS,GUARD-DEBUG,GUARD,T,VERIFY-GUARDS,TRUE-LISTP,NEGATEDP,IF,KWD-ALIST,GETARG,ALREADY-DEFINEDP,MACRO-ARGS,STATE,W,CURRENT-ACL2-WORLD,FORMALS,GETPROP,EQ,OR,LOOKS-ALREADY-DEFINED-P,CDR,ELEM-FORMALS,ELEMENTP,CAR,SYMBOLP,ELEMENT,CONSP,NOT,MEMBER,RAISE,NO-DUPLICATESP,FORMALS,SYMBOL-LISTP,AND,UNLESS,Y,N,A,NAME,INTERN-IN-PACKAGE-OF-SYMBOL,X,DEFLIST,QUOTE,__FUNCTION__,B*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST-FN">deflist-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-deflist-fn" data-sym="DEFLIST-FN" title="(defun std::deflist-fn
       (std::name std::formals std::element std::kwd-alist std::other-events
        std::state)
  (declare (std::xargs :mode :program))
  (std::b*
...">deflist-fn</a>
  (name <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
    element
    kwd-alist
    other-events
    state)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (b* ((__function__ '<a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a>) (x (intern-in-package-of-symbol <span class="string">"X"</span> name))
      (a (intern-in-package-of-symbol <span class="string">"A"</span> name))
      (n (intern-in-package-of-symbol <span class="string">"N"</span> name))
      (y (intern-in-package-of-symbol <span class="string">"Y"</span> name))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>)
           (<a class="sym-link system" href="../../../axioms.html#def-no-duplicatesp" data-sym="NO-DUPLICATESP">no-duplicatesp</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))) (raise <span class="string">"The formals must be a list of unique symbols, but are ~x0."</span>
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> x <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>)) (raise <span class="string">"The formals must contain ~x0, but are ~x1.~%"</span>
          x
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> a <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
           (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> n <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
           (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> y <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>)))) (raise <span class="string">"As a special restriction, formals may not mention ~x0, ~x1, ~
                or ~x2, but the formals are ~x3."</span>
          a
          n
          y
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (consp element) (symbolp (car element)))) (raise <span class="string">"The element recognizer must be a function applied to the ~
                formals, but is ~x0."</span>
          element))
      (elementp (car element))
      (elem-formals (cdr element))
      (looks-already-defined-p (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-getprop" data-sym="GETPROP">getprop</a> name
                '<a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
                <span class="keyword">:none</span> 'current-acl2-world
                (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
              <span class="keyword">:none</span>))
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="../../../axioms.html#def-getprop" data-sym="GETPROP">getprop</a> name
                'macro-args
                <span class="keyword">:none</span> 'current-acl2-world
                (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
              <span class="keyword">:none</span>))))
      (already-definedp (getarg <span class="keyword">:already-definedp</span> <span class="keyword">:unknown</span> kwd-alist))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> already-definedp <span class="keyword">:unknown</span>)
           (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> already-definedp looks-already-defined-p))) (raise <span class="string">"Found :already-definedp ~x0, but ~x1 is ~s2."</span>
          already-definedp
          name
          (if looks-already-defined-p
            <span class="string">"already defined."</span>
            <span class="string">"not defined."</span>)))
      (already-definedp looks-already-defined-p)
      (negatedp (getarg <span class="keyword">:negatedp</span> nil kwd-alist))
      (<a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (getarg <span class="keyword">:true-listp</span> nil kwd-alist))
      (<a class="sym-link system" href="../../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a> (getarg <span class="keyword">:verify-guards</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> kwd-alist))
      (<a class="sym-link system" href="../../../basis-b.html#def-guard" data-sym="GUARD">guard</a> (getarg <span class="keyword">:guard</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> kwd-alist))
      (guard-debug (getarg <span class="keyword">:guard-debug</span> nil kwd-alist))
      (guard-hints (getarg <span class="keyword">:guard-hints</span> nil kwd-alist))
      (elementp-of-nil (getarg <span class="keyword">:elementp-of-nil</span> <span class="keyword">:unknown</span> kwd-alist))
      (short (getarg <span class="keyword">:short</span> nil kwd-alist))
      (long (getarg <span class="keyword">:long</span> nil kwd-alist))
      (theory-hack (getarg <span class="keyword">:theory-hack</span> nil kwd-alist))
      (non-emptyp (getarg <span class="keyword">:non-emptyp</span> nil kwd-alist))
      (prepwork (getarg <span class="keyword">:prepwork</span> nil kwd-alist))
      (<a class="sym-link system" href="../../../axioms.html#def-rest" data-sym="REST">rest</a> (<a class="sym-link system" href="../../../axioms.html#def-append" data-sym="APPEND">append</a> (getarg <span class="keyword">:rest</span> nil kwd-alist)
          other-events))
      (mode (getarg <span class="keyword">:mode</span> (<a class="sym-link system" href="../../../axioms.html#def-default-defun-mode" data-sym="DEFAULT-DEFUN-MODE">default-defun-mode</a> (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
          kwd-alist))
      (parents-p (<a class="sym-link system" href="../../../axioms.html#def-assoc" data-sym="ASSOC">assoc</a> <span class="keyword">:parents</span> kwd-alist))
      (parents (cdr parents-p))
      (parents (if parents-p
          parents
          (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (get-default-parents (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state))
            '(undocumented))))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-booleanp" data-sym="BOOLEANP">booleanp</a> negatedp)) (raise <span class="string">":negatedp must be a boolean, but is ~x0."</span>
          negatedp))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-booleanp" data-sym="BOOLEANP">booleanp</a> <a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>)) (raise <span class="string">":true-listp must be a boolean, but is ~x0."</span>
          <a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-booleanp" data-sym="BOOLEANP">booleanp</a> <a class="sym-link system" href="../../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>)) (raise <span class="string">":verify-guards must be a boolean, but is ~x0."</span>
          <a class="sym-link system" href="../../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> mode <span class="keyword">:logic</span>) (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> mode <span class="keyword">:program</span>))) (raise <span class="string">":mode must be one of :logic or :program, but is ~x0."</span>
          mode))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> mode <span class="keyword">:logic</span>) (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> already-definedp))) (raise <span class="string">":mode :program and already-definedp cannot be used together."</span>))
      ((unless (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> elementp-of-nil '(<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> nil <span class="keyword">:unknown</span>))) (raise <span class="string">":elementp-of-nil must be t, nil, or :unknown"</span>))
      (short (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> short
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> parents
            (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a>
              <span class="string">"@(call "</span>
              (full-escape-symbol name)
              <span class="string">") recognizes lists where every element "</span>
              (if negatedp
                <span class="string">"is rejected by "</span>
                <span class="string">"satisfies "</span>)
              <span class="string">"@(see? "</span>
              (full-escape-symbol elementp)
              <span class="string">")."</span>))))
      (long (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> long
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> parents
            (if <a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>
              <span class="string">"&lt;p&gt;This is an ordinary @(see std::deflist).  It is
                           &quot;strict&quot; in that it requires @(&#39;x&#39;) to be a
                           &quot;properly&quot; nil-terminated list.&lt;/p&gt;"</span>
              <span class="string">"&lt;p&gt;This is an ordinary @(see std::deflist).  It is
                         &quot;loose&quot; in that it does not care whether @(&#39;x&#39;) is
                         nil-terminated.&lt;/p&gt;"</span>))))
      (car-test (if negatedp
          `(<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (,STD::ELEMENTP ,@(SUBST `(CAR ,STD::X) STD::X STD::ELEM-FORMALS)))
          `(,STD::ELEMENTP ,@(SUBST `(CAR ,STD::X) STD::X STD::ELEM-FORMALS))))
      (end-test (if <a class="sym-link system" href="../../../axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a>
          `(<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> ,STD::X)
          <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
      (def (if already-definedp
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> parents-p parents) short long)
            `((defxdoc ,STD::NAME
               ,@(AND (OR STD::PARENTS-P STD::PARENTS) `(:PARENTS ,STD::PARENTS))
               ,@(AND STD::SHORT `(:SHORT ,STD::SHORT))
               ,@(AND STD::LONG `(:LONG ,STD::LONG))
               <span class="keyword">:no-override</span> <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)))
          `((define ,STD::NAME
             (,@STD::FORMALS)
             ,@(AND (OR STD::PARENTS-P STD::PARENTS) `(:PARENTS ,STD::PARENTS))
             ,@(AND STD::SHORT `(:SHORT ,STD::SHORT))
             ,@(AND STD::LONG `(:LONG ,STD::LONG))
             <span class="keyword">:returns</span> bool
             <span class="keyword">:guard</span> ,STD::GUARD
             <span class="keyword">:normalize</span> nil
             ,@(AND (EQ STD::MODE :LOGIC)
       `(:VERIFY-GUARDS ,STD::VERIFY-GUARDS
         ,@(AND STD::GUARD-DEBUG `(:GUARD-DEBUG ,STD::GUARD-DEBUG))
         :GUARD-HINTS ,STD::GUARD-HINTS))
             ,(IF STD::NON-EMPTYP
     `(AND (CONSP ,STD::X) ,STD::CAR-TEST
           (LET ((,STD::X (CDR ,STD::X)))
             (IF (CONSP ,STD::X)
                 (,STD::NAME ,@STD::FORMALS)
                 ,STD::END-TEST)))
     `(IF (CONSP ,STD::X)
          (AND ,STD::CAR-TEST
               (,STD::NAME ,@(SUBST `(CDR ,STD::X) STD::X STD::FORMALS)))
          ,STD::END-TEST))))))
      ((when (<a class="sym-link system" href="../../../axioms.html#def-eq" data-sym="EQ">eq</a> mode <span class="keyword">:program</span>)) `(<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
          (<a class="sym-link system" href="../../../axioms.html#def-program" data-sym="PROGRAM">program</a>)
          ,@STD::PREPWORK
          ,@STD::DEF
          ,@REST))
      (want-doc-p (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> short long parents))
      (thms (<a class="sym-link local-def" href="#def-deflist-instantiate-table-thms" data-sym="DEFLIST-INSTANTIATE-TABLE-THMS" title="(defun std::deflist-instantiate-table-thms
       (std::name std::formals std::element std::kwd-alist std::x std::world)
  (std::b*
   ((std::non-emptyp (std::getarg :non-emptyp nil std::kwd-alist))
    (std::table
...">deflist-instantiate-table-thms</a> name
          <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a>
          element
          kwd-alist
          x
          (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state)))
      (name-basics (intern-in-package-of-symbol (<a class="sym-link system" href="../../../axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="../../../axioms.html#def-string" data-sym="STRING">string</a> (symbol-name name) <span class="string">"-BASICS"</span>)
          name))
      (thms-section (if (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> want-doc-p)
            (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> already-definedp
              (find-topic name-basics
                (get-xdoc-table (<a class="sym-link system" href="../../../axioms.html#def-w" data-sym="W">w</a> state)))))
          `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> . ,STD::THMS)
          `(defsection-progn ,STD::NAME-BASICS
            <span class="keyword">:parents</span> (,STD::NAME)
            <span class="keyword">:short</span> ,(CONCATENATE &#39;STRING &quot;Basic theorems about @(see &quot;
              (XDOC::FULL-ESCAPE-SYMBOL STD::NAME)
              &quot;), generated by @(see std::deflist).&quot;) . ,STD::THMS)))
      (events `((<a class="sym-link system" href="../../../axioms.html#def-logic" data-sym="LOGIC">logic</a>) ,@STD::PREPWORK
          (<a class="sym-link system" href="../../../axioms.html#def-set-inhibit-warnings" data-sym="SET-INHIBIT-WARNINGS">set-inhibit-warnings</a> <span class="string">"theory"</span>
            <span class="string">"free"</span>
            <span class="string">"non-rec"</span>
            <span class="string">"double-rewrite"</span>
            <span class="string">"subsume"</span>
            <span class="string">"disable"</span>)
          (<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~|~%Deflist: attempting to show, using your current theory, ~
                that ~x0 is always Boolean valued.~%"</span>
              ',STD::ELEMENT))
          (<a class="sym-link system" href="../../../axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:stack</span> <span class="keyword">:pop</span> <span class="keyword">:off</span> (summary <a class="sym-link system" href="../../../basis-a.html#def-observation" data-sym="OBSERVATION">observation</a>)
            (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> deflist-local-booleanp-element-thm
                (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal ,STD::ELEMENT <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>) (equal ,STD::ELEMENT nil))
                <span class="keyword">:rule-classes</span> <span class="keyword">:type-prescription</span>)))
          ,@(AND (NOT (EQ STD::ELEMENTP-OF-NIL :UNKNOWN))
       `((STD::VALUE-TRIPLE
          (STD::CW &quot;~|~%Deflist: attempting to justify, using your ~
                         current theory, :ELEMENTP-OF-NIL ~x0.~%&quot;
           &#39;,STD::ELEMENTP-OF-NIL))
         (STD::WITH-OUTPUT :STACK :POP :OFF (SUMMARY)
          (STD::LOCAL
           (STD::MAYBE-DEFTHM-AS-REWRITE STD::DEFLIST-LOCAL-ELEMENTP-OF-NIL-THM
            (EQUAL (,STD::ELEMENTP ,@(SUBST &#39;&#39;NIL STD::X STD::ELEM-FORMALS))
                   &#39;,STD::ELEMENTP-OF-NIL))))))
          (<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> (<a class="sym-link system" href="../../../axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~|~%Deflist: introducing ~x0 and proving deflist theorems.~%"</span>
              ',STD::NAME))
          ,@STD::DEF
          (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (theory 'minimal-theory)))
          (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (enable ,STD::NAME
                (<span class="keyword">:type-prescription</span> ,STD::NAME)
                deflist-local-booleanp-element-thm)))
          (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (enable-if-theorem deflist-local-elementp-of-nil-thm))
          ,@STD::THEORY-HACK
          ,STD::THMS-SECTION)))
    `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil . ,STD::EVENTS) . ,(AND REST
      `((STD::VALUE-TRIPLE (STD::CW &quot;Deflist: submitting /// events.~%&quot;))
        (STD::WITH-OUTPUT :STACK :POP
         (STD::DEFSECTION STD::USER-EVENTS
          ,@(AND STD::WANT-DOC-P `(:EXTENSION ,STD::NAME))
          (STD::LOCAL (STD::IN-THEORY (STD::ENABLE ,STD::NAME))) . ,REST)))))))</pre>
  </div>

<div class="form-block macro" id="def-deflist" data-defines="DEFLIST" data-references="VALUE-TRIPLE,PROGN,MAKE-EVENT,WITH-OUTPUT,QUASIQUOTE,GETARG,VERBOSEP,ELEMENT,FORMALS,TUPLEP,*DEFLIST-VALID-KEYWORDS*,EXTRACT-KEYWORDS,FORMALS-ELEM,KWD-ALIST,SPLIT-///,OTHER-EVENTS,MAIN-STUFF,MV,LIST,CTX,RAISE,SYMBOLP,UNLESS,QUOTE,__FUNCTION__,B*,ARGS,&REST,NAME,DEFMACRO" data-used-by="DEFLIST-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFLIST">deflist</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a>
  (name &amp;rest <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>)
  (b* ((__function__ '<a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a>) ((unless (symbolp name)) (raise <span class="string">"Name must be a symbol."</span>))
      (ctx (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a> name))
      ((<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> main-stuff other-events) (split-/// ctx <a class="sym-link system" href="../../../defuns.html#def-args" data-sym="ARGS">args</a>))
      ((<a class="sym-link system" href="../../../axioms.html#def-mv" data-sym="MV">mv</a> kwd-alist formals-elem) (extract-keywords ctx
          *deflist-valid-keywords*
          main-stuff
          nil))
      ((unless (tuplep <span class="number">2</span> formals-elem)) (raise <span class="string">"Wrong number of arguments to deflist."</span>))
      ((<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link system" href="../../../basis-b.html#def-formals" data-sym="FORMALS">formals</a> element) formals-elem)
      (verbosep (getarg <span class="keyword">:verbosep</span> nil kwd-alist)))
    `(<a class="sym-link system" href="../../../axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:stack</span> <span class="keyword">:push</span> ,@(IF STD::VERBOSEP
      NIL
      &#39;(:GAG-MODE T :OFF (SUMMARY OBSERVATION PROVE PROOF-TREE EVENT)))
      (<a class="sym-link system" href="../../../axioms.html#def-make-event" data-sym="MAKE-EVENT">make-event</a> `(<a class="sym-link system" href="../../../axioms.html#def-progn" data-sym="PROGN">progn</a> ,(STD::DEFLIST-FN &#39;,STD::NAME &#39;,STD::FORMALS &#39;,STD::ELEMENT &#39;,STD::KWD-ALIST
  &#39;,STD::OTHER-EVENTS STD::STATE)
          (<a class="sym-link system" href="../../../axioms.html#def-value-triple" data-sym="VALUE-TRIPLE">value-triple</a> '(<a class="sym-link local-def" href="#def-deflist" data-sym="DEFLIST" title="(defmacro std::deflist (std::name &amp;rest std::args)
  (std::b*
   ((std::__function__ &#39;std::deflist)
    ((unless (symbolp std::name)) (std::raise &quot;Name must be a symbol.&quot;))
    (std::ctx (list &#39;std::deflist std::name))
...">deflist</a> ,&#39;,STD::NAME)))))))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>