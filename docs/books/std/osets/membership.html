<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>membership - ACL2 Book</title>
  <meta property="name" content="membership">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">membership</h1>
    <div class="path"><a href="membership.lisp" class="source-link">books/std/osets/membership</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"SET"</span>)</pre>
  </div>

<div class="form-block other" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="primitives.html" title="Open primitives">"primitives"</a>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="computed-hints.html" title="Open computed-hints">"computed-hints"</a>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-set-verify-guards-eagerness" data-sym="SET-VERIFY-GUARDS-EAGERNESS">set-verify-guards-eagerness</a> <span class="number">2</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection in
  <span class="keyword">:parents</span> (std/osets)
  <span class="keyword">:short</span> <span class="string">"@(call in) determines if @(&#39;a&#39;) is a member of the set @(&#39;X&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The logical definition of @(&#39;in&#39;) makes no mention of the set
order, except implicitly by the use of the set @(see primitives) like @(see
head) and @(see tail).&lt;/p&gt;

&lt;p&gt;The :exec version just inlines the set primitives and does one level of loop
unrolling.  On CCL, it seems to run about 2.6x faster on the following
loop:&lt;/p&gt;

@({
 ;; 4.703 sec logic, 1.811 sec exec
 (let ((big-set (loop for i from 1 to 100000 collect i)))
   (gc$)
   (time (loop for i fixnum from 1 to 30000 do (set::in i big-set))))
})

&lt;p&gt;There are other ways we could optimize @(&#39;in&#39;).  Since the set is ordered,
we could try to use the set order @(see &lt;&lt;) to stop early when we ran into an
element that is larger than the one we are looking for.  For instance, when
looking for 1 in the set &#39;(2 3 4), we know that since @(&#39;1 &lt;&lt; 2&#39;) that @(&#39;1&#39;)
cannot be a member of this set.&lt;/p&gt;

&lt;p&gt;The simplest way to do this is to use @(&#39;&lt;&lt;&#39;) at every element.  But set
order comparisons can be very expensive, especially when sets contain large
cons structures.  So while it is easy to contrive situations where exploiting
the order would be advantageous, like&lt;/p&gt;

@({
 (in 1 &#39;(2 3 4 .... 100000))
})

&lt;p&gt;where we could return instantly, there are also times where it would be
slower.  For instance, on&lt;/p&gt;

@({
 (in 100001 &#39;(1 2 3 4 ... 100000))
})

&lt;p&gt;we would incur the extra cost of 100,000 calls to @(&#39;&lt;&lt;&#39;).&lt;/p&gt;

&lt;p&gt;For this reason, we do not currently implement any short-circuiting.  The
reasoning is:&lt;/p&gt;

&lt;ul&gt;

&lt;li&gt;it is not clear which would be faster in all cases,&lt;/li&gt;

&lt;li&gt;it is not clear what the typical usage behavior of @(&#39;in&#39;) is, so even if
we wanted to benchmark alternate implementations, it may be hard to come up
with the right benchmarking suite&lt;/li&gt;

&lt;li&gt;both solutions are O(n) anyway, and @(&#39;in&#39;) isn&#39;t a function that should
probably be used in any kind of loop so its performance shouldn&#39;t be especially
critical to anything&lt;/li&gt;

&lt;li&gt;the current method is arguably no less efficient than an unordered
implementation.&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;Future note.  In principle membership in an ordered list might be done in
@(&#39;O(log_2 n)&#39;).  We are considering using a &lt;i&gt;galloping&lt;/i&gt; membership check
in the future to obtain something along these lines.&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> in
    (a x)
    (declare (xargs <span class="keyword">:guard</span> (setp x) <span class="keyword">:verify-guards</span> nil))
    (<a class="sym-link system" href="../../../axioms.html#def-mbe" data-sym="MBE">mbe</a> <span class="keyword">:logic</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x))
        (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal a (head x))
          (in a (tail x))))
      <span class="keyword">:exec</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> x
        (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal a (car x))
          (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (cdr x)
            (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal a (<a class="sym-link system" href="../../../axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
              (in a (<a class="sym-link system" href="../../../axioms.html#def-cddr" data-sym="CDDR">cddr</a> x))))))))
  (<a class="sym-link system" href="../../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a> in
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> primitive-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-type
    (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal (in a x) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
      (equal (in a x) nil))
    <span class="keyword">:rule-classes</span> <span class="keyword">:type-prescription</span>)
  (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> head-not-whole
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x))
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal (head x) x)))
        <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> primitive-rules))))))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x) (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> y))
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in x y)))))
    (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> not-in-self (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in x x))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-sfix-cancel
    (equal (in a (sfix x))
      (in a x)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> never-in-empty
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (emptyp x)
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-set
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in a x) (setp x)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-tail
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in a (tail x))
      (in a x)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-tail-or-head
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (in a x)
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a (tail x))))
      (equal (head x) a)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-head
    (equal (in (head x) x)
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x)))))</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection head-unique
  <span class="keyword">:extension</span> head
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x))
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal a (head x)))
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (&lt;&lt; a (head (tail x))))
          (&lt;&lt; a (head x)))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x)))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
         <span class="keyword">:cases</span> ((emptyp (tail x)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> head-minimal
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (&lt;&lt; a (head x))
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> head-minimal-2
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in a x)
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (&lt;&lt; a (head x)))))
  (add-to-ruleset order-rules
    '(head-minimal head-minimal-2))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma2
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (emptyp (tail x))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in (head x) (tail x))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma3
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp (tail x)))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in (head x) (tail x))))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> head-unique
    (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in (head x) (tail x)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:use</span> ((<span class="keyword">:instance</span> lemma2) (<span class="keyword">:instance</span> lemma3))))))</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection in-insert
  <span class="keyword">:extension</span> insert
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> insert-identity
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in a x)
      (equal (insert a x) x))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable head-tail-same
         (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-insert
    (equal (in a (insert b x))
      (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (in a x) (equal a b)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
       <span class="keyword">:induct</span> (insert b x)))))</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection weak-insert-induction
  <span class="keyword">:parents</span> (insert)
  <span class="keyword">:short</span> <span class="string">"Inducting over insert without exposing the set order."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;When we want to insert an element into an ordered set, the set
order obviously has to be involved so that we can decide where to put the new
element.  Accordingly, the set order plays a role in the induction scheme that
we get from @(see insert)&#39;s definition.  This makes insert somewhat different
than other set operations (membership, union, cardinality, etc.) that just use
a simple @(see tail)-based induction, where the set order is already hidden by
@(&#39;tail&#39;).&lt;/p&gt;

&lt;p&gt;When we are proving theorems about sets, we generally want to avoid thinking
about the set order, but we sometimes need to induct over @(&#39;insert&#39;).  So,
here we introduce a new induction scheme that allows us to induct over insert
but hides the set order.  We disable the ordinary induction scheme that insert
uses, and set up an induction hint so that @(&#39;weak-insert-induction&#39;) will
automatically be used instead.&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> weak-insert-induction-helper-1
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal (head (insert a x)) a)))
      (equal (head (insert a x))
        (head x)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> weak-insert-induction-helper-2
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal (head (insert a x)) a)))
      (equal (tail (insert a x))
        (insert a (tail x))))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> weak-insert-induction-helper-3
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x))
        (equal (head (insert a x)) a))
      (equal (tail (insert a x))
        (sfix x)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> weak-insert-induction
    (a x)
    (declare (xargs <span class="keyword">:guard</span> (setp x)))
    (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((emptyp x) nil)
      ((in a x) nil)
      ((equal (head (insert a x)) a) nil)
      (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> (weak-insert-induction a (tail x))))))
  (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable (<span class="keyword">:induction</span> insert)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> use-weak-insert-induction
    <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
    <span class="keyword">:rule-classes</span> ((<span class="keyword">:induction</span> <span class="keyword">:pattern</span> (insert a x)
       <span class="keyword">:scheme</span> (weak-insert-induction a x)))))</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection subset
  <span class="keyword">:parents</span> (std/osets)
  <span class="keyword">:short</span> <span class="string">"@(call subset) determines if @(&#39;X&#39;) is a subset of @(&#39;Y&#39;)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;We use a logically simple definition, but using MBE we exploit the
set order to implement a tail-recursive, linear subset check.&lt;/p&gt;

&lt;p&gt;The :exec version of fast-subset just inlines the set primitives and tweaks
the way the order check is done.  It is about 3x faster than the :logic version
of fast-subset on the following loop:&lt;/p&gt;

@({
 ;; 3.83 sec logic, 1.24 seconds exec
 (let ((x (loop for i from 1 to 1000 collect i)))
   (gc$)
   (time$ (loop for i fixnum from 1 to 100000 do (set::subset x x))))
})

&lt;p&gt;In the future we may investigate developing a faster subset check based on
galloping.&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> fast-subset
    (x y)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
        <span class="keyword">:guard-hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> primitive-rules) &lt;&lt;)))))
    (<a class="sym-link system" href="../../../axioms.html#def-mbe" data-sym="MBE">mbe</a> <span class="keyword">:logic</span> (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((emptyp x) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
        ((emptyp y) nil)
        ((&lt;&lt; (head x) (head y)) nil)
        ((equal (head x) (head y)) (fast-subset (tail x) (tail y)))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (fast-subset x (tail y))))
      <span class="keyword">:exec</span> (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> x) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
        ((<a class="sym-link system" href="../../../axioms.html#def-null" data-sym="NULL">null</a> y) nil)
        ((fast-lexorder (car x) (car y)) (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (equal (car x) (car y))
            (fast-subset (cdr x) (cdr y))))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (fast-subset x (cdr y))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defun-inline" data-sym="DEFUN-INLINE">defun-inline</a> subset
    (x y)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
        <span class="keyword">:verify-guards</span> nil))
    (<a class="sym-link system" href="../../../axioms.html#def-mbe" data-sym="MBE">mbe</a> <span class="keyword">:logic</span> (if (emptyp x)
        <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (in (head x) y)
          (subset (tail x) y)))
      <span class="keyword">:exec</span> (fast-subset x y)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-type
    (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (equal (subset x y) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
      (equal (subset x y) nil))
    <span class="keyword">:rule-classes</span> <span class="keyword">:type-prescription</span>)
  (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> lemma
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in (head y) x))
          (equal (subset x y)
            (subset x (tail y))))))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> case-1
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x))
            (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp y))
            (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (&lt;&lt; (head x) (head y)))
            (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal (head x) (head y)))
            (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp (tail y)))
              (equal (fast-subset x (tail y))
                (subset x (tail y)))))
          (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
            (equal (fast-subset x y)
              (subset x y))))
        <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
           <span class="keyword">:use</span> (<span class="keyword">:instance</span> lemma)))))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> case-2
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp x))
            (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (emptyp y))
            (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (&lt;&lt; (head x) (head y)))
            (equal (head x) (head y))
            (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp (tail x))
                (setp (tail y)))
              (equal (fast-subset (tail x) (tail y))
                (subset (tail x) (tail y)))))
          (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
            (equal (fast-subset x y)
              (subset x y))))
        <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
           <span class="keyword">:use</span> (<span class="keyword">:instance</span> lemma (x (tail x)))))))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> fast-subset-equivalence
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
          (equal (fast-subset x y)
            (subset x y)))
        <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
           <span class="keyword">:induct</span> (fast-subset x y)))))
    (<a class="sym-link system" href="../../../axioms.html#def-verify-guards" data-sym="VERIFY-GUARDS">verify-guards</a> subset$inline)))</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection all-by-membership
  <span class="keyword">:parents</span> (std/osets)
  <span class="keyword">:short</span> <span class="string">"A way to quantify over sets."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;@(&#39;all-by-membership&#39;) is a generic theorem that can be used to
prove that a property holds of a set by showing that a related property holds
of the set elements.&lt;/p&gt;

&lt;p&gt;The most important role of @(&#39;all-by-membership&#39;) is to allow for
pick-a-point proofs of @(see subset).  That is, it allows us to show that
@(&#39;(subset X Y)&#39;) holds by showing that every element of X satisfies @(&#39;(in a
Y)&#39;).&lt;/p&gt;

&lt;p&gt;More generally, we could show that a set satisfies a predicate like
@(&#39;integer-setp&#39;) because each of its elements satisfies @(&#39;integerp&#39;).&lt;/p&gt;


&lt;h3&gt;Pick-a-Point Proofs in ACL2&lt;/h3&gt;

&lt;p&gt;We begin by explaining how pick-a-point proofs of subset can be carried out.
In traditional mathematics, @(see subset) is defined using quantification over
members, e.g., as follows:&lt;/p&gt;

@({
  (equal (subset X Y)
         (forall a (implies (in a X) (in a Y))))
})

&lt;p&gt;This definition is very useful for &lt;b&gt;pick-a-point&lt;/b&gt; proofs that some set
@(&#39;X&#39;) is a subset of @(&#39;Y&#39;).  Such a proof begins by picking an arbitrary
point @(&#39;a&#39;) that is a member of @(&#39;X&#39;).  Then, if we can show that @(&#39;a&#39;) must
be a member of @(&#39;Y&#39;), we have established @(&#39;(subset X Y)&#39;).&lt;/p&gt;

&lt;p&gt;These kinds of arguments are extremely useful, and we would like to be able
to carry them out in ACL2 about osets.  But since ACL2 does not have explicit
quantifiers, we cannot even write a theorem like this:&lt;/p&gt;

@({
 (implies (forall a (implies (in a X) (in a Y)))
          (subset X Y))
})

&lt;p&gt;But consider the contrapositive of this theorem:&lt;/p&gt;

@({
 (implies (not (subset X Y))
          (exists a (and (in a X) (not (in a Y)))))
})

&lt;p&gt;We &lt;i&gt;can&lt;/i&gt; prove something like this, by writing an explicit function to
search for an element of @(&#39;X&#39;) that is not an element of @(&#39;Y&#39;).  That is, we
can prove:&lt;/p&gt;

@({
 (implies (not (subset X Y))
          (let ((a (find-witness X Y)))
            (and (in a X)
                 (not (in a Y)))))
})

&lt;p&gt;Once we prove the above, we still need to be able to &quot;reduce&quot; a proof of
@(&#39;(subset X Y)&#39;) to a proof of @(&#39;(implies (in a X) (in a Y))&#39;).  While we
can&#39;t do this with a direct rewrite rule, we can sort of fake it using
functional instantiation.  As groundwork:&lt;/p&gt;

&lt;ul&gt;

&lt;li&gt;Using @(see encapsulate), we introduce functions @(&#39;sub&#39;) and @(&#39;super&#39;)
with the constraint that @({
 (implies (in a (sub))
          (in a (super)))
})&lt;/li&gt;

&lt;li&gt;Using this constraint, we prove the generic theorem:
@({
 (subset (sub) (super))
})&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;Then, when we want to prove @(&#39;(subset X Y)&#39;) for some particular @(&#39;X&#39;) and
@(&#39;Y&#39;), we can functionally instantiate the generic theorem with&lt;/p&gt;

@({
   sub   &lt;-- (lambda () X)
   super &lt;-- (lambda () Y)
})

&lt;p&gt;And this allows us to prove @(&#39;(subset X Y)&#39;) as long as we can relieve the
constraint, i.e., @(&#39;(implies (in a X) (in a Y))&#39;).&lt;/p&gt;


&lt;h3&gt;Generalizing Pick-a-Point Proofs&lt;/h3&gt;

&lt;p&gt;In earlier versions of the osets library, we used an explicit argument to
reduce subset proofs to pick-a-point style membership arguments.  But we later
generalized the approach to arbitrary predicates instead.&lt;/p&gt;

&lt;p&gt;First, notice that if you let the predicate @(&#39;(P a)&#39;) be defined as @(&#39;(in
a Y)&#39;), then @(&#39;(subset X Y)&#39;) is just&lt;/p&gt;

@({
 (forall a (implies (in a X) (P a)))
})

&lt;p&gt;Our generalization basically lets you reduce a proof of @(&#39;(P-setp X)&#39;) to a
proof of @(&#39;(implies (in a X) (P a))&#39;), for an arbitrary predicate @(&#39;P&#39;).
This can be used to prove subset by just chooisng @(&#39;P&#39;) as described above,
but it can also be used for many other ideas by just changing the meaning of
@(&#39;P&#39;).  For instance, if @(&#39;P&#39;) is @(see integerp), then we can show that
@(&#39;X&#39;) is an @(&#39;integer-setp&#39;) or similar.&lt;/p&gt;

&lt;p&gt;The mechanism is just an adaptation of that described in the previous
section.&lt;/p&gt;

&lt;ul&gt;

&lt;li&gt;We begin by introducing a completely arbitrary @(&#39;predicate&#39;).&lt;/li&gt;

&lt;li&gt;Based on @(&#39;predicate&#39;), we introduce a new function, @(&#39;all&#39;), which
checks to see if every member in a set satisfies @(&#39;predicate&#39;).&lt;/li&gt;

&lt;li&gt;We set up an encapsulate which allows us to assume that some hypotheses are
true and that any member of some set satisfies @(&#39;predicate&#39;).&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;Finally, we prove @(&#39;all-by-membership&#39;), which shows that under these
assumptions, the set satisfies @(&#39;all&#39;).  This theorem can be functionally
instantiated to reduce a proof of @(&#39;(all X)&#39;) to a proof of&lt;/p&gt;

@({
  (implies (in a X) (P a))
})"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> (((predicate <a class="sym-link system" href="../../../axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="../../../axioms.html#def-_2A" data-sym="*">*</a>))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> predicate (x) x)))
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> all
    (set-for-all-reduction)
    (declare (xargs <span class="keyword">:guard</span> (setp set-for-all-reduction)))
    (if (emptyp set-for-all-reduction)
      <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
      (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (predicate (head set-for-all-reduction))
        (all (tail set-for-all-reduction)))))
  (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> (((all-hyps) =&gt; <a class="sym-link system" href="../../../axioms.html#def-_2A" data-sym="*">*</a>) ((all-set) =&gt; <a class="sym-link system" href="../../../axioms.html#def-_2A" data-sym="*">*</a>))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> all-hyps nil nil))
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> all-set nil nil))
    (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> membership-constraint
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (all-hyps)
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in arbitrary-element (all-set))
          (predicate arbitrary-element)))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> find-not
      (x)
      (declare (xargs <span class="keyword">:guard</span> (setp x)))
      (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((emptyp x) nil)
        ((<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (predicate (head x))) (head x))
        (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> (find-not (tail x))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lemma-find-not-is-a-witness
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (all x))
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (in (find-not x) x)
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (predicate (find-not x)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> all-by-membership
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (all-hyps) (all (all-set)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:use</span> (<span class="keyword">:instance</span> membership-constraint
         (arbitrary-element (find-not (all-set))))))))</pre>
  </div>

<div class="form-block other" id="form-10" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection pick-a-point-subset-strategy
  <span class="keyword">:parents</span> (std/osets)
  <span class="keyword">:short</span> <span class="string">"Automatic pick-a-point proofs of @(see subset)."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The rewrite rule @(&#39;pick-a-point-subset-strategy&#39;) tries to
automatically reduce proof goals such as:&lt;/p&gt;

@({
 (implies hyps
          (subset X Y))
})

&lt;p&gt;To proofs of:&lt;/p&gt;

@({
 (implies (and hyps (in a X))
          (in a Y))
})

&lt;p&gt;The mechanism for doing this is somewhat elaborate: the rewrite rule
replaces the @(&#39;(subset X Y)&#39;) with @(&#39;(subset-trigger X Y)&#39;).  This trigger is
recognized by a computed hint, which then suggests proving the theorem via
functional instantiation of @(see all-by-membership).&lt;/p&gt;

&lt;p&gt;The pick-a-point method is often a good way to prove subset relations.  On
the other hand, this rule is very heavy-handed, and you may need to disable it
if you do not want to use the pick-a-point method to solve your goal.&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> subset-trigger
    (x y)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))))
    (subset x y))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> pick-a-point-subset-strategy
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (rewriting-goal-lit mfc state))
        (<a class="sym-link system" href="../../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (rewriting-conc-lit `(subset$inline ,SET::X ,SET::Y)
            mfc
            state)))
      (equal (subset x y)
        (subset-trigger x y))))
  (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable subset-trigger))
  (automate-instantiation <span class="keyword">:new-hint-name</span> pick-a-point-subset-hint
    <span class="keyword">:generic-theorem</span> all-by-membership
    <span class="keyword">:generic-predicate</span> predicate
    <span class="keyword">:generic-hyps</span> all-hyps
    <span class="keyword">:generic-collection</span> all-set
    <span class="keyword">:generic-collection-predicate</span> all
    <span class="keyword">:actual-collection-predicate</span> subset
    <span class="keyword">:actual-trigger</span> subset-trigger
    <span class="keyword">:predicate-rewrite</span> (((predicate ?x ?y) (in ?x ?y)))
    <span class="keyword">:tagging-theorem</span> pick-a-point-subset-strategy)
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> pick-a-point-subset-constraint-helper
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> (equal set-for-all-reduction
          'set-for-all-reduction))
      (equal (subset set-for-all-reduction rhs)
        (<a class="sym-link system" href="../../../axioms.html#def-cond" data-sym="COND">cond</a> ((emptyp set-for-all-reduction) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)
          ((in (head set-for-all-reduction) rhs) (subset (tail set-for-all-reduction)
              rhs))
          (<a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a> nil))))))</pre>
  </div>

<div class="form-block other" id="form-11" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection subset-theorems
  <span class="keyword">:extension</span> subset
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-sfix-cancel-x
    (equal (subset (sfix x) y)
      (subset x y)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-sfix-cancel-y
    (equal (subset x (sfix y))
      (subset x y)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> emptyp-subset
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (emptyp x)
      (subset x y)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> emptyp-subset-2
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (emptyp y)
      (equal (subset x y) (emptyp x))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-in
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y) (in a x))
        (in a y))
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (in a x) (subset x y))
        (in a y))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-in-2
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a y)))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x)))
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a y))
          (subset x y))
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a x)))))
  (<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
    (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> l0
        (equal (subset (insert a nil) y)
          (in a y))
        <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> primitive-rules))))))
    (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-insert-x
      (equal (subset (insert a x) y)
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y) (in a y)))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:induct</span> (insert a x)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-reflexive
    (subset x x))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-transitive
    (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y z))
        (subset x z))
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset y z)
          (subset x y))
        (subset x z))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-membership-tail
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
        (in a (tail x)))
      (in a (tail y)))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-membership-tail-2
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
        (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a (tail y))))
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (in a (tail x))))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (disable subset-membership-tail)
       <span class="keyword">:use</span> (<span class="keyword">:instance</span> subset-membership-tail))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-insert
    (subset x (insert a x)))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-tail
    (subset (tail x) x)
    <span class="keyword">:rule-classes</span> ((<span class="keyword">:rewrite</span>) (<span class="keyword">:forward-chaining</span> <span class="keyword">:trigger-terms</span> ((tail x))))))</pre>
  </div>

<div class="form-block other" id="form-12" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defsection double-containment
  <span class="keyword">:parents</span> (std/osets)
  <span class="keyword">:short</span> <span class="string">"A strategy for proving sets are equal because they are subsets
of one another."</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Double containment can be a good way to prove that two sets are
equal to one another.&lt;/p&gt;

&lt;p&gt;Unfortunately, because this rule targets @(&#39;equal&#39;) it can get quite
expensive.  You may sometimes wish to disable it to speed up your proofs, as
directed by @(see accumulated-persistence).  In fact, this rule is disabled
when importing @(&#39;[books]/std/osets/top.lisp&#39;). To reduce its cost when enabled,
this rule has a backchain limit.&lt;/p&gt;

&lt;p&gt;On the other hand, there are cases in which this rule works well, and where
the backchain limit is detrimental.  For this reason, we also provide a version
of the rule that has no backchain limit.  This version can be enabled
as needed.&lt;/p&gt;"</span>
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> double-containment-lemma-head
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y x))
        (equal (head x) (head y)))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> in-tail-expand
      (equal (in a (tail x))
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (in a x)
          (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal a (head x)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> double-containment-lemma-in-tail
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y x))
        (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (in a (tail x))
          (in a (tail y))))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable (<span class="keyword">:ruleset</span> order-rules))
         <span class="keyword">:use</span> ((<span class="keyword">:instance</span> in-tail-expand
            (a a)
            (x x)) (<span class="keyword">:instance</span> in-tail-expand
             (a a)
             (x y)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> double-containment-lemma-tail
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y x))
        (subset (tail x) (tail y)))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable double-containment-lemma-in-tail)))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> double-tail-induction
      (x y)
      (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))))
      (if (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (emptyp x) (emptyp y))
        (<a class="sym-link system" href="../../../axioms.html#def-list" data-sym="LIST">list</a> x y)
        (double-tail-induction (tail x)
          (tail y)))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> double-containment-is-equality-lemma
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (emptyp x) (emptyp y)))
          (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset (tail x) (tail y))
              (subset (tail y) (tail x)))
            (equal (equal (tail x) (tail y)) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
          (setp x)
          (setp y)
          (subset x y)
          (subset y x))
        (equal (equal x y) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable head-tail-same)
         <span class="keyword">:use</span> ((<span class="keyword">:instance</span> double-containment-lemma-tail
            (x x)
            (y y)) (<span class="keyword">:instance</span> double-containment-lemma-tail
             (x y)
             (y x))
           (<span class="keyword">:instance</span> double-containment-lemma-head
             (x x)
             (y y)))))))
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> double-containment-is-equality
      (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x)
          (setp y)
          (subset x y)
          (subset y x))
        (equal (equal x y) <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
      <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable head-tail-same)
         <span class="keyword">:induct</span> (double-tail-induction x y)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> double-containment
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
      (equal (equal x y)
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y x))))
    <span class="keyword">:rule-classes</span> ((<span class="keyword">:rewrite</span> <span class="keyword">:backchain-limit-lst</span> <span class="number">1</span>))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:use</span> (<span class="keyword">:instance</span> double-containment-is-equality))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthmd" data-sym="DEFTHMD">defthmd</a> double-containment-no-backchain-limit
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
      (equal (equal x y)
        (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (subset x y)
          (subset y x))))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:by</span> double-containment))))</pre>
  </div>

<div class="form-block other" id="form-13" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable head-minimal head-minimal-2))</pre>
  </div>

<div class="form-block other" id="form-14" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> nil
  (<a class="sym-link system" href="../../../axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (enable (<span class="keyword">:ruleset</span> primitive-rules)
        (<span class="keyword">:ruleset</span> order-rules))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> setp-of-cons
    (equal (setp (cons a x))
      (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x)
        (<a class="sym-link system" href="../../../axioms.html#def-or" data-sym="OR">or</a> (&lt;&lt; a (head x))
          (emptyp x)))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> in-to-member
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (setp x)
      (equal (in a x)
        (if (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> a x)
          <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>
          nil))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> not-member-when-smaller
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (&lt;&lt; a (car x)) (setp x))
      (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="../../../axioms.html#def-member" data-sym="MEMBER">member</a> a x))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subset-to-subsetp
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-and" data-sym="AND">and</a> (setp x) (setp y))
      (equal (subset x y) (<a class="sym-link system" href="../../../axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> x y))))
  (<a class="sym-link system" href="../../../axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> lexorder-&lt;&lt;-equiv
    (<a class="sym-link system" href="../../../axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="../../../axioms.html#def-not" data-sym="NOT">not</a> (equal a b))
      (equal (equal (&lt;&lt; a b)
          (<a class="sym-link system" href="../../../axioms.html#def-lexorder" data-sym="LEXORDER">lexorder</a> a b))
        <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>))
    <span class="keyword">:hints</span> ((<span class="string">"Goal"</span> <span class="keyword">:in-theory</span> (enable &lt;&lt;)))))</pre>
  </div>

<div class="form-block other" id="form-15" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(def-ruleset low-level-rules
  '(setp-of-cons in-to-member
    not-member-when-smaller
    subset-to-subsetp
    lexorder-&lt;&lt;-equiv
    (<span class="keyword">:ruleset</span> primitive-rules)
    (<span class="keyword">:ruleset</span> order-rules)))</pre>
  </div>

<div class="form-block other" id="form-16" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-theory" data-sym="IN-THEORY">in-theory</a> (disable (<span class="keyword">:ruleset</span> low-level-rules)))</pre>
  </div>

<div class="form-block function" id="def-fast-measure" data-defines="FAST-MEASURE" data-references="ACL2-COUNT,+,Y,X,DEFUN" data-part-name="FAST-MEASURE" data-part-args="Y,X" data-part-body="Y,X,ACL2-COUNT,+" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FAST-MEASURE">fast-measure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fast-measure" data-sym="FAST-MEASURE" title="(defun set::fast-measure (set::x set::y)
  (+ (set::acl2-count set::x) (set::acl2-count set::y)))">fast-measure</a>
  (x y)
  (<a class="sym-link system" href="../../../axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x) (<a class="sym-link system" href="../../../axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> y)))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>