<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>developers-guide - ACL2 Book</title>
  <meta property="name" content="developers-guide">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">developers-guide</h1>
    <div class="path"><a href="developers-guide.lisp" class="source-link">books/system/doc/developers-guide</a></div>
  </div>
  
  <main property="text">
  <div class="includes-section">
    <h2>Included Books</h2>
    <div class="includes-list">
      <a class="include-link" href="../../xdoc/top.html" title="xdoc/top">top</a>
    </div>
  </div>

<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block include-book" id="form-1" typeof="Code">
    <div class="form-header"><span class="form-type">include-book</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="../../../axioms.html#def-include-book" data-sym="INCLUDE-BOOK">include-book</a> <a class="include-path" href="../../../xdoc/top.html" title="Open xdoc/top">"xdoc/top"</a> <span class="keyword">:dir</span> <span class="keyword">:system</span>)</pre>
  </div>

<div class="form-block other" id="form-2" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide
  <span class="keyword">:parents</span> (programming)
  <span class="keyword">:short</span> <span class="string">"Guide for ACL2 developers"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This guide is &lt;b&gt;NOT&lt;/b&gt; intended for the full ACL2 user community.
 Rather, it is intended for &lt;i&gt;experienced&lt;/i&gt; ACL2 users who may wish to
 become ACL2 &lt;i&gt;developers&lt;/i&gt;, that is, to contribute to the maintenance and
 enhancement of the ACL2 source code.  Don&#39;t waste your time here unless you&#39;re
 an ACL2 developer, or intending to become one!&lt;/p&gt;

 &lt;p&gt;ACL2 is maintained solely by Matt Kaufmann and J Moore, although for some
 time they have occasionally vetted code written by others, ultimately
 incorporating it into the system.  Although this is anticipated to remain the
 case for some time, a process is underway towards gradually turning
 maintenance over to some other small group of trusted, reliable, responsible
 people.  This guide was motivated by the desire to begin to support the
 eventual development of such a group.&lt;/p&gt;

 &lt;p&gt;(Of course, given the permissive license of ACL2, anyone is allowed to
 modify a copy of its source code.  Here we are talking about what is generally
 called ``ACL2&#39;&#39;, which is distributed from github and from the University of
 Texas at Austin.)&lt;/p&gt;

 &lt;p&gt;The first step towards contributing to ACL2 development is to join the
 @(&#39;acl2-devel&#39;) mailing list by &lt;a
 href=&#39;mailto:kaufmann@cs.utexas.edu&#39;&gt;emailing Matt Kaufmann&lt;/a&gt; with a request
 to be added.&lt;/p&gt;

 &lt;p&gt;The website for the (first) Developer&#39;s Workshop has quite a bit of useful
 information.  It is at: &lt;code&gt;&lt;a
 href=&#39;http://www.cs.utexas.edu/users/moore/acl2/workshop-devel-2017/&#39;&gt;http://www.cs.utexas.edu/users/moore/acl2/workshop-devel-2017/&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

 &lt;p&gt;Note that for the second Developer&#39;s Workshop, some colors were added to
 this Guide to help guide the discussion.  (Colors show up in the web version
 but not in the @(see acl2-doc) browser.)  This &lt;color rgb=&#39;#c00000&#39;&gt;red
 color&lt;/color&gt; highlights passages that were to be given some emphasis.  Also,
 in some cases there is a note of the following form, for use in the
 workshop:&lt;/p&gt;

 &lt;p&gt;Prospective ACL2 developers are advised to read the paper, &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-2009/final/10/10.pdf&#39;&gt;&amp;ldquo;Abbreviated
 Output for Input in ACL2&amp;rdquo;&lt;/a&gt;, which has a lot of discussion about ACL2
 development.&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;&lt;p&gt;[...SOME NOTES FOR THE WORKSHOP...]&lt;/p&gt;&lt;/color&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;For a small list of potential ACL2 development tasks, see community books
 file &lt;a
 href=&#39;https://github.com/acl2/acl2/blob/master/books/system/to-do.txt&#39;&gt;@(&#39;books/system/to-do.txt&#39;)&lt;/a&gt;.
 If you decide to work on one of these tasks, please make a note (just below
 the one-line header at the top of the tasks&#39;s item) saying that you are doing
 so.  Before you start, ask Matt Kaufmann to commit to incorporating your
 changes; without a commitment from Matt, he reserves the right not to consider
 doing so.&lt;/p&gt; &lt;/color&gt;

 &lt;p&gt;The subtopics listed below are sometimes referred to as ``chapters&#39;&#39; of
 this (Developer&#39;s) Guide.  They can be read in any order, but on a first read,
 you may find it helpful to read them in the order in which they appear
 below.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-introduction)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-introduction
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Introduction"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This &lt;see topic=&#39;@(url developers-guide)&#39;&gt;Developer&#39;s Guide&lt;/see&gt;
 is intended to provide an overview of how to maintain the ACL2 source
 code.&lt;/p&gt;

 &lt;p&gt;There are several points we want to make at the outset.&lt;/p&gt;

 &lt;h3&gt;Experienced users only, please&lt;/h3&gt;

 &lt;p&gt;Without a sense of how to use ACL2, there is significant risk that an
 attempt to modify its source code could be truly misguided.&lt;/p&gt;

 &lt;h3&gt;This guide is highly incomplete!&lt;/h3&gt;

 &lt;p&gt;There are at least the following reasons for its incompleteness.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;Comments in the source code may already suffice for a given topic.&lt;/li&gt;

 &lt;li&gt;The source code is large and complex; this guide is, ideally,
 manageable.&lt;/li&gt;

 &lt;li&gt;At the time this manual is being created, many aspects of the system are
 difficult to explain because the writers have forgotten them &amp;mdash; and
 that&#39;s OK!

 &lt;ul&gt;&lt;li&gt;It is typical to read comments (which are sometimes extensive) when
 modifying the source code, often after reading some user-level documentation,
 to get up to speed.  As we encounter comments that aren&#39;t clear (and correct),
 we fix them.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;

 &lt;/ul&gt;

 &lt;h3&gt;Where do the definitive sources reside?&lt;/h3&gt;

 &lt;p&gt;The ACL2 source code resides on the filesystem of the Computer Science
 Department at the University of Texas.  These files are kept in sync with the
 github sources, of course.  So unless something goes horribly wrong with
 github, the sources may reasonably be said also to reside at &lt;code&gt;&lt;a
 href=&#39;https://github.com/acl2/acl2&#39;&gt;https://github.com/acl2/acl2&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

 &lt;h3&gt;Some longer source code comments are called ``Essays&#39;&#39;.&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;&lt;p&gt;[JUST TOUCH ON THIS SECTION]&lt;/p&gt;&lt;/color&gt;

 &lt;p&gt;These essays can provide very helpful introductions, at a higher level than
 may be found in Lisp comments that are inside definitions.  You can search for
 the string&lt;/p&gt;

 @({
 ; Essay on ...
 })

 &lt;p&gt;by using, for example, @(&#39;grep&#39;) or the Emacs utility @(&#39;meta-x
 tags-search&#39;).  For example, suppose you are trying to understand @(tsee
 make-event).  Then a first step might be to review its user-level
 documentation (for @(see make-event) and its subtopics); but after that, you
 could search with @(&#39;grep&#39;), or with a tags-search, for the following
 string.&lt;/p&gt;

 @({
 ; Essay on make-event
 })

 &lt;p&gt;If your search is case-insensitive, then you will find ``; Essay on
 Make-event&#39;&#39;.  Such an essay is not necessarily complete, or even close to
 being complete, but it is a good starting point before modifying source code
 that supports @(&#39;make-event&#39;).&lt;/p&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;As of this writing there are nearly 100 such essays!  This manual does not
 begin to cover them all; in fact it barely touches on most of them, at best.
 Moreover, some important components of ACL2 have no high-level essay.&lt;/p&gt;
 &lt;/color&gt;

 &lt;ul&gt;&lt;li&gt;For example, there is no essay on induction.  In such cases the
 relevant source comments are generally found inside definitions.  For example,
 in the case of induction one can start with the function, @(&#39;induct&#39;), and
 read its comments and code to start exploring the rather complex ACL2
 implementation of induction.&lt;/li&gt;&lt;/ul&gt;

 &lt;h3&gt;Some initiative and hacking are necessary.&lt;/h3&gt;

 &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;.  Suppose you encounter the @(&#39;pspv&#39;) argument in the
 source function @(&#39;simplify-clause&#39;), and you don&#39;t know what that is.  You
 can then search for @(&#39;pspv&#39;) and you&#39;ll find the following: @(&#39;(access
 prove-spec-var pspv :rewrite-constant)&#39;).  Now @(&#39;access&#39;) is a basic
 record-accessing utility that we do cover in this manual; and we&#39;ll also talk
 about the use of Emacs to find definitions.  So you&#39;ll know to use the Emacs
 command, @(&#39;meta-.&#39;) , to take you to the definition of the record structure,
 @(&#39;prove-spec-var&#39;).  There, you&#39;ll find a few comments that explain this
 structure; unfortunately, however, not many.  The field names can provide a
 clue.  One of the fields is @(&#39;rewrite-constant&#39;), so if you&#39;re exploring the
 @(&#39;pspv&#39;) because of its effect on rewriting, you can guess that this field is
 relevant.  So let&#39;s say that you want to know about the @(&#39;rewrite-constant&#39;)
 field.  Using @(&#39;meta-.&#39;) once again, you can find the @(&#39;rewrite-constant&#39;)
 record structure definition; and this time there are many comments.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;.  What is the flow of the ACL2 waterfall?  By using the
 Emacs command, @(&#39;meta-.&#39;) , we can develop this call graph.&lt;/p&gt;

 @({
      waterfall
        waterfall1-lst
          waterfall1
            waterfall0
            waterfall0-with-hint-settings
              waterfall0
                waterfall-step
 })

 &lt;h3&gt;User-level documentation vs. system-level documentation&lt;/h3&gt;

 &lt;p&gt;User-level documentation is in community book
 @(&#39;books/system/doc/acl2-doc.lisp&#39;) and appears in the acl2+books combined
 manual and the ACL2 User&#39;s Manual.  (This Guide is an exception, of course; it
 is included in the acl2-books combined manual but it is at the system level,
 not at the user level.)  See @(see developers-guide-build) for how that
 documentation is integrated into ACL2 builds.&lt;/p&gt;

 &lt;p&gt;By contrast, system-level documentation is in Lisp comments found in the
 ACL2 sources and in this Guide.  Those comments are geared towards
 implementors; so while they are written with care, they sometimes assume
 implementation-level background.  For example, the word ``primitive&#39;&#39; is
 sometimes used for any built-in function, while other times it might suggest
 the more limited notion implemented by the constant
 @(&#39;*primitive-formals-and-guards*&#39;); the context may help in understanding the
 intended meaning (though perhaps, eventually, someone will use ``built-in&#39;&#39;
 for all uses of the broader notion).  Sometimes an Essay (see above) may
 provide helpful background; indeed, comments sometimes direct the reader to an
 Essay.&lt;/p&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;Please read the comments in a definition carefully before you modify it!
 In particular, there are often comments warning you to ``keep in sync&#39;&#39; with
 one or more other definitions, which need to be heeded.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;It is often helpful to read user-level documentation before reading
 system-level documentation when preparing to modify ACL2.  Often the
 user-level documentation will be on specific topics, such as @(tsee
 make-event) as described above.  But user-level documentation may also provide
 general background; in particular, the topic @(see programming-with-state) is
 highly recommended for anyone who is considering doing system development.
 However, for most ACL2 system-level documentation, it is best to put it in the
 ACL2 sources as Lisp comments or in this Guide, rather than elsewhere in the
 documentation, to avoid confusing or intimidating typical users.&lt;/p&gt;

 &lt;p&gt;The topic @(tsee system-utilities) is a borderline case.  These utilities
 were created for developing the ACL2 system.  However, users increasingly do
 ``systems programming&#39;&#39; in ACL2; so, this topic collects some system-level
 utilities that may benefit such users.&lt;/p&gt;

 &lt;h3&gt;This is a living document.&lt;/h3&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;Feel free to modify this guide!  You can, if you like, run modifications by
 the acl2-devel mailing list before making changes.&lt;/p&gt;
 &lt;/color&gt;

 &lt;h3&gt;Do not feel obligated to read this guide linearly, cover-to-cover!&lt;/h3&gt;

 &lt;p&gt;Exploration of the ACL2 system is perhaps most efficient when
 goal-directed, i.e., when you are trying to understand specific aspects of the
 system.  That said, a quick browse of this entire guide is recommended for
 ACL2 system developers.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-emacs)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-4" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-emacs
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Emacs As a Critical Tool for ACL2 Developers"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Emacs has traditionally been used by ACL2 system developers.  In
 principle, any text editor would suffice.  But as of this writing, we don&#39;t
 know how to maintain ACL2 effectively without using Emacs.  It is not the goal
 here to give an Emacs tutorial; but here are some Emacs utilities that are
 particularly useful to ACL2 developers.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;@(&#39;meta-.&#39;)&lt;br/&gt;Move to the indicated definition in the ACL2 sources (must
 initialize with @(&#39;meta-x visit-tags-table&#39;)).  This is much faster than
 bringing up the file in an editor and searching for the definition.  Use a
 prefix argument to find the next match if desired.&lt;/li&gt;

 &lt;li&gt;@(&#39;meta-x tags-apropos&#39;)&lt;br/&gt;Bring up all symbols whose definition matches
 the given regular expression.  One can find a suitable such symbol and use
 @(&#39;meta-.&#39;) to go rapidly to its definition.&lt;/li&gt;

 &lt;li&gt;@(&#39;meta-x tags-search&#39;)&lt;br/&gt;Find an occurrence of a given regular
 expression, using @(&#39;meta-,&#39;) to find subsequent occurrences.&lt;/li&gt;

 &lt;li&gt;@(&#39;meta-x tags-query-replace&#39;)&lt;br/&gt;Replace occurrences of a given regular
 expression with a given string, with a query each time, using @(&#39;meta-,&#39;) to
 find subsequent occurrences.&lt;/li&gt;

 &lt;li&gt;@(&#39;meta-x compare-windows&#39;)&lt;br/&gt;After splitting the window in two
 (say, with @(&#39;control-x 2&#39;)), compare the upper window with the lower.  This
 is particularly useful when comparing two versions of some source code, for
 example, the original version and a modified version.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;The file @(&#39;emacs/emacs-acl2.el&#39;) has many helpful utilities, so you may
 want to load it in your @(&#39;~/.emacs&#39;) file.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;For example, it defines @(&#39;ctl-t w&#39;) as a shortcut for @(&#39;meta-x
 compare-windows&#39;), and it defines @(&#39;ctl-t q&#39;) to do the same thing but
 ignoring whitespace (by providing a prefix argument for @(&#39;meta-x
 compare-windows&#39;)).&lt;/li&gt;

 &lt;li&gt;&lt;color rgb=&#39;#c00000&#39;&gt;Maintain @(&#39;emacs/emacs-acl2.el&#39;) with taste: avoid using fancy Emacs Lisp
 code that could be difficult for others to maintain.&lt;/color&gt;  If one is competent at
 maintaining the ACL2 sources base, then a little Emacs Lisp competence should
 be sufficient for maintaining @(&#39;emacs/emacs-acl2.el&#39;) as well.  So avoid
 fancy Emacs features not already found in use in that file.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-background)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-5" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-background
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Some Implementation Background"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;When background is found to be lacking in this topic, it might be acquired
 by querying the acl2-devel mailing list.  In that case it would probably be
 good to extend this chapter by adding the background that had been
 lacking.&lt;/p&gt;
 &lt;/color&gt;

 &lt;h3&gt;Source files&lt;/h3&gt;

 &lt;p&gt;ACL2 has many source files.  &lt;color rgb=&#39;#c00000&#39;&gt;The definitive list of
 source files is the value of the constant @(&#39;*acl2-files*&#39;) found in source
 file @(&#39;acl2.lisp&#39;).&lt;/color&gt; This list is consistent with the list associated
 with the variable @(&#39;&quot;sources&quot;&#39;) in @(&#39;GNUmakefile&#39;), with the exception of
 generated file @(&#39;doc.lisp&#39;) (which is discussed later in this Guide; see
 @(see developers-guide-build)).  Perhaps surprisingly, @(&#39;acl2.lisp&#39;) is not
 in either list!  That&#39;s due to a traditional ambiguity in the use of the term
 ``source file&#39;&#39; for ACL2.  The files in the list @(&#39;*acl2-files*&#39;) are all
 written in ACL2 (with the exception of relatively little raw Lisp code, as
 discussed in the section on ``Readtime Conditionals&#39;&#39; below).  A few other
 files support the infrastructure surrounding the ACL2 system.  These may be
 found in the definition of variable @(&#39;&quot;sources_extra&quot;&#39;) in
 @(&#39;GNUmakefile&#39;); @(&#39;acl2.lisp&#39;) is one of those files.&lt;/p&gt;

 &lt;p&gt;We may talk of ``earlier&#39;&#39; and ``later&#39;&#39; source files.  Here we reference
 their order in @(&#39;*acl2-files*&#39;), which is essentially the order in which they
 are processed via @(tsee ld) when building an ACL2 executable.  Note however
 that files @(&#39;*-raw.lisp&#39;) are not intended for processing by @(tsee ld)
 during the build, but rather, are simply loaded directly into Common Lisp,
 perhaps after being compiled.&lt;/p&gt;

 &lt;p&gt;&lt;color rgb=&#39;#c00000&#39;&gt;The names of the source files are somewhat suggestive
 of their contents.  However, over time this correspondence has weakened, in
 large part because of the requirement that a function must be defined before
 it is used.&lt;/color&gt; For example, function @(&#39;find-rules-of-rune&#39;) was moved in
 git commit @(&#39;5647bd402e&#39;) from @(&#39;defthm.lisp&#39;) to an earlier file,
 @(&#39;rewrite.lisp&#39;), in support of a new function,
 @(&#39;backchain-limit-enforcers&#39;), which in turn was introduced in support of an
 existing function in @(&#39;rewrite.lisp&#39;)
 (@(&#39;tilde-@-failure-reason-phrase1&#39;)) that reports failures in the @(see
 break-rewrite) loop.&lt;/p&gt;

 &lt;h3&gt;Source file &lt;tt&gt;axioms.lisp&lt;/tt&gt;&lt;/h3&gt;

 &lt;p&gt;The source file @(&#39;axioms.lisp&#39;) is the place for defining most @(see
 logic)-mode functions that form the core of the ACL2 programming language, and
 also for some basic axioms and theorems about these functions as well as the
 built-in primitives like @(see car) and @(see unary-/) that have no explicit
 definition.  The theorems are stated as @(tsee defthm) @(see events), while
 the axioms are stated as @(tsee defaxiom) events.  The axioms are intended to
 completely specify the @(see ground-zero) theory.  However, it is less clear
 when to include a @(&#39;defthm&#39;) event into @(&#39;axioms.lisp&#39;), rather than simply
 putting that theorem into a book.&lt;/p&gt;

 &lt;p&gt;The section on ``Build-time proofs&#39;&#39; in the topic, @(see
 developers-guide-build), has a discussion of executing ``@(&#39;make proofs&#39;)&#39;&#39; to
 admit events, including those in @(&#39;axioms.lisp&#39;).  Some @(&#39;defthm&#39;) events
 are critical for this purpose, for example, for proving termination or
 verifying guards.  Others are simply very basic: so useful that it seems a
 pity to relegate them to books, rather than to include them in the build.
 Moreover, the specific form of some axioms and theorems is chosen to be useful
 for reasoning; for example, here is a rather critical @(&#39;:&#39;)@(tsee elim) rule
 in addition to being an important axiom.&lt;/p&gt;

 @({
 (defaxiom car-cdr-elim
   (implies (consp x)
            (equal (cons (car x) (cdr x)) x))
   :rule-classes :elim)
 })

 &lt;p&gt;It is good to be careful when considering the addition of @(&#39;defthm&#39;)
 events to @(&#39;axioms.lisp&#39;).  If @(&#39;defthm&#39;) events are to be added in order to
 support termination or @(see guard) verification when doing ``@(&#39;make
 proofs&#39;)&#39;&#39;, you can consider making the events @(tsee local) so that they
 don&#39;t make it into the build.  But you might leave some non-local if they seem
 to be extremely useful, for example:&lt;/p&gt;

 @({
 (defthm fold-consts-in-+
   (implies (and (syntaxp (quotep x))
                 (syntaxp (quotep y)))
            (equal (+ x (+ y z))
                   (+ (+ x y) z))))
 })

 &lt;p&gt;There is potential controversy here.  One could argue that such theorems
 belong in books, not in the source code.  This can be argued either way:
 putting in the source code is good because ACL2 can do obviously-expected
 things at start-up, and is bad because it&#39;s inelegant and narrows user
 choices.  These days, we tend to add @(&#39;defthm&#39;) events to @(&#39;axioms.lisp&#39;)
 only sparingly, without removing any.  One could argue endlessly about this
 controversy, but there are probably many more fruitful ways to spend limited
 development resources!&lt;/p&gt;

 &lt;h3&gt;The ACL2 state and logical world&lt;/h3&gt;

 &lt;p&gt;&lt;color rgb=&#39;#c00000&#39;&gt;The ACL2 state is represented in the implementation as
 a symbol, which is the value of constant @(&#39;*the-live-state*&#39;).&lt;/color&gt;
 Sometimes we call this the ``&lt;color rgb=&#39;#c00000&#39;&gt;live state&lt;/color&gt;&#39;&#39;, to
 distinguish it from its logical value, which is a list of fields.  See @(see
 state) for relevant background.&lt;/p&gt;

 &lt;p&gt;&lt;color rgb=&#39;#c00000&#39;&gt;It may seem impossible for a fixed symbol to represent
 a changeable state.  But let us consider for example what happens when we
 update a state global variable (see @(see f-put-global)) in raw Lisp.&lt;/color&gt;
 In the following example (where we elide code for the case of wormholes) there
 are two cases.  The interesting case is the first one, in which the state is
 the live state.  We see below that there is an associated global (special)
 variable, in a package obtained by prefixing the string @(&#39;&quot;ACL2_GLOBAL_&quot;&#39;)
 to the front of the symbol&#39;s package-name: &lt;tt&gt;&lt;color
 rgb=&#39;#c00000&#39;&gt;ACL2_GLOBAL_&lt;/color&gt;ACL2::XYZ&lt;/tt&gt;.  The code below updates that
 global.&lt;/p&gt;

 @({
 ? (pprint (macroexpand &#39;(f-put-global &#39;xyz (+ 3 4) state)))

 (LET ((#:G128770 (+ 3 4)) (#:G128771 STATE))
   (COND ((LIVE-STATE-P #:G128771)
          (COND (*WORMHOLEP* ...))
          (LET ()
            (DECLARE (SPECIAL ACL2_GLOBAL_ACL2::XYZ))
            (SETQ ACL2_GLOBAL_ACL2::XYZ #:G128770)
            #:G128771))
         (T (PUT-GLOBAL &#39;XYZ #:G128770 #:G128771))))
 ?
 })

 &lt;p&gt;To read a state global from the live state, we simply read its associated
 global variable.&lt;/p&gt;

 @({
 ? (pprint (macroexpand &#39;(f-get-global &#39;xyz state)))

 (LET ((#:G128772 STATE))
   (DECLARE (SPECIAL ACL2_GLOBAL_ACL2::XYZ))
   (COND ((LIVE-STATE-P #:G128772) ACL2_GLOBAL_ACL2::XYZ)
         (T (GET-GLOBAL &#39;XYZ #:G128772))))
 ?
 })

 &lt;p&gt;Note that the ACL2 state can be viewed as a special, built-in case of a
 @(see stobj).  Indeed, we may also speak of ``&lt;color rgb=&#39;#c00000&#39;&gt;live
 stobjs&lt;/color&gt;&#39;&#39;, to distinguish them from their logical, list-based
 representations, and a stobj, @(&#39;st&#39;), is represented in the implementation as
 @(&#39;*the-live-st*&#39;).  These ``live&#39;&#39; constants are illustrated below.&lt;/p&gt;

 @({
 ACL2 !&gt;(defstobj st fld)

 Summary
 Form:  ( DEFSTOBJ ST ...)
 Rules: NIL
 Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
  ST
 ACL2 !&gt;:q

 Exiting the ACL2 read-eval-print loop.  To re-enter, execute (LP).
 ? *the-live-st*
 #&lt;SIMPLE-VECTOR 1&gt;
 ? *the-live-state*
 ACL2_INVISIBLE::|The Live State Itself|
 ?
 })

 &lt;p&gt;One of the logical fields of the state is the &lt;i&gt;global-table&lt;/i&gt;, which is
 an association list mapping symbols, namely state global variables (sometimes
 called ``state globals&#39;&#39;), to values.  See also @(see programming-with-state).
 One particular state global, the symbol @(&#39;current-acl2-world&#39;), is mapped to
 the current logical @(see world), often just called ``the world&#39;&#39;.  Here is
 the logical definition of the function @(&#39;(w state)&#39;) that returns this world;
 note that it calls the macro @(tsee f-get-global), which, as explained above,
 generates a read of a Lisp global.&lt;/p&gt;

 @(def w)

 &lt;p&gt;The current logical world, in turn, is a list of triples of the form
 @(&#39;(name property . value)&#39;).  The function @(tsee getprop) may be used to
 access the value for a given name and property.  For example, suppose that we
 submit the event @(&#39;(defun f (x) (cons x x))&#39;).  This actually pushes several
 triples on the world, one of which is the so-called &lt;i&gt;unnormalized body&lt;/i&gt;
 of @(&#39;f&#39;), accessible via @(&#39;getprop&#39;) as follows.&lt;/p&gt;

 @({
 ACL2 !&gt;(getprop &#39;f &#39;unnormalized-body nil &#39;current-acl2-world (w state))
 (CONS X X)
 ACL2 !&gt;
 })

 &lt;p&gt;It is extremely common for the last three arguments of @(&#39;getprop&#39;) to be
 as displayed above, so the macro @(tsee getpropc) is often used instead.&lt;/p&gt;

 @({
 ACL2 !&gt;(getpropc &#39;f &#39;unnormalized-body)
 (CONS X X)
 ACL2 !&gt;
 })

 &lt;p&gt;Also see @(see walkabout) for a tool that can be extremely helpful for
 examining the world.&lt;/p&gt;

 &lt;h3&gt;Terms, translate, and untranslate&lt;/h3&gt;

 &lt;p&gt;For relevant background on the notion of &lt;i&gt;term&lt;/i&gt; in ACL2, see @(see
 term).  The ACL2 source code traffics in what that documentation topic calls
 ``translated terms&#39;&#39;.  In any discussion at the implementation level,
 including this guide and source code comments, &lt;color rgb=&#39;#c00000&#39;&gt;we just
 say ``term&#39;&#39; to refer to a translated term.  The source code traffics almost
 entirely in terms,&lt;/color&gt; though user input is in the form of what the
 documentation for @(see term) calls an ``untranslated term&#39;&#39;.  &lt;color
 rgb=&#39;#c00000&#39;&gt;The ACL2 functions @(tsee translate) and @(tsee untranslate) map
 from untranslated terms to terms and vice-versa, respectively.&lt;/color&gt; These
 both take the @(see world) as a formal parameter, because they need to consult
 the world: for example, @(&#39;translate&#39;) consults the world to determine, for a
 call @(&#39;(f t1 t2 ...)&#39;), whether @(&#39;f&#39;) is a function symbol, a macro, or (in
 the error case) neither of these; and @(&#39;untranslate&#39;) consults the world for
 more subtle reasons such as converting a call of @(tsee return-last) to
 something more readable.&lt;/p&gt;

 &lt;p&gt;The definition of the function @(&#39;untranslate1&#39;), which is the workhorse
 for @(&#39;untranslate&#39;), is instructive for how ACL2 processes terms.  &lt;color
 rgb=&#39;#c00000&#39;&gt;It has the following form.&lt;/color&gt;&lt;/p&gt;

 @({
 (defun untranslate1 (term iff-flg untrans-tbl preprocess-fn wrld)
   (let ((term (if preprocess-fn ... term)))
     (cond ((variablep term) term)
           ((fquotep term)
            (cond (&lt;basically, not a cons or symbol&gt;
                   (cadr term))
                  (t term)))
           ((flambda-applicationp term)
            &lt;Turn the lambda application into a LET.&gt;)
           ((eq (ffn-symb term) &#39;if)
            &lt;Many special cases, e.g.,
             (if x1 &#39;nil &#39;t) negates untranslation of x1&gt;
           ...))))
 })

 &lt;color rgb=&#39;#c00000&#39;&gt;

 &lt;p&gt;This sort of structure is typical: handle the variable case, then the case
 of @(&#39;(quote _)&#39;), then the case of a lambda application, and finally one or
 more cases for the call of a function symbol.  If you peruse the source code
 you will see handy term utilities.  Please strive for consistency by studying
 some of those (e.g., search the source code for @(&#39;&quot;variablep&quot;&#39;) or
 @(&#39;&quot;quotep&quot;&#39;)).  For example, don&#39;t build a new term with @(&#39;(cons fn
 args)&#39;); use &lt;tt&gt;cons-term&lt;/tt&gt; or &lt;tt&gt;fcons-term&lt;/tt&gt; instead of
 &lt;tt&gt;cons&lt;/tt&gt;.&lt;/p&gt;

 &lt;/color&gt;

 &lt;h3&gt;The @(tsee defrec) macro&lt;/h3&gt;

 &lt;p&gt;We defer to a later chapter (see @(see developers-guide-utilities)) a
 discussion of macros that are commonly used in the ACL2 implementation, with
 one exception: @(tsee defrec).  We cover that macro here because it is so
 crucial for understanding some topics covered below.&lt;/p&gt;

 &lt;p&gt;See @(see defrec) for user-level documentation on @(&#39;defrec&#39;).  This macro
 provides a cheap way to lay out a record structure using @(&#39;cons&#39;) (since the
 Common Lisp macro @(&#39;defstruct&#39;) is not supported by ACL2, which does not have
 structures).  Sometimes it is worthwhile to think a bit about expected reads
 and writes of the fields, to help lay them out efficiently.  For example,
 consider the definition of an important record for the prover,
 @(&#39;prove-spec-var&#39;) (with comments omitted here):&lt;/p&gt;

 @({
 (defrec prove-spec-var
   ((rewrite-constant induction-hyp-terms . induction-concl-terms)
    (tag-tree hint-settings . tau-completion-alist)
    (pool . gag-state)
    user-supplied-term displayed-goal orig-hints . otf-flg)
   t)
 })

 &lt;p&gt;Notice above and in the following generated definition that the field,
 @(&#39;orig-hints&#39;), is buried deep inside this structure.&lt;/p&gt;

 @({
 ACL2 !&gt;:trans (access prove-spec-var some-pspv :orig-hints)

 ((LAMBDA (ORIG-HINTS)
          (CAR (CDR (CDR (CDR (CDR (CDR ORIG-HINTS)))))))
  SOME-PSPV)

 =&gt; *

 ACL2 !&gt;
 })

 &lt;p&gt;An Emacs @(&#39;tags-search&#39;) for ``@(&#39;:orig-hints&#39;)&#39;&#39; shows that this field is
 used only during initialization of the prover (excluding ACL2(p)), not within
 the waterfall, let alone the rewriter; of course, this is hardly surprising.
 So it seems fine to push this field way back in the record definition.  On the
 other hand, the @(&#39;rewrite-constant&#39;) field is more rapidly accessible as the
 @(tsee caar), which is reasonable since it is accessed quite frequently within
 the waterfall.&lt;/p&gt;

 &lt;p&gt;One can often learn about a record by reading its field names, seeing how
 they are used in the source code (with a tags-search), or reading code
 comments inserted into the @(&#39;defrec&#39;) form that defines it or near that
 definition.  You could try learning more now about the @(&#39;prove-spec-var&#39;) and
 @(&#39;rewrite-constant&#39;), which are quite important in the prover code.&lt;/p&gt;

 &lt;h3&gt;Commands and events&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;DEMO: USING WALKABOUT TO EXPLORE THE WORLD&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;Among the triples in the @(see world) are so-called &lt;i&gt;command
 landmarks&lt;/i&gt; and &lt;i&gt;event landmarks&lt;/i&gt;, which are put there at the
 conclusion of a @(see command) or @(see event), respectively.  What are
 commands and events, and what&#39;s the difference between them?&lt;/p&gt;

 &lt;p&gt;Let&#39;s start with commands.  The (user-level) documentation for @(see
 command)s says that they are ``forms you type at the top-level, but the word
 `command&#39; usually refers to a top-level form whose evaluation produces a new
 logical @(see world).&#39;&#39;  At the implementation level, a command is a form read
 and evaluated by @(see ld).  If you follow the source code starting with
 @(&#39;ld&#39;), you&#39;ll see that it reads and evaluates forms with the function
 @(&#39;ld-loop&#39;), which in turn calls @(&#39;ld-read-eval-print&#39;) on each form.  That
 function, in turn, calls @(&#39;ld-read-command&#39;) to read the next form and then
 calls a version of @(tsee trans-eval), @(&#39;trans-eval-default-warning&#39;), to
 evaluate it.  (See also the section on ``Evaluators&#39;&#39; in the chapter, @(see
 developers-guide-utilities); also see the chapter, @(see
 developers-guide-evaluation).)  When there is no error, the function
 @(&#39;maybe-add-command-landmark&#39;) is called.  It checks whether the world has
 changed, and if so it pushes a new triple on the new world, a so-called
 &lt;i&gt;command landmark&lt;/i&gt;, provided the new world doesn&#39;t already have a command
 landmark as the topmost triple.  Let&#39;s use the @(tsee walkabout) utility to
 see what a command landmark might look like.&lt;/p&gt;

 @({
 ACL2 !&gt;(with-output :off :all (defun foo (x) x)) ; avoid noise just below
  FOO
 ACL2 !&gt;(walkabout (w state) state)

 Commands:
 0, 1, 2, ..., nx, bk, pp, (pp n), (pp lev len), =, (= symb), and q.

 ((COMMAND-LANDMARK GLOBAL-VALUE 7357 ...)
  (EVENT-LANDMARK GLOBAL-VALUE 8625 ...)
  (FOO ABSOLUTE-EVENT-NUMBER . 8625)
  ...)
 :1
 (COMMAND-LANDMARK GLOBAL-VALUE 7357 ...)
 :pp
 (COMMAND-LANDMARK GLOBAL-VALUE 7357
                   (:LOGIC WITH-OUTPUT :OFF
                           :ALL (DEFUN FOO (X) X))
                   &quot;/share/projects/&quot;)
 :
 })

 &lt;p&gt;The triple just above is, as with every triple in the world, of the form
 @(&#39;(sym prop . val)&#39;).  We thus interpret the triple above to say that the
 current @(&#39;command-landmark&#39;) has a @(&#39;global-value&#39;) property of the form
 @(&#39;(7357 (:logic . &lt;form&gt;) &lt;dir&gt; . nil)&#39;).  The definition of the record
 structure @(&#39;command-tuple&#39;) (which is easy to find with the Emacs command,
 @(&#39;meta-.&#39;)) uses the @(tsee defrec) macro, discussed above.  For now we
 explain the fields in our example as follows; see the Essay on Command Tuples
 and ensuing definitions for more information.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;the &lt;i&gt;absolute command number&lt;/i&gt; is 7357.&lt;/li&gt;

 &lt;li&gt;The @(tsee defun-mode) is @(&#39;:logic&#39;).&lt;/li&gt;

 &lt;li&gt;The &lt;i&gt;form&lt;/i&gt; is @(&#39;(with-output :off :all (defun foo (x) x))&#39;).&lt;/li&gt;

 &lt;li&gt;The @(tsee cbd) is @(&#39;&quot;/share/projects/&quot;&#39;).&lt;/li&gt;

 &lt;li&gt;The @(&#39;last-make-event-expansion&#39;) field is @(&#39;nil&#39;).&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;&lt;color rgb=&#39;#c00000&#39;&gt;We turn now from commands to @(see events).&lt;/color&gt;
 There are primitive events that modify the world such as a call of @(tsee
 defun), @(tsee defthm), and @(tsee table).  See @(see events) and especially
 see @(see embedded-event-form), which explain that events may go in calls of
 @(tsee encapsulate) and @(tsee progn), which themselves are also (compound)
 events, and events may also go in @(see books).  Several other utilities are
 events in the sense that they are allowed in compound events and books, but
 they are really just wrappers of sorts for actual events.  &lt;color
 rgb=&#39;#c00000&#39;&gt;Here is a list of event macros, taken from a comment in the
 definition of function @(&#39;chk-embedded-event-form&#39;), which is the recognizer
 for (embeddable) events.&lt;/color&gt;&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;@(&#39;local&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;skip-proofs&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;with-cbd&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;with-guard-checking-event&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;with-output&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;with-prover-step-limit&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;with-prover-time-limit&#39;)&lt;/li&gt;
 &lt;li&gt;@(&#39;make-event&#39;)&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;Of course, @(tsee make-event) is a complex sort of wrapper, in that it
 serves to &lt;i&gt;generate&lt;/i&gt; an event, its &lt;i&gt;expansion&lt;/i&gt;.&lt;/p&gt;

 &lt;p&gt;Continuing the demo of @(&#39;walkabout&#39;) started above (when explaining
 commands), we see an &lt;i&gt;event-landmark&lt;/i&gt; immediately below the
 command-landmark.&lt;/p&gt;

 @({
 :nx
 (EVENT-LANDMARK GLOBAL-VALUE 8625 ...)
 :pp
 (EVENT-LANDMARK GLOBAL-VALUE 8625 ((DEFUN) FOO . :IDEAL)
                 DEFUN FOO (X)
                 X)
 :
 })

 &lt;p&gt;Let&#39;s take this opportunity to explore how to make sense of ACL2 data
 structures.  If we use the Emacs command @(&#39;meta-x tags-apropos&#39;) on
 @(&#39;&quot;event-landmark&quot;&#39;) we find the function @(&#39;add-event-landmark&#39;); then
 using the @(&#39;meta-.&#39;) command on @(&#39;add-event-landmark&#39;), we find its
 definition and we see a call of @(&#39;make-event-tuple&#39;).  That function has
 comments that explain the fields; perhaps more illuminating, accessors for
 event-tuple fields are defined immediately below the definition of
 @(&#39;make-event-tuple&#39;).  We can apply these accessors to deconstruct the value,
 @(&#39;val&#39;), in the triple above, @(&#39;(event-landmark global-value . val)&#39;).
 Regarding the @(&#39;local-p&#39;) field of an event-tuple: if an event @(&#39;E&#39;) is
 evaluated in a @(see local) context, then the corresponding event-tuple is
 @(&#39;(local . x)&#39;) where @(&#39;x&#39;) is the event-tuple for @(&#39;E&#39;).&lt;/p&gt;

 @({
 ACL2 !&gt;(let ((val (cddr &#39;(EVENT-LANDMARK GLOBAL-VALUE 8625 ((DEFUN) FOO . :IDEAL)
                                           DEFUN FOO (X)
                                           X))))
           (list :local-p (access-event-tuple-local-p val)
                 :number  (access-event-tuple-number val)
                 :depth   (access-event-tuple-depth val)
                 :type    (access-event-tuple-type val)
                 :skipp   (access-event-tuple-skipped-proofs-p val)
                 :namex   (access-event-tuple-namex val)
                 :form    (access-event-tuple-form val)
                 :symcls  (access-event-tuple-symbol-class val)))
 (:LOCAL-P NIL
           :NUMBER 8625
           :DEPTH 0
           :TYPE DEFUN
           :SKIPP NIL
           :NAMEX FOO
           :FORM (DEFUN FOO (X) X)
           :SYMCLS :IDEAL)
 ACL2 !&gt;
 })

 &lt;color rgb=&#39;#c00000&#39;&gt;

 &lt;p&gt;We conclude our discussion of commands and events with a few
 observations.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;Commands can be undone, using @(tsee ubt) and related utilities.  Events
 are not undone (except when they are also commands); only commands are
 undone.&lt;/li&gt;

 &lt;li&gt;@(&#39;:&#39;)@(tsee Puff) is applied to @(see command-descriptor)s, so naturally
 it expands commands, not events.&lt;/li&gt;

 &lt;li&gt;Only events can go into books and calls of @(tsee progn) or @(tsee
 encapsulate), not arbitrary commands.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;/color&gt;

 &lt;h3&gt;Exploring the source code with an example: prover flow&lt;/h3&gt;

 &lt;p&gt;An important skill for ACL2 code development and maintenance is the ability
 to explore the source code to gain necessary background.  This is really an
 art, developed with experience.  There has been a lot of attention to
 documenting the source code &amp;mdash; as of mid-March 2018, about 30% of the
 source file lines (that is, from @(&#39;*.lisp&#39;) files not including the generated
 documentation file @(&#39;doc.lisp&#39;)) consisted entirely of a comment line, and of
 course other lines contained comments as well.  Here we show the raw data.&lt;/p&gt;

 @({
 ginger:/projects/acl2/acl2/saved% wc -l *.lisp | grep total
   373606 total
 ginger:/projects/acl2/acl2/saved% wc -l doc.lisp
 121865 doc.lisp
 ginger:/projects/acl2/acl2/saved% grep &#39;^[ ]*;&#39; *.lisp | wc -l
 76588
 ginger:/projects/acl2/acl2/saved% grep &#39;^[ ]*;&#39; doc.lisp | wc -l
 1545
 ginger:/projects/acl2/acl2/saved%
 })

 &lt;p&gt;Unfortunately, 30+% comments is not sufficient!  In a perfect world, more
 ACL2 functions would have extensive documentation, with clear pointers to
 necessary background including high-level algorithm discussion.  This Guide is
 intended to help to fill the gap, but can only do so partially.  The missing
 additional ingredient to absorbing source code &amp;mdash; as practiced for years
 by ACL2 developers as of this writing in March 2018 &amp;mdash; is the ability to
 explore the sources.  Ideally this is a skill that can be learned by
 practicing.&lt;/p&gt;

 &lt;p&gt;As a simple example, we show how to explore the source code to get a sense
 of the flow of the theorem prover.  This is very far from getting a sense of
 the ACL2 system in general, which supports much more than the prover (think of
 book certification, @(tsee make-event), @(see invariant-risk), and on and
 on).&lt;/p&gt;

 &lt;p&gt;Let&#39;s start with @(tsee thm):&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;

 &lt;p&gt;DEMO: EXPLORE HOW THM ULTIMATELY CALLS THE REWRITER.  But unlike the
 discussion below, I&#39;ll go bottom-up.  This may give us some idea of how the
 prover is structured.  One result may be found in the documentation section,
 @(see developers-guide-background-extra).&lt;/p&gt;
 &lt;/color&gt;

 @(def thm)

 &lt;p&gt;@(&#39;Thm-fn&#39;) calls @(&#39;prove&#39;), which calls @(&#39;prove-loop&#39;) and so on, as is
 easy to discover using the Emacs command, @(&#39;meta-.&#39;) .  We thus work our way
 to the waterfall.&lt;/p&gt;

 @({
 thm-fn
   prove
     prove-loop
       prove-loop0
         prove-loop1
           prove-loop2
             waterfall
 })

 &lt;p&gt;At this point things get more complicated.  @(&#39;Waterfall&#39;) calls
 @(&#39;waterfall1-lst@par&#39;), which should be thought of as @(&#39;waterfall1-lst&#39;), as
 discussed below where we talk about ACL2(p).  We see that @(&#39;waterfall1-lst&#39;)
 is part of a rather complex @(tsee mutual-recursion).  But a key function
 called in that @(&#39;mutual-recursion&#39;) is @(&#39;waterfall-step&#39;), which is shown as
 calls of @(&#39;waterfall-step@par&#39;).  Knowing about @(&#39;waterfall-step&#39;) is one of
 those pieces of background knowledge to learn that makes it easier over time
 to peruse the ACL2 sources.  In the body of that function is a call of
 @(&#39;waterfall-step1&#39;), which provides a clue about the main flow of the prover:
 the key subroutine of a function @(&#39;foo&#39;) often has the name @(&#39;foo1&#39;), or
 perhaps @(&#39;foo-1&#39;), @(&#39;foo-aux&#39;), or @(&#39;foo-rec&#39;), or more generally,
 @(&#39;foo&lt;something&gt;&#39;).  The function @(&#39;waterfall-step1&#39;) has a nice structure
 showing how it leads to calls of individual waterfall processing functions, in
 particular, the simplifier via the function @(&#39;simplify-clause&#39;).  We can
 explore the definition of @(&#39;simplify-clause&#39;) in a similar way, finding
 @(&#39;simplify-clause1&#39;), which has these key subroutines.&lt;/p&gt;

 @({
 remove-trivial-equivalences
 forward-chain-top
 setup-simplify-clause-pot-lst
 process-equational-polys
 rewrite-clause
 })

 &lt;p&gt;The flow suggests that the first four of these functions are called to set
 things up for the call to @(&#39;rewrite-clause&#39;).  That function can be similarly
 explored, in particular to find key subroutines that include the
 following.&lt;/p&gt;

 @({
 built-in-clausep1
 rewrite-clause-type-alist
 rewrite-atm
 clausify
 rewrite-clause-lst
 })

 &lt;p&gt;The function @(&#39;rewrite-atm&#39;) does yet a bit more processing, using
 @(&#39;known-whether-nil&#39;), before calling @(&#39;rewrite&#39;).  Feel free to explore
 @(&#39;rewrite&#39;), but beware, as it&#39;s quite complicated!  Indeed, the usual
 activity of an ACL2 maintainer is not to explore for the sake of general
 background, as we have been doing above, but rather to explore for the sake of
 more specific understanding before making desired modifications or
 additions.&lt;/p&gt;

 &lt;h3&gt;Build-time checks&lt;/h3&gt;

 &lt;p&gt;There are several checks done near the end of an ACL2 build, as performed
 by (subfunctions of) the function, @(&#39;check-acl2-initialization&#39;).  There is
 not much that we need to say here, because if one of those tests fails, then
 the error message should make it clear how to proceed.&lt;/p&gt;

 &lt;h3&gt;Raw Lisp and readtime conditionals&lt;/h3&gt;

 &lt;p&gt;ACL2 is built on top of Common Lisp.  Some knowledge of that programming
 language is occasionally necessary.  The definitive reference is the Common
 Lisp Hyperspec, which can be found easily with a web search.&lt;/p&gt;

 &lt;p&gt;Every ACL2 source file is either loaded directly into Common Lisp as part
 of the ACL2 build, or is first compiled into a compiled file before loading
 that compiled file.  (Files @(&#39;acl2.lisp&#39;) and @(&#39;acl2-init.lisp&#39;) are never
 subjected to file compilation, as noted in a comment near the top of each
 file.)  Thus, &lt;color rgb=&#39;#c00000&#39;&gt;ACL2 macros including @(tsee defun), @(tsee
 defthm), @(tsee table), @(tsee defconst), @(tsee local), and @(tsee
 encapsulate) must be suitable for Common Lisp evaluation.&lt;/color&gt; This is
 arranged differently for different macros, as illustrated by the following
 examples.&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;DEMO: RATHER THAN GO THROUGH WHAT&#39;S BELOW, I&#39;LL JUST EXPLORE DEFUN,
 DEFTHM, LOCAL, and QUIT, AND USE THEM TO EXPLAIN *features* AND SPECIFICALLY
 acl2-loop-only.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;First consider @(&#39;defun&#39;).  We have only the following definition of
 @(&#39;defun&#39;) in the ACL2 source code.&lt;/p&gt;

 @({
 #+acl2-loop-only
 (defmacro defun (&amp;whole event-form &amp;rest def)

 ; Warning: See the Important Boot-Strapping Invariants before modifying!

   (list &#39;defun-fn
         (list &#39;quote def)
         &#39;state
         (list &#39;quote event-form)
         #+:non-standard-analysis ; std-p
         nil))
 })

 &lt;p&gt;The notation ``@(&#39;#+acl2-loop-only&#39;)&#39;&#39; is called a &lt;i&gt;readtime
 conditional&lt;/i&gt;.  In this case, it says that the definition of @(&#39;defun&#39;)
 immediately following that notion is ignored by the reader unless the symbol
 @(&#39;:acl2-loop-only&#39;) is a member of the Lisp variable, @(&#39;*features*&#39;).
 Normally, and during loading and (when it occurs) compilation of ACL2 source
 files, @(&#39;:acl2-loop-only&#39;) is not a member of @(&#39;*features*&#39;), so the
 definition above is ignored &amp;mdash; as is appropriate, since @(&#39;defun&#39;) is
 already defined in Common Lisp.  The function @(&#39;initialize-acl2&#39;) pushes the
 symbol @(&#39;:acl2-loop-only&#39;) onto @(&#39;*features*&#39;) before beginning to @(&#39;ld&#39;)
 the ACL2 source files; thus, as ACL2 processes its own source files, the
 definition above is read (not ignored) and evaluated; you can evaluate @(&#39;:pe
 defun&#39;) in the top-level loop to see the definition above.&lt;/p&gt;

 &lt;p&gt;Next consider @(tsee defthm).  This time there are two definitions.  One is
 much like the definition above of @(&#39;defun&#39;):&lt;/p&gt;

 @({
 #+acl2-loop-only
 (defmacro defthm (&amp;whole event-form
                   name term
                        &amp;key (rule-classes &#39;(:REWRITE))
                        instructions
                        hints
                        otf-flg)

 ; Warning: See the Important Boot-Strapping Invariants before modifying!

   (list &#39;defthm-fn
         (list &#39;quote name)
         (list &#39;quote term)
         &#39;state
         (list &#39;quote rule-classes)
         (list &#39;quote instructions)
         (list &#39;quote hints)
         (list &#39;quote otf-flg)
         (list &#39;quote event-form)
         #+:non-standard-analysis ; std-p
         nil))
 })

 &lt;p&gt;The other definition occurs in a raw Lisp context, as follows.&lt;/p&gt;

 @({
 #-acl2-loop-only
 (progn

 ...

 (defmacro defthm (&amp;rest args)
  (declare (ignore args))
  nil)

 ...)
 })

 &lt;p&gt;Thus, the Common Lisp loader or compiler will see this definition of
 @(&#39;defthm&#39;), but the @(&#39;ld&#39;) of the ACL2 source files will not.  In summary:
 @(&#39;defthm&#39;) is defined in terms of @(&#39;defthm-fn&#39;) in the ACL2 loop, but it is
 defined simply to return @(&#39;nil&#39;) in raw Lisp.&lt;/p&gt;

 &lt;p&gt;Interesting cases are @(tsee local) and @(tsee encapsulate).  These have
 rather complex definitions in the ACL2 loop, but let&#39;s see
 what happens during macroexpansion in raw Lisp.&lt;/p&gt;

 @({
 ? (pprint
    (macroexpand &#39;(encapsulate (((f *) =&gt; *))
                    (local (defun f (x) x))
                    (defun g (x) (f x))
                    (local (defthm consp-g
                             (implies (consp x) (consp (g x))))))))

 (PROGN (DEFUN F (X1) (THROW-OR-ATTACH F (X1)))
        (LOCAL (DEFUN F (X) X))
        (DEFUN G (X) (F X))
        (LOCAL (DEFTHM CONSP-G (IMPLIES (CONSP X) (CONSP (G X))))))
 ? (macroexpand &#39;(LOCAL (DEFUN F (X) X)))
 NIL
 T
 ? (macroexpand &#39;(LOCAL (DEFTHM CONSP-G (IMPLIES (CONSP X) (CONSP (G X))))))
 NIL
 T
 ?
 })

 &lt;p&gt;Evidently, @(&#39;encapsulate&#39;) defines its signature functions simply to cause
 errors, actually like this:&lt;/p&gt;

 @({
 ACL2 Error in TOP-LEVEL:  ACL2 cannot ev the call of non-executable
 function F on argument list:

 (3)

 })

 &lt;p&gt;It is also apparent that calls of @(&#39;local&#39;) in raw Lisp expand simply to
 @(&#39;nil&#39;).&lt;/p&gt;

 &lt;p&gt;To understand such behavior, let&#39;s look at the definitions of @(&#39;local&#39;)
 and @(&#39;encapsulate&#39;), eliding comments and some code for brevity.  The elided
 code in the first definition of @(&#39;encapsulate&#39;) below, which is for raw Lisp,
 defines the functions in the signature to cause errors when called.&lt;/p&gt;

 @({
 #-acl2-loop-only
 (progn

 ...

 (defmacro encapsulate (signatures &amp;rest lst)
   `(progn ,@(mapcar &lt;...elided code...&gt; signatures)
           ,@lst))

 ...

 (defmacro local (x)
   (declare (ignore x))
   nil)

 ...)

 #+acl2-loop-only
 (defmacro local (x)
   (list &#39;if
         &#39;(equal (ld-skip-proofsp state) &#39;include-book)
         &#39;(mv nil nil state)
         (list &#39;if
               &#39;(equal (ld-skip-proofsp state) &#39;initialize-acl2)
               &#39;(mv nil nil state)
               (list &#39;state-global-let*
                     &#39;((in-local-flg t))
                     (list &#39;when-logic &quot;LOCAL&quot; x)))))

 #+acl2-loop-only
 (defmacro encapsulate (&amp;whole event-form signatures &amp;rest cmd-lst)
   (list &#39;encapsulate-fn
         (list &#39;quote signatures)
         (list &#39;quote cmd-lst)
         &#39;state
         (list &#39;quote event-form)))
 })

 &lt;p&gt;We see that in raw Lisp, @(&#39;encapsulate&#39;) generates a suitable @(&#39;progn&#39;)
 and @(&#39;local&#39;) is a no-op.&lt;/p&gt;

 &lt;p&gt;You may find it instructive to look at the @(&#39;#-acl2-loop-only&#39;) and
 @(&#39;#+acl2-loop-only&#39;) definitions of other event macros.&lt;/p&gt;

 &lt;h3&gt;Implementation-specific code&lt;/h3&gt;

 &lt;p&gt;As of this writing, six Common Lisp implementations support ACL2: Allegro
 Common Lisp (ACL), Clozure CL (CCL), CMU Common Lisp (CMUCL), GNU Common
 Lisp (GCL), LispWorks, and Steel Bank Common Lisp (SBCL).  However, see @(see
 allegro-cl) for concerns about using Allegro CL (though, as noted in topic
 @(see developers-guide-maintenance), that Lisp has a particularly nice
 statistical profiler.)  Some ACL2 raw-Lisp code is implementation-specific,
 that is, depends on which of these six Common Lisp implementations is the host
 lisp.  See for example the definitions of @(&#39;exit-lisp&#39;) and @(&#39;getenv$-raw&#39;).
 Here is an elided version of the definition of @(&#39;exit-lisp&#39;).  Notice the
 readtime conditional used for each of the six supported Lisp implementations
 and also some that are no longer supported, like CLISP.  (Note: Normally we
 see ``@(&#39;gcl&#39;)&#39;&#39; for GCL but sometimes, as below, we see the somewhat
 archaic (but still acceptable) ``@(&#39;akcl&#39;)&#39;&#39;.)&lt;/p&gt;

 @({
 (defun exit-lisp (&amp;optional (status &#39;0 status-p))
   &lt;&lt;code elided&gt;&gt;
   #+clisp
   (if status-p (user::exit status) (user::exit))
   #+lispworks ; Version 4.2.0; older versions have used bye
   (if status-p (lispworks:quit :status status) (lispworks:quit))
   #+akcl
   (if status-p (si::bye status) (si::bye))
   #+lucid
   (lisp::exit) ; don&#39;t know how to handle status, but don&#39;t support lucid
   #+ccl
   (if status-p (ccl::quit status) (ccl::quit))
   #+cmu
   &lt;&lt;code elided&gt;&gt;
   #+allegro
   (user::exit status :no-unwind t)
   #+(and mcl (not ccl))
   (cl-user::quit) ; mcl support is deprecated, so we don&#39;t worry about status
   #+sbcl
   &lt;&lt;code elided&gt;&gt;
   (progn status-p status))
 })

 &lt;h3&gt;ACL2 ``Experimental Versions&#39;&#39;&lt;/h3&gt;

 &lt;p&gt;Two dissertations have produced modifications of ACL2.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;ACL2(r), courtesy of Ruben Gamboa, extends the rational number data type
 to include irrational numbers.  It is built on a foundation of non-standard
 analysis, which is a logical theory (really, more than one) that makes sense
 of Leibniz&#39;s notion of ``infinitesimal&#39;&#39; in place of foundations based on
 limits.&lt;/li&gt;

 &lt;li&gt;ACL2(p), courtesy of David Rager, supports both parallel evaluation in
 general and parallelization of the ACL2 waterfall.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;Code that is to be read only when building ACL2(r) has the readtime
 conditional @(&#39;#+:non-standard-analysis&#39;), where the leading colon is actually
 optional but is typically used by convention.  Code that is to be read only
 when building ACL2(p) has the readtime conditional @(&#39;#+acl2-par&#39;).  As of
 this writing, the maintenance of these systems has typically been performed by
 Kaufmann and Moore when reasonably feasible, but sometimes with assistance
 from Gamboa and Rager, especially when there is a major change.&lt;/p&gt;

 &lt;p&gt;Note that ACL2(r) changes the logic &amp;mdash; for example, the formula
 @(&#39;(not (equal (* x x) 2))&#39;) is a theorem of ACL2 but is disprovable in
 ACL2(r) &amp;mdash; but ACL2(p) does not change the logic.  Another difference is
 that ACL2(r) was intended, as a design decision, to be sound; by contrast,
 ACL2(p) was intended to be sound in practice but with a small risk that an
 unsound result could be obtained.&lt;/p&gt;

 &lt;p&gt;There is a somewhat elaborate mechanism for incorporating ACL2(p) source
 code into the ACL2 sources.  One part involves the use of feature
 @(&#39;:acl2-par&#39;): that is, the use of @(&#39;#+acl2-par&#39;) to prefix code to be read
 only when building ACL2(p) and of @(&#39;#-acl2-par&#39;) to prefix code to be read
 only when building ACL2.  But there is also support for function and macro
 names with suffix @(&#39;&quot;@PAR&quot;&#39;).  When considering ACL2 and not ACL2(p), these
 should be read simply by removing that suffix: for example, @(&#39;defun@par&#39;) is
 to be read as @(&#39;defun&#39;), @(&#39;er@par&#39;) is to be read as @(&#39;er&#39;), and so on.
 For information about how to make sense of the @(&#39;&quot;@PAR&quot;&#39;) suffix when
 reading the sources as ACL2(p) sources, see the Essay on Parallelism,
 Parallelism Warts, Parallelism Blemishes, Parallelism No-fixes, Parallelism
 Hazards, and #+ACL2-PAR notes.  Several definitions near the end of
 @(&#39;axioms.lisp&#39;), below mention of that essay, implement the handling of
 @(&#39;&quot;@PAR&quot;&#39;) suffixes.&lt;/p&gt;

 &lt;p&gt;At one time, the addition of hash-cons, function memoization, and
 fast-alists (see @(see hons-and-memoization)) was considered experimental, and
 resulted in a system called ACL2(h) with a corresponding readtime conditional
 of @(&#39;#+hons&#39;).  That system, which was originally built on top of ACL2 by Bob
 Boyer and Warren Hunt and was updated by Jared Davis and Sol Swords, with
 contributions by Matt Kaufmann and J Moore, was ultimately updated and
 incorporated into ACL2 by Kaufmann and Moore after an extensive code review.
 Since Kaufmann and Moore now stand behind the resulting system and are
 maintaining it, and with assent from its contributors, what was formerly
 ACL2(h) is now just ACL2.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-extending-knowledge)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-extending-knowledge
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Illustration using tracing, comments and Essays to explore ACL2 behaviors"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This topic grew out of a discussion on the acl2-devel mailing list
 in which some relevant background had already been presented.  It illustrates
 how one might go about learning about specific features of ACL2, in this case
 aspects of the @(see tau-system).&lt;/p&gt;

 &lt;p&gt;First,&lt;/p&gt;

 @({
 (include-book ``tau/bounders/elementary-bounders&#39;&#39; :dir :system)
 })

 &lt;p&gt;and&lt;/p&gt;

 @({
 (trace$ tau-term)
 })

 &lt;p&gt;and then submit the non-theorem:&lt;/p&gt;

 @({
 (thm (implies (and (natp x)(&lt;= 0 x) (&lt;= x 15))
               (equal xxx (+ 3 x))))
 })

 &lt;p&gt;The objective is to see what the tau of @(&#39;(+ 3 x)&#39;) is, under the
 assumptions @(&#39;(and (natp x) (&lt;= 0 x) (&lt;= x 15))&#39;).  The idea is to attempt to
 prove a non-theorem that lists the assumptions being made and then to see how
 the ACL2 source function, @(&#39;tau-term&#39;), is called on the term in question and
 what @(&#39;tau-term&#39;) returns.  (We assume here the somehow we know that
 @(&#39;tau-term&#39;) is relevant, perhaps by querying the acl2-devel mailing list.)
 First let&#39;s consider what it returns because that gives us a chance to see a
 tau object.  Then we&#39;ll explore how @(&#39;tau-term&#39;) was called.&lt;/p&gt;

 &lt;p&gt;If you search the failed proof for the first call of @(&#39;tau-term&#39;) on
 @(&#39;(binary-+ &#39;3 x)&#39;) &amp;mdash; which is the translated form of @(&#39;(+ 3 x)&#39;) (see
 @(see term)) &amp;mdash; and look at what that call returns, you see:&lt;/p&gt;

 @({
   &lt;2 (TAU-TERM ((NIL)
                 (INTEGERP (NIL . 3) NIL . 18)
                 ((166 . FILE-CLOCK-P)
                  (155 . 32-BIT-INTEGERP) ; probably not after 3/29/2023
                  (20 . O-FINP)
                  (19 . POSP)
                  (17 . NATP)
                  (9 . EQLABLEP)
                  (5 . RATIONALP)
                  (4 . INTEGERP)
                  (0 . ACL2-NUMBERP))
                 (192 . BAD-ATOM)
                 (182 . ZPF)
                 (176 . WRITABLE-FILE-LISTP1)
                 (173 . READ-FILE-LISTP1)
                 (170 . WRITTEN-FILE)
                 (167 . READABLE-FILE)
                 (163 . OPEN-CHANNEL1)
                 (137 . KEYWORDP)
                 (129 . LOWER-CASE-P)
                 (128 . UPPER-CASE-P)
                 (127 . ALPHA-CHAR-P)
                 (124 . STANDARD-CHAR-P)
                 (118 . IMPROPER-CONSP)
                 (117 . PROPER-CONSP)
                 (104 . WEAK-ABSSTOBJ-INFO-P)
                 (72 . WEAK-CURRENT-LITERAL-P)
                 (34 . WEAK-IO-RECORD-P)
                 (31 . BOOLEANP)
                 (27 . MINUSP)
                 (18 . BITP)
                 (16 . ZIP)
                 (15 . ZP)
                 (7 . SYMBOLP)
                 (6 . STRINGP)
                 (3 . CONSP)
                 (2 . COMPLEX-RATIONALP)
                 (1 . CHARACTERP))
                ...)
 })

 &lt;p&gt;The @(&#39;...&#39;) above is the second returned value of @(&#39;tau-term&#39;), which is
 the ``tau completion alist&#39;&#39;, an efficiency hack that we&#39;ll ignore here.  The
 first result returned is the tau of @(&#39;(+ 3 x)&#39;) under our assumptions.&lt;/p&gt;

 &lt;p&gt;You can decode it with @(&#39;(decode-tau &lt;tau&gt; &lt;term&gt;)&#39;) where @(&#39;&lt;tau&gt;&#39;) is a
 tau and @(&#39;&lt;term&gt;&#39;) is a term that allegedly has that tau (i.e., has that
 ``type&#39;&#39;).&lt;/p&gt;

 @({
 (decode-tau &#39;((NIL)
               (INTEGERP (NIL . 3) NIL . 18)
               ((166 . FILE-CLOCK-P)
                (155 . 32-BIT-INTEGERP) ; probably not after 3/29/2023
                (20 . O-FINP)
                (19 . POSP)
                (17 . NATP)
                (9 . EQLABLEP)
                (5 . RATIONALP)
                (4 . INTEGERP)
                (0 . ACL2-NUMBERP))
               (192 . BAD-ATOM)
               (182 . ZPF)
               (176 . WRITABLE-FILE-LISTP1)
               (173 . READ-FILE-LISTP1)
               (170 . WRITTEN-FILE)
               (167 . READABLE-FILE)
               (163 . OPEN-CHANNEL1)
               (137 . KEYWORDP)
               (129 . LOWER-CASE-P)
               (128 . UPPER-CASE-P)
               (127 . ALPHA-CHAR-P)
               (124 . STANDARD-CHAR-P)
               (118 . IMPROPER-CONSP)
               (117 . PROPER-CONSP)
               (104 . WEAK-ABSSTOBJ-INFO-P)
               (72 . WEAK-CURRENT-LITERAL-P)
               (34 . WEAK-IO-RECORD-P)
               (31 . BOOLEANP)
               (27 . MINUSP)
               (18 . BITP)
               (16 . ZIP)
               (15 . ZP)
               (7 . SYMBOLP)
               (6 . STRINGP)
               (3 . CONSP)
               (2 . COMPLEX-RATIONALP)
               (1 . CHARACTERP))
             &#39;(binary-+ &#39;3 x))
 })

 &lt;p&gt;If @(&#39;(tau-term &lt;term&gt; ...&lt;assumptions&gt;...)&#39;) returns @(&#39;&lt;tau&gt;&#39;), then
 @(&#39;(decode-tau &lt;tau&gt; &lt;term&gt;)&#39;) prints out everything the tau system can deduce
 about @(&#39;&lt;term&gt;&#39;) under those @(&#39;&lt;assumptions&gt;&#39;).  It&#39;s a way of asking ``what
 does this @(&#39;&lt;tau&gt;&#39;) mean?&#39;&#39;  The answer is shown below, where the three
 important facts have been indicated:&lt;/p&gt;

 @({
 (AND (ACL2-NUMBERP (BINARY-+ &#39;3 X))
      (INTEGERP (BINARY-+ &#39;3 X))                 ; &lt;---
      (RATIONALP (BINARY-+ &#39;3 X))
      (EQLABLEP (BINARY-+ &#39;3 X))
      (NATP (BINARY-+ &#39;3 X))
      (POSP (BINARY-+ &#39;3 X))
      (O-FINP (BINARY-+ &#39;3 X))
      (32-BIT-INTEGERP (BINARY-+ &#39;3 X)) ; probably not after 3/29/2023
      (FILE-CLOCK-P (BINARY-+ &#39;3 X))
      (&lt;= 3 (BINARY-+ &#39;3 X))                     ; &lt;---
      (&lt;= (BINARY-+ &#39;3 X) 18)                    ; &lt;---
      (NOT (CHARACTERP (BINARY-+ &#39;3 X)))
      (NOT (COMPLEX-RATIONALP (BINARY-+ &#39;3 X)))
      (NOT (CONSP (BINARY-+ &#39;3 X)))
      (NOT (STRINGP (BINARY-+ &#39;3 X)))
      (NOT (SYMBOLP (BINARY-+ &#39;3 X)))
      (NOT (ZP (BINARY-+ &#39;3 X)))
      (NOT (ZIP (BINARY-+ &#39;3 X)))
      (NOT (BITP (BINARY-+ &#39;3 X)))
      (NOT (MINUSP (BINARY-+ &#39;3 X)))
      (NOT (BOOLEANP (BINARY-+ &#39;3 X)))
      (NOT (WEAK-IO-RECORD-P (BINARY-+ &#39;3 X)))
      (NOT (WEAK-CURRENT-LITERAL-P (BINARY-+ &#39;3 X)))
      (NOT (WEAK-ABSSTOBJ-INFO-P (BINARY-+ &#39;3 X)))
      (NOT (PROPER-CONSP (BINARY-+ &#39;3 X)))
      (NOT (IMPROPER-CONSP (BINARY-+ &#39;3 X)))
      (NOT (STANDARD-CHAR-P (BINARY-+ &#39;3 X)))
      (NOT (ALPHA-CHAR-P (BINARY-+ &#39;3 X)))
      (NOT (UPPER-CASE-P (BINARY-+ &#39;3 X)))
      (NOT (LOWER-CASE-P (BINARY-+ &#39;3 X)))
      (NOT (KEYWORDP (BINARY-+ &#39;3 X)))
      (NOT (OPEN-CHANNEL1 (BINARY-+ &#39;3 X)))
      (NOT (READABLE-FILE (BINARY-+ &#39;3 X)))
      (NOT (WRITTEN-FILE (BINARY-+ &#39;3 X)))
      (NOT (READ-FILE-LISTP1 (BINARY-+ &#39;3 X)))
      (NOT (WRITABLE-FILE-LISTP1 (BINARY-+ &#39;3 X)))
      (NOT (ZPF (BINARY-+ &#39;3 X)))
      (NOT (BAD-ATOM (BINARY-+ &#39;3 X))))
 })

 &lt;p&gt;Another way of thinking about a tau, @(&#39;&lt;tau&gt;&#39;), is that it is a reasonably
 fast and compact encoding of a predicate,&lt;/p&gt;

 @({
 `(lambda (zzz) ,(decode-tau &lt;tau&gt; &#39;zzz))
 })

 &lt;p&gt;Of course, a tau is very redundant.  There is no reason to say that
 something&#39;s NOT a bad-atom if you say it IS a NATP!  But by encoding
 everything the tau system knows about a term it&#39;s easy to answer questions
 about what we know.&lt;/p&gt;

 &lt;p&gt;Now, going back to that call of @(&#39;tau-term&#39;) on @(&#39;(binary-+ &#39;3 x)&#39;) in
 the trace, it was:&lt;/p&gt;

 @({
  (TAU-TERM &#39;(BINARY-+ &#39;3 X)
            &lt;tau-alist&gt;
            &#39;(((EQUAL (BINARY-+ &#39;3 X) XXX)              ; type-alist
               128
               (LEMMA (:FAKE-RUNE-FOR-TYPE-SET NIL)))
              ((&lt; &#39;15 X) 128)
              ((&lt; X &#39;0) 128)
              (X 7)
              (X 23))
            &#39;(((0 (((((X . -1)) NIL) 15 &lt;= T)))         ; linear pot list
               X (((((X . 1)) NIL) 0 &lt;= T))))
            &lt;ens&gt;
            &lt;w&gt;
            &lt;calist&gt;)
 })

 &lt;p&gt;Let&#39;s assume that we already know about the @(see type-alist) and the
 linear pot (see @(see linear-arithmetic)); they&#39;re set up when
 @(&#39;tau-clausep&#39;) is called, by assuming all the literals of the clause false
 and doing the initialization of the linear data base.&lt;/p&gt;

 &lt;p&gt;The @(&#39;&lt;tau-alist&gt;&#39;) basically repeats as much of that information as
 possible in terms of tau.  That is, it records the known tau of various terms
 computed so far by @(&#39;tau-clause1p&#39;).  It starts as @(&#39;nil&#39;) in
 @(&#39;tau-clausep&#39;).&lt;/p&gt;

 &lt;p&gt;When playing with @(&#39;tau-term&#39;), it is OK to just set @(&#39;tau-alist&#39;) to
 @(&#39;nil&#39;).  If a term is on the @(&#39;tau-alist&#39;) and you ask for its tau,
 @(&#39;tau-term&#39;) just returns the tau in the alist.  But if the term isn&#39;t on the
 alist, @(&#39;tau-term&#39;) computes it.  So generally speaking, the @(&#39;tau-alist&#39;)
 just saves time.  Since the tau system is complicated it could be that putting
 an entry on the alist that tau can compute will cause @(&#39;tau-term&#39;) to compute
 a stronger tau for that term, but this is unlikley.  In any case, a good
 approximation and a perfectly sound way to use tau is to just set
 @(&#39;tau-alist&#39;) to @(&#39;nil&#39;)!&lt;/p&gt;

 &lt;p&gt;It is also acceptable to use @(&#39;nil&#39;) for @(&#39;&lt;calist&gt;&#39;) in calls of
 @(&#39;tau-term&#39;).&lt;/p&gt;

 &lt;p&gt;The general lesson here is simple: if you want to try to understand some
 part of the prover, @(tsee trace$) it and give the prover a formula that will
 exercise the part in question and look at how it&#39;s called and what it
 returns.&lt;/p&gt;

 &lt;p&gt;Of course, you can also read the comments!  There is a good essay on the
 tau system that is well worth reading if you&#39;re interested.&lt;/p&gt;

 @({
 ; Essay on the Tau System

 ; This essay touches on a wide variety of topics in the design of the tau
 ; system.  It is consequently divided into many subsections with the following
 ; headers.  We recommend scanning this list for subsections of interest; an
 ; introduction to tau is provided by the first six or so, in order.

 ; On Tau-Like Terms
 ; On the Name ``tau&#39;&#39;
 ; On Some Basic Ideas
 ; On Tau Recognizers -- Part 1
 ; On the Tau Database and General Design
 ; On Tau Recognizers -- Part 2
 ; On Tau Intervals and &lt; versus &lt;=
 ; On the Tau Data Structure
 ; On the Built-in Tau and the Abuse of Tau Representation
 ; On the Additional Restrictions on Tau Fields
 ; On the Use of ENS by Function Evaluation in the Tau System
 ; On the Most Basic Implications of Being in an Interval
 ; On Firing Signature Rules
 ; On Comparing Bounds
 ; On the Proof of Correctness of upper-bound-&lt;
 ; On the Near-Subset Relation for Intervals
 ; On the Tau Database
 ; On Closing the Database under Conjunctive Rules
 ; On Converting Theorems in the World to Tau Rules
 ; On Tau-Like Terms
 ; On Loops in Relieving Dependent Hyps in Tau Signature Rules
 ; On the Tau Msgp Protocol
 ; On Removal of Ancestor Literals -- The Satriani Hack Prequel
 ; On the Motivation for Tau-Subrs
 ; On the Tau Completion Alist (calist)
 ; On Disjoining Tau
 ; On the Role of Rewriting in Tau
 ; On Tau-Clause -- Using Tau to Prove or Mangle Clauses
 ; On Tau Debugging Features
 })

 &lt;p&gt;NEXT SECTION: @(see developers-guide-build)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-7" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-background-extra
  <span class="keyword">:parents</span> (developers-guide-background)
  <span class="keyword">:short</span> <span class="string">"Some Implementation Background Extra Information"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Here is a call tree built bottom-up when exploring how @(&#39;thm-fn&#39;)
 calls the rewriter, which is an exercise suggested in the section, @(see
 developers-guide-background).  There are a few extra nodes in this tree,
 obtained by looking for callers of @(&#39;rewrite&#39;) and of @(&#39;prove&#39;).&lt;/p&gt;

 @({
 rewrite
   rewrite-atm
     rewrite-clause, rewrite-clause-lst
       simplify-clause1
         simplify-clause
           waterfall-step1
             waterfall-step
               waterfall0
                 waterfall1
                   waterfall
                     prove-loop2
                       prove-loop1
                         prove-loop0
                           prove-loop
                             prove
                               prove-termination
                               prove-guard-clauses
                               #+:non-standard-analysis verify-valid-std-usage
                               prove-corollaries1
                               defthm-fn1
                                 defthm-fn
                               thm-fn
                               prove-defattach-guards1
                               prove-defattach-constraint
                             pc-prove
   mfc-rw-raw
   pc-rewrite*-1
 })"</span>)</pre>
  </div>

<div class="form-block other" id="form-8" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-build
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Building ACL2 Executables"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Building an ACL2 executable is easy: one simply submits `@(&#39;make&#39;)&#39;
 in the top-level ACL2 directory.  Here we say a few words about how that works
 and comment on some variants.&lt;/p&gt;

 &lt;h3&gt;Building with `@(&#39;make&#39;)&#39;&lt;/h3&gt;

 &lt;p&gt;The preceding chapter (see @(see developers-guide-background)) notes five
 or six different Lisps on which ACL2 may be built.  &lt;color rgb=&#39;#c00000&#39;&gt;There
 have been occasions when an ACL2 bug only showed up with one of those Lisps;
 so, it is a good idea to build ACL2 in each of them from time to time, when
 feasible.&lt;/color&gt; Just specify @(&#39;LISP&#39;) on the command line, typically with
 @(&#39;PREFIX&#39;) specified as well, which is put on the front of @(&#39;saved_acl2&#39;).
 For example, to build ACL2 in SBCL, you might issue the following shell
 command to create an SBCL-based ACL2 executable named
 @(&#39;sbcl-saved_acl2&#39;).&lt;/p&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 @({
 (make PREFIX=sbcl- LISP=sbcl) &gt;&amp; make-sbcl.log&amp;
 })
 &lt;/color&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;DEMO: make-acl2 [alias].&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;Check the log to see if the build seems to have completed normally, in
 particular with ``Initialization SUCCEEDED&#39;&#39; printed near the end of the log.
 It is a good idea to do case-insensitive searches for the string,
 &quot;compiler&quot;, if the Lisp is CCL (you should find four occurrences, all of
 them for SET-COMPILER-ENABLED) and for &quot;warning:&quot; for the other Lisp
 implementations (you should find no occurrences except in GCL, pertaining to
 ``trace&#39;&#39;).&lt;/p&gt;

 &lt;p&gt;Let us now provide some analysis of what the invocation of `@(&#39;make&#39;)&#39; is
 doing.  If you inspect @(&#39;GNUmakefile&#39;), you may see these two lines:&lt;/p&gt;

 @({
 # Top (default) target:
 all: large
 })

 &lt;p&gt;Thus, ``@(&#39;make&#39;)&#39;&#39; is really ``@(&#39;make all&#39;)&#39;&#39;, which is mostly ``@(&#39;make
 large&#39;)&#39;&#39;.  (There was formerly a way to build smaller executables, but no
 longer.)  That target, in turn, is defined as follows.&lt;/p&gt;

 @({
 large: acl2r full init
 })

 &lt;p&gt;Let&#39;s briefly consider each of the three targets above.  For details, read
 @(&#39;GNUmakefile&#39;), which is intended to be comprehensible.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;The @(&#39;acl2r&#39;) target just generates a file @(&#39;acl2r.lisp&#39;) that is loaded
 in to Lisp at start up by the other two targets.  It defines features that
 support readtime conditionals during the build process.&lt;/li&gt;

 &lt;li&gt;The @(&#39;full&#39;) target compiles source files when compilation is indicated.
 Compilation is skipped for host Lisps CCL and SBCL because those Lisps compile
 on-the-fly, hence there is no clear advantage to compiling the source
 files.&lt;/li&gt;

 &lt;li&gt;The @(&#39;init&#39;) target generates a call of @(&#39;initialize-acl2&#39;), which
 constructs the initial @(see world) &amp;mdash; the so-called ``boot-strap world&#39;&#39;
 &amp;mdash; by running @(tsee ld) on ACL2 source files.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;Not surprisingly, there are many details that we omit here.  We expect ACL2
 developers to be able to follow the source code and @(&#39;GNUmakefile&#39;) where
 they lead when it is important to understand details.&lt;/p&gt;

 &lt;h3&gt;Debugging a failed build&lt;/h3&gt;

 &lt;p&gt;When a build fails using ``@(&#39;make&#39;)&#39;&#39;, you can generally re-create the
 failure in an interactive session as follows, so that you can use the Lisp
 debugger to investigate.  First, look for a file ``@(&#39;workxxx&#39;)&#39;&#39; in the build
 directory.  It should contain the forms that were executed in Lisp to get to
 the error.  So, start Lisp, and then execute each of those forms until you get
 to the error &amp;mdash; it&#39;s as simple as that!  (Of course, the debugging that
 ensues may be simple or complex.)&lt;/p&gt;

 &lt;h3&gt;Documentation&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;DEMO: make-doc [alias] COVERS WHAT&#39;S BELOW.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;The generated file @(&#39;doc.lisp&#39;) can be built in the ACL2 sources directory
 by invoking @(&#39;make DOC&#39;) or @(&#39;make update-doc.lisp&#39;).  These each will build
 that file in the ACL2 sources directory, which in turn supports the use of
 @(&#39;:doc&#39;) at the terminal without the need to include books.  The way that
 works is as follows: @(&#39;doc.lisp&#39;) is generated from
 @(&#39;books/system/doc/acl2-doc.lisp&#39;), and then @(&#39;doc.lisp&#39;) is processed with
 @(tsee ld) as an ACL2 source file to populate the appropriate documentation
 database.  That database consists of the alist,
 @(&#39;*acl2-system-documentation*&#39;), whose keys are the built-in documented
 topics.&lt;/p&gt;

 &lt;p&gt;Warning: If there are functions, macros, or constants that are keys of
 @(&#39;*acl2-system-documentation*&#39;) but do not belong to the constant
 @(&#39;*acl2-exports*&#39;), then the community book
 @(&#39;books/misc/check-acl2-exports.lisp&#39;) will probably fail to certify.  So
 whenever @(&#39;doc.lisp&#39;) is regenerated, it is a good idea to recertify that
 book after deleting its @(&#39;.cert&#39;) file.&lt;/p&gt;

 &lt;p&gt;If you include links to @(see community-books) topics in
 @(&#39;acl2-doc.lisp&#39;), follow the suggestions in the ``Remark for Experienced
 Users&#39;&#39; in the documentation topic, @(see documentation).&lt;/p&gt;

 &lt;h3&gt;Untouchables etc.&lt;/h3&gt;

 &lt;p&gt;Note that during the build, ACL2 does not enforce its usual restrictions
 against using @(see untouchable)s or utilities in the list
 @(&#39;*ttag-fns-and-macros*&#39;).  Be careful!  Those restrictions are in place
 because their use can destroy the integrity of an ACL2 session.  As
 developers, we can&#39;t be hampered by such restrictions, but in return for this
 freedom we take responsibility for wise usage.&lt;/p&gt;

 &lt;h3&gt;Build-time proofs&lt;/h3&gt;

 &lt;p&gt;ACL2 has the ability to ``prove its way through&#39;&#39; some of its source code.
 Most proofs are skipped by default.  To do such proofs, run `&lt;color
 rgb=&#39;#c00000&#39;&gt;&lt;tt&gt;make proofs&lt;/tt&gt;&lt;/color&gt;&#39;, which should be done only after
 compiling the sources if that would normally be done for the host Lisp that is
 being used.  To be safe it might be best to build ACL2 first the normal way,
 even if CCL or SBCL is being used and hence sources aren&#39;t subjected to
 @(&#39;compile-file&#39;).&lt;/p&gt;

 &lt;h3&gt;Proving termination and guards in books: Making a ``devel&#39;&#39; build&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;&lt;p&gt;[JUST TOUCH ON THIS SECTION]&lt;/p&gt;&lt;/color&gt;

 &lt;p&gt;Just above, we talk about doing proofs during the build.  That is an
 admirable thing to do, but it can be difficult to carry out certain proofs,
 for at least two reasons: the build environment is not interactive, and there
 is no way to include helpful books during the build.  Fortunately, there is a
 procedure for deferring those proofs until after the build is complete.  The
 documentation topic @(see verify-guards-for-system-functions) provides
 details.  &lt;color rgb=&#39;#c00000&#39;&gt;However, after you have some familiarity with
 this procedure you might prefer to follow a script given as a comment in
 @(&#39;*system-verify-guards-alist*&#39;).&lt;/color&gt;&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-maintenance)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-9" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-maintenance
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Modifying, Testing, and Debugging"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;color rgb=&#39;#c00000&#39;&gt;&lt;p&gt;Before working on changes to ACL2, consider
 sending email to the acl2-devel list (@(&#39;acl2-devel@utlists.utexas.edu&#39;)),
 explaining what you have in mind.  This will avoid duplication and also
 provide an opportunity for feedback.  In particular, you may want to wait for
 confirmation from Kaufmann or Moore that at least one of them will be willing
 to review your patch; otherwise they make no commitment to do so, and your
 efforts might be wasted!&lt;/p&gt;&lt;/color&gt;

 &lt;p&gt;Please try to limit your modifications to those that are directly related
 to what you intend to change.  For example, please don&#39;t delete comments in a
 source file or a book.  (If you feel moved to do so, at least first check with
 an author of the file you propose to change.)  That said, it&#39;s certainly it&#39;s
 fine to fix typos.&lt;/p&gt;

 &lt;p&gt;Detailed steps for making a contribution are outlined in the topic, @(see
 developers-guide-contributing).&lt;/p&gt;

 &lt;h3&gt;Development&lt;/h3&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;The first step towards changing ACL2 is typically to create a patch file,
 which here we call @(&#39;patch.lisp&#39;).  It will typically have the following
 shape.&lt;/p&gt;
 &lt;/color&gt;

 @({
 ;;; Github commit hash as of your starting ACL2 version (see below)

 ;;; Comments at the top (perhaps an email thread with a request for the
 ;;; change)

 (redef+)

 &lt;your code&gt;

 (redef-)
 (reset-prehistory) ; optional
 })

 &lt;p&gt;The reason to record the github commit hash is so that Kaufmann and Moore
 can correctly merge in your changes even after there have been several ACL2
 commits.  You can get that hash by running the following command under the
 main ACL2 directory.&lt;/p&gt;

 @({
 git rev-parse HEAD
 })

 &lt;p&gt;Next, start copying into @(&#39;patch.lisp&#39;) the source functions that you want
 to modify.  (As already noted, it is helpful for this process to use
 @(&#39;meta-.&#39;) in Emacs.)  It is often best to keep the functions in order: if
 @(&#39;f&#39;) calls @(&#39;g&#39;) and both are defined (or redefined) in @(&#39;patch.lisp&#39;),
 then the definition of @(&#39;g&#39;) should precede the definition of @(&#39;f&#39;) in
 @(&#39;patch.lisp&#39;).&lt;/p&gt;

 &lt;p&gt;Now modify those source functions and write any additional supporting
 functions that you need.  Try to use existing source functions when possible.
 perhaps finding them by using the Emacs command, @(&#39;meta-x tags-apropos&#39;).
 For example, to find a function that concatenates a list of strings, you could
 run @(&#39;meta-x tags-apropos append&#39;) and then search for @(&#39;string&#39;) in the
 resulting display; you would find @(&#39;string-append-lst&#39;), and you could run
 the Emacs command @(&#39;meta-.&#39;) on that word in order to find its definition in
 the sources, to see if it has the desired functionality.  You may also find it
 useful to consult the documentation topic, @(see system-utilities).&lt;/p&gt;

 &lt;p&gt;If there are further changes that you wish to make to the ACL2 source code
 which are not of the form of function definitions or redefinitions &amp;mdash; for
 example, if you want to add or modify a top-level comment, or put some of the
 new functions in a particular file or a newly created file, etc. &amp;mdash; then
 feel free to add instructions that reflect your intent in comments in
 @(&#39;patch.lisp&#39;), within reason.  We will be reading over @(&#39;patch.lisp&#39;)
 manually, so human-directed comments are welcome &amp;mdash; the exact format of
 @(&#39;patch.lisp&#39;) is not rigid.&lt;/p&gt;

 &lt;h3&gt;Initial testing&lt;/h3&gt;

 &lt;p&gt;Test your patch by starting ACL2 and evaluating the following form in the
 loop (but see below for an exception).  The use of @(&#39;:ld-pre-eval-print&#39;) is
 optional, but can be helpful when debugging since it prints each form before
 evaluating it.&lt;/p&gt;

 @({
 (ld &quot;patch.lisp&quot; :ld-pre-eval-print t)
 })

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;EXCEPTION: the form above may not work if your patch file has any
 occurrences of the @(&#39;acl2-loop-only&#39;) readtime conditional (preceded either
 by @(&#39;#+&#39;) or by @(&#39;#-&#39;)).  In that case, run @(&#39;LP!&#39;) as follows.  NOTE: if
 you are making changes that affect definition processing, then you may need to
 switch the order: first @(&#39;load&#39;), then after @(&#39;(LP!)&#39;), run @(&#39;ld&#39;).&lt;/p&gt;
 &lt;/color&gt;

 @({
 :q
 (LP!)
 (ld &quot;patch.lisp&quot; :ld-pre-eval-print t)
 :q
 (load &quot;patch.lisp&quot;) ; only needed if #-acl2-loop-only occurs in patch.lisp
 (LP)
 })

 &lt;p&gt;Remark (only rarely to be considered).  If efficiency is a concern and you
 are using a Lisp implementation that does not compile on-the-fly (as of this
 writing, that includes Lisps other than CCL and SBCL), then put
 @(&#39;(set-compile-fns t)&#39;) near the top of @(&#39;patch.lisp&#39;), and replace @(&#39;(load
 &quot;patch.lisp&quot;)&#39;) just above by the following (perhaps first adding
 @(&#39;(in-package &quot;ACL2&quot;)&#39;) at the top of @(&#39;patch.lisp&#39;)):&lt;/p&gt;

 @({
 (load &quot;patch.lisp&quot;)
 (compile-file &quot;patch.lisp&quot;)
 (load &quot;patch&quot;)
 })

 &lt;p&gt;Now test your patch.  A quick test could be the following.&lt;/p&gt;

 @({
 (mini-proveall) ; should complete normally
 (ubt! 1) ; back to just after reset-prehistory was evaluated
 })

 &lt;p&gt;You might also want to do your own tests.  In some cases, you could even
 add a book of tests in directory @(&#39;books/system/tests/&#39;).  If the change was
 inspired by problems with a specific event in an existing book, the following
 can be useful.&lt;/p&gt;

 @({
 (ld &quot;foo.port&quot;)
 (rebuild &quot;foo.lisp&quot; t)
 :ubt &lt;bad-event-name&gt;
 &lt;bad-event&gt;
 })

 &lt;h3&gt;Installing and building&lt;/h3&gt;

 &lt;p&gt;When you are satisfied that all is well, take your copy of ACL2 and install
 the patches: for each system function redefined in patch.lisp, replace the
 definition in your copy of the ACL2 sources with the redefinition, preceded by
 new supporting definitions as necessary.  Then in your acl2-sources directory,
 build the system; see @(see developers-guide-build).&lt;/p&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;
 &lt;p&gt;Since ACL2 insists that functions, macros, and constants are introduced
 before they are referenced, you might need to move some definitions around.
 You might even need to move then to ``earlier&#39;&#39; files (see @(see
 developers-guide-background)).  This is normal.  Although a file name like
 ``@(&#39;rewrite.lisp&#39;)&#39;&#39; is suggestive of its contents, and ideally the file
 contains code that reflects the intent of the filename, nevertheless this is
 not a rule; ACL2 implementors often need to move definitions forward in
 support of other functions.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;The following two additional steps are occasionally advisable, especially
 for patches that change definitions that are in @(&#39;:&#39;)@(tsee logic) mode.
 Feel free to ask an ACL2 author if they are necessary; as of this writing,
 that would be Matt Kaufmann, at @(&#39;kaufmann@cs.utexas.edu&#39;).&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;Run ``@(&#39;make proofs&#39;)&#39;&#39;.  That should conclude with the message,
 ``Initialization SUCCEEDED.&#39;&#39;&lt;/li&gt;

 &lt;li&gt;Do a ``devel&#39;&#39; build, regression, and check.  See @(see
 verify-guards-for-system-functions), specifically the six steps at the end of
 the topic.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;h3&gt;Regression testing&lt;/h3&gt;

 &lt;p&gt;Now do a regression test.  The most complete regression is done using the
 @(&#39;regression-everything&#39;) target in the top-level ACL2 sources directory, or
 equivalently, the @(&#39;regression-everything&#39;) target in the @(&#39;books/&#39;)
 directory.  Please install a SAT solver first; see @(see
 satlink::sat-solver-options).&lt;/p&gt;

 &lt;p&gt;Note that the ``@(&#39;regression-everything&#39;)&#39;&#39; level of testing may only work
 for CCL and SBCL; for other Lisps, or for ACL2(p) or ACL2(r), just use the
 @(&#39;regression&#39;) target in the top-level ACL2 sources directory or,
 equivalently, the @(&#39;all&#39;) target in the @(&#39;books/&#39;) directory.  This could
 take a few hours &amp;mdash; perhaps more than 5 hours or even more than 8 hours,
 depending on the Lisp and the machine.  But feel free to do only a
 @(&#39;regression-everything&#39;) regression for ACL2 using CCL or SBCL, ignoring
 ACL2(p) and ACL2(r).&lt;/p&gt;

 @({
 make clean-books ; \
 (time nice make -j 8 regression-everything) &gt;&amp; make-regression-everything.log&amp;
 })

 &lt;p&gt;A search for @(&#39;**&#39;) in the log will determine whether there have been any
 failures; equivalently, in most cases, a failure has occurred when there is a
 non-zero exit status.&lt;/p&gt;

 &lt;p&gt;&lt;color rgb=&#39;#c00000&#39;&gt;It is a good idea to keep a record of the time it
 takes to complete a regression&lt;/color&gt; using a given host Lisp and a given
 value for the @(&#39;-j&#39;) argument of `@(&#39;make&#39;)&#39;.  If there is a jump of more
 than a percent or two that is not attributable to book changes, then perhaps
 the change is degrading performance.  Of course, that time increase could be
 noise; we have observed significantly more reliable timings, for example, on
 Linux than on Mac.  There are wonderful tools @(&#39;books/build/critpath.pl&#39;) and
 @(&#39;books/build/compare.pl&#39;) for narrowing time increases to the level of
 individual books, which you can investigate interactively, for example using
 profiling; see @(see profile-acl2) and @(see profile-all).  (Also, Allegro CL
 has a particularly nice statistical profiler.)  Here is the first step, to be
 run in two ACL2 directories, @(&#39;DIR1&#39;) and @(&#39;DIR2&#39;), that you want to compare
 after having run a regression test in each.&lt;/p&gt;

 @({
 cd books
 find . -name &#39;*.cert.time&#39; -print | sed &#39;s/[.]time$//&#39; | sort &gt; certs.txt
 ./build/critpath.pl -t certs.txt --write-costs timingfile &gt; timing.txt
 })

 &lt;p&gt;Then run the following command anywhere, which produces a file
 @(&#39;compare.txt&#39;) showing results, sorted two different ways.&lt;/p&gt;

 @({
 &lt;path_to_acl2&gt;/books/build/compare.pl \
   DIR1/books/timingfile \
   DIR2/books/timingfile &gt; compare.txt
 })

 &lt;h3&gt;Documentation&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;&lt;p&gt;[JUST TOUCH ON THIS SECTION]&lt;/p&gt;&lt;/color&gt;

 &lt;p&gt;Be sure to document your changes.  This will typically involve adding a
 release note to a topic like @(see note-8-2).  The XDOC source code
 documentation for ACL2 resides in the community book
 @(&#39;books/system/doc/acl2-doc.lisp&#39;).  If the change is not user visible, then
 a Lisp comment in the corresponding @(&#39;defxdoc&#39;) form is probably best; the
 existing @(&#39;(defxdoc note-xxx ...)&#39;) forms can provide guidance on this.
 Minor output changes don&#39;t generally require any release note.  Be sure to
 keep the @(see XDOC) documentation at a user level, not at the level of the
 implementation.  Note that it is good practice to explain your changes as
 noted above &amp;mdash; that is, in the text or comments of a @(tsee defxdoc)
 release note form &amp;mdash; rather than merely in GitHub commit messages.
 Every user should be able to find changes documented in the release notes, and
 every developer should additionally be able to find pertinent Lisp comments;
 neither will necessarily look back in GitHub logs (some may, but some may
 not).&lt;/p&gt;

 &lt;p&gt;If your changes are related to @(see community-books), consider adding
 links to topics defined in those books as described in the ``Remark for
 Experienced Users&#39;&#39; in the documentation topic, @(see documentation).&lt;/p&gt;

 &lt;p&gt;Also be sure to comment your code well with Lisp comments, at an
 implementation level.  For example, don&#39;t say ``union is commutative&#39;&#39; without
 explaining that you mean this with respect to set equality, not
 ordinary (Lisp) equality.&lt;/p&gt;

 &lt;p&gt;Whoever actually commits and pushes to github &amp;mdash; just Kaufmann and
 Moore as of this writing, but ideally others in the future &amp;mdash; should also
 synchronize generated ACL2 source file @(&#39;doc.lisp&#39;) (see @(see
 developers-guide-build)) with @(&#39;books/system/doc/acl2-doc.lisp&#39;).&lt;/p&gt;

 &lt;p&gt;When you add new documentation in community book
 @(&#39;books/system/doc/acl2-doc.lisp&#39;) for a symbol that is the name of a
 function, macro, or constant, there is a check in the community book
 @(&#39;books/misc/check-acl2-exports.lisp&#39;) that the symbol belongs to the list,
 @(&#39;*acl2-exports*&#39;).  Rather than add the symbol immediately to that list,
 however, it may be best to override the check for that symbol, as indicated in
 the definition of the constant, @(&#39;*acl2-exports-exclusions*&#39;), in
 @(&#39;books/misc/check-acl2-exports.lisp&#39;).  The reason for this delay is that if
 you change @(&#39;*acl2-exports*&#39;), many books may need to be recertified, which
 could be inconvenient for users.  This issue is documented in the definition
 of the constant @(tsee *acl2-exports*); see the ``WARNING&#39;&#39; comment there.&lt;/p&gt;

 &lt;h3&gt;Debugging&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;&lt;p&gt;[JUST TOUCH ON THIS SECTION]&lt;/p&gt;&lt;/color&gt;

 &lt;p&gt;The art of debugging is... an art.  Some tools that can help with debugging
 are @(tsee trace$), @(tsee trace!), @(tsee break-on-error), @(tsee
 set-debugger-enable), @(tsee walkabout), @(see iprinting), and (rarely) @(tsee
 disassemble$).  Also see @(see debugging).&lt;/p&gt;

 &lt;p&gt;A common way to debug an unexpected error is to invoke
 @(&#39;(set-debugger-enable t)&#39;) and @(&#39;(break-on-error)&#39;).  This may put you in
 the debugger when there is an error.  Each host Lisp has its own debugger
 commands for looking at the backtrace; for example, in CCL the command is
 @(&#39;:b&#39;), while in SBCL it is @(&#39;backtrace&#39;).  CCL&#39;s debugger lets you easily
 explore individual forms in the backtrace.  &lt;color rgb=&#39;#c00000&#39;&gt;Here is an
 edited log showing how that works.&lt;/color&gt;&lt;/p&gt;

 @({
 ACL2 !&gt;(defun f (x) (declare (xargs :mode :program)) (car x))

 Summary
 Form:  ( DEFUN F ...)
 Rules: NIL
 Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
  F
 ACL2 !&gt;(set-debugger-enable t)
 &lt;state&gt;
 ACL2 !&gt;(f 3)

 &gt; Error: Fault during read of memory address #x1D
 &gt; While executing: F, in process listener(1).
 &gt; Type :GO to continue, :POP to abort, :R for a list of available restarts.
 &gt; If continued: Skip evaluation of (acl2::acl2-default-restart)
 &gt; Type :? for other options.
 1 &gt; :b
 *(25819710) : 0 (F 3) 16
  (25819770) : 1 (RAW-EV-FNCALL F (3) (&#39;3) ((STATE . ACL2_INVISIBLE::|The Live State Itself|)) ((COMMAND-LANDMARK GLOBAL-VALUE 7662 # &quot;/Users/kaufmann/acl2/acl2-git-scratch/books/system/doc/&quot;) (EVENT-LANDMARK GLOBAL-VALUE 9539 DEFUN F ...) (F ABSOLUTE-EVENT-NUMBER . 9539) (CLTL-COMMAND GLOBAL-VALUE DEFUNS :PROGRAM NIL ...) (TOP-LEVEL-CLTL-COMMAND-STACK GLOBAL-VALUE #) ...) NIL NIL T) 1253
  (25819840) : 2 (EV (F &#39;3) ((STATE . ACL2_INVISIBLE::|The Live State Itself|)) ACL2_INVISIBLE::|The Live State Itself| ((STATE . ACL2_INVISIBLE::|The Live State Itself|)) NIL T) 357

 &lt;&lt;... etc. ...&gt;&gt;

  (25819F98) : 21 (FUNCALL #&#39;#&lt;(:INTERNAL CCL::THREAD-MAKE-STARTUP-FUNCTION)&gt;) 277
 1 &gt; (:form 1) ; show the form labeled with 1 in the backtrace
 (RAW-EV-FNCALL &#39;F &#39;# &#39;# &#39;# ...)
 1 &gt; (walkabout (unquote (nth 5 *)) state) ; world

 Commands:
 0, 1, 2, ..., nx, bk, pp, (pp n), (pp lev len), =, (= symb), and q.

 ((COMMAND-LANDMARK GLOBAL-VALUE 7662 ...)
  (EVENT-LANDMARK GLOBAL-VALUE 9539 ...)
  (F ABSOLUTE-EVENT-NUMBER . 9539)
  ...)
 :
 })

 &lt;p&gt;Some problems are, of course, more awkward to debug.  One that pops up from
 time to time is an error like this.&lt;/p&gt;

 @({
    &gt; Error: value NIL is not of the expected type NUMBER.
    &gt; While executing: CCL::+-2, in process listener(1).
 })

 &lt;p&gt;That particular sort of error may indicate that the @(&#39;state&#39;) argument of
 some function was passed incorrectly, perhaps in the wrong argument
 position.&lt;/p&gt;

 &lt;p&gt;In rare cases an error may occur for which the backtrace isn&#39;t helpful or
 even makes little sense.  Something to try is to build with safety 3, for
 example as follows.&lt;/p&gt;

 @({
 make ACL2_SAFETY=3 PREFIX=safety-3-
 })

 &lt;p&gt;If your test case involves including books, then also clean the books or
 use @(tsee set-compiler-enabled) to avoid loading their compiled files.  Then
 try again with the new executable; of course, if you cleaned the books, then
 first recertify as appropriate using the new executable.  ACL2 will run more
 slowly, but in return it will do a lot more checking along the way and might
 well provide a much better backtrace than before.&lt;/p&gt;

 &lt;p&gt;If you are reading this and have more debugging suggestions, by all means
 consider adding them here!&lt;/p&gt;

 &lt;h3&gt;Finishing up&lt;/h3&gt;

 &lt;p&gt;Now feel free to send all changed files and also the starting git commit
 hash (or even the entire patch file, too) for review, to whoever has offered
 to look at your patch!  Some day others besides Kaufmann and Moore may be
 authorized to commit and push source code changes directly to GitHub; but
 getting someone else to review the changes could still be a good thing to
 do.&lt;/p&gt;

 &lt;p&gt;When you are ready to have your patch incorporated into ACL2, follow the
 detailed steps for making a contribution outlined in the topic, @(see
 developers-guide-contributing).&lt;/p&gt;

 &lt;h3&gt;General guidance&lt;/h3&gt;

 &lt;p&gt;We close this chapter with some relevant tips and observations, some of
 which may also be found elsewhere in this Guide.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;&lt;color rgb=&#39;#c00000&#39;&gt;Small examples help when testing new features or bug fixes.&lt;/color&gt;  For a bug fix
 it is important to have an example that exhibits the bug, both to guarantee
 that there really is a problem and to use to test your patch.  Ideally the
 example will be small, as this is useful for reading the output from tracing
 functions or debugger backtraces, and small examples are often helpful for
 understanding the problem.  Consider adding one or more relevant tests to
 @(&#39;books/system/tests/&#39;) or perhaps, if appropriate, @(&#39;books/demos/&#39;).&lt;/li&gt;

 &lt;li&gt;&lt;color rgb=&#39;#c00000&#39;&gt;Often it is best to avoid making a more sweeping change than necessary,
 instead waiting for users to complain.&lt;/color&gt;  This process has several advantages:
 it avoids needless code complications; the user&#39;s complaint may help to inform
 the nature of the additional changes; and it may take significantly less time
 to complete the implementation, especially if there is a simple fix that is
 clearly correct and solves the problem.&lt;/li&gt;

 &lt;li&gt;&lt;color rgb=&#39;#c00000&#39;&gt;Look for precedents&lt;/color&gt;, since new code is probably more likely to be correct
 to the extent it is analogous to existing code.  ACL2 is a complex system with
 invariants that are not always explicit, so to the extent that you can follow
 the existing implementation of some feature, you may avoid introducing bugs or
 undesirable behavior.  For example, if you want to add a new key to the @(tsee
 acl2-defaults-table), find an existing such key and do a tags-search for it,
 and mimic the implementation of that existing key to the extent it makes
 sense.  Try to pick a key that is little-used, so that the tags-search mainly
 hits on the essential aspects of being a key in the @(&#39;acl2-defaults-table&#39;).
 For another example: to arrange for adding @(tsee system-attachments) to the
 @(see summary), the process was to follow how @(&#39;hint-events&#39;) is put into the
 summary, so a first step was to do tags-search for ``@(&#39;hint-events&#39;)&#39;&#39;.&lt;/li&gt;

 &lt;li&gt;At what point during the development of a source code change is it best to
 write comments and user-level documentation?  It may be good to write an
 outline before coding, as a guide towards what you want.  But ACL2
 implementation work can be tricky, which may lead you to change the
 specification slightly; so it is probably best to leave detailed documentation
 until after the other work is done, including testing.&lt;/li&gt;

 &lt;li&gt;&lt;color rgb=&#39;#c00000&#39;&gt;Expect to take considerable time writing comments,
 documentation, and output (e.g., for warnings and errors).&lt;/color&gt; These are
 important and may take longer than the implementation work itself.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-contributing)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-10" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-contributing
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Contributing changes"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: This is just a draft.  Suggestions for improvements
 would be great; please send them to kaufmann@cs.utexas.edu&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;IMPORTANT&lt;/b&gt;: Before reading this topic, be sure to read the topic,
 @(see developers-guide-maintenance).  The present topic assumes that you have
 followed the process there to make changes in your copy of ACL2 and the @(see
 community-books), including testing and documentation.  Here are the steps for
 contributing your changes when they are complete and fully tested and
 documented.&lt;/p&gt;

 &lt;ol&gt;

 &lt;li&gt;Create your modifications by following the processes outlined in the
 topic, @(see developers-guide-maintenance).  Have you added at least one
 release note item?  If not, then please look again at the topic, @(see
 developers-guide-maintenance), where that and other prerequisites are
 covered.&lt;/li&gt;

 &lt;li&gt;Create a tarball that contains your changes that are &lt;i&gt;NOT&lt;/i&gt; under the
 @(&#39;books/&#39;) directory.  For example, if (as is typical) those changes are all
 in the top-level ACL2 @(&#39;*.lisp&#39;) source files, you can do the following while
 standing in the ACL2 sources directory:
 @({
 tar cfz acl2-sources.tgz *.lisp
 })&lt;/li&gt;

 &lt;li&gt;Create a git branch on your local machine, called @(&#39;my-branch&#39;) below
 (but give it a more descriptive name, for example, @(&#39;true-list-fix&#39;)):
 @({
 git checkout -b my-branch
 })&lt;/li&gt;

 &lt;li&gt;Commit your updates that are under @(&#39;books/&#39;), but &lt;i&gt;ONLY&lt;/i&gt; those
 updates.  Be sure that the file with your commit message, @(&#39;tmp.msg&#39;) (or
 whatever you decide to call it, but below it is called @(&#39;tmp.msg&#39;)),
 describes your changes to the books.  The description can generally be brief
 (use @(&#39;git log&#39;) if you want to see examples), often quoting your new release
 note item.
 @({
 git add books
 git commit -F tmp.msg
 })&lt;/li&gt;

 &lt;li&gt;Create your own GitHub fork if you don&#39;t already have one (for example, as
 explained in the documentation topic, @(see
 github-commit-code-using-pull-requests), Section (A)).  Assuming your GitHub
 username is @(&#39;my-username&#39;) and (again) your branch name is @(&#39;my-branch&#39;),
 this should make your branch publicly accessible at the following URL: @({
 https://github.com/my-username/acl2/tree/my-branch })&lt;/li&gt;

 &lt;li&gt;Push to your own GitHub fork, as follows:
 @({
 git push https://github.com/my-username/acl2 my-branch
 })&lt;/li&gt;

 &lt;li&gt;Send the commit hash and tarball (see ``Create a tarball&#39;&#39; above), as well
 as the name and URL of your new branch (as discussed above), to an ACL2
 author.  Optionally also send the commit hash for the version of master that
 was your starting point.  As of this writing, those are to be sent to Matt
 Kaufmann, at @(&#39;kaufmann@cs.utexas.edu&#39;).&lt;/li&gt;

 &lt;li&gt;The last steps will be done by Matt, who will start by getting your
 changes as follows, in a fresh directory.

 @({
 git clone https://github.com/acl2/acl2 .
 git fetch https://github.com/my-username/acl2 my-branch:my-branch
 git checkout my-branch
 })

 Note that after the @(&#39;checkout&#39;) command just above, @(&#39;my-branch&#39;) will
 contain only your changes.  Matt will then install your source code
 changes (from the tarball) into the branch, @(&#39;my-branch&#39;), possibly make some
 edits, and run &amp;lsquo;@(&#39;make regression-everything&#39;)&amp;rsquo;.  When this
 passes, Matt will run the following two commands, where @(&#39;tmp.msg&#39;) says
 something about the changes, with credit to you.  Note that the @(&#39;commit&#39;)
 command will cause @(&#39;my-branch&#39;) to contain all changes, both under
 @(&#39;books/&#39;) and from the sources tarball, possibly after edits from Matt.
 NOTE: Matt might instead decide not to make any edits or run a regression
 before doing this, in which case he will do those things after the merge
 below, as noted below.

 @({
 git commit -a -F tmp.msg
 })

 Finally, Matt will run a @(&#39;merge&#39;) command so that @(&#39;master&#39;) contains all
 changes (both from @(&#39;books/&#39;) and from outside @(&#39;books/&#39;)), and then
 complete the update to @(&#39;master&#39;) in the GitHub repository.

 @({
 git checkout master
 # Get master up-to-date (this is just ``git pull&#39;&#39; with a check):
 bin/pull.sh
 git merge my-branch
 # Possibly run ``regression-everything&#39;&#39; before the final push just
 # below.  In fact this is critical if that wasn&#39;t done before.  There
 # may be additional edits and additional commits to master before the
 # push just below.
 git push https://github.com/acl2/acl2 master
 })&lt;/li&gt;
 &lt;/ol&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-utilities)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-11" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-utilities
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Data Structures and Utilities"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This topic introduces some of the data structures and utilities
 built into ACL2.  Also see @(see system-utilities) and @(see
 programming-with-state).  Those topics have lots of useful information not
 covered in this overview topic.  Just to give one example: someone once needed
 a utility to print clauses nicely, so the utility @(&#39;prettyify-clause&#39;), not
 mentioned below, was added to the list of utilities in @(see
 system-utilities).&lt;/p&gt;

 &lt;h3&gt;@(csee State) and the logical @(see world).&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;Much of this is covered in @(see developers-guide-background).&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;The @(&#39;state&#39;) is, logically, a data structure with many fields.  However,
 it is represented in ACL2 by a symbol, which is the value of
 @(&#39;*the-live-state*&#39;):&lt;/p&gt;

 @({
 ACL2 !&gt;:q

 Exiting the ACL2 read-eval-print loop.  To re-enter, execute (LP).
 ? state
 ACL2_INVISIBLE::|The Live State Itself|
 ? *the-live-state*
 ACL2_INVISIBLE::|The Live State Itself|
 ?
 })

 &lt;p&gt;For technical reasons involving (as best recalled at this writing) tail
 recursion removal in some host Lisps, @(&#39;state&#39;) is not declared as a Common
 Lisp special variable.  So raw Lisp code (say, conditioned by
 @(&#39;#-acl2-loop-only&#39;)) should reference @(&#39;*the-live-state*&#39;) when @(&#39;state&#39;)
 is not lexically bound, to avoid compiler warnings.&lt;/p&gt;

 @({
 ? (defun foo () state)
 ;Compiler warnings :
 ;   In FOO: Undeclared free variable STATE
 FOO
 ? (defun foo () *the-live-state*)
 FOO
 ?
 })

 &lt;p&gt;As discussed in an earlier chapter of this Guide (see @(see
 developers-guide-background)), a key logical field of @(&#39;state&#39;) is the
 @(&#39;global-table&#39;), which is an alist associating state global variables with
 their values.  Also see @(see programming-with-state), which explains this
 idea further along with many other key data structures and programming idioms
 that pertain to @(&#39;state&#39;).&lt;/p&gt;

 &lt;p&gt;The logical world is the value of state global variable
 @(&#39;current-acl2-world&#39;), but is normally accessed using the function,
 @(&#39;w&#39;).&lt;/p&gt;

 @({
 ACL2 !&gt;(equal (f-get-global &#39;current-acl2-world state)
               (w state))
 T
 ACL2 !&gt;(set-guard-checking nil)

 Masking guard violations but still checking guards except for self-
 recursive calls.  To avoid guard checking entirely, :SET-GUARD-CHECKING
 :NONE.  See :DOC set-guard-checking.

 ACL2 &gt;(eq (f-get-global &#39;current-acl2-world state)
           (w state))
 T
 ACL2 &gt;
 })

 &lt;h3&gt;Enabled structures&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;THIS SECTION IS WORTH COVERING IN ITS ENTIRETY.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;ACL2 handles @(see theories) using &lt;i&gt;enabled structures&lt;/i&gt;.  Ideally you
 could learn about enabled structures by visiting the @(tsee defrec) form for
 @(&#39;enabled-structure&#39;).  As of this writing, there are virtually no comments
 in that @(&#39;defrec&#39;) form!  Fortunately, the field names are suggestive of
 their meaning; but that is not really adequate documentation.  This is one of
 those place in the ACL2 sources where additional comments would be useful.  In
 the meantime, you can learn about enabled structures by seeing how they are
 used, by doing an Emacs tags-search for ``@(&#39;enabled-structure&#39;)&#39;&#39; or perhaps
 ``@(&#39;(access enabled-structure&#39;)&#39;&#39;.  Another option is to follow the
 definition of @(&#39;disabledp&#39;) to find the definition of @(&#39;enabled-runep&#39;),
 where you&#39;ll see that @(&#39;(enabled-runep rune ens wrld)&#39;) is
 @(&#39;(enabled-numep (fnume rune wrld) ens)&#39;).  Note that @(&#39;ens&#39;) is a variable
 that is commonly used for enabled structures, and @(&#39;fnume&#39;) returns the
 &lt;i&gt;nume&lt;/i&gt; of a @(see rune), which is a unique number corresponding to the
 rune.  The definition of @(&#39;enabled-numep&#39;) helps to explain the fields of an
 enabled structure.&lt;/p&gt;

 @(def enabled-numep)

 &lt;p&gt;An ACL2 developer sometimes needs to be able to follow definitions like
 this to learn about ACL2 data structures &amp;mdash; sad, but true.&lt;/p&gt;

 &lt;h3&gt;Tag trees&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;PERHAPS WE&#39;LL JUST LOOK AT A CALL OF PUSH-LEMMA IN REWRITE.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;A &lt;i&gt;tag tree&lt;/i&gt;, or &lt;i&gt;ttree&lt;/i&gt; (pronounced ``tee-tree&#39;&#39;), is a
 structure that is used for recording information generated by the prover.
 There is no @(&#39;defrec&#39;) form for tag trees, but fortunately, there is a long
 comment in the ACL2 sources labeled ``; Essay on Tag-Trees&#39;&#39;.  Here is a
 high-level introduction that may be helpful before you read that Essay.&lt;/p&gt;

 &lt;p&gt;Abstractly a tag-tree represents a list of sets, each member set having a
 name given by one of the ``tags&#39;&#39; (which are symbols) of the ttree.  The
 elements of the set named @(&#39;tag&#39;) are all of the objects tagged @(&#39;tag&#39;) in
 the tree.  Definitions of primitives in the source code for manipulating tag
 trees are labeled with the comment ``; Note: Tag-tree primitive&#39;&#39;.&lt;/p&gt;

 &lt;p&gt;Many ACL2 prover functions take and return tag trees.  The function
 @(&#39;rewrite&#39;), for example, takes a @(see term) and a ttree (among other
 things), and returns a new term, @(&#39;term&#39;&#39;), and new ttree, @(&#39;ttree&#39;&#39;).
 @(&#39;Term&#39;&#39;) is provably equivalent to the input term (under the current
 assumptions) and @(&#39;ttree&#39;&#39;) is an extension of the input ttree.  If we focus
 just on the set associated with the tag @(&#39;LEMMA&#39;) in the ttrees, then the set
 for @(&#39;ttree&#39;&#39;) is the extension of that for the input ttree, which is
 obtained by unioning into it all the @(see rune)s used by the rewriter.  The
 set associated with tag @(&#39;LEMMA&#39;) can be obtained by @(&#39;(tagged-objects
 &#39;LEMMA ttree)&#39;).  Tag trees contain useful prover information based not only
 on lemmas used but also on hints, assumptions generated by @(tsee force),
 @(see forward-chaining), and so on.  It is critical not to avoid tag trees
 that contain assumptions (see @(see developers-guide-pitfalls)).&lt;/p&gt;

 &lt;p&gt;The Essay on Tag-Trees describes some of the legal tags for a ttree, but
 the definitive list is the one enforced by function
 @(&#39;all-runes-in-ttree&#39;).  Here for example is an interesting clause from a
 @(tsee case) expression in the body of that definition.&lt;/p&gt;

 @({
            (assumption
 ; Shape: assumption record
             ans)
 })

 &lt;p&gt;If you see this, then you might be curious about the notion of an
 ``assumption record&#39;&#39;.  Then you can simply go to the definition of
 @(&#39;assumption&#39;) (typically, using the Emacs command, @(&#39;meta-.&#39;)).  You&#39;ll see
 quite a few lines of comments in that vicinity, which may help to get your
 head around these records.&lt;/p&gt;

 &lt;h3&gt;Macros&lt;/h3&gt;

 &lt;p&gt;Many macros that are useful in the ACL2 source code are also helpful to
 users, and hence are documented.  Among these are @(tsee defrec) (already
 discussed in the chapter, @(see developers-guide-background))), @(tsee
 defabbrev), @(tsee er-progn), @(tsee pprogn), @(tsee state-global-let*), and
 @(tsee revert-world).  Others could reasonably have their own documentation
 topics but are discussed in other topics; for example, see @(see
 programming-with-state) for a discussion of @(tsee er-let*).  Still others are
 not mentioned in the xdoc documentation but have Lisp comments in the source
 code, for example, @(&#39;revert-world-on-error&#39;), @(&#39;with-ctx-summarized&#39;),
 @(&#39;io?&#39;), and @(&#39;acl2-unwind-protect&#39;).  Perhaps the best way to learn about
 the variety of available macros for ACL2 system programming is to notice their
 usage in existing ACL2 source code, then looking them up in the xdoc
 documentation and/or in the source code (typically with the Emacs command,
 @(&#39;meta-.&#39;)).&lt;/p&gt;

 &lt;h3&gt;Evaluators&lt;/h3&gt;

 &lt;p&gt;Source code often contains calls that evaluate terms.  A prime example is
 the implementation of the read-eval-print loop, as explained in the chapter,
 @(see developers-guide-background).  There are several evaluators available.
 The most familiar to users may be @(tsee trans-eval), which is actually a
 combination of translation and evaluation.  If you look at the source code and
 drill down (following definitions) from @(&#39;trans-eval&#39;), you&#39;ll see that there
 are several optimizations, in part to support lazy treatment of @(&#39;if&#39;) calls:
 based on the test, perhaps only one of the two branches will need to be
 translated, let alone evaluated.  If you keep drilling down, you may
 ultimately see a call of @(&#39;ev&#39;), which is an evaluator for (translated)
 terms.  In a sense @(&#39;ev&#39;) is the most basic term evaluator.  Note that
 @(&#39;ev&#39;) takes and returns @(&#39;state&#39;).  A related evaluator, @(&#39;ev-w&#39;), may be
 used if @(&#39;state&#39;) and @(&#39;stobjs&#39;) are not involved.&lt;/p&gt;

 &lt;p&gt;There is more to evaluation, such as the handling of stobjs via so-called
 ``latches&#39;&#39; and the @(&#39;user-stobj-alist&#39;), which pertain to the subtle notion
 that user-defined stobjs are actually part of the ACL2 state; you can read
 comments in the sources to learn more about that when the need arises.  Also
 see the chapter, @(see developers-guide-evaluation).&lt;/p&gt;

 &lt;h3&gt;Using @(tsee return-last)&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;THIS SECTION IS WORTH COVERING IN ITS ENTIRETY.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;There are occasions in which a utility is naturally defined as a function
 in ACL2 but as a macro in Common Lisp.  Consider @(tsee mbe).  Even though
 @(&#39;mbe&#39;) is itself a macro, it must expand to a function call involving its
 @(&#39;:logic&#39;) and @(&#39;:exec&#39;) arguments, so that a suitable @(see guard) proof
 obligation can be generated.  However, in raw Lisp we want an @(&#39;mbe&#39;) call to
 be fast, by simply running the @(&#39;:exec&#39;) argument.  Let&#39;s see how this is all
 arranged.&lt;/p&gt;

 @({
 ACL2 !&gt;:trans (mbe :logic (zp n) :exec (= n 0))

 (RETURN-LAST &#39;MBE1-RAW (= N &#39;0) (ZP N))

 =&gt; *

 ACL2 !&gt;:q

 Exiting the ACL2 read-eval-print loop.  To re-enter, execute (LP).
 ? (macroexpand &#39;(mbe :logic (zp n) :exec (= n 0)))
 (= N 0)
 T
 ?
 })

 &lt;p&gt;The key, obviously, is to use @(tsee return-last), which is the &lt;i&gt;only&lt;/i&gt;
 ACL2 utility that is defined to be a function in the ACL2 loop but is defined
 to be a macro in raw Lisp.  Before you add a new utility that, like @(&#39;mbe&#39;),
 needs to operate as a function in the ACL2 loop but as a macro in raw Lisp,
 commit yourself to defining it using @(&#39;return-last&#39;).  The reason is that
 handling any such utility is tricky (see for example the definition of
 @(&#39;ev-rec-return-last&#39;)), so it would be ill-advised to replicate all the work
 done already for @(&#39;return-last&#39;) in handling any additional such utility.  Of
 course, the first step then is to become familiar with @(&#39;return-last&#39;).  The
 xdoc documentation on @(see return-last) is quite extensive, and may suffice;
 of course, it is also advisable to read the comments in the source code
 definition of @(&#39;return-last&#39;).&lt;/p&gt;

 &lt;p&gt;The use of @(&#39;return-last&#39;) provides an example of the suggestion to use
 precedents (see @(see developers-guide-maintenance)).  Imagine that you want
 to add a function to ACL2 that is implemented under-the-hood as a macro in raw
 Lisp.  Ideally, you would look at an existing such utility, such as @(&#39;mbe&#39;),
 to see how it is implemented.  This would lead you to @(&#39;return-last&#39;), which
 you would then use similarly to implement your new utility.&lt;/p&gt;

 &lt;h3&gt;Type-alists&lt;/h3&gt;

 &lt;p&gt;A fundamental data structure in the ACL2 prover is the &lt;i&gt;type-alist&lt;/i&gt;.
 Since some user-level utilities display the type-alist, there is user-level
 documentation for this data structure; see @(see type-alist), which contains
 important system-level background.  Perusal of the source code will reveal
 utilities for computing with type-alists.  Two key such utilities are
 @(&#39;type-set&#39;), which computes the type-set of a term with respect to a given
 type-alist, and which again has user-level documentation (see @(see type-set))
 that also serves to provide important system-level background; and
 @(&#39;assume-true-false&#39;), which extends a type-alist as one dives into the true
 or false branch of a call of @(&#39;IF&#39;).  Before creating type-alists with
 lower-level or new utilities, be sure to &lt;color rgb=&#39;#c00000&#39;&gt;read the ``Essay
 on the Invariants on Type-alists, and Canonicality&lt;/color&gt;.&#39;&#39;  In general,
 look for essays on any topic that is relevant to changes that you are making,
 unless you are reasonably confident that the essay is at a lower level than
 you need.  For example, &lt;color rgb=&#39;#c00000&#39;&gt;if you call
 @(&#39;assume-true-false&#39;) to extend an existing type-alist, then you are using a
 well-worn interface and you needn&#39;t be concerned about the well-formedness of
 the resulting type-alists&lt;/color&gt;.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-logic)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-12" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-logic
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Logical Considerations"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This Developer&#39;s Guide may give the impression that ACL2
 maintenance is primarily a programming exercise, and that is probably true.
 However, &lt;color rgb=&#39;#c00000&#39;&gt;there are some subtle logical
 considerations&lt;/color&gt; that need to be considered when working with some parts
 of the implementation.  This topic addresses an assortment of such
 considerations, often by pointing to source code comments.  Additional reading
 for those intrigued by logic is the paper: ``Structured Theory Development for
 a Mechanized Logic,&#39;&#39; Matt Kaufmann and J Strother Moore, Journal of Automated
 Reasoning 26, no. 2 (2001), pp. 161--203.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;color rgb=&#39;#c00000&#39;&gt;The examples below are by no means
 comprehensive!&lt;/color&gt; You are encouraged to extend this documentation topic
 with additional logical considerations as they arise.  Also see the Essay on
 Soundness Threats.&lt;/p&gt;

 &lt;h3&gt;Histories, chronologies, and theories&lt;/h3&gt;

 &lt;p&gt;An ACL2 session has at least three logical interpretations, as follows.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;The corresponding &lt;color rgb=&#39;#c00000&#39;&gt;&lt;i&gt;history&lt;/i&gt;&lt;/color&gt;, which is
 the sequence of all &lt;i&gt;axiomatic @(see events)&lt;/i&gt; from the session: this
 includes @(tsee defun), @(tsee defchoose), and @(tsee defaxiom) events, as
 well as @(tsee encapsulate) events with non-empty @(see signature)s.  It does
 not include @(tsee defthm) events.&lt;/li&gt;

 &lt;li&gt;The corresponding &lt;color rgb=&#39;#c00000&#39;&gt;&lt;i&gt;chronology&lt;/i&gt;&lt;/color&gt;, which is
 the sequence of all events from the session with logical content.  Thus the
 history is a subsequence of the chronology, but the chronology also includes
 @(&#39;defthm&#39;) events.&lt;/li&gt;

 &lt;li&gt;The corresponding &lt;color rgb=&#39;#c00000&#39;&gt;&lt;i&gt;theory&lt;/i&gt;&lt;/color&gt; of the
 session, which is the first-order theory of its history, that is, axiomatized
 by the formulas in its history.  (Careful: This theory is not sensitive to
 which runes are enabled, unlike the macro, @(tsee current-theory).)  A basic
 property of ACL2 is that all formulas in the session&#39;s chronology are provable
 in the session&#39;s theory.  In particular, by restricting to the chronology of
 events up to and including a given @(&#39;defthm&#39;) event, we see that the formula
 of that event is provable from the axiomatic events that precede it.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;

 &lt;p&gt;When a session @(&#39;S1&#39;) is extended to a session @(&#39;S2&#39;) without using
 @(&#39;defaxiom&#39;) events, then the theory @(&#39;T2&#39;) for @(&#39;S2&#39;) is a &lt;i&gt;conservative
 extension&lt;/i&gt; of the theory @(&#39;T1&#39;) for @(&#39;S1&#39;): that is, every theorem of
 @(&#39;T2&#39;) whose function symbols all occur in @(&#39;T1&#39;) &amp;mdash; that is, are all
 introduced in @(&#39;S1&#39;) &amp;mdash; is a theorem of @(&#39;T1&#39;).  An important corollary
 is that if a session has no @(&#39;defaxiom&#39;) events, then its theory is
 consistent.&lt;/p&gt;

 &lt;/color&gt;

 &lt;p&gt;Note that @(tsee defattach) events are ignored for all three notions listed
 above.  There is also a notion of &lt;i&gt;evaluation theory&lt;/i&gt;, which is the
 extension of the session&#39;s theory by the equations that equate each function
 with its attachment.  A basic property is that every evaluation theory built
 from a session free of @(&#39;defaxiom&#39;) events is the theory of some history that
 is free of @(&#39;defaxiom&#39;) events, and thus (by the corollary stated in the
 preceding paragraph) is consistent.  For a detailed development of theory
 supporting the use of @(&#39;defattach&#39;) (though this can probably ignored unless
 you are doing deep work with @(&#39;defattach&#39;)), see the source code comment,
 ``Essay on Defattach.&#39;&#39;&lt;/p&gt;

 &lt;p&gt;There is also a logical explanation for @(tsee apply$), which is based on
 the notion of evaluation theory mentioned above for @(&#39;defattach&#39;).  The
 upshot is that a certain construction, the ``doppelganger construction&#39;&#39;,
 produces an evaluation theory in which every @(see warrant) is valid.  For
 detailed theoretical justification (probably not necessary for most
 developers, unless perhaps they are doing deep modifications pertaining to
 @(&#39;defattach&#39;) or @(&#39;apply$&#39;)), see the source code comment, ``Essay on
 Admitting a Model for Apply$ and the Functions that Use It.&#39;&#39;&lt;/p&gt;

 &lt;h3&gt;@(tsee Local)&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;IN THIS SECTION WE CAN FOCUS MAINLY ON THE DISPLAYS.&lt;/p&gt;
 &lt;/color&gt;

 &lt;color rgb=&#39;#c00000&#39;&gt;

 &lt;p&gt;Many soundness bugs in past versions of ACL2 &amp;mdash; indeed, perhaps the
 majority of them &amp;mdash; can be attributed to a subtle mishandling of @(tsee
 local) @(see events).  Perhaps the only advice possible in this regard is the
 following: Think carefully about the effects of @(&#39;local&#39;) when making
 event-level changes to ACL2!&lt;/p&gt;

 &lt;/color&gt;

 &lt;p&gt;Consider for example the following, seemingly innocuous ``enhancement&#39;&#39;:
 allow @(tsee verify-guards) to comprehend macro-aliases (see @(see
 macro-aliases-table)).  Such an ``enhancement&#39;&#39; would be unsound!  Instead, a
 similar but sound enhancement, @(&#39;verify-guards+&#39;), was introduced (into
 Version 6.3).  &lt;color rgb=&#39;#c00000&#39;&gt;See @(see verify-guards+) for an example,
 using @(tsee encapsulate) and @(tsee local), for why such an enhancement to
 @(&#39;verify-guards&#39;) would be unsound.&lt;/color&gt;&lt;/p&gt;

 &lt;p&gt;We turn now to discuss a key mechanism for avoiding potential soundness
 issues caused by @(&#39;local&#39;): the @(tsee acl2-defaults-table).  Because of the
 logical information stored in this @(see table), it is prohibited to modify
 this table locally, as we illustrate with a couple of examples.  First
 consider the following introduction of a @(see program)-mode function, @(&#39;f&#39;),
 that clearly is inadmissible in @(see logic)-mode.&lt;/p&gt;

 @({
 (encapsulate
   ()
   (program)
   (defun f () (not (f))))
 })

 &lt;p&gt;If the @(&#39;(program)&#39;) event were allowed to be local, then the second pass
 of the @(&#39;encapsulate&#39;) event would introduce @(&#39;f&#39;) in logic-mode, creating
 an inconsistent theory!&lt;/p&gt;

 &lt;p&gt;A slightly more subtle example is the following.&lt;/p&gt;

 @({
 (encapsulate
   ()
   (set-ruler-extenders :all)
   (defun foo (x)
     (cons (if (consp x) (foo (cdr x)) x)
           3)))
 })

 &lt;p&gt;The induction scheme stored for @(&#39;foo&#39;) is as follows, which is the same
 as would be stored for the simpler definition, @(&#39;(defun foo (x) (if (consp
 x) (foo (cdr x)) x))&#39;).  (Don&#39;t worry about the form of the structure below.
 Further relevant discussion may be found below in the section, ``Induction,
 recursion, and termination.&#39;&#39;)&lt;/p&gt;

 @({
 ACL2 !&gt;(getpropc &#39;foo &#39;induction-machine)
 ((TESTS-AND-CALLS ((CONSP X))
                   (FOO (CDR X)))
  (TESTS-AND-CALLS ((NOT (CONSP X)))))
 ACL2 !&gt;
 })

 &lt;p&gt;The @(&#39;&#39;induction-machine&#39;) property is computed based on the
 ruler-extenders.  So if the event @(&#39;(set-ruler-extenders :all)&#39;) above could
 be made local, we would be storing the same induction machine as for the
 following definition.&lt;/p&gt;

 @({
 (skip-proofs
  (defun foo (x)
    (declare (xargs :measure (acl2-count x)))
    (cons (if (consp x) (foo (cdr x)) x)
          3)))
 })

 &lt;p&gt;But that induction-machine is unsound!&lt;/p&gt;

 @({
 (thm nil :hints ((&quot;Goal&quot; :induct (foo x))))
 })

 &lt;p&gt;The two examples above illustrate the importance of thinking about whether
 an event can soundly be local.  If not, then it may be best for that event to
 be one that sets the @(tsee acl2-defaults-table), like @(tsee program) and
 @(tsee set-ruler-extenders), since @(tsee table) events that set the
 @(&#39;acl2-defaults-table&#39;) are not permitted to be local.&lt;/p&gt;

 &lt;h3&gt;@(tsee Skip-proofs) vs. @(tsee defaxiom)&lt;/h3&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;IN THE WORKSHOP THE FOCUS WILL BE ONLY ON THE LOGICAL DIFFERENCE.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;There is a fundamental logical difference between wrapping @(tsee
 skip-proofs) around a @(tsee defthm) event and using @(tsee defaxiom).  When
 using @(&#39;skip-proofs&#39;), the user is promising that the ensuing proof
 obligations are indeed theorems of the theory of the current ACL2 session.
 However, the meaning of @(&#39;defaxiom&#39;) is to extend that theory with a new
 axiom, one which is generally not provable from the session&#39;s theory.  See
 @(see skip-proofs) and see @(see defaxiom).  This logical distinction has
 ramifications for the implementation, as we now describe.&lt;/p&gt;

 &lt;p&gt;Since the use of @(tsee skip-proofs) carries an implicit promise of
 provability, the implementation can largely ignore the question of whether an
 event was, or was not, introduced using @(&#39;skip-proofs&#39;).  The key reason to
 do any such tracking is to inform @(tsee certify-book) when the use of keyword
 argument @(&#39;:skip-proofs-okp t&#39;) is required.&lt;/p&gt;

 &lt;p&gt;On the other hand, it is critical for soundness to track the use of @(tsee
 defaxiom).  In particular, it is unsound to allow @(see local) @(&#39;defaxiom&#39;)
 events.  That is obvious from the following example, which would leave us in
 an ACL2 world in which @(&#39;nil&#39;) is provable even though there is no
 @(&#39;defaxiom&#39;) event in that world.&lt;/p&gt;

 @({
 (encapsulate
   ()
   (local (defaxiom bad-axiom nil :rule-classes nil))
   (defthm bad-theorem nil
     :hints ((&quot;Goal&quot; :use bad-axiom))
     :rule-classes nil))
 })

 &lt;p&gt;That event is, of course, rejected by ACL2.  The following, on the other
 hand, is accepted; but this does not demonstrate unsoundness of ACL2, because
 the user violated the implied promise that, quoting from above, ``the ensuing
 proof obligations are indeed theorems of the theory of the current ACL2
 session.&#39;&#39;&lt;/p&gt;

 @({
 (encapsulate
   ()
   (local (skip-proofs (defthm bad-axiom nil :rule-classes nil)))
   (defthm bad-theorem nil
     :hints ((&quot;Goal&quot; :use bad-axiom))
     :rule-classes nil))
 })

 &lt;p&gt;We conclude this section by noting that there are different ``levels&#39;&#39; of
 @(&#39;skip-proofs&#39;) used by the implementation that are not directly visible to
 the user.  The basic @(&#39;skip-proofs&#39;) you see around an event generates a
 binding of state global @(&#39;&#39;ld-skip-proofsp&#39;) to @(&#39;t&#39;).  However, when you
 include a book, state global @(&#39;&#39;ld-skip-proofsp&#39;) is bound to
 @(&#39;&#39;include-book&#39;), which has two major effects: @(&#39;local&#39;) events are
 skipped, and some checks are omitted.  For example, the redundancy checks
 normally performed after @(&#39;(set-enforce-redundancy t)&#39;) are, as one would
 hope, omitted when including a book.  If you tags-search the sources for
 ``@(&#39;(enforce-redundancy&#39;)&#39;&#39;, you&#39;ll see that it is used to implement
 events (see for example the definition of @(&#39;defconst-fn&#39;)); then if you look
 at the definition of @(&#39;enforce-redundancy&#39;), you&#39;ll see that its check is
 skipped when state global @(&#39;&#39;ld-skip-proofsp&#39;) is bound to
 @(&#39;&#39;include-book&#39;), hence when a book is being included.  Also see @(see
 ld-skip-proofsp).&lt;/p&gt;

 &lt;h3&gt;Induction, recursion, and termination&lt;/h3&gt;

 &lt;p&gt;Every proposed definition with recursion generates two related artifacts: a
 proof obligation that is generally described as the termination proof
 obligation, and an induction scheme to be stored if the definition is
 admitted.  &lt;color rgb=&#39;#c00000&#39;&gt;A key soundness requirement is that the
 termination proof obligation justifies use of the induction scheme.&lt;/color&gt;
 This produces a tension, as can be seen by the analysis below of the following
 example.&lt;/p&gt;

 @({
 (defun f (x)
   (if (consp x)
       (cons (if (consp (car x)) (f (car x)) x)
             x)
     x))
 })

 &lt;p&gt;The generated induction is displayed symbolically just below: when proving
 a proposition @(&#39;(P x)&#39;), the induction step is to assume @(&#39;(consp x)&#39;) and
 @(&#39;(P (car x))&#39;) when proving @(&#39;(P x)&#39;), and the base case is to assume
 @(&#39;(not (consp x))&#39;) when proving @(&#39;(P x)&#39;).&lt;/p&gt;

 @({
 ACL2 !&gt;(getpropc &#39;f &#39;induction-machine)
 ((TESTS-AND-CALLS ((CONSP X))
                   (F (CAR X)))
  (TESTS-AND-CALLS ((NOT (CONSP X)))))
 ACL2 !&gt;
 })

 &lt;p&gt;There is a comment just above the @(&#39;defrec&#39;) for @(&#39;tests-and-calls&#39;) that
 explains that record structure.  The corresponding termination
 scheme may be seen by evaluating @(&#39;(trace$ termination-machine)&#39;) before
 submitting the @(&#39;defun&#39;) form above.  Here is the result.&lt;/p&gt;

 @({
 &lt;1 (TERMINATION-MACHINE ((TESTS-AND-CALL ((CONSP X))
                                          (F (CAR X)))))
 })

 &lt;p&gt;What this means is that ACL2 must prove that under the hypothesis @(&#39;(consp
 x)&#39;), then @(&#39;(acl2-count (car x))&#39;) is smaller than @(&#39;(acl2-count x)&#39;).
 That proof obligation clearly justifies the induction scheme described
 above.&lt;/p&gt;

 &lt;p&gt;But let us try an experiment in which ACL2 is instructed to consider, for
 termination and induction, any @(&#39;IF&#39;)-tests that are not at the top level
 &amp;mdash; in this case, within the call of @(&#39;cons&#39;).  In a fresh session, we
 try this instead.&lt;/p&gt;

 @({
 (defun f (x)
   (declare (xargs :ruler-extenders (cons)))
   (if (consp x)
       (cons (if (consp (car x)) (f (car x)) x)
             x)
     x))
 })

 &lt;p&gt;The induction machine produced this time includes the extra @(&#39;if&#39;) test or
 its negation.  It says that when proving a proposition @(&#39;(P x)&#39;), the
 induction step is to assume @(&#39;(consp x)&#39;), @(&#39;(consp (car x))&#39;), and
 @(&#39;(P (car x))&#39;) when proving @(&#39;(P x)&#39;); one base case is to assume @(&#39;(consp
 x)&#39;) and @(&#39;(not (consp (car x)))&#39;) when proving @(&#39;(P x)&#39;); and the other
 base case is to assume @(&#39;(not (consp x))&#39;) when proving @(&#39;(P x)&#39;).&lt;/p&gt;

 @({
 ACL2 !&gt;(getpropc &#39;f &#39;induction-machine)
 ((TESTS-AND-CALLS ((CONSP X) (CONSP (CAR X)))
                   (F (CAR X)))
  (TESTS-AND-CALLS ((CONSP X) (NOT (CONSP (CAR X)))))
  (TESTS-AND-CALLS ((NOT (CONSP X)))))
 ACL2 !&gt;
 })

 &lt;p&gt;This time there is a different termination proof obligation as well,
 stating that @(&#39;(car x)&#39;) has a smaller @(&#39;acl2-count&#39;) than that of @(&#39;x&#39;)
 under the conjunction of the pair of assumptions @(&#39;(consp x)&#39;) and
 @(&#39;(consp (car x))&#39;).  As before, it justifies the induction scheme just
 above.&lt;/p&gt;

 @({
 &lt;1 (TERMINATION-MACHINE ((TESTS-AND-CALL ((CONSP X) (CONSP (CAR X)))
                                          (F (CAR X)))))

 })

 &lt;p&gt;Now suppose that the implementation is careless, by making the @(see
 ruler-extenders) affect the termination proof obligations but not the
 induction scheme.  Consider the following example.&lt;/p&gt;

 @({
 (defun g (x)
   (declare (xargs :ruler-extenders (cons)))
   (cons (if (consp x) (g (car x)) x)
         x))
 })

 &lt;p&gt;This produces the termination proof obligation represented as follows
 (again from a trace), which says that assuming @(&#39;(consp x)&#39;), @(&#39;(acl2-count
 (car x))&#39;) is less than @(&#39;(acl2-count x)&#39;).  Note that this is indeed a
 theorem.&lt;/p&gt;

 @({
 &lt;1 (TERMINATION-MACHINE ((TESTS-AND-CALL ((CONSP X))
                                          (G (CAR X)))))

 })

 &lt;p&gt;To see what the induction scheme would be if we ignored the
 ruler-extenders, we submit the following.&lt;/p&gt;

 @({
 (skip-proofs
  (defun g (x)
    (declare (xargs :measure (acl2-count x)))
    (cons (if (consp (car x)) (g (car x)) x)
          x)))
 })

 &lt;p&gt;The corresponding induction machine states that to prove @(&#39;(P x)&#39;), we may
 assume @(&#39;(P (car x))&#39;).&lt;/p&gt;

 @({
 ACL2 !&gt;(getpropc &#39;g &#39;induction-machine)
 ((TESTS-AND-CALLS NIL (G (CAR X))))
 ACL2 !&gt;
 })

 &lt;p&gt;If we let @(&#39;(P x)&#39;) be @(&#39;(consp x)&#39;), then clearly this induction scheme
 allows us to prove @(&#39;(consp x)&#39;) for all @(&#39;x&#39;)!&lt;/p&gt;

 @({
 (thm (consp x)
      :hints ((&quot;Goal&quot; :induct (g x))))
 })

 &lt;p&gt;This induction scheme is thus clearly unsound.&lt;/p&gt;

 &lt;p&gt;The moral of the story is this: As the termination machine is modified to
 accommodate the ruler-extenders, the induction machine must be modified
 accordingly.  More generally, and as already noted: The termination machine
 must justify the induction machine.&lt;/p&gt;

 &lt;h3&gt;Other tricky stuff&lt;/h3&gt;

 &lt;p&gt;The logical underpinnings of ACL2 can be a bit overwhelming when considered
 together, so the following paragraphs should be taken as a suggestion for what
 to explore only when you&#39;re in the mood for some logic, and also as an
 acknowledgment that many subtle logical issues exist.  It is &lt;i&gt;NOT&lt;/i&gt; meant
 as a prescription for what you need to explore!  Moreover, it is far from
 complete.&lt;/p&gt;

 &lt;p&gt;The foundations of metatheoretic reasoning can be challenging.  If you
 tags-search for ``; Essay on Metafunction Support&#39;&#39;, you&#39;ll see two relevant
 essays.  But a much longer essay is the ``Essay on Correctness of Meta
 Reasoning&#39;&#39;.  That essay even ties into the ``Essay on Defattach&#39;&#39;, at the
 mention of the Attachment Restriction Lemma.  If you decide to change the
 handling of metafunctions or clause-processors or their corresponding @(see
 rule-classes), @(&#39;:meta&#39;) and @(&#39;:clause-processor&#39;), other than fixing coding
 bugs or making extra-logical changes such as output, you probably should read
 these Essays.  Of course, before reading these or any essays, it is generally
 a good idea to read relevant user-level documentation, such as the
 documentation for @(see meta) or @(see clause-processor).&lt;/p&gt;

 &lt;p&gt;A few other features of ACL2 with interesting logical foundations are
 @(tsee defchoose), @(tsee defabsstobj), and the interaction of packages with
 @(tsee local) (see the ``Essay on Hidden Packages&#39;&#39;).&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-programming)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-13" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-programming
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Programming Considerations"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This chapter discusses some things to keep in mind when modifying
 the ACL2 sources.  It is not intended to discuss any particular aspects of the
 ACL2 source code, but rather, to highlight some general principles.&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;ALL OF THIS TOPIC IS VERY IMPORTANT.&lt;/p&gt;
 &lt;/color&gt;

 &lt;h3&gt;Keep the user in mind&lt;/h3&gt;

 &lt;p&gt;Error and warning messages take time to write, but can (obviously) be
 really helpful to users.  Avoid trying to say too much in one message, instead
 pointing to one or more @(see documentation) topics for elaboration if
 appropriate.&lt;/p&gt;

 &lt;p&gt;It is generally fine to change a system utility&#39;s behavior or even to
 delete its definition.  However, this is discouraged if that utility is
 documented; otherwise there could be an annoyed user who is adversely
 affected.&lt;/p&gt;

 &lt;h3&gt;Program defensively&lt;/h3&gt;

 &lt;p&gt;It is a good idea to look for precedents.  See also the discussion of
 precedents in the topic, @(see developers-guide-maintenance).&lt;/p&gt;

 &lt;p&gt;Add assertions and errors when appropriate.  For example, the function
 @(&#39;all-runes-in-ttree&#39;) contains a large @(tsee case) expression, which covers
 each tag that could occur in a tag tree.  The last case is an error whose
 message mentions the bad tag together with the values associated with that
 tag.&lt;/p&gt;

 &lt;p&gt;Check invariants.  For example, the function @(&#39;check-acl2-initialization&#39;)
 checks some properties that are expected to hold at the end of a build; in
 particular, it calls @(&#39;check-none-ideal&#39;), which reports @(see logic)-mode
 functions that are not @(see guard)-verified.  (If a logic-mode function is
 not guard-verified, then it may run slowly.  We don&#39;t want built-in functions
 to run slowly.)&lt;/p&gt;

 &lt;h3&gt;Use installed worlds&lt;/h3&gt;

 &lt;p&gt;Fundamental utilities for ACL2 programmers are the function, @(tsee
 getprop), and its associated abbreviation, @(tsee getpropc).  @(&#39;Getprop&#39;) is
 defined in the logic to walk through a given logical @(see world), much as
 @(tsee assoc) walks through a given association list.  However, @(&#39;getprop&#39;)
 is defined ``under-the-hood&#39;&#39; with raw Lisp code (see the discussion of
 @(&#39;acl2-loop-only&#39;) in @(see developers-guide-background)) so that if the
 world is what we call ``installed&#39;&#39;, typically @(&#39;(w state)&#39;), then access is
 essentially constant-time.  The ACL2 utilities @(&#39;set-w&#39;), @(&#39;set-w!&#39;),
 @(&#39;extend-world&#39;), and @(&#39;retract-world&#39;) all may be invoked to install
 worlds, but it is rarely necessary or even advisable to call these directly.
 They are typically used in the implementations of @(see events).&lt;/p&gt;

 &lt;p&gt;Typically, ACL2 system programming passes along worlds that are installed,
 and one needn&#39;t think about whether a world is installed or not.  A major
 exception is when code recurs through the world, looking for a suitable
 triple.  Consider the source code definition of @(&#39;new-verify-guards-fns1&#39;);
 we include an elided version of it here.&lt;/p&gt;

 @({
 (defun new-verify-guards-fns1 (wrld installed-wrld acc)
   (declare (xargs :guard ...))
   (cond ((or (endp wrld) ...)
          ...)
         ((and (eq (cadar wrld) &#39;symbol-class)
               (eq (cddar wrld) :COMMON-LISP-COMPLIANT)
               (getpropc (caar wrld) &#39;predefined nil installed-wrld))
          (new-verify-guards-fns1 (cdr wrld)
                                  installed-wrld
                                  (cons (caar wrld) acc)))
         (t (new-verify-guards-fns1 (cdr wrld) installed-wrld acc))))
 })

 &lt;p&gt;We may reasonably assume from its name that the argument
 @(&#39;installed-wrld&#39;) is an installed world.  That&#39;s a good thing, since it
 guarantees that the @(&#39;getpropc&#39;) call above will be fast.  Suppose, by
 contrast, that the definition had been made in the following, more
 ``straightforward&#39;&#39;, manner.&lt;/p&gt;

 @({
 (defun BAD-new-verify-guards-fns1 (wrld acc)
   (declare (xargs :guard ...))
   (cond ((or (endp wrld) ...)
          ...)
         ((and (eq (cadar wrld) &#39;symbol-class)
               (eq (cddar wrld) :COMMON-LISP-COMPLIANT)
               (getpropc (caar wrld) &#39;predefined nil wrld))
          (BAD-new-verify-guards-fns1 (cdr wrld)
                                      (cons (caar wrld) acc)))
         (t (BAD-new-verify-guards-fns1 (cdr wrld) installed-wrld acc))))
 })

 &lt;p&gt;As we cdr down the given world, we deal with worlds that are not the
 installed world.  The @(&#39;getpropc&#39;) call will then need to walk linearly
 through its world until it finds the desired property &amp;mdash; typically very
 far from constant-time behavior.&lt;/p&gt;

 &lt;p&gt;Note that there are occasions for which the world is extended a bit before
 properties are obtained, and that&#39;s fine.  For example, in the source code
 definition of function @(&#39;chk-acceptable-defuns1&#39;) we find a call
 @(&#39;(putprop-x-lst1 names &#39;symbol-class symbol-class wrld1)&#39;), which
 contributes to an extension of @(&#39;wrld1&#39;) that will ultimately be used for
 definitional processing, including the termination proof.  The prover makes
 many calls of @(&#39;getprop&#39;) (typically via @(&#39;getpropc&#39;)) on that extended
 world.  Normally this isn&#39;t a problem: @(&#39;getprop&#39;) will then walk linearly
 through the new part of the world but will soon hit the installed world, and
 then finish its work quickly.  When large @(tsee mutual-recursion) nests are
 involved, this could be problematic, except that this issue is taken care of
 by the @(&#39;big-mutrec&#39;) hack; see for example the definition of
 @(&#39;defuns-fn1&#39;).  But we&#39;re getting into the weeds now; our point is that
 @(&#39;getprop&#39;) and @(&#39;getpropc&#39;) do best with worlds that are installed or are
 modest extensions of installed worlds.&lt;/p&gt;

 &lt;h3&gt;More generally, program efficiently&lt;/h3&gt;

 &lt;p&gt;Program with tail-recursion when possible, as tail-recursive functions are
 less likely to cause stack overflows and might also execute more
 efficiently.&lt;/p&gt;

 &lt;p&gt;Undoubtedly there are many other tips that could be given here on efficient
 programming.  Maybe they&#39;ll be added over time.&lt;/p&gt;

 &lt;h3&gt;Write good comments&lt;/h3&gt;

 &lt;p&gt;This is a matter of taste, and tastes vary.  Probably we can all agree that
 obvious bits of simple code need not be commented; for example, the code
 @(&#39;(append lst1 lst2)&#39;) does not need a comment ``concatenate the two
 lists&#39;&#39;.  At the other extreme, probably we can all agree that a complex
 algorithm deserves a comment.  When in doubt it might be best to write a bit
 too much rather than a bit too little.  A good guiding principle is to imagine
 yourself reading the code ten or twenty years later; will it make sense?&lt;/p&gt;

 &lt;p&gt;NOTE: If a comment is worth putting into a git commit message, then it&#39;s
 probably worth putting into the source code or documentation.&lt;/p&gt;

 &lt;h3&gt;Use good names&lt;/h3&gt;

 &lt;p&gt;For new names, avoid common strings so that it&#39;s easy to tags-search for
 them later.  Good examples include @(&#39;&quot;rune&quot;&#39;) and @(&#39;&quot;pspv&quot;&#39;) for the
 data structures, ``RUle NamE&#39;&#39; and ``Prover SPecial Variable&#39;&#39; (see the record
 @(&#39;prove-spec-var&#39;)).  (With the Emacs command @(&#39;meta-x tags-apropos&#39;) you
 can see many function names that mention include these two strings.)  A
 thesaurus such as &lt;a href=&#39;http://thesaurus.com&#39;&gt;@(&#39;thesaurus.com&#39;)&lt;/a&gt; may be
 helpful in naming a notion.&lt;/p&gt;

 &lt;p&gt;Do not abbreviate excessively.  Good naming examples may be found in the
 fields of the record @(&#39;prove-spec-var&#39;).  These fields are not well
 commented, but the names are helpful; for example, the field name
 @(&#39;user-supplied-term&#39;) is suggestive of the contents of that field, i.e., the
 term supplied to the prover by the user.  For another example, the function
 @(&#39;rewrite-with-linear&#39;) hints at its purpose, which is to use linear
 arithmetic during rewriting.  If we see a call of this function we can get a
 sense of what it&#39;s about.  That would be more difficult if the function were
 named @(&#39;rwl&#39;).&lt;/p&gt;

 &lt;p&gt;But this is a matter of taste.  For example, the function
 @(&#39;assume-true-false&#39;) hints at its functionality, which, roughly speaking, is
 to extend a @(see type-alist) by assuming an @(&#39;IF&#39;) test either true or
 false.  So why is there a function @(&#39;mv-atf&#39;)?  This is not such a huge
 transgression, since it&#39;s only used in the implementation of
 @(&#39;assume-true-false&#39;), so if you see it then your head is probably in a place
 where the abbreviation @(&#39;atf&#39;) makes sense.&lt;/p&gt;

 &lt;h3&gt;Add tests&lt;/h3&gt;

 &lt;p&gt;This is something that could probably be done more often; as of this
 writing, unit testing of specific features is relatively rare or in Lisp
 comments.  The @(see community-books) directories @(&#39;books/system/tests/&#39;) and
 @(&#39;books/demos/&#39;) are places to put small, specific tests, and others exist
 elsewhere, for example, the four test files
 @(&#39;books/misc/defabsstobj-example-*.lisp&#39;).  So there really aren&#39;t specific
 places to place tests.  If you run the following command in the @(&#39;books/&#39;)
 directory, you will find that there are likely well over 100 books that do
 some sort of testing, albeit not necessarily of specific features implemented
 in the ACL2 source code (159 of these as of this writing).&lt;/p&gt;

 @({
 find . -name &#39;*test*.lisp&#39; -print | fgrep -v quicklisp | wc -l
 })

 &lt;h3&gt;In general, be careful&lt;/h3&gt;

 &lt;p&gt;Of course, that&#39;s easier said than done!  But please, at the least, make
 some effort to avoid introducing inefficiencies, unclear code, or (especially)
 unsoundness.&lt;/p&gt;

 &lt;p&gt;Let us consider one example: the question of whether to skip certain checks
 when proofs are skipped.  You may want to look for precedents (as discussed
 above).  You may find that when @(&#39;(ld-skip-proofsp state)&#39;) is
 @(&#39;&#39;include-book&#39;) or @(&#39;&#39;include-book-with-locals&#39;), the function
 @(&#39;load-theory-into-enabled-structure&#39;) avoids a call of
 @(&#39;chk-theory-invariant&#39;) (actually shown as @(&#39;chk-theory-invariant@par&#39;);
 see the discussion of ACL2(p) in the chapter, @(see
 developers-guide-background)).  Thus, theory invariants &lt;i&gt;are&lt;/i&gt; checked
 when @(&#39;(ld-skip-proofsp state)&#39;) is @(&#39;t&#39;), i.e., when we are skipping proofs
 but not including a book (as discussed in the chapter, @(see
 developers-guide-logic)).  The idea here is that when including a certified
 book, we check theory-invariants just once, at the end of the book inclusion
 process, for efficiency.  So one way to be careful is to do various checks
 even when @(&#39;(ld-skip-proofsp state)&#39;) is @(&#39;t&#39;), even if these checks are to
 be skipped when including books.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-prioritizing)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-14" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-prioritizing
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Prioritizing: When to Make Changes"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;It may be tempting to enhance ACL2 whenever an intriguing idea
 comes along for making an improvement.  There is something to be said for
 doing so: the immediate motivation may make the work fun and lead to good
 results.&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;SUMMARY THAT SHOULD SUFFICE: Fix bugs, prioritize what will actually be
 used, and beware of massive regression failures.  Changes can be extremely
 valuable, and can also be substantially more work than predicted.&lt;/p&gt;
 &lt;/color&gt;

 &lt;p&gt;But there can be drawbacks to taking on every opportunity to make an
 improvement.  Heuristic improvements can be very difficult to work out without
 breaking, or slowing down, the regression suite.  A change may inadvertently
 break something.  Changes may be much more time-consuming than expected, and
 may take time away from other more important changes to be made.  Below we
 explore some aspects of prioritizing development tasks.&lt;/p&gt;

 &lt;h3&gt;Bugs&lt;/h3&gt;

 &lt;p&gt;Bug fixes are generally a priority, especially (of course) if they impact
 soundness.  Enough said?&lt;/p&gt;

 &lt;h3&gt;Accommodating user requests&lt;/h3&gt;

 &lt;p&gt;It has been observed that many ideas for improvements that may &lt;i&gt;seem&lt;/i&gt;
 helpful are actually &lt;i&gt;not&lt;/i&gt; very helpful to anyone actually using ACL2.
 It is therefore usually a good idea to prioritize changes that either
 accommodate specific requests from a user, or at the least can be seen as
 having significant positive impact on users.  It is very easy to think a new
 feature will be useful, but with the result that it&#39;s rarely or ever used, yet
 it complicates the source base.  A feature you consider might be close to
 being useful, but by waiting for a specific request, you can perhaps get
 substantially more insight about what would truly be useful, thus refining
 your initial idea for that feature.&lt;/p&gt;

 &lt;h3&gt;Impacts on the regression suite&lt;/h3&gt;

 &lt;p&gt;The ACL2 @(see community-books) provide a well-established set of
 libraries, as well as a useful set of regression tests.  Changes to ACL2 may
 cause some failures when certifying these books.  Often these are easy to fix,
 for example by modifying @(see theory) @(see hints) or by changing subgoal
 names on hints.  Changes may also impact ACL2(p) or ACL2(r), which are
 probably tested significantly less frequently.  More worrisome is the
 potential impact on private repositories, for example proprietary (not public)
 sets of books at companies.  There can also be slowdowns, which can be
 debugged by running the tool @(&#39;compare.pl&#39;); see the chapter, @(see
 developers-guide-maintenance).  There is a balance, addressed by using
 judgment, between introducing behavioral changes and maintaining the community
 books and private repositories.  There needs to be a guess about whether the
 benefit of the change outweighs the effort required to design and implement it
 and the fallout of requiring changes to books.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-evaluation)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-15" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-evaluation
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"How Evaluation Is Implemented in ACL2"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Our focus here is primarily on evaluation in the top-level loop.
 Also see the section on ``Evaluators&#39;&#39; in the chapter, @(see
 developers-guide-utilities).&lt;/p&gt;

 &lt;color rgb=&#39;#800080&#39;&gt;
 &lt;p&gt;ALL OF THIS TOPIC IS IMPORTANT; coverage will depend on time available at
 the workshop.&lt;/p&gt;
 &lt;/color&gt;

 &lt;h3&gt;Introduction and further reading&lt;/h3&gt;

 &lt;p&gt;This chapter is in two parts (not including this introduction).  It starts
 with a very brief review of evaluation in the read-eval-print loop.  Then it
 dives a bit into how *1* function definitions are generated.  It may be
 helpful to read the following additional material either before or after
 reading this chapter, or perhaps, both.&lt;/p&gt;

 &lt;p&gt;The documentation topic, @(see evaluation), explains ``*1* functions&#39;&#39;
 &amp;mdash; we assume here that you have some basic familiarity with that notion
 &amp;mdash; and ``submitted functions&#39;&#39;, which are the functions directly produced
 by the @(&#39;defun&#39;) forms in raw Lisp).  That topic also explains the role of
 these two functions in evaluation.  Below we start with a very brief
 illustration of that material.  For other reading relevant to evaluation at
 the user level, see @(see guard) and consider looking at some of its
 subtopics, especially @(see guard-evaluation-table).  Finally, look at
 relevant source comments pertaining to the aspect of evaluation that you are
 modifying, whether that is in @(&#39;ev-rec&#39;), @(&#39;oneify&#39;), or some other
 function.&lt;/p&gt;

 &lt;p&gt;The implementation of evaluation in ACL2 is rather subtle.  As is the case
 for this Developer&#39;s Guide in general, this chapter is not intended to provide
 complete coverage of the topic.  Its purpose is to provide sufficient
 background so that comments and code in the ACL2 sources can fill in on
 demand, as necessary.&lt;/p&gt;

 &lt;h3&gt;Brief overview of evaluation in the ACL2 read-eval-print loop&lt;/h3&gt;

 &lt;p&gt;The section on ``Commands and events&#39;&#39; in the chapter, @(see
 developers-guide-background), explains that evaluation of a form in the ACL2
 loop is performed by a variant of the function, @(tsee trans-eval).  That
 function (as well as @(&#39;trans-eval&#39;) itself), in turn, leads to a call of the
 evaluator, @(&#39;ev&#39;), which ultimately leads to calls of the raw Lisp function,
 @(&#39;raw-ev-fncall&#39;), to evaluate function calls @(&#39;(f val1 ... valk)&#39;).  The
 function @(&#39;raw-ev-fncall&#39;), in turn, calls the *1* function for the function
 symbol given as its first argument.  Let&#39;s see how that works.  First we
 define two functions and trace both of them.&lt;/p&gt;

 @({
 (defun f1 (x)
   (declare (xargs :guard (true-listp x)))
   (car x))

 (defun f2 (x)
   (f1 x))

 (trace$ f1 f2)
 })

 &lt;p&gt;Now let&#39;s see what can happen during evaluation.&lt;/p&gt;

 @({
 ACL2 !&gt;(f2 &#39;(3 4))
 1&gt; (ACL2_*1*_ACL2::F2 (3 4))
   2&gt; (ACL2_*1*_ACL2::F1 (3 4))
     3&gt; (F1 (3 4))
     &lt;3 (F1 3)
   &lt;2 (ACL2_*1*_ACL2::F1 3)
 &lt;1 (ACL2_*1*_ACL2::F2 3)
 3
 ACL2 !&gt;
 })

 &lt;p&gt;Evaluation starts with a call to the *1* function for @(&#39;f2&#39;).  Since
 @(&#39;f2&#39;) is not guard-verified, there is no call of the submitted function for
 @(&#39;f2&#39;) (see @(see evaluation) for terminology).  Instead, the *1* function
 for @(&#39;f2&#39;) directly calls the *1* function for @(&#39;f1&#39;).  Since @(&#39;f1&#39;) is
 guard-verified, this leads to a call of the submitted function for
 @(&#39;f1&#39;).&lt;/p&gt;

 &lt;h3&gt;Producing *1* functions: @(&#39;oneify&#39;) and @(&#39;oneify-cltl-code&#39;)&lt;/h3&gt;

 &lt;p&gt;The production of *1* functions is subtle, largely because many cases need
 to be handled in order to connect the ACL2 logic with Common Lisp; see @(see
 guard-evaluation-table) for a partial exploration of that connection.  @(Csee
 stobjs) must be handled properly as well.&lt;/p&gt;

 &lt;p&gt;The top-level function for creating *1* functions is @(&#39;oneify-cltl-code&#39;).
 This function, in turn, calls @(&#39;oneify&#39;) on its guard and body.  Here is
 annotated trace output, created by submitting the definition of @(&#39;f1&#39;) above
 after tracing as follows: @(&#39;(trace! (oneify-cltl-code :native
 t) (oneify :native t))&#39;).  Note that we use ``oneify&#39;&#39; as a verb: to oneify is
 to create code for a *1* function.&lt;/p&gt;

 @({
 ; Top-level call:

 1&gt; (ONEIFY-CLTL-CODE :LOGIC
                      (F1 (X)
                          (DECLARE (XARGS :GUARD (TRUE-LISTP X)))
                          (CAR X))
                      NIL |current-acl2-world|)

 ; Oneify the guard:

   2&gt; (ONEIFY (TRUE-LISTP X)
              NIL |current-acl2-world| NIL)
     3&gt; (ONEIFY X NIL |current-acl2-world| NIL)
     &lt;3 (ONEIFY X)
   &lt;2 (ONEIFY (ACL2_*1*_ACL2::TRUE-LISTP X))

 ; Oneify the body:

   2&gt; (ONEIFY (CAR X)
              NIL |current-acl2-world| NIL)
     3&gt; (ONEIFY X NIL |current-acl2-world| NIL)
     &lt;3 (ONEIFY X)
   &lt;2 (ONEIFY (ACL2_*1*_COMMON-LISP::CAR X))

 ; Return the definition of the *1* function for f1 (without the leading
 ; ``defun&#39;&#39;):

 &lt;1 (ONEIFY-CLTL-CODE
         (ACL2_*1*_ACL2::F1
              (X)
              (WHEN (NOT (EQ (F-GET-GLOBAL &#39;GUARD-CHECKING-ON
                                           *THE-LIVE-STATE*)
                             :NONE))

 ; Unless guard-checking is :none, we check the guard.

                    (COND ((TRUE-LISTP X)

 ; When the guard holds, call the submitted function to obtain the value.

                           (RETURN-FROM ACL2_*1*_ACL2::F1 (F1 X)))
                          ((F-GET-GLOBAL &#39;GUARD-CHECKING-ON
                                         *THE-LIVE-STATE*)

 ; The guard fails, and unless guard-checking is nil (or :none, but that was
 ; already considered above), cause an guard violation.

                           (THROW-RAW-EV-FNCALL (LIST &#39;EV-FNCALL-GUARD-ER
                                                      &#39;F1
                                                      (LIST X)
                                                      &#39;(TRUE-LISTP X)
                                                      &#39;(NIL)
                                                      NIL)))))

 ; If we didn&#39;t return or get a guard violation, then call a local function
 ; defined to have the oneified body.  Note: LABELS is like LET but for
 ; local function definitions, which may be recursively defined.  See any
 ; Common Lisp documentation for more about LABELS.

              (LABELS ((ACL2_*1*_ACL2::F1 (X)
                                          (ACL2_*1*_COMMON-LISP::CAR X)))
                      (ACL2_*1*_ACL2::F1 X))))
 })

 &lt;p&gt;Do you see an inefficiency above?&lt;/p&gt;

 &lt;p&gt;See code comments for how oneification deals with subtleties such as
 safe-mode, stobjs, and invariant-risk.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-miscellany)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-16" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-miscellany
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Miscellaneous Information"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;The initial version of this chapter is little more than a stub.  It
 will probably always benefit from expansion to cover more topics.&lt;/p&gt;

 &lt;h3&gt;Trust tags&lt;/h3&gt;

 &lt;p&gt;See @(see defttag) for user-level information about trust tags.  The
 ``Essay on Trust Tags (Ttags)&#39;&#39; provides a lot of relevant background on trust
 tags at the implementation level.  A particularly important point to be
 emphasized here is the following: The critical aspect of trust tags is that
 whenever a trust tag is activated, the string @(&#39;&quot;TTAG NOTE&quot;&#39;) must be
 printed to @(&#39;*standard-co*&#39;) (see the definition of @(&#39;print-ttag-note&#39;)),
 with the exception that if ttag notes are deferred then initially, only the
 first such is printed; see @(see set-deferred-ttag-notes).  The paper
 ``Hacking and Extending ACL2&#39;&#39; from the 2007 ACL2 Workshop may be helpful.&lt;/p&gt;

 &lt;h3&gt;Fixnums&lt;/h3&gt;

 &lt;p&gt;In general, Common Lisp computations with numbers are much faster when they
 only deal with ``small&#39;&#39; numbers called &lt;i&gt;fixnums&lt;/i&gt;.  See the ``Essay on
 Fixnum Declarations&#39;&#39; for information about fixnums and ACL2, including a
 description of the ranges for 32-bit fixnums in different Common Lisp
 implementations as of this writing.  There may be some opportunities made
 available by modern Lisps that have 64-bit implementations.  (CMUCL seems to
 be an exception.)&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-releases)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-17" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-releases
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Releases"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;For ACL2, there are two senses of the notion, ``release&#39;&#39;.  This
 word traditionally referred to numbered releases of ACL2 at the University of
 Texas, such as Version 8.0, as documented in the @(see release-notes).  But
 the ACL2 community increasingly obtains versions of ACL2 from GitHub, at &lt;a
 href=&#39;https://github.com/acl2/acl2&#39;&gt;@(&#39;https://github.com/acl2/acl2&#39;)&lt;/a&gt;.
 These ``releases&#39;&#39; are typically well-tested, though not as thoroughly tested
 as numbered releases, which (as of this writing) are always tested on Linux
 using all of the supported Common Lisp implementations, and also tested on
 Mac.  Even GitHub releases should generally be tested using the
 ``@(&#39;regression-everything&#39;)&#39;&#39; target for `@(&#39;make&#39;)&#39; in the top-level
 directory, or equivalently, the ``@(&#39;regression-everything&#39;)&#39;&#39; target in the
 @(&#39;books/&#39;) directory.&lt;/p&gt;

 &lt;p&gt;There are extensive instructions for doing numbered releases, which as of
 this writing have not been made public.  Anyone who cares to volunteer to make
 numbered releases should talk with Matt Kaufmann about obtaining those
 instructions, which perhaps would become public at that point.  (It could take
 non-trivial effort to clarify those instructions for the ``public&#39;&#39;, so let&#39;s
 wait till there is such a volunteer.)&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-style)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-18" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-style
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Style Guidelines for Developing ACL2 System Code"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;Here we set out some style guidelines that have traditionally been
 followed in the ACL2 sources.  They can guide development to help maintain
 ACL2&#39;s quality by giving its source files a consistent look.&lt;/p&gt;

 &lt;p&gt;The right margin is 79.  (In Emacs: @(&#39;set-fill-column 79&#39;).)  Existing
 code with margin 70 is OK to leave as is, though it&#39;s nice to convert to a
 margin of 79 when modifying comments within a given function.&lt;/p&gt;

 &lt;p&gt;Tabs are not used.  In Emacs, setting buffer-local variable
 @(&#39;indent-tabs-mode&#39;) to @(&#39;nil&#39;) will accomplish this.  That can be
 accomplished automatically for Lisp files, as is done in distributed file
 @(&#39;emacs/emacs-acl2.el&#39;); search there for @(&#39;indent-tabs-mode&#39;), or simply
 load that file in your @(&#39;.emacs&#39;) file.&lt;/p&gt;

 &lt;p&gt;Periods that end sentences are followed by two spaces (useful for the
 @(&#39;meta-e&#39;) command in Emacs).&lt;/p&gt;

 &lt;p&gt;Comments for a function go immediately after its formal parameters
 (even before @(see declare) forms).&lt;/p&gt;

 &lt;p&gt;Comments generally consist of complete sentences, starting on the left
 margin, each line starting with a single semicolon followed by a space.  An
 exception is very short comments to the right of code up to the end of the
 same line.&lt;/p&gt;

 &lt;p&gt;Use of the @(tsee cond) macro is generally preferred to the use of @(&#39;if&#39;),
 an exception being small expressions that are not at the top level of the
 @(&#39;if&#39;) structure.&lt;/p&gt;

 &lt;p&gt;System state globals need to be included in
 @(&#39;*initial-global-table*&#39;).&lt;/p&gt;

 &lt;p&gt;Blank lines are avoided except in the usual circumstances, e.g.,
 surrounding comments and between definitions.  Avoid consecutive blank
 lines.&lt;/p&gt;

 &lt;p&gt;A multi-line argument is not followed by an argument on the same line.  For
 example, there should be a linebreak before the argument, @(&#39;arg&#39;), after the
 string in this @(&#39;COND&#39;) clause:&lt;/p&gt;

 @({
 (t (er soft ctx
        &quot;The value associated with a :SOME-NEW-HINT hint must be a positive ~
        integer, but ~x0 is not.&quot; arg))
 })

 &lt;p&gt;We generally avoid capitalizing all letters in a single word, except
 perhaps for keywords or quoted constants.&lt;/p&gt;

 &lt;p&gt;There are no multi-line comments: @(&#39;#|| ... ||#&#39;).&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-other)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-19" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-pitfalls
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Avoiding potentially common pitfalls"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This topic is initially little more than a stub.  It is a place to
 list things to keep in mind in order to avoid potentially common mistakes.&lt;/p&gt;

 &lt;p&gt;It may be tempting to ignore the @(see tag-tree) (ttree) returned by a
 function.  But tag-trees may contain @(&#39;assumption&#39;) records, stored under the
 tag @(&#39;&#39;assumption&#39;), that record @(tsee force)d assumptions to be proved
 later (in forcing rounds or, in the case of @(tsee case-split) or @(tsee
 immediate-force-modep), more immediately).  So it can be unsound to ignore
 tag-trees unless they are sure not to contain assumptions (see
 @(&#39;assumption-free-ttreep&#39;)).&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-20" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-other
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"Topics Not Covered"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;There are many aspects of the ACL2 implementation, even major ones,
 that aren&#39;t covered in this Development Guide.&lt;/p&gt;

 &lt;h3&gt;It&#39;s perfectly OK that this Guide is incomplete!&lt;/h3&gt;

 &lt;p&gt;ACL2 has been maintained for more than 25 years by people who don&#39;t recall
 very much about large portions of the source code, probably the majority of
 it.  The key is that when making changes, one explores relevant code, reading
 relevant user-level documentation and code comments (including Essays), and
 talking with other developer(s) about questions and issues.  System
 maintenance generally gets easier with experience.&lt;/p&gt;

 &lt;p&gt;Here is a partial list of topics, in no particular order, that are left
 uncovered by this guide, or largely so: @(tsee defproxy) and (except for brief
 mention) @(tsee defattach); @(see stobj)s, including nested stobjs and
 abstract stobjs; @(see arrays); hons, memoization, and fast-alists (see @(see
 hons-and-memoization)); the @(see serialize) reader and writer; @(tsee
 apply$); @(tsee make-event); @(see meta)functions and @(see
 clause-processor)s; @(see hints), including @(see computed-hints), default
 hints, @(see override-hints), and custom keyword hints; @(see wormhole)s;
 printing, including evisceration (see @(see evisc-tuple)), @(see iprinting),
 pretty-printing, @(tsee fmt), @(tsee cw), @(tsee print-object$) and @(tsee
 with-output); @(see constraint)s and @(see functional-instantiation); the
 @(see documentation) system; the prover, including the @(see waterfall), the
 rewriter (for example @(see break-rewrite), congruences and patterned
 congruences, the @(see rewrite-cache), etc.), the @(see tau-system), @(see
 forward-chaining), and much more; pathnames, including @(see
 canonical-pathname)s; @(tsee encapsulate) and @(see functional-instantiation),
 including the @(&#39;proved-functional-instances-alist&#39;); the @(see
 proof-builder); and certifying and including @(see books).  And this is only a
 partial list!&lt;/p&gt;

 &lt;p&gt;But again, the Guide is not intended to be complete.  In principle, at
 least, you can learn about any of the topics above when necessary, by reading
 user-level documentation and using the Emacs tags-search and @(&#39;meta-.&#39;)
 commands to find relevant code, and comments, and in particular, essays.&lt;/p&gt;

 &lt;h3&gt;Expanding this Guide&lt;/h3&gt;

 &lt;p&gt;Perhaps this Guide will be expanded in the future.  If so, the expansion
 should probably not duplicate code comments, but rather, provide overview
 information and perspective with pointers to those comments.&lt;/p&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-examples)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-21" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-examples
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"ACL2 development examples"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;This topic discusses issues encountered during ACL2 development
  using two examples.  It consists of notes for the following talk.&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Title: Some Illustrations of ACL2 Development&lt;br/&gt;
 Speaker: Matt Kaufmann&lt;br/&gt;
 Date/venue: March 31, 2023, over zoom&lt;br/&gt;
 Follow &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/manuals/movies/2023-03-31-Developer-Talk.mov&#39;&gt;this
 link&lt;/a&gt; to see a video recording of the talk (@(&#39;.mov&#39;) format).&lt;/p&gt;

 &lt;p&gt;Abstract:&lt;/p&gt;

 &lt;p&gt;(WARNING: This is *NOT* a typical ACL2 talk!  It is focused on
 implementation, not ACL2 usage, to help those who may want to contribute ACL2
 source code in the future.  There are no specific prerequisites; but, for
 example, you&#39;ll be lost if you don&#39;t know what is meant by &amp;ldquo;error
 triple&amp;rdquo;.)&lt;/p&gt;

 &lt;p&gt;ACL2 development continues to be the responsibility of J Moore and me.  But
 we envision a time when others may take on that role.  To that end we hosted
 &amp;ldquo;Developer&#39;s Workshops&amp;rdquo; in &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-devel-2017/&#39;&gt;2017&lt;/a&gt;
 and &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-devel-2018/&#39;&gt;2018&lt;/a&gt;,
 added documentation topic @(see developers-guide) to the manual, and added
 @(see community-books) file @(&#39;books/system/to-do.txt&#39;).  This talk continues
 towards developing developers.&lt;/p&gt;

 &lt;p&gt;This talk will use recent examples to illustrate ACL2 development.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;.  Although I&#39;m trying to provide training for others to do
 ACL2 development, contact me first if you want your development work to make
 it into the system (as per &amp;ldquo;WARNINGS&amp;rdquo; near the top of @(see
 community-book) file @(&#39;books/system/to-do.txt&#39;)).  (Of course, this will
 change when J and I are no longer the ACL2 maintainers.)&lt;/p&gt;

 &lt;p&gt;For another example illustration of ACL2 development issues, see my paper
 &amp;ldquo;&lt;i&gt;Abbreviated Output for Input in ACL2: An Implementation Case
 Study&lt;/i&gt;&amp;rdquo;, either &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-2009/presentations/kaufmann-evisc.pdf&#39;&gt;the
 slides&lt;/a&gt; or &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-2009/final/10/10.pdf&#39;&gt;the
 paper&lt;/a&gt;, in Proceedings of &lt;a
 href=&#39;https://www.cs.utexas.edu/users/moore/acl2/workshop-2009/&#39;&gt;ACL2 Workshop
 2009&lt;/a&gt;.&lt;/p&gt;

 &lt;h3&gt;EXAMPLE 1:&lt;br/&gt;NEW FEATURE SET-WARNINGS-AS-ERRORS&lt;/h3&gt;

 &lt;p&gt;Mark Greenstreet found that when he used ACL2, @(&#39;&quot;Use&quot;&#39;) warnings would
 often be followed by proof failures.  So he wanted those warnings to be errors
 in his sessions.  Quoting :DOC @(see note-8-6):&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Added utility @(tsee set-warnings-as-errors), which can change @(see
 warnings) to hard @(see errors).  Thanks to Mark Greenstreet for the idea and
 for discussions that were helpful in refining it.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;This is a good time to take a look at the documentation for @(tsee
 set-warnings-as-errors).&lt;/p&gt;

 &lt;h4&gt;APPROACH: CONVERT WARNINGS TO HARD ERRORS&lt;/h4&gt;

 &lt;p&gt;I changed warnings to hard errors, not soft errors, because changing
 them to soft errors could be a massive undertaking.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;A soft error @(&#39;(er soft ...)&#39;) returns @(&#39;(mv t nil state)&#39;) after doing
 some printing.  There is no error &amp;ldquo;signaled&amp;rdquo; &amp;mdash; the caller
 needs to handle this appropriately.&lt;/li&gt;

 &lt;li&gt;The primary warning macro, @(&#39;warning$&#39;), returns @(tsee state).&lt;/li&gt;

 &lt;li&gt;So how can we signal an error when a function returns @(&#39;state&#39;)?&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;Example call stack:&lt;/p&gt;

 @({
 print-summary [which returns state]
   calls
 print-redefinition-warning [which returns state]
   calls
 warning$
 })

 &lt;p&gt;Another issue: @(&#39;warning$-cw0&#39;) returns @(&#39;nil&#39;), which makes it
 impossible to convert to a soft error (returning @(&#39;state&#39;)).  More on that is
 below.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;SOLUTION&lt;/b&gt;.  Convert warnings to hard errors, @(&#39;(er hard ...)&#39;),
 which are really aborts.&lt;/p&gt;

 &lt;p&gt;This illustrates an important trade-off: don&#39;t sacrifice quality, but if we
 can get something useful and correct for 10% (or less!) of the effort it would
 take to get something perfect &amp;mdash; e.g., converting warnings to hard errors
 instead of soft errors &amp;mdash; that&#39;s possibly quite fine.  It&#39;s a judgment
 call.&lt;/p&gt;

 &lt;h4&gt;KEY SURPRISE: TIME TAKEN&lt;/h4&gt;

 &lt;p&gt;This task took me something like 10 hours or maybe a bit more, even though
 this seemed like a relatively easy task.  That&#39;s more time even than it took
 me for the more subtle changes in the second example below.&lt;/p&gt;

 &lt;p&gt;It took non-trivial time to develop tests and documentation; more on that
 below.&lt;/p&gt;

 &lt;h4&gt;COMPLICATION 1: COMMENT-WINDOW WARNINGS&lt;/h4&gt;

 &lt;p&gt;Note that while @(&#39;warning$&#39;) takes and returns @(tsee state),
 @(&#39;warning$-cw0&#39;) does &amp;ldquo;comment window&amp;rdquo; printing without taking or
 returning state.&lt;/p&gt;

 &lt;p&gt;The definitions of @(&#39;warning$&#39;) and @(&#39;warning$-cw1&#39;) lead to similar
 calls of the macro, @(&#39;warning1-form&#39;).  The lack of @(&#39;state&#39;) available to
 @(&#39;warning$-cw1&#39;) leads to the use of the @(&#39;state-vars&#39;) record (shown
 below), which contains state information and was originally introduced so that
 @(&#39;translate11&#39;), the main &amp;ldquo;translate&amp;rdquo; function, has access to
 some state components without taking state.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;I&#39;m not sure I&#39;d use a macro like @(&#39;warning1-form&#39;) now.  I might instead
 just write analogous code for @(&#39;warning$&#39;) and @(&#39;warning$-cw1&#39;) and comments
 about keeping them in sync.&lt;/li&gt;

 &lt;li&gt;But as a rule, I take an &lt;i&gt;incremental&lt;/i&gt; approach to ACL2 code
 development: building on what&#39;s there seems less error-prone and
 time-consuming than ripping things apart (unless there&#39;s a good reason rather
 than a minor stylistic one).&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;I had to add to @(&#39;state-vars&#39;), but I didn&#39;t want to worry about impacting
 efficiency.  So my modification had minimal effect on only one existing field,
 namely, @(&#39;do-expressionp&#39;).  From the source code at the time (comments
 omitted here):&lt;/p&gt;

 @({
 (defrec state-vars
   (((safe-mode . boot-strap-flg) . (temp-touchable-vars . guard-checking-on))
    .
    ((ld-skip-proofsp . temp-touchable-fns) .
     ((parallel-execution-enabled . in-macrolet-def)
      do-expressionp warnings-as-errors . inhibit-output-lst)))
   nil)
 })

 &lt;p&gt;Related changes, for example deprecating @(&#39;warning$-cw&#39;) in favor of
 @(&#39;warning$-cw0&#39;), aren&#39;t discussed here.&lt;/p&gt;

 &lt;h4&gt;COMPLICATION 2: RUN-SCRIPT&lt;/h4&gt;

 &lt;p&gt;Testing is obviously important, and the @(tsee run-script) utility was very
 helpful, especially for this effort.  During development I added to the tests
 incrementally, and I checked that new mods didn&#39;t introduce unfortunate
 changes to the output.&lt;/p&gt;

 &lt;p&gt;I added the following files to test output; see @(see run-script).&lt;/p&gt;

 @({
 books/system/tests/warnings-as-errors-input.lsp
 books/system/tests/warnings-as-errors-book.acl2
 books/system/tests/warnings-as-errors-book.lisp
 books/system/tests/warnings-as-errors-log.txt
 })

 &lt;p&gt;Recall that @(&#39;*standard-co*&#39;) is the default character output channel for
 standard output (see @(see IO) and that @(&#39;(standard-co state)&#39;) is the
 &lt;i&gt;current&lt;/i&gt; such channel.  @(&#39;Run-tests&#39;) redirects output so that
 @(&#39;(standard-co state)&#39;) points to a file (the generated @(&#39;*-log.out&#39;) file).
 Also note that @(&#39;warning$-cw1&#39;) uses @(&#39;*standard-co*&#39;) and not @(tsee
 standard-co), since changes to files should be recorded in the ACL2 @(see
 state) but @(&#39;warning$-cw1&#39;) doesn&#39;t take or return state.&lt;/p&gt;

 &lt;p&gt;So, warnings produced by @(&#39;warning$-cw1&#39;) were going to the terminal, not
 to the intended output file.  Therefore I put the following hack near the top
 of @(&#39;warnings-as-errors-input.lsp&#39;).&lt;/p&gt;

 @({
 (redef+)
 (make-event `(defconst *standard-co* &#39;,(standard-co state)))
 (redef-)
 })

 &lt;h4&gt;COMPLICATION 3: INTERFACE DESIGN ISSUES&lt;/h4&gt;

 &lt;p&gt;This section discusses several design issues.&lt;/p&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; How does setting warnings as errors interact with inhibiting
 warnings?&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Recall that essentially &lt;i&gt;all&lt;/i&gt; warnings can be turned off (inhibited)
 with&lt;/p&gt;

 @({
 (set-inhibit-output-lst &#39;(... warning ...))
 })

 &lt;p&gt;or one can turn off only certain warning &lt;i&gt;types&lt;/i&gt; (what the sources
 call the &amp;ldquo;summary strings&amp;rdquo;) with a call such as the following.&lt;/p&gt;

 @({
 (set-inhibit-warnings &quot;theory&quot; &quot;use&quot;)&#39;)
 })

 &lt;p&gt;If @(&#39;warning$&#39;) is called but the warning is inhibited, does that affect
 whether the warning is converted to an error?&lt;/p&gt;

 &lt;p&gt;Demo:&lt;/p&gt;

 @({
 (thm (equal x x) :hints ((&quot;Goal&quot; :use nth))) ; warning
 (set-warnings-as-errors T &#39;(&quot;use&quot;) state)
 (thm (equal x x) :hints ((&quot;Goal&quot; :use nth))) ; error
 (set-inhibit-warnings &quot;USE&quot;)
 (thm (equal x x) :hints ((&quot;Goal&quot; :use nth))) ; quiet
 (set-warnings-as-errors :always &#39;(&quot;use&quot;) state)
 (thm (equal x x) :hints ((&quot;Goal&quot; :use nth))) ; error
 })

 &lt;p&gt;The demo shows that I decided to provide two settings for converting
 warnings to errors: @(&#39;T&#39;) for causing an error only if the warning is to be
 printed, and @(&#39;:ALWAYS&#39;) without that restriction.&lt;/p&gt;

 @({
 (set-warnings-as-errors T types state)
 (set-warnings-as-errors :ALWAYS types state)
 })

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; Can we convert warnings to errors regardless of the type
 (summary string).&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Solution:&lt;/p&gt;

 @({
 (set-warnings-as-errors flg :ALL state)
 })

 &lt;p&gt;The documentation explains that we can do that and then go back to just
 warnings for specific types.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; If a warning is converted to an error, is printing
 controllable?&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Solution: Yes, using @(&#39;(set-inhibit-output-lst ... error ...)&#39;) or using
 @(tsee set-inhibit-er).  Regarding the latter, in @(&#39;warning1-form&#39;) we
 find the following call that deals with the summary string.&lt;/p&gt;

 @({
 (hard-error ctx (cons summary str) alist)
 })

 &lt;p&gt;Quoting :DOC @(tsee set-warnings-as-errors):&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;When a warning of a given type (possibly @(&#39;nil&#39;) type) is converted to a
 hard error as specified above, then whether that error is printed is
 controlled by the usual mechanism for suppressing error messages; see @(see
 set-inhibit-er).  Note that the error will still be signaled regardless of
 whether the error message is thus suppressed.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; Some warnings are intended to be followed by errors, so we
 avoid converting those warnings to errors, as explained in :DOC @(see
 set-warnings-as-errors).  NOTE: Some of you may have noticed recent testing
 failures that were missing such warnings, and the following from that :DOC
 addresses that problem.&lt;/p&gt;

 &lt;ul&gt;
 &lt;li&gt;No warning whose type specified by constant
 @(&#39;*uninhibited-warning-summaries*&#39;) is converted to an error.  Those types
 are the ones that belong, with a case-insensitive check, to the list
 @(`*uninhibited-warning-summaries*`).  This exception overrides all discussion
 below.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; How about @(tsee make-event) expansion?  We allow
 @(&#39;make-event&#39;) to change state global @(&#39;warnings-as-errors&#39;); see the
 definition of @(&#39;*protected-system-state-globals*&#39;).  But that setting will
 revert after @(tsee certify-book) or @(tsee include-book), as noted below.&lt;/p&gt;

 &lt;p&gt;&lt;i&gt;ISSUE.&lt;/i&gt; If I ship you a book, you&#39;ll want @(tsee certify-book) to
 succeed even if you are setting warnings as errors.  So, again quoting :DOC
 @(see set-warnings-as-errors):&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Previous evaluations of calls of @(&#39;set-warnings-as-errors&#39;) are ignored
 during @(tsee certify-book) and @(tsee include-book).  The handling of
 warnings as errors is restored at the end of these operations to what it was
 at the beginning.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;h4&gt;COMPLICATION 4: GUARD VERIFICATION&lt;/h4&gt;

 &lt;p&gt;The &amp;ldquo;@(&#39;make devel-check&#39;)&amp;rdquo; process verifies guards for quite a
 few built-in functions: see @(see verify-guards-for-system-functions), though
 I follow a comment in @(&#39;*system-verify-guards-alist*&#39;).&lt;/p&gt;

 &lt;p&gt;For that devel-check process, I needed to modify guard verification for
 @(&#39;bind-macro-args&#39;).  I added the following two forms to the ACL2
 sources.&lt;/p&gt;

 @({
 (verify-termination-boot-strap warnings-as-errors-val-guard) ; and guards
 (verify-termination-boot-strap warnings-as-errors-val) ; and guards
 })

 &lt;p&gt;But where did I put them? A guiding principle in ACL2 development is to
 follow precedent when feasible.  So I added those forms in the following
 section of @(&#39;boot-strap-pass-2-a.lisp&#39;).&lt;/p&gt;

 @({
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; Miscellaneous verify-termination and guard verification
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 })

 &lt;p&gt;Guard verification for @(&#39;bind-macro-args&#39;) is (I think) why I used @(tsee
 ec-call) in @(&#39;warning1-form&#39;) (e.g., for the call of @(&#39;warning$-cw1&#39;) in
 @(&#39;bind-macro-args-keys1&#39;)).&lt;/p&gt;

 &lt;h4&gt;COMPLICATION 5: DOCUMENTATION AND COMMENTS&lt;/h4&gt;

 &lt;p&gt;Well, that&#39;s not exactly a complication &amp;mdash; but @(see documentation)
 can be time-consuming to write!&lt;/p&gt;

 &lt;p&gt;For this task I documented @(tsee set-warnings-as-errors).  I think it
 helped that as I implemented stuff, I kept notes on what to remember to
 document.&lt;/p&gt;

 &lt;p&gt;J and I write a lot of comments, but here&#39;s a small remark on @(tsee
 defrec) and comments.&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Maybe I should add a comment in the following that the @(&#39;:default&#39;) field
 is @(&#39;nil&#39;), @(&#39;t&#39;), or @(&#39;:always&#39;).  But I think that&#39;s pretty clear if one
 reads the :DOC for @(see set-warnings-as-errors) and does a tags-search for
 @(&#39;warnings-as-errors&#39;).&lt;/p&gt;

 @({
 (defrec warnings-as-errors
   (default . alist)
   nil)
 })

 &lt;p&gt;Notice the &amp;lsquo;cheap&amp;rsquo; flag of @(&#39;nil&#39;), which causes accesses to
 check that we indeed have a @(&#39;warnings-as-errors&#39;) record.  We can use
 @(&#39;:&#39;)@(tsee trans1) on the above @(tsee defrec) call to see how the generated
 definition of @(&#39;weak-warnings-as-errors-p&#39;) depends on the cheap flag.  Maybe
 some day I&#39;ll be confident enough to change that @(&#39;nil&#39;) to @(&#39;t&#39;).&lt;/p&gt;

 &lt;p&gt;So, the @(tsee access) call below checks that we have a valid record.  Note
 the use of @(tsee defabbrev) to avoid evaluating @(&#39;x&#39;) more than once.&lt;/p&gt;

 @({
 (defabbrev warnings-as-errors-default (x)
   (and x ; else default is nil
        (access warnings-as-errors x :default)))
 })

 &lt;/blockquote&gt;

 &lt;h4&gt;SOME GENERAL ADVICE before modifying sources&lt;/h4&gt;

 &lt;p&gt;This advice is from both me (Matt) and J.&lt;/p&gt;

 &lt;ul&gt;
 &lt;li&gt;Read relevant documentation.&lt;/li&gt;
 &lt;li&gt;Read relevant Lisp comments in the source code.&lt;/li&gt;
 &lt;li&gt;Make up tests of new or modified features.&lt;/li&gt;
 &lt;li&gt;Keep back-ups along the way, copying/moving the @(&#39;saved/&#39;)
 directory.&lt;/li&gt;
 &lt;li&gt;Do regression testing.&lt;/li&gt;
 &lt;li&gt;Try to follow precedents.&lt;/li&gt;
 &lt;li&gt;Update documentation, including release notes.&lt;/li&gt;
 &lt;li&gt;For each bug discovered, even if it&#39;s not related to what you&#39;re doing,
 either fix it or make a note to come back to it.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;TESTING SUMMARY&lt;/h4&gt;

 &lt;p&gt;When I change ACL2 sources, I always do a fresh &amp;ldquo;@(&#39;make
 regression-everything&#39;)&amp;rdquo; (except for comment-only changes), e.g., as
 follows.&lt;/p&gt;

 @({
 make clean-books ; (time nice make -j 16 regression-everything \
 USE_QUICKLISP=1) &gt;&amp; \
 make-regression-everything-ccl-quicklisp-j-16.log&amp;
 })

 &lt;p&gt;But when there are changes to @(see logic)-mode functions, I often run the
 following two tests as well.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;@(&#39;make proofs&#39;)

 &lt;blockquote&gt;

 &lt;p&gt;This causes ACL2 to &amp;ldquo;prove its way&amp;rdquo; through parts of the
 sources, adding a bit of extra assurance.&lt;/p&gt;

 &lt;/blockquote&gt;&lt;/li&gt;

 &lt;li&gt;@(&#39;make devel-check&#39;)

 &lt;blockquote&gt;

 &lt;p&gt;See @(see verify-guards-for-system-functions) for information about this
 test.  That provides instructions, but I usually follow a comment in
 @(&#39;*system-verify-guards-alist*&#39;).&lt;/p&gt;

 &lt;/blockquote&gt;&lt;/li&gt;

 &lt;/ul&gt;

 &lt;h4&gt;THE PATCH FILE: SUMMARY OF CHANGES&lt;/h4&gt;

 &lt;p&gt;My patch file may be found in
 @(&#39;books/system/doc/warnings-as-errors-patch.lsp&#39;).&lt;/p&gt;

 &lt;p&gt;It may be instructive to compare it with ACL2 sources from git commit
 55d5fff82d920f9cd42943aa26cf58d44d6a333d, which was a version shortly before
 warnings-as-errors was added).&lt;/p&gt;

 &lt;p&gt;The very first function in that patch file, @(&#39;output-ignored-p&#39;), is to
 fix a bug encountered in the process: &amp;ldquo;Tweaked output production, in
 particular from @(&#39;:&#39;)@(tsee pso)&amp;rdquo;.  Details are in the message for
 commit 55f20c02c15f9a2d7626060d7381eed3fc849933, which has been added at the
 end of the patch file.  I fixed that bug as part of the work, rather than
 deferring its fix, because that helped with the warnings-as-errors
 implementation.&lt;/p&gt;

 &lt;h3&gt;EXAMPLE 2:&lt;br/&gt;NEW FEATURE SET-LD-ALWAYS-SKIP-TOP-LEVEL-LOCALS&lt;/h3&gt;

 &lt;p&gt;Quoting :DOC @(see note-8-6):&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;A new @(tsee LD) special, @(tsee ld-always-skip-top-level-locals), has the
 effect of skipping @(tsee local) top-level forms.  Thanks to Sol Swords for
 requesting such a capability, to support faster loading of @(&#39;.port&#39;) files by
 the build system (see @(tsee build::cert.pl)).&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;Sol requested this because @(&#39;cert.pl&#39;) loads @(&#39;.port&#39;) files of included
 books (stemming from @(&#39;.acl2&#39;) files), but those may contain expensive @(see
 local) @(tsee include-book) forms books that should be ignored.&lt;/p&gt;

 @({
 (local (include-book ...)) ; form in a .port file to be ignored
 })

 &lt;p&gt;After&lt;/p&gt;

 &lt;ul&gt;
 &lt;li&gt;understanding the requested change,&lt;/li&gt;
 &lt;li&gt;being convinced of the change&#39;s utility,&lt;/li&gt;
 &lt;li&gt;helpful discussions with Sol, and&lt;/li&gt;
 &lt;li&gt;a helpful chat with J,&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;then I decided to add an @(&#39;LD&#39;) &lt;i&gt;special&lt;/i&gt; (see @(tsee ld) &amp;mdash;
 think, keyword argument of @(&#39;LD&#39;)).  So after this change, Sol arranged for
 @(&#39;cert.pl&#39;) to load @(&#39;.port&#39;) files roughly as follows (see
 @(&#39;books/build/make_cert_help.pl&#39;)).&lt;/p&gt;

 @({
 (ld &quot;foo.port&quot; :ld-always-skip-top-level-locals t)
 })

 &lt;p&gt;An @(&#39;LD&#39;) special is good because:&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;it&#39;s documented where users will see it; and&lt;/li&gt;

 &lt;li&gt;it&#39;s bound rather than merely set &amp;mdash; the original value is restored
 when the @(&#39;LD&#39;) call returns.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;&lt;b&gt;QUESTION&lt;/b&gt;:&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;Why not just do this by adding a new possible value for @(tsee
 ld-skip-proofsp)?&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;ANSWER&lt;/b&gt;:&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;There are two dimensions of @(&#39;ld-skip-proofsp&#39;):&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;Skip proofs or not&lt;/li&gt;
 &lt;li&gt;Skip locals or not&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;Values of @(&#39;ld-skip-proofsp&#39;) already support three of the four
 combinations, as follows.&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;@(&#39;nil&#39;) &amp;mdash;&lt;br/&gt;
 do not skip proofs, do not skip locals&lt;/li&gt;

 &lt;li&gt;@(&#39;&#39;include-book&#39;) &amp;mdash;&lt;br/&gt;
 skip proofs, skip locals&lt;/li&gt;

 &lt;li&gt;@(&#39;t&#39;) &amp;mdash;&lt;br/&gt;
 skip proofs, do not skip locals&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt;So why not have a fourth value as follows?&lt;/p&gt;

 &lt;ul&gt;
 &lt;li&gt;@(&#39;&#39;skip-locals&#39;) &amp;mdash;&lt;br/&gt;
 do not skip proofs, do skip locals&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;The reason is that it&#39;s too easy to make a mistake.  In particular, a
 non-@(&#39;nil&#39;) value of @(&#39;(f-get-global &#39;ld-skip-proofsp state)&#39;) currently
 means &amp;ldquo;proofs are being skipped&amp;rdquo;.  That would no longer be the
 case if the value can be @(&#39;&#39;skip-locals&#39;) &amp;mdash; so many changes would have
 to be made, and some may be in proprietary books.  Also, the name doesn&#39;t fit
 @(&#39;ld-skip-proofsp&#39;), since the new @(&#39;&#39;skip-locals&#39;) value is not about
 skipping proofs.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;QUESTION&lt;/b&gt;:&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;So what did I do?&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;ANSWER&lt;/b&gt;:&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;I added a new @(&#39;LD&#39;) special, @(tsee ld-always-skip-top-level-locals).&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;OLD TRICK&lt;/b&gt;:&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;To add @(&#39;ld-always-skip-top-level-locals&#39;) I tags-searched for @(tsee
 ld-missing-input-ok) to find code to modify; also, I searched
 @(&#39;books/&#39;) (both @(&#39;.lisp&#39;) and @(&#39;.acl2&#39;) files).&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;IMPORTANT&lt;/b&gt;:  Ignore the new @(&#39;LD&#39;) special when appropriate.&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;It is bound to @(&#39;nil&#39;) for @(tsee certify-book), @(tsee include-book), and
 @(tsee encapsulate).  Those need to behave as intended, without skipping
 @(tsee local) events.&lt;/p&gt;

 &lt;p&gt;Binding to @(&#39;nil&#39;) for @(&#39;encapsulate&#39;) but not @(&#39;progn&#39;) was easy.  The
 trick was to bind @(&#39;ld-always-skip-top-level-locals&#39;) to @(&#39;nil&#39;) in
 @(&#39;process-embedded-events&#39;), not @(&#39;eval-event-lst&#39;).  One learns about such
 utilities over time.&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;&lt;b&gt;WHAT&#39;S IN A NAME?&lt;/b&gt;&lt;/p&gt;

 &lt;blockquote&gt;

 &lt;p&gt;At one point during development, the name was @(&#39;ld-always-skip-locals&#39;); I
 changed it to @(&#39;ld-always-skip-top-level-locals,&#39;) given the @(&#39;encapsulate&#39;)
 behavior.  I don&#39;t mind that the name is long; I don&#39;t expect widespread
 usage, just occasional use in tools like @(&#39;cert.pl&#39;).&lt;/p&gt;

 &lt;/blockquote&gt;

 &lt;p&gt;NEXT SECTION: @(see developers-guide-acl2-devel)&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-22" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(defxdoc developers-guide-acl2-devel
  <span class="keyword">:parents</span> (developers-guide)
  <span class="keyword">:short</span> <span class="string">"&lt;color rgb=&#39;#c00000&#39;&gt;Use the acl2-devel List!&lt;/color&gt;"</span>
  <span class="keyword">:long</span> <span class="string">"&lt;p&gt;For years, Kaufmann and Moore have had regular chats during which
 they collaborate on development issues.  Use the acl2-devel mailing list to
 continue that tradition.  For example, if you are trying to get oriented about
 the waterfall and how hints interact with it, you could query the acl2-devel
 list and maybe someone will point you to the documentation topic, @(see
 hints-and-the-waterfall).&lt;/p&gt;

 &lt;p&gt;But please don&#39;t use the acl2-help or acl2 mailing lists for
 developer-level discussions, as that can spook users.  The acl2-books list
 also is not the right place; note that it is missing at least one important
 member of acl2-devel.&lt;/p&gt;

 &lt;p&gt;This is the final topic under @(see developers-guide).&lt;br/&gt;HAPPY
 DEVELOPING!&lt;/p&gt;"</span>)</pre>
  </div>

<div class="form-block other" id="form-23" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link external" href="../../xdoc/top.html#def-order-subtopics" data-sym="ORDER-SUBTOPICS">order-subtopics</a> developers-guide nil <a class="sym-link system" href="../../../axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>