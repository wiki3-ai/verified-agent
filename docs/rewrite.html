<!DOCTYPE html>
<html lang="en" vocab="http://schema.org/" typeof="SoftwareSourceCode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rewrite - ACL2 Book</title>
  <meta property="name" content="rewrite">
  <meta property="programmingLanguage" content="ACL2">
  
<style>
/* ACL2 Book HTML Documentation Styles */
/* Generated by cert2 - build2 system */

/* Dark theme (default) */
:root {
  --bg: #1e1e2e;
  --fg: #cdd6f4;
  --comment: #6c7086;
  --keyword: #cba6f7;
  --string: #a6e3a1;
  --function: #89b4fa;
  --type: #f9e2af;
  --link: #89dceb;
  --link-hover: #f5c2e7;
  --highlight: rgba(137, 180, 250, 0.2);
  --border: #313244;
  --block-bg: rgba(49, 50, 68, 0.5);
  --btn-bg: #313244;
  --btn-hover: rgba(137, 180, 250, 0.2);
}

/* Light theme */
[data-theme="light"] {
  --bg: #eff1f5;
  --fg: #4c4f69;
  --comment: #6c6f85;
  --keyword: #8839ef;
  --string: #40a02b;
  --function: #1e66f5;
  --type: #df8e1d;
  --link: #04a5e5;
  --link-hover: #ea76cb;
  --highlight: rgba(30, 102, 245, 0.15);
  --border: #ccd0da;
  --block-bg: rgba(204, 208, 218, 0.3);
  --btn-bg: #ccd0da;
  --btn-hover: rgba(30, 102, 245, 0.15);
}

body {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  background: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: 20px;
  line-height: 1.6;
  font-size: 14px;
  transition: background 0.1s, color 0.1s;
}

/* Controls toolbar */
.controls-left {
  position: fixed;
  top: 10px;
  left: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
  transition: transform 0.1s ease;
}

.controls-right {
  position: fixed;
  top: 10px;
  right: 20px;
  display: flex;
  gap: 8px;
  align-items: center;
  z-index: 200;
}

.control-btn {
  padding: 6px 12px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  transition: all 0.1s;
}

.control-btn:hover {
  background: var(--btn-hover);
  border-color: var(--link);
}

.name-filter {
  padding: 6px 10px;
  background: var(--btn-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  width: 150px;
  transition: all 0.1s;
}

.name-filter:focus {
  outline: none;
  border-color: var(--link);
  width: 200px;
}

.name-filter::placeholder {
  color: var(--comment);
}

.regex-label {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--comment);
  font-size: 12px;
  cursor: pointer;
}

.regex-label input {
  cursor: pointer;
}

.book-header {
  border-bottom: 2px solid var(--border);
  padding-bottom: 20px;
  margin-bottom: 20px;
}

.book-header h1 {
  color: var(--keyword);
  margin: 0;
}

.book-header .path {
  color: var(--comment);
  font-size: 0.9em;
}

.book-header .path .source-link {
  color: var(--comment);
  text-decoration: none;
}

.book-header .path .source-link:hover {
  color: var(--link);
  text-decoration: underline;
}

.form-block {
  margin: 10px 0;
  padding: 15px;
  background: var(--block-bg);
  border-radius: 8px;
  border-left: 3px solid var(--border);
}

.form-block.theorem { border-left-color: var(--keyword); }
.form-block.function { border-left-color: var(--function); }
.form-block.macro { border-left-color: var(--type); }
.form-block.include-book { border-left-color: var(--string); }

.form-block.hidden { display: none; }
.form-block.dimmed { opacity: 0.3; }

.form-block.highlight {
  animation: highlight-pulse 0.4s ease-out;
}

@keyframes highlight-pulse {
  0% { background: var(--highlight); box-shadow: 0 0 20px var(--link); }
  100% { background: rgba(49, 50, 68, 0.5); box-shadow: none; }
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.form-name {
  color: var(--function);
  font-weight: bold;
  cursor: pointer;
}

.form-name:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

.form-type {
  color: var(--comment);
  font-size: 0.85em;
}

pre.code {
  margin: 0;
  overflow-x: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.sym-ref {
  color: var(--link);
  cursor: pointer;
  border-radius: 2px;
}

.sym-ref:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.sym-ref.local-def { color: var(--function); font-weight: bold; }
.sym-ref.external { color: var(--type); }

/* Symbol links (clickable hyperlinks) */
.sym-link {
  color: var(--link);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
  position: relative;
}

.sym-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

.sym-link.local-def {
  color: var(--function);
  font-weight: bold;
}

.sym-link.external {
  color: var(--type);
}

/* Tooltips using title attribute with custom styling */
.sym-link[title] {
  /* Browser will show title on hover */
}

/* Syntax highlighting in code blocks */
.keyword {
  color: var(--keyword);
}

.string {
  color: var(--string);
}

.number {
  color: #f77524; /* orange */
}

/* Include-book path links */
.include-path {
  color: var(--string);
  text-decoration: none;
  border-radius: 2px;
  cursor: pointer;
}

.include-path:hover {
  background: var(--highlight);
  color: var(--link-hover);
  text-decoration: underline;
}

/* Part buttons for defthm */
.part-buttons {
  display: flex;
  gap: 5px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.part-btn {
  padding: 4px 10px;
  background: var(--border);
  border: 1px solid var(--comment);
  border-radius: 4px;
  color: var(--fg);
  cursor: pointer;
  font-size: 0.85em;
  font-family: inherit;
}

.part-btn:hover {
  background: var(--highlight);
  border-color: var(--link);
}

.part-btn.active {
  background: var(--link);
  color: var(--bg);
  border-color: var(--link);
}

/* References panel */
.refs-panel {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  display: none;
}

.refs-panel.visible { display: block; }

.refs-panel h4 {
  margin: 0 0 5px 0;
  color: var(--comment);
  font-size: 0.9em;
}

.refs-list {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

/* Included books section */
.includes-section {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(49, 50, 68, 0.3);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.includes-section h2 {
  margin: 0 0 10px 0;
  color: var(--comment);
  font-size: 1em;
  font-weight: normal;
}

.includes-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.include-link {
  padding: 6px 12px;
  background: var(--border);
  border-radius: 4px;
  color: var(--link);
  text-decoration: none;
  font-size: 0.9em;
  transition: all 0.1s;
}

.include-link:hover {
  background: var(--highlight);
  color: var(--link-hover);
}

.include-link.local {
  border-left: 2px solid var(--comment);
}

/* Filter status */
.filter-status {
  position: fixed;
  top: 10px;
  left: 20px;
  background: var(--bg);
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  z-index: 201;
  display: none;
  align-items: center;
  gap: 10px;
}

.filter-status.active {
  display: flex;
  align-items: center;
  gap: 10px;
}

.clear-filter {
  padding: 5px 15px;
  background: var(--keyword);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* RDFa vocab indicator */
[vocab] { /* semantic web annotations present */ }

</style>

</head>
<body>
  <div class="controls-left">
    <input type="text" id="name-filter" class="name-filter" placeholder="Filter by name..." title="Filter definitions by name">
    <label class="regex-label"><input type="checkbox" id="regex-toggle"> regex</label>
  </div>

  <div class="controls-right">
    <button class="control-btn" id="theme-toggle" title="Toggle light/dark theme">☀️</button>
    <button class="control-btn" id="font-smaller" title="Decrease font size">A-</button>
    <button class="control-btn" id="font-larger" title="Increase font size">A+</button>
  </div>

  <div class="filter-status">
    <span class="filter-text">Filtering...</span>
    <button class="clear-filter">Clear Filter</button>
  </div>
  
  <div class="book-header">
    <h1 property="name">rewrite</h1>
    <div class="path"><a href="rewrite.lisp" class="source-link">rewrite</a></div>
  </div>
  
  <main property="text">
<div class="form-block other" id="form-0" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-in-package" data-sym="IN-PACKAGE">in-package</a> <span class="string">"ACL2"</span>)</pre>
  </div>

<div class="form-block function" id="def-warranted-fns-of-world1" data-defines="WARRANTED-FNS-OF-WORLD1" data-references="T,CDR,CONS,FUNCTION-SYMBOLP,SYMBOLP,ACCESS-BADGE-USERFN-STRUCTURE-TUPLE-WARRANTP,CAR,WEAK-BADGE-USERFN-STRUCTURE-TUPLEP,AND,ATOM,COND,PLIST-WORLDP,XARGS,DECLARE,WRLD,X,DEFUN" data-used-by="WARRANTED-FNS-OF-WORLD" data-part-name="WARRANTED-FNS-OF-WORLD1" data-part-args="WRLD,X" data-part-declare="WRLD,PLIST-WORLDP,XARGS,DECLARE" data-part-body="T,CDR,WARRANTED-FNS-OF-WORLD1,CONS,WRLD,FUNCTION-SYMBOLP,SYMBOLP,ACCESS-BADGE-USERFN-STRUCTURE-TUPLE-WARRANTP,CAR,WEAK-BADGE-USERFN-STRUCTURE-TUPLEP,AND,X,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WARRANTED-FNS-OF-WORLD1">warranted-fns-of-world1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-warranted-fns-of-world1" data-sym="WARRANTED-FNS-OF-WORLD1" title="(defun warranted-fns-of-world1 (x wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld)))
  (cond ((atom x) nil)
        ((and (weak-badge-userfn-structure-tuplep (car x))
              (access-badge-userfn-structure-tuple-warrantp (car x))
...">warranted-fns-of-world1</a>
  (x wrld)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> x) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (weak-badge-userfn-structure-tuplep (car x))
       (access-badge-userfn-structure-tuple-warrantp (car x))
       (symbolp (car (car x)))
       (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> (car (car x)) wrld)) (cons (car (car x)) (<a class="sym-link local-def" href="#def-warranted-fns-of-world1" data-sym="WARRANTED-FNS-OF-WORLD1" title="(defun warranted-fns-of-world1 (x wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld)))
  (cond ((atom x) nil)
        ((and (weak-badge-userfn-structure-tuplep (car x))
              (access-badge-userfn-structure-tuple-warrantp (car x))
...">warranted-fns-of-world1</a> (cdr x) wrld)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-warranted-fns-of-world" data-defines="WARRANTED-FNS-OF-WORLD" data-references="ASSOC-EQ,CDR,WARRANTED-FNS-OF-WORLD1,BADGE-TABLE,QUOTE,TABLE-ALIST,ALISTP,AND,PLIST-WORLDP,XARGS,DECLARE,WRLD,DEFUN" data-part-name="WARRANTED-FNS-OF-WORLD" data-part-args="WRLD" data-part-declare="WRLD,PLIST-WORLDP,XARGS,DECLARE" data-part-body="ASSOC-EQ,CDR,WARRANTED-FNS-OF-WORLD1,WRLD,BADGE-TABLE,QUOTE,TABLE-ALIST,ALISTP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WARRANTED-FNS-OF-WORLD">warranted-fns-of-world</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-warranted-fns-of-world" data-sym="WARRANTED-FNS-OF-WORLD" title="(defun warranted-fns-of-world (wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld) :verify-guards nil))
  (and (alistp (table-alist &#39;badge-table wrld))
       (warranted-fns-of-world1
        (cdr
...">warranted-fns-of-world</a>
  (wrld)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)
      <span class="keyword">:verify-guards</span> nil))
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'badge-table wrld))
    (<a class="sym-link local-def" href="#def-warranted-fns-of-world1" data-sym="WARRANTED-FNS-OF-WORLD1" title="(defun warranted-fns-of-world1 (x wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld)))
  (cond ((atom x) nil)
        ((and (weak-badge-userfn-structure-tuplep (car x))
              (access-badge-userfn-structure-tuple-warrantp (car x))
...">warranted-fns-of-world1</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:badge-userfn-structure</span> (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'badge-table wrld)))
      wrld)))</pre>
  </div>

<div class="form-block other" id="form-3" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-partial-encapsulate" data-sym="PARTIAL-ENCAPSULATE">partial-encapsulate</a> (((ev-fncall+-fns <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>))
  nil
  (<a class="sym-link system" href="axioms.html#def-logic" data-sym="LOGIC">logic</a>)
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> ev-fncall+-fns
      (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> wrld big-n safe-mode gc-off strictp)
      (declare (ignore fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> big-n safe-mode gc-off))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> strictp) (<a class="sym-link local-def" href="#def-warranted-fns-of-world" data-sym="WARRANTED-FNS-OF-WORLD" title="(defun warranted-fns-of-world (wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld) :verify-guards nil))
  (and (alistp (table-alist &#39;badge-table wrld))
       (warranted-fns-of-world1
        (cdr
...">warranted-fns-of-world</a> wrld))))
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> all-function-symbolps-ev-fncall+-fns-lemma
      (<a class="sym-link system" href="axioms.html#def-all-function-symbolps" data-sym="ALL-FUNCTION-SYMBOLPS">all-function-symbolps</a> (<a class="sym-link local-def" href="#def-warranted-fns-of-world1" data-sym="WARRANTED-FNS-OF-WORLD1" title="(defun warranted-fns-of-world1 (x wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld)))
  (cond ((atom x) nil)
        ((and (weak-badge-userfn-structure-tuplep (car x))
              (access-badge-userfn-structure-tuple-warrantp (car x))
...">warranted-fns-of-world1</a> x wrld)
        wrld)))
  (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> all-function-symbolps-ev-fncall+-fns
    (let ((fns (ev-fncall+-fns fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> wrld big-n safe-mode gc-off nil)))
      (<a class="sym-link system" href="axioms.html#def-all-function-symbolps" data-sym="ALL-FUNCTION-SYMBOLPS">all-function-symbolps</a> fns wrld)))
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subsetp-equal-cons
      (<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a> (<a class="sym-link system" href="axioms.html#def-subsetp-equal" data-sym="SUBSETP-EQUAL">subsetp-equal</a> x y) (<a class="sym-link system" href="axioms.html#def-subsetp-equal" data-sym="SUBSETP-EQUAL">subsetp-equal</a> x (cons a y)))))
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> subsetp-equal-x-x (<a class="sym-link system" href="axioms.html#def-subsetp-equal" data-sym="SUBSETP-EQUAL">subsetp-equal</a> x x)))
  (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> ev-fncall+-fns-is-subset-of-badged-fns-of-world
    (<a class="sym-link system" href="axioms.html#def-subsetp" data-sym="SUBSETP">subsetp</a> (ev-fncall+-fns fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> wrld big-n safe-mode gc-off nil)
      (<a class="sym-link local-def" href="#def-warranted-fns-of-world" data-sym="WARRANTED-FNS-OF-WORLD" title="(defun warranted-fns-of-world (wrld)
  (declare (xargs :mode :logic :guard (plist-worldp wrld) :verify-guards nil))
  (and (alistp (table-alist &#39;badge-table wrld))
       (warranted-fns-of-world1
        (cdr
...">warranted-fns-of-world</a> wrld)))
  (<a class="sym-link system" href="axioms.html#def-defthm" data-sym="DEFTHM">defthm</a> function-symbolp-ev-fncall+-fns-strictp
    (let ((fn (ev-fncall+-fns fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> wrld big-n safe-mode gc-off <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp fn) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fn) (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> fn wrld))))
    <span class="keyword">:rule-classes</span> nil))</pre>
  </div>

<div class="form-block function" id="def-ev-fncall_2B-w" data-defines="EV-FNCALL+-W" data-references="MV,IGNORE,DECLARE,NOT,AND,T,EV-FNCALL-REC-LOGICAL,LATCHES,VAL,ERP,MV-LET,EV-FNCALL+-FNS,FNS,BIG-N,LET*,STRICTP,GC-OFF,SAFE-MODE,W,ARGS,FN,DEFUN" data-used-by="EV-FNCALL+" data-part-name="EV-FNCALL+-W" data-part-args="STRICTP,GC-OFF,SAFE-MODE,W,ARGS,FN" data-part-body="MV,IGNORE,DECLARE,NOT,AND,T,EV-FNCALL-REC-LOGICAL,LATCHES,VAL,ERP,MV-LET,STRICTP,GC-OFF,SAFE-MODE,W,ARGS,FN,EV-FNCALL+-FNS,FNS,BIG-N,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EV-FNCALL+-W">ev-fncall+-w</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ev-fncall_2B-w" data-sym="EV-FNCALL+-W" title="(defun ev-fncall+-w (fn args w safe-mode gc-off strictp)
  (let* ((big-n (big-n))
         (fns (ev-fncall+-fns fn args w big-n safe-mode gc-off strictp)))
    (mv-let (erp val latches)
            (ev-fncall-rec-logical fn args nil w nil big-n safe-mode gc-off nil
...">ev-fncall+-w</a>
  (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> safe-mode gc-off strictp)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((big-n (big-n)) (fns (ev-fncall+-fns fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> big-n safe-mode gc-off strictp)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val latches)
      (ev-fncall-rec-logical fn
        <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
        nil
        <a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a>
        nil
        big-n
        safe-mode
        gc-off
        nil
        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
        nil
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> strictp) fns))
      (declare (ignore latches))
      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp val fns))))</pre>
  </div>

<div class="form-block function" id="def-ev-fncall_2B" data-defines="EV-FNCALL+" data-references="GC-OFF,SAFE-MODE,QUOTE,F-GET-GLOBAL,W,EV-FNCALL+-W,STATE,STRICTP,ARGS,FN,DEFUN" data-used-by="REWRITE,SCONS-TERM" data-part-name="EV-FNCALL+" data-part-args="STATE,STRICTP,ARGS,FN" data-part-body="STRICTP,GC-OFF,SAFE-MODE,QUOTE,F-GET-GLOBAL,STATE,W,ARGS,FN,EV-FNCALL+-W" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EV-FNCALL+">ev-fncall+</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ev-fncall_2B" data-sym="EV-FNCALL+" title="(defun ev-fncall+ (fn args strictp state)
  (ev-fncall+-w fn args (w state) (f-get-global &#39;safe-mode state)
                (gc-off state) strictp))">ev-fncall+</a>
  (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> strictp state)
  (<a class="sym-link local-def" href="#def-ev-fncall_2B-w" data-sym="EV-FNCALL+-W" title="(defun ev-fncall+-w (fn args w safe-mode gc-off strictp)
  (let* ((big-n (big-n))
         (fns (ev-fncall+-fns fn args w big-n safe-mode gc-off strictp)))
    (mv-let (erp val latches)
            (ev-fncall-rec-logical fn args nil w nil big-n safe-mode gc-off nil
...">ev-fncall+-w</a> fn
    <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
    (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)
    (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'safe-mode state)
    (gc-off state)
    strictp))</pre>
  </div>

<div class="form-block other" id="form-6" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> congruence-rule (nume equiv . rune) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block constant" id="def-_2Ageneqv-iff_2A" data-defines="*GENEQV-IFF*" data-references="IFF,QUOTE,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,CONGRUENCE-RULE,MAKE,LIST,DEFCONST" data-used-by="REWRITE,SEARCH-GROUND-UNITS1,REWRITE-IF11,GENEQV-LST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*GENEQV-IFF*">*geneqv-iff*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> congruence-rule
      <span class="keyword">:rune</span> *fake-rune-for-anonymous-enabled-rule*
      <span class="keyword">:nume</span> nil
      <span class="keyword">:equiv</span> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>)))</pre>
  </div>

<div class="form-block function" id="def-refinementp" data-defines="REFINEMENTP" data-references="COARSENINGS,GETPROPC,CDR,MEMBER-EQ,T,EQUAL,QUOTE,EQ,COND,WRLD,EQUIV2,EQUIV1,DEFUN" data-used-by="REDUCE-GENEQV-FOR-EQUIV" data-part-name="REFINEMENTP" data-part-args="WRLD,EQUIV2,EQUIV1" data-part-body="WRLD,COARSENINGS,GETPROPC,CDR,MEMBER-EQ,EQUIV2,T,EQUAL,QUOTE,EQUIV1,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REFINEMENTP">refinementp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-refinementp" data-sym="REFINEMENTP" title="(defun refinementp (equiv1 equiv2 wrld)
  (cond ((eq equiv1 &#39;equal) t) ((eq equiv2 &#39;equal) nil) ((eq equiv1 equiv2) t)
        (t (member-eq equiv2 (cdr (getpropc equiv1 &#39;coarsenings nil wrld))))))">refinementp</a>
  (equiv1 equiv2 wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv1 'equal) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv2 'equal) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv1 equiv2) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> equiv2
        (cdr (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> equiv1 'coarsenings nil wrld))))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-refinementp1" data-defines="GENEQV-REFINEMENTP1" data-references="CDR,T,CAR,CONGRUENCE-RULE,ACCESS,MEMBER-EQ,NULL,COND,GENEQV,COARSENINGS,DEFUN" data-used-by="GENEQV-REFINEMENTP" data-part-name="GENEQV-REFINEMENTP1" data-part-args="GENEQV,COARSENINGS" data-part-body="CDR,GENEQV-REFINEMENTP1,T,COARSENINGS,CAR,CONGRUENCE-RULE,ACCESS,MEMBER-EQ,GENEQV,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-REFINEMENTP1">geneqv-refinementp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-refinementp1" data-sym="GENEQV-REFINEMENTP1" title="(defun geneqv-refinementp1 (coarsenings geneqv)
  (cond ((null geneqv) nil)
        ((member-eq (access congruence-rule (car geneqv) :equiv) coarsenings)
         (access congruence-rule (car geneqv) :rune))
        (t (geneqv-refinementp1 coarsenings (cdr geneqv)))))">geneqv-refinementp1</a>
  (coarsenings geneqv)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) nil)
    ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:equiv</span>)
       coarsenings) (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:rune</span>))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-geneqv-refinementp1" data-sym="GENEQV-REFINEMENTP1" title="(defun geneqv-refinementp1 (coarsenings geneqv)
  (cond ((null geneqv) nil)
        ((member-eq (access congruence-rule (car geneqv) :equiv) coarsenings)
         (access congruence-rule (car geneqv) :rune))
        (t (geneqv-refinementp1 coarsenings (cdr geneqv)))))">geneqv-refinementp1</a> coarsenings (cdr geneqv)))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-refinementp" data-defines="GENEQV-REFINEMENTP" data-references="COARSENINGS,GETPROPC,GENEQV-REFINEMENTP1,T,NULL,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,EQUAL,QUOTE,EQ,COND,WRLD,GENEQV,EQUIV,DEFUN" data-used-by="REWRITE,EXPAND-PERMISSION-RESULT1,SEARCH-GROUND-UNITS1,REWRITE-SOLIDIFY-REC,OBJ-TABLE,FIND-REWRITING-EQUIVALENCE,GENEQV-FOR-REWRITE,ACCUMULATE-SHALLOW-PEQUIV-ALIST,NEXT-PEQUIVS-ALIST,SUBST-EQUIV-EXPR1,GENEQV-LST1" data-part-name="GENEQV-REFINEMENTP" data-part-args="WRLD,GENEQV,EQUIV" data-part-body="WRLD,COARSENINGS,GETPROPC,GENEQV-REFINEMENTP1,T,GENEQV,NULL,*FAKE-RUNE-FOR-ANONYMOUS-ENABLED-RULE*,EQUAL,QUOTE,EQUIV,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-REFINEMENTP">geneqv-refinementp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a>
  (equiv geneqv wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv 'equal) *fake-rune-for-anonymous-enabled-rule*)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-geneqv-refinementp1" data-sym="GENEQV-REFINEMENTP1" title="(defun geneqv-refinementp1 (coarsenings geneqv)
  (cond ((null geneqv) nil)
        ((member-eq (access congruence-rule (car geneqv) :equiv) coarsenings)
         (access congruence-rule (car geneqv) :rune))
        (t (geneqv-refinementp1 coarsenings (cdr geneqv)))))">geneqv-refinementp1</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> equiv 'coarsenings nil wrld)
        geneqv))))</pre>
  </div>

<div class="form-block function" id="def-some-congruence-rule-disabledp" data-defines="SOME-CONGRUENCE-RULE-DISABLEDP" data-references="T,CDR,CAR,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,NULL,COND,ENS,GENEQV,DEFUN" data-used-by="SOME-GENEQV-DISABLEDP,FILTER-GENEQV" data-part-name="SOME-CONGRUENCE-RULE-DISABLEDP" data-part-args="ENS,GENEQV" data-part-body="T,CDR,SOME-CONGRUENCE-RULE-DISABLEDP,ENS,CAR,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,GENEQV,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SOME-CONGRUENCE-RULE-DISABLEDP">some-congruence-rule-disabledp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-some-congruence-rule-disabledp" data-sym="SOME-CONGRUENCE-RULE-DISABLEDP" title="(defun some-congruence-rule-disabledp (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (some-congruence-rule-disabledp (cdr geneqv) ens))
        (t t)))">some-congruence-rule-disabledp</a>
  (geneqv ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) nil)
    ((enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:nume</span>)
       ens) (<a class="sym-link local-def" href="#def-some-congruence-rule-disabledp" data-sym="SOME-CONGRUENCE-RULE-DISABLEDP" title="(defun some-congruence-rule-disabledp (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (some-congruence-rule-disabledp (cdr geneqv) ens))
        (t t)))">some-congruence-rule-disabledp</a> (cdr geneqv) ens))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))</pre>
  </div>

<div class="form-block function" id="def-filter-geneqv1" data-defines="FILTER-GENEQV1" data-references="T,CDR,CONS,CAR,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,NULL,COND,ENS,GENEQV,DEFUN" data-used-by="FILTER-GENEQV" data-part-name="FILTER-GENEQV1" data-part-args="ENS,GENEQV" data-part-body="T,CDR,FILTER-GENEQV1,CONS,ENS,CAR,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,GENEQV,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FILTER-GENEQV1">filter-geneqv1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-filter-geneqv1" data-sym="FILTER-GENEQV1" title="(defun filter-geneqv1 (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (cons (car geneqv) (filter-geneqv1 (cdr geneqv) ens)))
        (t (filter-geneqv1 (cdr geneqv) ens))))">filter-geneqv1</a>
  (geneqv ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) nil)
    ((enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:nume</span>)
       ens) (cons (car geneqv) (<a class="sym-link local-def" href="#def-filter-geneqv1" data-sym="FILTER-GENEQV1" title="(defun filter-geneqv1 (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (cons (car geneqv) (filter-geneqv1 (cdr geneqv) ens)))
        (t (filter-geneqv1 (cdr geneqv) ens))))">filter-geneqv1</a> (cdr geneqv) ens)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-filter-geneqv1" data-sym="FILTER-GENEQV1" title="(defun filter-geneqv1 (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (cons (car geneqv) (filter-geneqv1 (cdr geneqv) ens)))
        (t (filter-geneqv1 (cdr geneqv) ens))))">filter-geneqv1</a> (cdr geneqv) ens))))</pre>
  </div>

<div class="form-block function" id="def-filter-geneqv" data-defines="FILTER-GENEQV" data-references="T,FILTER-GENEQV1,SOME-CONGRUENCE-RULE-DISABLEDP,COND,ENS,GENEQV,DEFUN" data-used-by="FILTER-GENEQV-LST1" data-part-name="FILTER-GENEQV" data-part-args="ENS,GENEQV" data-part-body="T,FILTER-GENEQV1,ENS,GENEQV,SOME-CONGRUENCE-RULE-DISABLEDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FILTER-GENEQV">filter-geneqv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-filter-geneqv" data-sym="FILTER-GENEQV" title="(defun filter-geneqv (geneqv ens)
  (cond
   ((some-congruence-rule-disabledp geneqv ens) (filter-geneqv1 geneqv ens))
   (t geneqv)))">filter-geneqv</a>
  (geneqv ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-some-congruence-rule-disabledp" data-sym="SOME-CONGRUENCE-RULE-DISABLEDP" title="(defun some-congruence-rule-disabledp (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (some-congruence-rule-disabledp (cdr geneqv) ens))
        (t t)))">some-congruence-rule-disabledp</a> geneqv ens) (<a class="sym-link local-def" href="#def-filter-geneqv1" data-sym="FILTER-GENEQV1" title="(defun filter-geneqv1 (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (cons (car geneqv) (filter-geneqv1 (cdr geneqv) ens)))
        (t (filter-geneqv1 (cdr geneqv) ens))))">filter-geneqv1</a> geneqv ens))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> geneqv)))</pre>
  </div>

<div class="form-block function" id="def-some-geneqv-disabledp" data-defines="SOME-GENEQV-DISABLEDP" data-references="CDR,T,CAR,SOME-CONGRUENCE-RULE-DISABLEDP,NULL,COND,ENS,LST,DEFUN" data-used-by="FILTER-GENEQV-LST" data-part-name="SOME-GENEQV-DISABLEDP" data-part-args="ENS,LST" data-part-body="CDR,SOME-GENEQV-DISABLEDP,T,ENS,CAR,SOME-CONGRUENCE-RULE-DISABLEDP,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SOME-GENEQV-DISABLEDP">some-geneqv-disabledp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-some-geneqv-disabledp" data-sym="SOME-GENEQV-DISABLEDP" title="(defun some-geneqv-disabledp (lst ens)
  (cond ((null lst) nil) ((some-congruence-rule-disabledp (car lst) ens) t)
        (t (some-geneqv-disabledp (cdr lst) ens))))">some-geneqv-disabledp</a>
  (lst ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    ((<a class="sym-link local-def" href="#def-some-congruence-rule-disabledp" data-sym="SOME-CONGRUENCE-RULE-DISABLEDP" title="(defun some-congruence-rule-disabledp (geneqv ens)
  (cond ((null geneqv) nil)
        ((enabled-numep (access congruence-rule (car geneqv) :nume) ens)
         (some-congruence-rule-disabledp (cdr geneqv) ens))
        (t t)))">some-congruence-rule-disabledp</a> (car lst) ens) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-some-geneqv-disabledp" data-sym="SOME-GENEQV-DISABLEDP" title="(defun some-geneqv-disabledp (lst ens)
  (cond ((null lst) nil) ((some-congruence-rule-disabledp (car lst) ens) t)
        (t (some-geneqv-disabledp (cdr lst) ens))))">some-geneqv-disabledp</a> (cdr lst) ens))))</pre>
  </div>

<div class="form-block function" id="def-filter-geneqv-lst1" data-defines="FILTER-GENEQV-LST1" data-references="CDR,CAR,FILTER-GENEQV,CONS,T,NULL,COND,ENS,LST,DEFUN" data-used-by="FILTER-GENEQV-LST" data-part-name="FILTER-GENEQV-LST1" data-part-args="ENS,LST" data-part-body="CDR,FILTER-GENEQV-LST1,ENS,CAR,FILTER-GENEQV,CONS,T,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FILTER-GENEQV-LST1">filter-geneqv-lst1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-filter-geneqv-lst1" data-sym="FILTER-GENEQV-LST1" title="(defun filter-geneqv-lst1 (lst ens)
  (cond ((null lst) nil)
        (t
         (cons (filter-geneqv (car lst) ens)
               (filter-geneqv-lst1 (cdr lst) ens)))))">filter-geneqv-lst1</a>
  (lst ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-filter-geneqv" data-sym="FILTER-GENEQV" title="(defun filter-geneqv (geneqv ens)
  (cond
   ((some-congruence-rule-disabledp geneqv ens) (filter-geneqv1 geneqv ens))
   (t geneqv)))">filter-geneqv</a> (car lst) ens)
        (<a class="sym-link local-def" href="#def-filter-geneqv-lst1" data-sym="FILTER-GENEQV-LST1" title="(defun filter-geneqv-lst1 (lst ens)
  (cond ((null lst) nil)
        (t
         (cons (filter-geneqv (car lst) ens)
               (filter-geneqv-lst1 (cdr lst) ens)))))">filter-geneqv-lst1</a> (cdr lst) ens)))))</pre>
  </div>

<div class="form-block function" id="def-filter-geneqv-lst" data-defines="FILTER-GENEQV-LST" data-references="T,FILTER-GENEQV-LST1,SOME-GENEQV-DISABLEDP,NULL,COND,ENS,LST,DEFUN" data-used-by="GENEQV-LST,GENEQV-LST1" data-part-name="FILTER-GENEQV-LST" data-part-args="ENS,LST" data-part-body="T,FILTER-GENEQV-LST1,SOME-GENEQV-DISABLEDP,LST,ENS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FILTER-GENEQV-LST">filter-geneqv-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-filter-geneqv-lst" data-sym="FILTER-GENEQV-LST" title="(defun filter-geneqv-lst (lst ens)
  (cond ((null ens) lst)
        ((some-geneqv-disabledp lst ens) (filter-geneqv-lst1 lst ens)) (t lst)))">filter-geneqv-lst</a>
  (lst ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ens) lst)
    ((<a class="sym-link local-def" href="#def-some-geneqv-disabledp" data-sym="SOME-GENEQV-DISABLEDP" title="(defun some-geneqv-disabledp (lst ens)
  (cond ((null lst) nil) ((some-congruence-rule-disabledp (car lst) ens) t)
        (t (some-geneqv-disabledp (cdr lst) ens))))">some-geneqv-disabledp</a> lst ens) (<a class="sym-link local-def" href="#def-filter-geneqv-lst1" data-sym="FILTER-GENEQV-LST1" title="(defun filter-geneqv-lst1 (lst ens)
  (cond ((null lst) nil)
        (t
         (cons (filter-geneqv (car lst) ens)
               (filter-geneqv-lst1 (cdr lst) ens)))))">filter-geneqv-lst1</a> lst ens))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> lst)))</pre>
  </div>

<div class="form-block function" id="def-refinementp1" data-defines="REFINEMENTP1" data-references="MEMBER-EQ,T,EQUAL,QUOTE,EQ,COND,EQUIV2,COARSENINGS1,EQUIV1,DEFUN" data-used-by="ADD-TO-CR-AND-COARSENINGS" data-part-name="REFINEMENTP1" data-part-args="EQUIV2,COARSENINGS1,EQUIV1" data-part-body="COARSENINGS1,MEMBER-EQ,EQUIV2,T,EQUAL,QUOTE,EQUIV1,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REFINEMENTP1">refinementp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-refinementp1" data-sym="REFINEMENTP1" title="(defun refinementp1 (equiv1 coarsenings1 equiv2)
  (cond ((eq equiv1 &#39;equal) t) ((eq equiv2 &#39;equal) nil) ((eq equiv1 equiv2) t)
        (t (member-eq equiv2 coarsenings1))))">refinementp1</a>
  (equiv1 coarsenings1 equiv2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv1 'equal) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv2 'equal) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> equiv1 equiv2) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> equiv2 coarsenings1))))</pre>
  </div>

<div class="form-block function" id="def-pair-congruence-rules-with-coarsenings" data-defines="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS" data-references="COARSENINGS,QUOTE,CONGRUENCE-RULE,ACCESS,GETPROPC,CDR,CAR,CONS,T,NULL,COND,WRLD,GENEQV,DEFUN" data-used-by="UNION-GENEQV" data-part-name="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS" data-part-args="WRLD,GENEQV" data-part-body="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS,WRLD,COARSENINGS,QUOTE,CONGRUENCE-RULE,ACCESS,GETPROPC,CDR,CAR,CONS,T,GENEQV,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS">pair-congruence-rules-with-coarsenings</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pair-congruence-rules-with-coarsenings" data-sym="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS" title="(defun pair-congruence-rules-with-coarsenings (geneqv wrld)
  (cond ((null geneqv) nil)
        (t
         (cons
          (cons (car geneqv)
...">pair-congruence-rules-with-coarsenings</a>
  (geneqv wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (car geneqv)
          (cdr (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:equiv</span>)
              'coarsenings
              nil
              wrld)))
        (<a class="sym-link local-def" href="#def-pair-congruence-rules-with-coarsenings" data-sym="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS" title="(defun pair-congruence-rules-with-coarsenings (geneqv wrld)
  (cond ((null geneqv) nil)
        (t
         (cons
          (cons (car geneqv)
...">pair-congruence-rules-with-coarsenings</a> (cdr geneqv) wrld)))))</pre>
  </div>

<div class="form-block function" id="def-add-to-cr-and-coarsenings" data-defines="ADD-TO-CR-AND-COARSENINGS" data-references="T,CONGRUENCE-RULE,ACCESS,CAR,REFINEMENTP1,AND,CDR,CONS,LIST,NULL,COND,BOTH-TESTS-FLG,OLD-CRS-AND-COARSENINGS,NEW-CR-COARSENINGS,NEW-CR,DEFUN" data-used-by="UNION-GENEQV1" data-part-name="ADD-TO-CR-AND-COARSENINGS" data-part-args="BOTH-TESTS-FLG,OLD-CRS-AND-COARSENINGS,NEW-CR-COARSENINGS,NEW-CR" data-part-body="T,ADD-TO-CR-AND-COARSENINGS,CONGRUENCE-RULE,ACCESS,CAR,REFINEMENTP1,BOTH-TESTS-FLG,AND,NEW-CR-COARSENINGS,CDR,NEW-CR,CONS,LIST,OLD-CRS-AND-COARSENINGS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-TO-CR-AND-COARSENINGS">add-to-cr-and-coarsenings</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-to-cr-and-coarsenings" data-sym="ADD-TO-CR-AND-COARSENINGS" title="(defun add-to-cr-and-coarsenings
       (new-cr new-cr-coarsenings old-crs-and-coarsenings both-tests-flg)
  (cond
   ((null old-crs-and-coarsenings)
    (list (cons new-cr (cdr new-cr-coarsenings))))
...">add-to-cr-and-coarsenings</a>
  (new-cr new-cr-coarsenings
    old-crs-and-coarsenings
    both-tests-flg)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> old-crs-and-coarsenings) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons new-cr (cdr new-cr-coarsenings))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> both-tests-flg
       (<a class="sym-link local-def" href="#def-refinementp1" data-sym="REFINEMENTP1" title="(defun refinementp1 (equiv1 coarsenings1 equiv2)
  (cond ((eq equiv1 &#39;equal) t) ((eq equiv2 &#39;equal) nil) ((eq equiv1 equiv2) t)
        (t (member-eq equiv2 coarsenings1))))">refinementp1</a> (car new-cr-coarsenings)
         (cdr new-cr-coarsenings)
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule
           (car (car old-crs-and-coarsenings))
           <span class="keyword">:equiv</span>))) old-crs-and-coarsenings)
    ((<a class="sym-link local-def" href="#def-refinementp1" data-sym="REFINEMENTP1" title="(defun refinementp1 (equiv1 coarsenings1 equiv2)
  (cond ((eq equiv1 &#39;equal) t) ((eq equiv2 &#39;equal) nil) ((eq equiv1 equiv2) t)
        (t (member-eq equiv2 coarsenings1))))">refinementp1</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule
         (car (car old-crs-and-coarsenings))
         <span class="keyword">:equiv</span>)
       (cdr (car old-crs-and-coarsenings))
       (car new-cr-coarsenings)) (<a class="sym-link local-def" href="#def-add-to-cr-and-coarsenings" data-sym="ADD-TO-CR-AND-COARSENINGS" title="(defun add-to-cr-and-coarsenings
       (new-cr new-cr-coarsenings old-crs-and-coarsenings both-tests-flg)
  (cond
   ((null old-crs-and-coarsenings)
    (list (cons new-cr (cdr new-cr-coarsenings))))
...">add-to-cr-and-coarsenings</a> new-cr
        new-cr-coarsenings
        (cdr old-crs-and-coarsenings)
        nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car old-crs-and-coarsenings)
        (<a class="sym-link local-def" href="#def-add-to-cr-and-coarsenings" data-sym="ADD-TO-CR-AND-COARSENINGS" title="(defun add-to-cr-and-coarsenings
       (new-cr new-cr-coarsenings old-crs-and-coarsenings both-tests-flg)
  (cond
   ((null old-crs-and-coarsenings)
    (list (cons new-cr (cdr new-cr-coarsenings))))
...">add-to-cr-and-coarsenings</a> new-cr
          new-cr-coarsenings
          (cdr old-crs-and-coarsenings)
          both-tests-flg)))))</pre>
  </div>

<div class="form-block function" id="def-union-geneqv1" data-defines="UNION-GENEQV1" data-references="COARSENINGS,QUOTE,CONGRUENCE-RULE,ACCESS,GETPROPC,CAR,ADD-TO-CR-AND-COARSENINGS,CDR,T,NULL,COND,WRLD,OLD-CRS-AND-COARSENINGS,GENEQV1,DEFUN" data-used-by="UNION-GENEQV" data-part-name="UNION-GENEQV1" data-part-args="WRLD,OLD-CRS-AND-COARSENINGS,GENEQV1" data-part-body="WRLD,COARSENINGS,QUOTE,CONGRUENCE-RULE,ACCESS,GETPROPC,CAR,ADD-TO-CR-AND-COARSENINGS,CDR,UNION-GENEQV1,T,OLD-CRS-AND-COARSENINGS,GENEQV1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UNION-GENEQV1">union-geneqv1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-union-geneqv1" data-sym="UNION-GENEQV1" title="(defun union-geneqv1 (geneqv1 old-crs-and-coarsenings wrld)
  (cond ((null geneqv1) old-crs-and-coarsenings)
        (t
         (union-geneqv1 (cdr geneqv1)
                        (add-to-cr-and-coarsenings (car geneqv1)
...">union-geneqv1</a>
  (geneqv1 old-crs-and-coarsenings wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv1) old-crs-and-coarsenings)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-union-geneqv1" data-sym="UNION-GENEQV1" title="(defun union-geneqv1 (geneqv1 old-crs-and-coarsenings wrld)
  (cond ((null geneqv1) old-crs-and-coarsenings)
        (t
         (union-geneqv1 (cdr geneqv1)
                        (add-to-cr-and-coarsenings (car geneqv1)
...">union-geneqv1</a> (cdr geneqv1)
        (<a class="sym-link local-def" href="#def-add-to-cr-and-coarsenings" data-sym="ADD-TO-CR-AND-COARSENINGS" title="(defun add-to-cr-and-coarsenings
       (new-cr new-cr-coarsenings old-crs-and-coarsenings both-tests-flg)
  (cond
   ((null old-crs-and-coarsenings)
    (list (cons new-cr (cdr new-cr-coarsenings))))
...">add-to-cr-and-coarsenings</a> (car geneqv1)
          (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv1) <span class="keyword">:equiv</span>)
            'coarsenings
            nil
            wrld)
          old-crs-and-coarsenings
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        wrld))))</pre>
  </div>

<div class="form-block function" id="def-union-geneqv" data-defines="UNION-GENEQV" data-references="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS,UNION-GENEQV1,STRIP-CARS,WRLD,GENEQV2,GENEQV1,DEFUN" data-used-by="PAIRWISE-UNION-GENEQV" data-part-name="UNION-GENEQV" data-part-args="WRLD,GENEQV2,GENEQV1" data-part-body="WRLD,GENEQV2,PAIR-CONGRUENCE-RULES-WITH-COARSENINGS,GENEQV1,UNION-GENEQV1,STRIP-CARS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UNION-GENEQV">union-geneqv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-union-geneqv" data-sym="UNION-GENEQV" title="(defun union-geneqv (geneqv1 geneqv2 wrld)
  (strip-cars
   (union-geneqv1 geneqv1 (pair-congruence-rules-with-coarsenings geneqv2 wrld)
                  wrld)))">union-geneqv</a>
  (geneqv1 geneqv2 wrld)
  (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> (<a class="sym-link local-def" href="#def-union-geneqv1" data-sym="UNION-GENEQV1" title="(defun union-geneqv1 (geneqv1 old-crs-and-coarsenings wrld)
  (cond ((null geneqv1) old-crs-and-coarsenings)
        (t
         (union-geneqv1 (cdr geneqv1)
                        (add-to-cr-and-coarsenings (car geneqv1)
...">union-geneqv1</a> geneqv1
      (<a class="sym-link local-def" href="#def-pair-congruence-rules-with-coarsenings" data-sym="PAIR-CONGRUENCE-RULES-WITH-COARSENINGS" title="(defun pair-congruence-rules-with-coarsenings (geneqv wrld)
  (cond ((null geneqv) nil)
        (t
         (cons
          (cons (car geneqv)
...">pair-congruence-rules-with-coarsenings</a> geneqv2 wrld)
      wrld)))</pre>
  </div>

<div class="form-block function" id="def-pairwise-union-geneqv" data-defines="PAIRWISE-UNION-GENEQV" data-references="CDR,CAR,UNION-GENEQV,CONS,T,NULL,COND,WRLD,LST2,LST1,DEFUN" data-used-by="GENEQV-LST1" data-part-name="PAIRWISE-UNION-GENEQV" data-part-args="WRLD,LST2,LST1" data-part-body="CDR,PAIRWISE-UNION-GENEQV,WRLD,LST2,CAR,UNION-GENEQV,CONS,T,LST1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PAIRWISE-UNION-GENEQV">pairwise-union-geneqv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pairwise-union-geneqv" data-sym="PAIRWISE-UNION-GENEQV" title="(defun pairwise-union-geneqv (lst1 lst2 wrld)
  (cond ((null lst1) nil)
        (t
         (cons (union-geneqv (car lst1) (car lst2) wrld)
               (pairwise-union-geneqv (cdr lst1) (cdr lst2) wrld)))))">pairwise-union-geneqv</a>
  (lst1 lst2 wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst1) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-union-geneqv" data-sym="UNION-GENEQV" title="(defun union-geneqv (geneqv1 geneqv2 wrld)
  (strip-cars
   (union-geneqv1 geneqv1 (pair-congruence-rules-with-coarsenings geneqv2 wrld)
                  wrld)))">union-geneqv</a> (car lst1) (car lst2) wrld)
        (<a class="sym-link local-def" href="#def-pairwise-union-geneqv" data-sym="PAIRWISE-UNION-GENEQV" title="(defun pairwise-union-geneqv (lst1 lst2 wrld)
  (cond ((null lst1) nil)
        (t
         (cons (union-geneqv (car lst1) (car lst2) wrld)
               (pairwise-union-geneqv (cdr lst1) (cdr lst2) wrld)))))">pairwise-union-geneqv</a> (cdr lst1) (cdr lst2) wrld)))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-lst1" data-defines="GENEQV-LST1" data-references="PAIRWISE-UNION-GENEQV,CDAR,FILTER-GENEQV-LST,CAAR,GENEQV-REFINEMENTP,CDR,ANS,LET,T,NULL,COND,WRLD,ENS,GENEQV,CONGRUENCES,DEFUN" data-used-by="GENEQV-LST" data-part-name="GENEQV-LST1" data-part-args="WRLD,ENS,GENEQV,CONGRUENCES" data-part-body="PAIRWISE-UNION-GENEQV,CDAR,FILTER-GENEQV-LST,CAAR,GENEQV-REFINEMENTP,WRLD,ENS,GENEQV,CDR,GENEQV-LST1,ANS,LET,T,CONGRUENCES,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-LST1">geneqv-lst1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-lst1" data-sym="GENEQV-LST1" title="(defun geneqv-lst1 (congruences geneqv ens wrld)
  (cond ((null congruences) nil)
        (t
         (let ((ans (geneqv-lst1 (cdr congruences) geneqv ens wrld)))
           (cond
...">geneqv-lst1</a>
  (congruences geneqv ens wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> congruences) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ans (<a class="sym-link local-def" href="#def-geneqv-lst1" data-sym="GENEQV-LST1" title="(defun geneqv-lst1 (congruences geneqv ens wrld)
  (cond ((null congruences) nil)
        (t
         (let ((ans (geneqv-lst1 (cdr congruences) geneqv ens wrld)))
           (cond
...">geneqv-lst1</a> (cdr congruences) geneqv ens wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> congruences) geneqv wrld) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ans) (<a class="sym-link local-def" href="#def-filter-geneqv-lst" data-sym="FILTER-GENEQV-LST" title="(defun filter-geneqv-lst (lst ens)
  (cond ((null ens) lst)
        ((some-geneqv-disabledp lst ens) (filter-geneqv-lst1 lst ens)) (t lst)))">filter-geneqv-lst</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> congruences) ens))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-pairwise-union-geneqv" data-sym="PAIRWISE-UNION-GENEQV" title="(defun pairwise-union-geneqv (lst1 lst2 wrld)
  (cond ((null lst1) nil)
        (t
         (cons (union-geneqv (car lst1) (car lst2) wrld)
               (pairwise-union-geneqv (cdr lst1) (cdr lst2) wrld)))))">pairwise-union-geneqv</a> (<a class="sym-link local-def" href="#def-filter-geneqv-lst" data-sym="FILTER-GENEQV-LST" title="(defun filter-geneqv-lst (lst ens)
  (cond ((null ens) lst)
        ((some-geneqv-disabledp lst ens) (filter-geneqv-lst1 lst ens)) (t lst)))">filter-geneqv-lst</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> congruences) ens)
                  ans
                  wrld))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ans))))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-lst" data-defines="GENEQV-LST" data-references="GENEQV-LST1,EQUAL,ASSOC-EQ,CDR,FILTER-GENEQV-LST,NULL,GETPROPC,CONGRUENCES,LET,T,*GENEQV-IFF*,LIST,IF,QUOTE,EQ,FLAMBDAP,COND,WRLD,ENS,GENEQV,FN,DEFUN" data-used-by="REWRITE,COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST,SUBST-EQUIV-EXPR1" data-part-name="GENEQV-LST" data-part-args="WRLD,ENS,GENEQV,FN" data-part-body="GENEQV-LST1,ENS,EQUAL,ASSOC-EQ,CDR,FILTER-GENEQV-LST,NULL,WRLD,GETPROPC,CONGRUENCES,LET,T,GENEQV,*GENEQV-IFF*,LIST,IF,QUOTE,EQ,FN,FLAMBDAP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-LST">geneqv-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>
  (fn geneqv ens wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'if) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a> geneqv geneqv))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((congruences (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'congruences nil wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> congruences) nil)
          ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> geneqv) (<a class="sym-link local-def" href="#def-filter-geneqv-lst" data-sym="FILTER-GENEQV-LST" title="(defun filter-geneqv-lst (lst ens)
  (cond ((null ens) lst)
        ((some-geneqv-disabledp lst ens) (filter-geneqv-lst1 lst ens)) (t lst)))">filter-geneqv-lst</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'equal congruences)) ens))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-geneqv-lst1" data-sym="GENEQV-LST1" title="(defun geneqv-lst1 (congruences geneqv ens wrld)
  (cond ((null congruences) nil)
        (t
         (let ((ans (geneqv-lst1 (cdr congruences) geneqv ens wrld)))
           (cond
...">geneqv-lst1</a> congruences geneqv ens wrld)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-subst-expr1" data-defines="SUBST-EXPR1" data-references="CDR,CAR,CONS,ENDP,PSEUDO-TERM-LISTP,ARGS,FARGS,SUBST-EXPR1-LST,FFN-SYMB,CONS-TERM,T,FQUOTEP,VARIABLEP,EQUAL,COND,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM,OLD,NEW,DEFUN,MUTUAL-RECURSION" data-used-by="SUBST-EXPR" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EXPR1">subst-expr1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-expr1" data-sym="SUBST-EXPR1" title="(mutual-recursion
 (defun subst-expr1 (new old term)
   (declare
    (xargs :guard
     (and (pseudo-termp new) (pseudo-termp old) (pseudo-termp term))))
...">subst-expr1</a>
    (new old term)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> new)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> old)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term old) new)
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) term)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) term)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
          (subst-expr1-lst new old (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> subst-expr1-lst
    (new old <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> new)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> old)
          (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-subst-expr1" data-sym="SUBST-EXPR1" title="(mutual-recursion
 (defun subst-expr1 (new old term)
   (declare
    (xargs :guard
     (and (pseudo-termp new) (pseudo-termp old) (pseudo-termp term))))
...">subst-expr1</a> new old (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
          (subst-expr1-lst new old (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-subst-expr-error" data-defines="SUBST-EXPR-ERROR" data-references="QUOTE,HARD,ER,XARGS,DECLARE,CONST,DEFUN" data-used-by="SUBST-EQUIV-EXPR,SUBST-EXPR" data-part-name="SUBST-EXPR-ERROR" data-part-args="CONST" data-part-declare="XARGS,DECLARE" data-part-body="CONST,SUBST-EXPR-ERROR,QUOTE,HARD,ER" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EXPR-ERROR">subst-expr-error</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-expr-error" data-sym="SUBST-EXPR-ERROR" title="(defun subst-expr-error (const)
  (declare (xargs :guard nil))
  (er hard &#39;subst-expr-error
      &quot;An attempt was made to substitute for the explicit value ~x0.  ~
       The substitution functions were optimized to disallow this.&quot;">subst-expr-error</a>
  (const)
  (declare (xargs <span class="keyword">:guard</span> nil))
  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
    '<a class="sym-link local-def" href="#def-subst-expr-error" data-sym="SUBST-EXPR-ERROR" title="(defun subst-expr-error (const)
  (declare (xargs :guard nil))
  (er hard &#39;subst-expr-error
      &quot;An attempt was made to substitute for the explicit value ~x0.  ~
       The substitution functions were optimized to disallow this.&quot;">subst-expr-error</a>
    <span class="string">"An attempt was made to substitute for the explicit value ~x0.  ~
       The substitution functions were optimized to disallow this."</span>
    const))</pre>
  </div>

<div class="form-block function" id="def-subst-expr" data-defines="SUBST-EXPR" data-references="SUBST-EXPR1,T,SUBST-EXPR-ERROR,FQUOTEP,SUBST-VAR,VARIABLEP,COND,QUOTEP,NOT,PSEUDO-TERMP,AND,XARGS,DECLARE,TERM,OLD,NEW,DEFUN" data-part-name="SUBST-EXPR" data-part-args="TERM,OLD,NEW" data-part-declare="TERM,QUOTEP,NOT,OLD,NEW,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="SUBST-EXPR1,T,SUBST-EXPR-ERROR,FQUOTEP,TERM,NEW,SUBST-VAR,OLD,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EXPR">subst-expr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-expr" data-sym="SUBST-EXPR" title="(defun subst-expr (new old term)
  (declare
   (xargs :guard
    (and (pseudo-termp new) (pseudo-termp old) (not (quotep old))
         (pseudo-termp term))))
...">subst-expr</a>
  (new old term)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> new)
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> old)
        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> old))
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> old) (subst-var new old term))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> old) (<a class="sym-link local-def" href="#def-subst-expr-error" data-sym="SUBST-EXPR-ERROR" title="(defun subst-expr-error (const)
  (declare (xargs :guard nil))
  (er hard &#39;subst-expr-error
      &quot;An attempt was made to substitute for the explicit value ~x0.  ~
       The substitution functions were optimized to disallow this.&quot;">subst-expr-error</a> old))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subst-expr1" data-sym="SUBST-EXPR1" title="(mutual-recursion
 (defun subst-expr1 (new old term)
   (declare
    (xargs :guard
     (and (pseudo-termp new) (pseudo-termp old) (pseudo-termp term))))
...">subst-expr1</a> new old term))))</pre>
  </div>

<div class="form-block function" id="def-comment-fn" data-defines="COMMENT-FN" data-references="PROGN,QUOTE,RETURN-LAST,QUASIQUOTE,T,XARGS,DECLARE,Y,X,DEFUN" data-used-by="HIDE-WITH-COMMENT,COMMENT" data-part-name="COMMENT-FN" data-part-args="Y,X" data-part-declare="T,XARGS,DECLARE" data-part-body="PROGN,QUOTE,RETURN-LAST,QUASIQUOTE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMMENT-FN">comment-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-comment-fn" data-sym="COMMENT-FN" title="(defun comment-fn (x y)
  (declare (xargs :guard t))
  `(return-last &#39;progn &#39;(:comment . ,x) ,y))">comment-fn</a>
  (x y)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  `(<a class="sym-link system" href="axioms.html#def-return-last" data-sym="RETURN-LAST">return-last</a> '<a class="sym-link system" href="axioms.html#def-progn" data-sym="PROGN">progn</a> '(<span class="keyword">:comment</span> . ,X) ,Y))</pre>
  </div>

<div class="form-block macro" id="def-comment" data-defines="COMMENT" data-references="COMMENT-FN,Y,X,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMMENT">comment</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-comment" data-sym="COMMENT" title="(defmacro comment (x y) (comment-fn x y))">comment</a> (x y) (<a class="sym-link local-def" href="#def-comment-fn" data-sym="COMMENT-FN" title="(defun comment-fn (x y)
  (declare (xargs :guard t))
  `(return-last &#39;progn &#39;(:comment . ,x) ,y))">comment-fn</a> x y))</pre>
  </div>

<div class="form-block other" id="form-30" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> hide-with-comment-p nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-31" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> hide-with-comment-p <a class="sym-link system" href="axioms.html#def-constant-t-function-arity-0" data-sym="CONSTANT-T-FUNCTION-ARITY-0">constant-t-function-arity-0</a>)</pre>
  </div>

<div class="form-block function" id="def-hide-with-comment" data-defines="HIDE-WITH-COMMENT" data-references="HARD,ER,&,FN-STR,DISABLEDP,FN?,BASE-SYMBOL,NAME,RUNE,LET,CASE-MATCH,SYMBOL-PACKAGE-NAME,SYMBOL-NAME,WARRANT-FUNCTION-NAMEP,ATTACHMENT-PAIR,STR2,STR1,STR0,SYMBOL-IN-CURRENT-PACKAGE-P,SKIP-PKG-PREFIX,GETPROPC,NON-EXECUTABLEP,NON-EXEC,IF,CDR,SYMBOLP,EV-FNCALL-NULL-BODY-ER,CAR,EQ,CONSP,AND,FN,LET*,SCONS-TERM-P,ERP,REASON-STRING,STRING,CONCATENATE,COMMENT-FN,Y,X,COMMENT-FN+,FLET,T,HIDE,QUOTE,FCONS-TERM*,HIDE-WITH-COMMENT-P,NULL,OR,COND,XARGS,DECLARE,STATE,WRLD,TERM,REASON,DEFUN" data-used-by="REWRITE,SCONS-TERM" data-part-name="HIDE-WITH-COMMENT" data-part-args="STATE,WRLD,TERM,REASON" data-part-declare="STATE,XARGS,DECLARE" data-part-body="HIDE-WITH-COMMENT,HARD,ER,&,FN-STR,DISABLEDP,FN?,BASE-SYMBOL,NAME,RUNE,LET,CASE-MATCH,SYMBOL-PACKAGE-NAME,SYMBOL-NAME,WARRANT-FUNCTION-NAMEP,ATTACHMENT-PAIR,STR2,STR1,STR0,SYMBOL-IN-CURRENT-PACKAGE-P,SKIP-PKG-PREFIX,GETPROPC,NON-EXECUTABLEP,NON-EXEC,IF,CDR,SYMBOLP,EV-FNCALL-NULL-BODY-ER,CAR,EQ,CONSP,AND,FN,LET*,STATE,WRLD,SCONS-TERM-P,ERP,REASON-STRING,STRING,CONCATENATE,COMMENT-FN,Y,X,COMMENT-FN+,FLET,T,TERM,HIDE,QUOTE,FCONS-TERM*,HIDE-WITH-COMMENT-P,REASON,NULL,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="HIDE-WITH-COMMENT">hide-with-comment</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a>
  (reason term wrld state)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span> <span class="keyword">:stobjs</span> state))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> reason) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (hide-with-comment-p))) (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> term))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (flet ((comment-fn+ (x y)
           (<a class="sym-link local-def" href="#def-comment-fn" data-sym="COMMENT-FN" title="(defun comment-fn (x y)
  (declare (xargs :guard t))
  `(return-last &#39;progn &#39;(:comment . ,x) ,y))">comment-fn</a> (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
               x
               <span class="string">";
see :DOC comment"</span>)
             y)) (reason-string (erp scons-term-p wrld state)
            (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp erp)
                   (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car erp) 'ev-fncall-null-body-er)
                   (symbolp (cdr erp))
                   (cdr erp))) (fn (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn <span class="keyword">:non-exec</span>)
                    '<a class="sym-link system" href="axioms.html#def-non-exec" data-sym="NON-EXEC">non-exec</a>
                    fn)))
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> fn
                (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((non-executablep (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'non-executablep nil wrld)) (skip-pkg-prefix (<a class="sym-link system" href="axioms.html#def-symbol-in-current-package-p" data-sym="SYMBOL-IN-CURRENT-PACKAGE-P">symbol-in-current-package-p</a> fn state))
                    (str0 (if scons-term-p
                        <span class="string">"Failed attempt (during substitution) to call "</span>
                        <span class="string">"Failed attempt to call "</span>))
                    (str1 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-non-exec" data-sym="NON-EXEC">non-exec</a>) <span class="string">""</span>)
                        (non-executablep <span class="string">"non-executable function "</span>)
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">"constrained function "</span>)))
                    (str2 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-non-exec" data-sym="NON-EXEC">non-exec</a>) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (attachment-pair fn wrld))) <span class="string">""</span>)
                        ((warrant-function-namep fn wrld) <span class="string">":
warrant functions are not executable during proofs"</span>)
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">":
its attachment is ignored during proofs"</span>))))
                  (if skip-pkg-prefix
                    (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a> str0 str1 (symbol-name fn) str2)
                    (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                      str0
                      str1
                      (symbol-package-name fn)
                      <span class="string">"::"</span>
                      (symbol-name fn)
                      str2)))))))
        (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> reason
          ((<span class="keyword">:non-executable</span> . erp) (let ((reason-string (reason-string erp nil wrld state)))
              (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
                (if reason-string
                  (comment-fn+ reason-string term)
                  term))))
          ((<span class="keyword">:scons-term</span> . erp) (let ((reason-string (reason-string erp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld state)))
              (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
                (if reason-string
                  (comment-fn+ reason-string term)
                  term))))
          ((<span class="keyword">:expand</span> rune . skip-pkg-prefix) (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
              (comment-fn+ (let ((name (if skip-pkg-prefix
                       (symbol-name (base-symbol rune))
                       (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                         (symbol-package-name (base-symbol rune))
                         <span class="string">"::"</span>
                         (symbol-name (base-symbol rune))))))
                  (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                    <span class="string">"Unable to expand using the rule "</span>
                    name))
                term)))
          ((<span class="keyword">:missing-warrant</span> . fn?) (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
              (comment-fn+ (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((<a class="sym-link system" href="defthm.html#def-disabledp" data-sym="DISABLEDP">disabledp</a> (consp fn?)) (fn (if <a class="sym-link system" href="defthm.html#def-disabledp" data-sym="DISABLEDP">disabledp</a>
                        (car fn?)
                        fn?))
                    (skip-pkg-prefix (<a class="sym-link system" href="axioms.html#def-symbol-in-current-package-p" data-sym="SYMBOL-IN-CURRENT-PACKAGE-P">symbol-in-current-package-p</a> fn state))
                    (fn-str (if skip-pkg-prefix
                        (symbol-name fn)
                        (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                          (symbol-package-name fn)
                          <span class="string">"::"</span>
                          (symbol-name fn)))))
                  (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                    <span class="string">"Call failed because "</span>
                    (if <a class="sym-link system" href="defthm.html#def-disabledp" data-sym="DISABLEDP">disabledp</a>
                      (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"the rule "</span> fn-str <span class="string">" is disabled"</span>)
                      (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>
                        <span class="string">"the warrant for "</span>
                        fn-str
                        <span class="string">" is not known to be true"</span>))))
                term)))
          (&amp; (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
              '<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a>
              <span class="string">"Unexpected reason supplied to ~x0!"</span>
              '<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-scons-term" data-defines="SCONS-TERM" data-references="PUFFERT,*T*,EQUAL,KWOTE,HIDE,FN-RUNE-NUME,PUSH-LEMMA,CONS,HIDE-WITH-COMMENT,STRIP-CADRS,EV-FNCALL+,PSTK,BAD-FN,VAL,ERP,MV-LET,PROGRAMP,CADDR,CAR,CADR,T,IF,EQ,CONS-TERM,MV,CONSTRAINEDP,QUOTE,GETPROPC,NOT,ENABLED-XFNP,FLAMBDAP,OR,ALL-QUOTEPS,AND,COND,TTREE,STATE,WRLD,ENS,ARGS,FN,DEFUN" data-used-by="SUBST-EQUIV-EXPR1" data-part-name="SCONS-TERM" data-part-args="TTREE,STATE,WRLD,ENS,ARGS,FN" data-part-body="PUFFERT,*T*,EQUAL,KWOTE,HIDE,FN-RUNE-NUME,PUSH-LEMMA,CONS,HIDE-WITH-COMMENT,STATE,STRIP-CADRS,EV-FNCALL+,PSTK,BAD-FN,VAL,ERP,MV-LET,PROGRAMP,CADDR,CAR,CADR,T,IF,EQ,TTREE,CONS-TERM,MV,CONSTRAINEDP,QUOTE,GETPROPC,NOT,WRLD,ENS,ENABLED-XFNP,FN,FLAMBDAP,OR,ARGS,ALL-QUOTEPS,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SCONS-TERM">scons-term</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-scons-term" data-sym="SCONS-TERM" title="(defun scons-term (fn args ens wrld state ttree)
  (cond
   ((and (all-quoteps args)
         (or (flambdap fn)
             (and (enabled-xfnp fn ens wrld)
...">scons-term</a>
  (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> ens wrld state ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (all-quoteps <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
       (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn)
         (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (enabled-xfnp fn ens wrld)
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'constrainedp nil wrld))))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'if) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            (if (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
              (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
              (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
            ttree))
        ((<a class="sym-link system" href="axioms.html#def-programp" data-sym="PROGRAMP">programp</a> fn wrld) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val bad-fn)
            (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-ev-fncall_2B" data-sym="EV-FNCALL+" title="(defun ev-fncall+ (fn args strictp state)
  (ev-fncall+-w fn args (w state) (f-get-global &#39;safe-mode state)
                (gc-off state) strictp))">ev-fncall+</a> fn (<a class="sym-link system" href="axioms.html#def-strip-cadrs" data-sym="STRIP-CADRS">strip-cadrs</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bad-fn (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                      (<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a> (cons <span class="keyword">:scons-term</span> erp)
                        (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                        wrld
                        state)
                      (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld) ttree)))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                  (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> val)
                  (push-lemma (fn-rune-nume fn nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld) ttree))))))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'equal) (equal (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (puffert ttree)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-subst-equiv-expr1" data-defines="SUBST-EQUIV-EXPR1" data-references="CONS,CDR,CAR,ARG,NULL,SCONS-TERM,NEW-TERM,HITP2,FARGS,GENEQV-LST,SUBST-EQUIV-EXPR1-LST,ARGS,HITP1,MV-LET,HIDE,QUOTE,FFN-SYMB,EQ,FQUOTEP,VARIABLEP,OR,PUSH-LEMMA,T,MV,GENEQV-REFINEMENTP,EQUAL,AND,COND,TTREE,STATE,WRLD,ENS,TERM,GENEQV,OLD,NEW,EQUIV,DEFUN,MUTUAL-RECURSION" data-used-by="SUBST-EQUIV-EXPR" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EQUIV-EXPR1">subst-equiv-expr1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-equiv-expr1" data-sym="SUBST-EQUIV-EXPR1" title="(mutual-recursion
 (defun subst-equiv-expr1 (equiv new old geneqv term ens wrld state ttree)
   (cond
    ((and (equal term old) (geneqv-refinementp equiv geneqv wrld))
     (mv t new (push-lemma (geneqv-refinementp equiv geneqv wrld) ttree)))
...">subst-equiv-expr1</a>
    (equiv new old geneqv term ens wrld state ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal term old)
         (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> equiv geneqv wrld)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
          new
          (push-lemma (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> equiv geneqv wrld) ttree)))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term)
         (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)
         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil term ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (hitp1 <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> ttree)
          (subst-equiv-expr1-lst equiv
            new
            old
            (<a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) geneqv ens wrld)
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
            ens
            wrld
            state
            ttree)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (hitp2 new-term ttree)
            (<a class="sym-link local-def" href="#def-scons-term" data-sym="SCONS-TERM" title="(defun scons-term (fn args ens wrld state ttree)
  (cond
   ((and (all-quoteps args)
         (or (flambdap fn)
             (and (enabled-xfnp fn ens wrld)
...">scons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> ens wrld state ttree)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> hitp1 hitp2) new-term ttree))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> subst-equiv-expr1-lst
    (equiv new old <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> ens wrld state ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (hitp1 arg ttree)
          (<a class="sym-link local-def" href="#def-subst-equiv-expr1" data-sym="SUBST-EQUIV-EXPR1" title="(mutual-recursion
 (defun subst-equiv-expr1 (equiv new old geneqv term ens wrld state ttree)
   (cond
    ((and (equal term old) (geneqv-refinementp equiv geneqv wrld))
     (mv t new (push-lemma (geneqv-refinementp equiv geneqv wrld) ttree)))
...">subst-equiv-expr1</a> equiv
            new
            old
            (car <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>)
            (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
            ens
            wrld
            state
            ttree)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (hitp2 <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> ttree)
            (subst-equiv-expr1-lst equiv
              new
              old
              (cdr <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>)
              (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
              ens
              wrld
              state
              ttree)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> hitp1 hitp2) (cons arg <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree)))))))</pre>
  </div>

<div class="form-block function" id="def-subst-equiv-expr" data-defines="SUBST-EQUIV-EXPR" data-references="SUBST-EQUIV-EXPR1,T,SUBST-EXPR-ERROR,MV,FQUOTEP,NVARIABLEP,AND,COND,TTREE,STATE,WRLD,ENS,TERM,GENEQV,OLD,NEW,EQUIV,DEFUN" data-part-name="SUBST-EQUIV-EXPR" data-part-args="TTREE,STATE,WRLD,ENS,TERM,GENEQV,OLD,NEW,EQUIV" data-part-body="STATE,WRLD,ENS,GENEQV,NEW,EQUIV,SUBST-EQUIV-EXPR1,T,TTREE,TERM,SUBST-EXPR-ERROR,MV,FQUOTEP,OLD,NVARIABLEP,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBST-EQUIV-EXPR">subst-equiv-expr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subst-equiv-expr" data-sym="SUBST-EQUIV-EXPR" title="(defun subst-equiv-expr (equiv new old geneqv term ens wrld state ttree)
  (cond
   ((and (nvariablep old) (fquotep old))
    (mv (subst-expr-error old) term ttree))
   (t (subst-equiv-expr1 equiv new old geneqv term ens wrld state ttree))))">subst-equiv-expr</a>
  (equiv new old geneqv term ens wrld state ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> old) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> old)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-subst-expr-error" data-sym="SUBST-EXPR-ERROR" title="(defun subst-expr-error (const)
  (declare (xargs :guard nil))
  (er hard &#39;subst-expr-error
      &quot;An attempt was made to substitute for the explicit value ~x0.  ~
       The substitution functions were optimized to disallow this.&quot;">subst-expr-error</a> old) term ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subst-equiv-expr1" data-sym="SUBST-EQUIV-EXPR1" title="(mutual-recursion
 (defun subst-equiv-expr1 (equiv new old geneqv term ens wrld state ttree)
   (cond
    ((and (equal term old) (geneqv-refinementp equiv geneqv wrld))
     (mv t new (push-lemma (geneqv-refinementp equiv geneqv wrld) ttree)))
...">subst-equiv-expr1</a> equiv
        new
        old
        geneqv
        term
        ens
        wrld
        state
        ttree))))</pre>
  </div>

<div class="form-block constant" id="def-_2Aanonymous-var_2A" data-defines="*ANONYMOUS-VAR*" data-references="Anonymous variable,QUOTE,DEFCONST" data-used-by="ONE-WAY-UNIFY1-TERM-ALIST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*ANONYMOUS-VAR*">*anonymous-var*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aanonymous-var_2A" data-sym="*ANONYMOUS-VAR*" title="(defconst *anonymous-var* &#39;|Anonymous variable|)">*anonymous-var*</a> '|Anonymous variable|)</pre>
  </div>

<div class="form-block mutual-recursion" id="def-equal-mod-alist" data-defines="EQUAL-MOD-ALIST" data-references="CAR,ENDP,TERM2-LST,TERM1-LST,FARGS,EQUAL-MOD-ALIST-LST,SUBLIS-VAR,*PRIMITIVE-FORMALS-AND-GUARDS*,FFN-SYMB,FLAMBDAP,NOT,AND,FQUOTEP,T,CDR,EQUAL,ASSOC-EQ,TEMP,LET,VARIABLEP,COND,TERM2,ALIST1,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="MEMBER-EQUAL-MOD-ALIST,ONE-WAY-UNIFY1-TERM-ALIST,EQUAL-MOD-ALIST2" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-MOD-ALIST">equal-mod-alist</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a>
    (term1 alist1 term2)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term1 alist1)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp (equal (cdr temp) term2))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (equal term1 term2)))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) (equal term1 term2))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1)))
             (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) <a class="sym-link system" href="basis-b.html#def-_2Aprimitive-formals-and-guards_2A" data-sym="*PRIMITIVE-FORMALS-AND-GUARDS*">*primitive-formals-and-guards*</a>)) (equal term2 (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> alist1 term1)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
      ((equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term2)) (equal-mod-alist-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1) alist1 (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> equal-mod-alist-lst
    (term1-lst alist1 term2-lst)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> term1-lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> (car term1-lst) alist1 (car term2-lst))
          (equal-mod-alist-lst (cdr term1-lst) alist1 (cdr term2-lst)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-equal-mod-alist2" data-defines="EQUAL-MOD-ALIST2" data-references="CAR,AND,ENDP,TERM2-LST,TERM1-LST,FARGS,EQUAL-MOD-ALIST2-LST,FFN-SYMB,EQUAL,FQUOTEP,T,IF,EQ,PAIR2,CDR,EQUAL-MOD-ALIST,ASSOC-EQ,PAIR1,LET,VARIABLEP,COND,ALIST2,TERM2,ALIST1,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="ONE-WAY-UNIFY1-TERM-ALIST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EQUAL-MOD-ALIST2">equal-mod-alist2</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-equal-mod-alist2" data-sym="EQUAL-MOD-ALIST2" title="(mutual-recursion
 (defun equal-mod-alist2 (term1 alist1 term2 alist2)
   (cond
    ((variablep term1)
     (let ((pair1 (assoc-eq term1 alist1)))
...">equal-mod-alist2</a>
    (term1 alist1 term2 alist2)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term1) (let ((pair1 (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term1 alist1)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair1 (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term2 alist2 (cdr pair1)))
            ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) (let ((pair2 (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term2 alist2)))
                (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term1
                  (if pair2
                    (cdr pair2)
                    term2))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) (let ((pair2 (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term2 alist2)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair2 (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term1 alist1 (cdr pair2)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term1) (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term2 alist2 term1))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2) (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term1 alist1 term2))
      ((equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term1) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term2)) (equal-mod-alist2-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term1)
          alist1
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2)
          alist2))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> equal-mod-alist2-lst
    (term1-lst alist1 term2-lst alist2)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> term1-lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-equal-mod-alist2" data-sym="EQUAL-MOD-ALIST2" title="(mutual-recursion
 (defun equal-mod-alist2 (term1 alist1 term2 alist2)
   (cond
    ((variablep term1)
     (let ((pair1 (assoc-eq term1 alist1)))
...">equal-mod-alist2</a> (car term1-lst)
            alist1
            (car term2-lst)
            alist2)
          (equal-mod-alist2-lst (cdr term1-lst)
            alist1
            (cdr term2-lst)
            alist2))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-one-way-unify1-term-alist" data-defines="ONE-WAY-UNIFY1-TERM-ALIST" data-references="PSEUDO-TERM-LISTP,TL,PL,FARGN,QUOTE,FARGS,ONE-WAY-UNIFY1-TERM-ALIST-LST,FFN-SYMB,ALIST2,ALIST1,ANS,ONE-WAY-UNIFY1-QUOTEP-SUBPROBLEMS,TERM2,PAT2,TERM1,PAT1,MV-LET,FQUOTEP,EQUAL,EQUAL-MOD-ALIST2,CDDR,CADR,EQUAL-MOD-ALIST,CAR,CDR,CONSP,LIST*,IF,ACONS,NULL,ASSOC-EQ,PAIR,LET,VARIABLEP,T,MV,*ANONYMOUS-VAR*,EQ,COND,ALISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,ALIST,TERM-ALIST,TERM,PAT,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ONE-WAY-UNIFY1-TERM-ALIST">one-way-unify1-term-alist</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a>
    (pat term term-alist alist)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)
          (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> term-alist)
          (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat <a class="sym-link local-def" href="#def-_2Aanonymous-var_2A" data-sym="*ANONYMOUS-VAR*" title="(defconst *anonymous-var* &#39;|Anonymous variable|)">*anonymous-var*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> pat) (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> pat alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pair) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> pat
                  (if term-alist
                    (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:sublis-var</span> term term-alist)
                    term)
                  alist)))
            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp pair)
               (consp (cdr pair))
               (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (cdr pair)) <span class="keyword">:sublis-var</span>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> term-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (cdr pair)) (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (cdr pair)) term)
                    alist))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-equal-mod-alist2" data-sym="EQUAL-MOD-ALIST2" title="(mutual-recursion
 (defun equal-mod-alist2 (term1 alist1 term2 alist2)
   (cond
    ((variablep term1)
     (let ((pair1 (assoc-eq term1 alist1)))
...">equal-mod-alist2</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (cdr pair))
                      (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (cdr pair))
                      term
                      term-alist)
                    alist))))
            ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> term-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (equal term (cdr pair)) alist))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term term-alist (cdr pair)) alist)))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> pat) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> term-alist)
             (equal term pat)
             (<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term term-alist pat)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term term-alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat (cdr pair) nil alist))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (pat1 term1 pat2 term2)
          (one-way-unify1-quotep-subproblems pat term)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist))
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat1 nil) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat2 nil) (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat1 term1 nil alist))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist1)
                (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat1 term1 nil alist)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ans nil) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist2)
                      (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat2 term2 nil alist1)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans alist2)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))))))))
      ((equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> pat) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist1)
          (one-way-unify1-term-alist-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> pat)
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
            term-alist
            alist)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans alist1))
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> pat) 'equal) (let ((pat1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> pat <span class="number">1</span>)) (pat2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> pat <span class="number">2</span>))
                  (term1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                  (term2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist1)
                  (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat2 term1 term-alist alist)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist2)
                        (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> pat1 term2 term-alist alist1)
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> ans alist2)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> one-way-unify1-term-alist-lst
    (pl tl term-alist alist)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp pl)
          (pseudo-term-listp tl)
          (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> term-alist)
          (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pl) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans alist)
          (<a class="sym-link local-def" href="#def-one-way-unify1-term-alist" data-sym="ONE-WAY-UNIFY1-TERM-ALIST" title="(mutual-recursion
 (defun one-way-unify1-term-alist (pat term term-alist alist)
   (declare
    (xargs :guard
     (and (pseudo-termp pat) (pseudo-termp term) (alistp term-alist)
...">one-way-unify1-term-alist</a> (car pl)
            (car tl)
            term-alist
            alist)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (one-way-unify1-term-alist-lst (cdr pl)
                (cdr tl)
                term-alist
                alist))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))))))))</pre>
  </div>

<div class="form-block other" id="form-40" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> pequiv (pattern unify-subst . congruence-rule) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-41" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> pequiv-pattern (fn posn pre-rev post next) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-42" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> pequiv-info
  (((rewritten-args-rev . rest-args) alist . bkptr) geneqv
    fn . deep-pequiv-lst)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-43" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> pequivs-property (deep shallow . deep-pequiv-p) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block constant" id="def-_2Aempty-pequivs-property_2A" data-defines="*EMPTY-PEQUIVS-PROPERTY*" data-references="PEQUIVS-PROPERTY,MAKE,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*EMPTY-PEQUIVS-PROPERTY*">*empty-pequivs-property*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aempty-pequivs-property_2A" data-sym="*EMPTY-PEQUIVS-PROPERTY*" title="(defconst *empty-pequivs-property*
          (make pequivs-property :deep nil :shallow nil :deep-pequiv-p nil))">*empty-pequivs-property*</a>
  (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> pequivs-property
    <span class="keyword">:deep</span> nil
    <span class="keyword">:shallow</span> nil
    <span class="keyword">:deep-pequiv-p</span> nil))</pre>
  </div>

<div class="form-block macro" id="def-pequivs-property-field" data-defines="PEQUIVS-PROPERTY-FIELD" data-references="PEQUIVS-PROPERTY,ACCESS,LET,QUASIQUOTE,KEYWORDP,NOT,QUOTE,MEMBER-EQ,AND,XARGS,DECLARE,FIELD,PROP,DEFMACRO" data-used-by="PEQUIVS-FOR-REWRITE-ARGS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PEQUIVS-PROPERTY-FIELD">pequivs-property-field</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-pequivs-property-field" data-sym="PEQUIVS-PROPERTY-FIELD" title="(defmacro pequivs-property-field (prop field)
  (declare
   (xargs :guard
    (and (member-eq field (quote (:deep :shallow :deep-pequiv-p)))
         (not (keywordp prop)))))
...">pequivs-property-field</a>
  (prop field)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> field '(<span class="keyword">:deep</span> <span class="keyword">:shallow</span> <span class="keyword">:deep-pequiv-p</span>))
        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> prop)))))
  `(let ((prop ,PROP))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> prop (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequivs-property prop ,FIELD))))</pre>
  </div>

<div class="form-block function" id="def-next-pequiv" data-defines="NEXT-PEQUIV" data-references="CHANGE,EQUAL,T,NULL,COND,PEQUIV-PATTERN,ONE-WAY-UNIFY1-TERM-ALIST-LST,UNIFY-SUBST,FLG,MV-LET,ACCESS,PATTERN,LET,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,PEQUIV,DEFUN" data-used-by="NEXT-PEQUIVS" data-part-name="NEXT-PEQUIV" data-part-args="ALIST,REST-ARGS,REWRITTEN-ARGS-REV,PEQUIV" data-part-body="CHANGE,EQUAL,ALIST,REST-ARGS,T,NULL,COND,REWRITTEN-ARGS-REV,PEQUIV-PATTERN,ONE-WAY-UNIFY1-TERM-ALIST-LST,UNIFY-SUBST,FLG,MV-LET,PEQUIV,ACCESS,PATTERN,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEXT-PEQUIV">next-pequiv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a>
  (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:pattern</span>)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
      (one-way-unify1-term-alist-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pattern <span class="keyword">:pre-rev</span>)
        rewritten-args-rev
        nil
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:unify-subst</span>))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) nil)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
            (one-way-unify1-term-alist-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pattern <span class="keyword">:post</span>)
              rest-args
              alist
              unify-subst)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) nil)
              ((equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:unify-subst</span>) unify-subst) (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> pequiv
                  pequiv
                  <span class="keyword">:pattern</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pattern <span class="keyword">:next</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> pequiv
                  pequiv
                  <span class="keyword">:pattern</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pattern <span class="keyword">:next</span>)
                  <span class="keyword">:unify-subst</span> unify-subst)))))))))</pre>
  </div>

<div class="form-block function" id="def-next-pequivs" data-defines="NEXT-PEQUIVS" data-references="CONS,CDR,CONGRUENCE-RULE,ENABLED-NUMEP,IF,EQL,EQ,AND,VARIABLEP,NOT,ASSERT$,NEXT-PEQUIV,PEQUIV-PATTERN,NEXT,PEQUIV,ACCESS,PAT,CAR,DEEP-PEQUIV,LET*,T,MV,ENDP,COND,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,ENS,CHILD-FN,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,DEEP-PEQUIV-LST,DEFUN" data-used-by="PEQUIVS-FOR-REWRITE-ARGS,NEXT-PEQUIVS-ALIST" data-part-name="NEXT-PEQUIVS" data-part-args="NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,ENS,CHILD-FN,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,DEEP-PEQUIV-LST" data-part-body="CONS,CDR,NEXT-PEQUIVS,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,ENS,CONGRUENCE-RULE,ENABLED-NUMEP,CHILD-FN,IF,BKPTR,EQL,PARENT-FN,EQ,AND,VARIABLEP,NOT,ASSERT$,NEXT-PEQUIV,PEQUIV-PATTERN,NEXT,PEQUIV,ACCESS,PAT,CAR,DEEP-PEQUIV,LET*,T,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,MV,DEEP-PEQUIV-LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEXT-PEQUIVS">next-pequivs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a>
  (deep-pequiv-lst rewritten-args-rev
    rest-args
    alist
    bkptr
    parent-fn
    child-fn
    ens
    next-deep-pequiv-lst
    next-shallow-pequiv-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> deep-pequiv-lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> next-deep-pequiv-lst next-shallow-pequiv-lst))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((deep-pequiv (car deep-pequiv-lst)) (pat (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv deep-pequiv <span class="keyword">:pattern</span>))
          (next (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:next</span>))
          (<a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> next))
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> parent-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:fn</span>))
                (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> bkptr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:posn</span>))
                (if child-fn
                  (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> child-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern next <span class="keyword">:fn</span>))
                  (enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv deep-pequiv <span class="keyword">:congruence-rule</span>)
                      <span class="keyword">:nume</span>)
                    ens))
                (<a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a> deep-pequiv rewritten-args-rev rest-args alist)))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a>) (<a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a> (cdr deep-pequiv-lst)
              rewritten-args-rev
              rest-args
              alist
              bkptr
              parent-fn
              child-fn
              ens
              next-deep-pequiv-lst
              next-shallow-pequiv-lst))
          ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern next <span class="keyword">:next</span>)) (<a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a> (cdr deep-pequiv-lst)
              rewritten-args-rev
              rest-args
              alist
              bkptr
              parent-fn
              child-fn
              ens
              next-deep-pequiv-lst
              (cons <a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a> next-shallow-pequiv-lst)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a> (cdr deep-pequiv-lst)
              rewritten-args-rev
              rest-args
              alist
              bkptr
              parent-fn
              child-fn
              ens
              (cons <a class="sym-link local-def" href="#def-next-pequiv" data-sym="NEXT-PEQUIV" title="(defun next-pequiv (pequiv rewritten-args-rev rest-args alist)
  (let ((pattern (access pequiv pequiv :pattern)))
    (mv-let (flg unify-subst)
            (one-way-unify1-term-alist-lst
             (access pequiv-pattern pattern :pre-rev) rewritten-args-rev nil
...">next-pequiv</a> next-deep-pequiv-lst)
              next-shallow-pequiv-lst)))))))</pre>
  </div>

<div class="form-block function" id="def-next-pequivs-alist" data-defines="NEXT-PEQUIVS-ALIST" data-references="T,CDR,CDAR,NEXT-PEQUIVS,MV-LET,CAAR,GENEQV-REFINEMENTP,MV,ENDP,COND,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,ENS,WRLD,PARENT-GENEQV,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,DEEP-PEQUIV-ALIST,DEFUN" data-used-by="PEQUIVS-FOR-REWRITE-ARGS" data-part-name="NEXT-PEQUIVS-ALIST" data-part-args="NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,ENS,WRLD,PARENT-GENEQV,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,DEEP-PEQUIV-ALIST" data-part-body="T,CDR,NEXT-PEQUIVS-ALIST,ENS,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,CDAR,NEXT-PEQUIVS,MV-LET,WRLD,PARENT-GENEQV,CAAR,GENEQV-REFINEMENTP,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,MV,DEEP-PEQUIV-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEXT-PEQUIVS-ALIST">next-pequivs-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-next-pequivs-alist" data-sym="NEXT-PEQUIVS-ALIST" title="(defun next-pequivs-alist
       (deep-pequiv-alist rewritten-args-rev rest-args alist bkptr parent-fn
        parent-geneqv wrld ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-alist) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs-alist</a>
  (deep-pequiv-alist rewritten-args-rev
    rest-args
    alist
    bkptr
    parent-fn
    parent-geneqv
    wrld
    ens
    next-deep-pequiv-lst
    next-shallow-pequiv-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> deep-pequiv-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> next-deep-pequiv-lst next-shallow-pequiv-lst))
    ((<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> deep-pequiv-alist)
       parent-geneqv
       wrld) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (next-deep-pequiv-lst next-shallow-pequiv-lst)
        (<a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> deep-pequiv-alist)
          rewritten-args-rev
          rest-args
          alist
          bkptr
          parent-fn
          nil
          ens
          next-deep-pequiv-lst
          next-shallow-pequiv-lst)
        (<a class="sym-link local-def" href="#def-next-pequivs-alist" data-sym="NEXT-PEQUIVS-ALIST" title="(defun next-pequivs-alist
       (deep-pequiv-alist rewritten-args-rev rest-args alist bkptr parent-fn
        parent-geneqv wrld ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-alist) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs-alist</a> (cdr deep-pequiv-alist)
          rewritten-args-rev
          rest-args
          alist
          bkptr
          parent-fn
          parent-geneqv
          wrld
          ens
          next-deep-pequiv-lst
          next-shallow-pequiv-lst)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-next-pequivs-alist" data-sym="NEXT-PEQUIVS-ALIST" title="(defun next-pequivs-alist
       (deep-pequiv-alist rewritten-args-rev rest-args alist bkptr parent-fn
        parent-geneqv wrld ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-alist) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs-alist</a> (cdr deep-pequiv-alist)
        rewritten-args-rev
        rest-args
        alist
        bkptr
        parent-fn
        parent-geneqv
        wrld
        ens
        next-deep-pequiv-lst
        next-shallow-pequiv-lst))))</pre>
  </div>

<div class="form-block function" id="def-extend-pequiv-lst" data-defines="EXTEND-PEQUIV-LST" data-references="CONS,CAR,PEQUIV,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,CDR,T,ENDP,COND,ACC,ENS,PEQUIV-LST,DEFUN" data-used-by="ACCUMULATE-SHALLOW-PEQUIV-ALIST" data-part-name="EXTEND-PEQUIV-LST" data-part-args="ACC,ENS,PEQUIV-LST" data-part-body="CONS,CAR,PEQUIV,CONGRUENCE-RULE,ACCESS,ENABLED-NUMEP,ENS,CDR,EXTEND-PEQUIV-LST,T,ACC,PEQUIV-LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-PEQUIV-LST">extend-pequiv-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-pequiv-lst" data-sym="EXTEND-PEQUIV-LST" title="(defun extend-pequiv-lst (pequiv-lst ens acc)
  (cond ((endp pequiv-lst) acc)
        (t
         (extend-pequiv-lst (cdr pequiv-lst) ens
                            (cond
...">extend-pequiv-lst</a>
  (pequiv-lst ens acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> pequiv-lst) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extend-pequiv-lst" data-sym="EXTEND-PEQUIV-LST" title="(defun extend-pequiv-lst (pequiv-lst ens acc)
  (cond ((endp pequiv-lst) acc)
        (t
         (extend-pequiv-lst (cdr pequiv-lst) ens
                            (cond
...">extend-pequiv-lst</a> (cdr pequiv-lst)
        ens
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule
               (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv (car pequiv-lst) <span class="keyword">:congruence-rule</span>)
               <span class="keyword">:nume</span>)
             ens) (cons (car pequiv-lst) acc))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> acc))))))</pre>
  </div>

<div class="form-block function" id="def-accumulate-shallow-pequiv-alist" data-defines="ACCUMULATE-SHALLOW-PEQUIV-ALIST" data-references="CDAR,EXTEND-PEQUIV-LST,CAAR,GENEQV-REFINEMENTP,CDR,T,ENDP,COND,ACC,ENS,WRLD,GENEQV,ALIST,DEFUN" data-used-by="PEQUIVS-FOR-REWRITE-ARGS" data-part-name="ACCUMULATE-SHALLOW-PEQUIV-ALIST" data-part-args="ACC,ENS,WRLD,GENEQV,ALIST" data-part-body="CDAR,EXTEND-PEQUIV-LST,CAAR,GENEQV-REFINEMENTP,ENS,WRLD,GENEQV,CDR,ACCUMULATE-SHALLOW-PEQUIV-ALIST,T,ACC,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATE-SHALLOW-PEQUIV-ALIST">accumulate-shallow-pequiv-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulate-shallow-pequiv-alist" data-sym="ACCUMULATE-SHALLOW-PEQUIV-ALIST" title="(defun accumulate-shallow-pequiv-alist (alist geneqv wrld ens acc)
  (cond ((endp alist) acc)
        (t
         (accumulate-shallow-pequiv-alist (cdr alist) geneqv wrld ens
                                          (cond
...">accumulate-shallow-pequiv-alist</a>
  (alist geneqv wrld ens acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-accumulate-shallow-pequiv-alist" data-sym="ACCUMULATE-SHALLOW-PEQUIV-ALIST" title="(defun accumulate-shallow-pequiv-alist (alist geneqv wrld ens acc)
  (cond ((endp alist) acc)
        (t
         (accumulate-shallow-pequiv-alist (cdr alist) geneqv wrld ens
                                          (cond
...">accumulate-shallow-pequiv-alist</a> (cdr alist)
        geneqv
        wrld
        ens
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) geneqv wrld) (<a class="sym-link local-def" href="#def-extend-pequiv-lst" data-sym="EXTEND-PEQUIV-LST" title="(defun extend-pequiv-lst (pequiv-lst ens acc)
  (cond ((endp pequiv-lst) acc)
        (t
         (extend-pequiv-lst (cdr pequiv-lst) ens
                            (cond
...">extend-pequiv-lst</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist) ens acc))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> acc))))))</pre>
  </div>

<div class="form-block function" id="def-pequivs-for-rewrite-args" data-defines="PEQUIVS-FOR-REWRITE-ARGS" data-references="OR,NEXT-PEQUIVS-ALIST,NEXT-PEQUIVS,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,MV-LET,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,ACCESS,DEEP-PEQUIV-LST,LET,ACCUMULATE-SHALLOW-PEQUIV-ALIST,AND,NOT,PEQUIVS-PROPERTY-FIELD,SHALLOW-PEQUIV-ALIST,PEQUIVS,QUOTE,GETPROPC,PROP,LET*,T,MV,FLAMBDAP,COND,ENS,WRLD,PEQUIV-INFO,GENEQV,FN,DEFUN" data-used-by="REWRITE" data-part-name="PEQUIVS-FOR-REWRITE-ARGS" data-part-args="ENS,WRLD,PEQUIV-INFO,GENEQV,FN" data-part-body="OR,NEXT-PEQUIVS-ALIST,NEXT-PEQUIVS,NEXT-SHALLOW-PEQUIV-LST,NEXT-DEEP-PEQUIV-LST,MV-LET,PARENT-FN,BKPTR,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,ACCESS,DEEP-PEQUIV-LST,LET,ENS,GENEQV,ACCUMULATE-SHALLOW-PEQUIV-ALIST,AND,PEQUIV-INFO,NOT,PEQUIVS-PROPERTY-FIELD,SHALLOW-PEQUIV-ALIST,WRLD,PEQUIVS,QUOTE,GETPROPC,PROP,LET*,T,MV,FN,FLAMBDAP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PEQUIVS-FOR-REWRITE-ARGS">pequivs-for-rewrite-args</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pequivs-for-rewrite-args" data-sym="PEQUIVS-FOR-REWRITE-ARGS" title="(defun pequivs-for-rewrite-args (fn geneqv pequiv-info wrld ens)
  (cond ((flambdap fn) (mv nil nil))
        (t
         (let* ((prop (getpropc fn &#39;pequivs nil wrld))
                (shallow-pequiv-alist (pequivs-property-field prop :shallow)))
...">pequivs-for-rewrite-args</a>
  (fn geneqv pequiv-info wrld ens)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((prop (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'pequivs nil wrld)) (shallow-pequiv-alist (<a class="sym-link local-def" href="#def-pequivs-property-field" data-sym="PEQUIVS-PROPERTY-FIELD" title="(defmacro pequivs-property-field (prop field)
  (declare
   (xargs :guard
    (and (member-eq field (quote (:deep :shallow :deep-pequiv-p)))
         (not (keywordp prop)))))
...">pequivs-property-field</a> prop <span class="keyword">:shallow</span>)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> pequiv-info) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-pequivs-property-field" data-sym="PEQUIVS-PROPERTY-FIELD" title="(defmacro pequivs-property-field (prop field)
  (declare
   (xargs :guard
    (and (member-eq field (quote (:deep :shallow :deep-pequiv-p)))
         (not (keywordp prop)))))
...">pequivs-property-field</a> prop <span class="keyword">:deep-pequiv-p</span>) <span class="keyword">:none</span>)
              (<a class="sym-link local-def" href="#def-accumulate-shallow-pequiv-alist" data-sym="ACCUMULATE-SHALLOW-PEQUIV-ALIST" title="(defun accumulate-shallow-pequiv-alist (alist geneqv wrld ens acc)
  (cond ((endp alist) acc)
        (t
         (accumulate-shallow-pequiv-alist (cdr alist) geneqv wrld ens
                                          (cond
...">accumulate-shallow-pequiv-alist</a> shallow-pequiv-alist
                geneqv
                wrld
                ens
                nil)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((deep-pequiv-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:deep-pequiv-lst</span>)) (rewritten-args-rev (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:rewritten-args-rev</span>))
                (rest-args (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:rest-args</span>))
                (alist (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:alist</span>))
                (bkptr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:bkptr</span>))
                (parent-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:fn</span>)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (next-deep-pequiv-lst next-shallow-pequiv-lst)
                (<a class="sym-link local-def" href="#def-next-pequivs" data-sym="NEXT-PEQUIVS" title="(defun next-pequivs
       (deep-pequiv-lst rewritten-args-rev rest-args alist bkptr parent-fn
        child-fn ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-lst) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs</a> deep-pequiv-lst
                  rewritten-args-rev
                  rest-args
                  alist
                  bkptr
                  parent-fn
                  fn
                  nil
                  nil
                  nil)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (next-deep-pequiv-lst next-shallow-pequiv-lst)
                  (<a class="sym-link local-def" href="#def-next-pequivs-alist" data-sym="NEXT-PEQUIVS-ALIST" title="(defun next-pequivs-alist
       (deep-pequiv-alist rewritten-args-rev rest-args alist bkptr parent-fn
        parent-geneqv wrld ens next-deep-pequiv-lst next-shallow-pequiv-lst)
  (cond
   ((endp deep-pequiv-alist) (mv next-deep-pequiv-lst next-shallow-pequiv-lst))
...">next-pequivs-alist</a> (<a class="sym-link local-def" href="#def-pequivs-property-field" data-sym="PEQUIVS-PROPERTY-FIELD" title="(defmacro pequivs-property-field (prop field)
  (declare
   (xargs :guard
    (and (member-eq field (quote (:deep :shallow :deep-pequiv-p)))
         (not (keywordp prop)))))
...">pequivs-property-field</a> prop <span class="keyword">:deep</span>)
                    rewritten-args-rev
                    rest-args
                    alist
                    bkptr
                    parent-fn
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-info pequiv-info <span class="keyword">:geneqv</span>)
                    wrld
                    ens
                    next-deep-pequiv-lst
                    next-shallow-pequiv-lst)
                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> next-deep-pequiv-lst
                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-pequivs-property-field" data-sym="PEQUIVS-PROPERTY-FIELD" title="(defmacro pequivs-property-field (prop field)
  (declare
   (xargs :guard
    (and (member-eq field (quote (:deep :shallow :deep-pequiv-p)))
         (not (keywordp prop)))))
...">pequivs-property-field</a> prop <span class="keyword">:deep-pequiv-p</span>) <span class="keyword">:none</span>))
                    (<a class="sym-link local-def" href="#def-accumulate-shallow-pequiv-alist" data-sym="ACCUMULATE-SHALLOW-PEQUIV-ALIST" title="(defun accumulate-shallow-pequiv-alist (alist geneqv wrld ens acc)
  (cond ((endp alist) acc)
        (t
         (accumulate-shallow-pequiv-alist (cdr alist) geneqv wrld ens
                                          (cond
...">accumulate-shallow-pequiv-alist</a> shallow-pequiv-alist
                      geneqv
                      wrld
                      ens
                      next-shallow-pequiv-lst)))))))))))</pre>
  </div>

<div class="form-block function" id="def-pequiv-info-for-rewrite" data-defines="PEQUIV-INFO-FOR-REWRITE" data-references="CONSP,AND,CDR,PEQUIV-INFO,MAKE,T,FQUOTEP,CAR,VARIABLEP,FLAMBDAP,NULL,OR,COND,DEEP-PEQUIV-LST,GENEQV,ALIST,ARGS,REWRITTEN-ARGS-REV,BKPTR,FN,DEFUN" data-used-by="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" data-part-name="PEQUIV-INFO-FOR-REWRITE" data-part-args="DEEP-PEQUIV-LST,GENEQV,ALIST,ARGS,REWRITTEN-ARGS-REV,BKPTR,FN" data-part-body="CONSP,AND,GENEQV,BKPTR,ALIST,CDR,REWRITTEN-ARGS-REV,PEQUIV-INFO,MAKE,T,FQUOTEP,ARGS,CAR,VARIABLEP,FN,FLAMBDAP,DEEP-PEQUIV-LST,NULL,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PEQUIV-INFO-FOR-REWRITE">pequiv-info-for-rewrite</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pequiv-info-for-rewrite" data-sym="PEQUIV-INFO-FOR-REWRITE" title="(defun pequiv-info-for-rewrite
       (fn bkptr rewritten-args-rev args alist geneqv deep-pequiv-lst)
  (cond
   ((or (null deep-pequiv-lst) (flambdap fn) (variablep (car args))
        (fquotep (car args)))
...">pequiv-info-for-rewrite</a>
  (fn bkptr
    rewritten-args-rev
    <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
    alist
    geneqv
    deep-pequiv-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> deep-pequiv-lst)
       (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn)
       (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
       (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> pequiv-info
        <span class="keyword">:rewritten-args-rev</span> rewritten-args-rev
        <span class="keyword">:rest-args</span> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        <span class="keyword">:alist</span> alist
        <span class="keyword">:bkptr</span> bkptr
        <span class="keyword">:fn</span> fn
        <span class="keyword">:geneqv</span> geneqv
        <span class="keyword">:deep-pequiv-lst</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp deep-pequiv-lst) deep-pequiv-lst)))))</pre>
  </div>

<div class="form-block function" id="def-reduce-geneqv-for-equiv" data-defines="REDUCE-GENEQV-FOR-EQUIV" data-references="CONS,CAR,CONGRUENCE-RULE,ACCESS,REFINEMENTP,CDR,REST,CHANGEDP,MV-LET,T,MV,ENDP,COND,GENEQV,WRLD,EQUIV,DEFUN" data-used-by="GENEQV-FOR-REWRITE" data-part-name="REDUCE-GENEQV-FOR-EQUIV" data-part-args="GENEQV,WRLD,EQUIV" data-part-body="CONS,CAR,CONGRUENCE-RULE,ACCESS,REFINEMENTP,CDR,WRLD,EQUIV,REDUCE-GENEQV-FOR-EQUIV,REST,CHANGEDP,MV-LET,T,MV,GENEQV,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REDUCE-GENEQV-FOR-EQUIV">reduce-geneqv-for-equiv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-reduce-geneqv-for-equiv" data-sym="REDUCE-GENEQV-FOR-EQUIV" title="(defun reduce-geneqv-for-equiv (equiv wrld geneqv)
  (cond ((endp geneqv) (mv nil nil))
        (t
         (mv-let (changedp rest)
                 (reduce-geneqv-for-equiv equiv wrld (cdr geneqv))
...">reduce-geneqv-for-equiv</a>
  (equiv wrld geneqv)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> geneqv) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-reduce-geneqv-for-equiv" data-sym="REDUCE-GENEQV-FOR-EQUIV" title="(defun reduce-geneqv-for-equiv (equiv wrld geneqv)
  (cond ((endp geneqv) (mv nil nil))
        (t
         (mv-let (changedp rest)
                 (reduce-geneqv-for-equiv equiv wrld (cdr geneqv))
...">reduce-geneqv-for-equiv</a> equiv wrld (cdr geneqv))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-refinementp" data-sym="REFINEMENTP" title="(defun refinementp (equiv1 equiv2 wrld)
  (cond ((eq equiv1 &#39;equal) t) ((eq equiv2 &#39;equal) nil) ((eq equiv1 equiv2) t)
        (t (member-eq equiv2 (cdr (getpropc equiv1 &#39;coarsenings nil wrld))))))">refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:equiv</span>)
             equiv
             wrld) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>))
          (changedp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car geneqv) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil geneqv)))))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-for-rewrite" data-defines="GENEQV-FOR-REWRITE" data-references="CONS,REDUCE-GENEQV-FOR-EQUIV,CHANGEDP,IGNORE,DECLARE,ONE-WAY-UNIFY1-TERM-ALIST-LST,UNIFY-SUBST,FLG,MV-LET,GENEQV-REFINEMENTP,EQL,PEQUIV-PATTERN,EQ,NOT,OR,CDR,EQUIV,CONGRUENCE-RULE,ACCESS,PAT,CAR,PEQUIV,LET*,T,NULL,COND,GENEQV,WRLD,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,BKPTR,FN,SHALLOW-PEQUIV-LST,DEFUN" data-used-by="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" data-part-name="GENEQV-FOR-REWRITE" data-part-args="GENEQV,WRLD,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,BKPTR,FN,SHALLOW-PEQUIV-LST" data-part-body="CONS,REDUCE-GENEQV-FOR-EQUIV,CHANGEDP,IGNORE,DECLARE,ONE-WAY-UNIFY1-TERM-ALIST-LST,UNIFY-SUBST,FLG,MV-LET,GENEQV-REFINEMENTP,EQL,PEQUIV-PATTERN,EQ,NOT,OR,WRLD,ALIST,REST-ARGS,REWRITTEN-ARGS-REV,BKPTR,FN,CDR,GENEQV-FOR-REWRITE,EQUIV,CONGRUENCE-RULE,ACCESS,PAT,CAR,PEQUIV,LET*,T,GENEQV,SHALLOW-PEQUIV-LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-FOR-REWRITE">geneqv-for-rewrite</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-for-rewrite" data-sym="GENEQV-FOR-REWRITE" title="(defun geneqv-for-rewrite
       (shallow-pequiv-lst fn bkptr rewritten-args-rev rest-args alist wrld
        geneqv)
  (cond ((null shallow-pequiv-lst) geneqv)
        (t
...">geneqv-for-rewrite</a>
  (shallow-pequiv-lst fn
    bkptr
    rewritten-args-rev
    rest-args
    alist
    wrld
    geneqv)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> shallow-pequiv-lst) geneqv)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pequiv (car shallow-pequiv-lst)) (pat (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:pattern</span>))
          (congruence-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:congruence-rule</span>))
          (equiv (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule congruence-rule <span class="keyword">:equiv</span>)))
        (<a class="sym-link local-def" href="#def-geneqv-for-rewrite" data-sym="GENEQV-FOR-REWRITE" title="(defun geneqv-for-rewrite
       (shallow-pequiv-lst fn bkptr rewritten-args-rev rest-args alist wrld
        geneqv)
  (cond ((null shallow-pequiv-lst) geneqv)
        (t
...">geneqv-for-rewrite</a> (cdr shallow-pequiv-lst)
          fn
          bkptr
          rewritten-args-rev
          rest-args
          alist
          wrld
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:fn</span>)))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> bkptr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:posn</span>)))
               (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> equiv geneqv wrld)) geneqv)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                (one-way-unify1-term-alist-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:pre-rev</span>)
                  rewritten-args-rev
                  nil
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv pequiv <span class="keyword">:unify-subst</span>))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) geneqv)
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                      (one-way-unify1-term-alist-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv-pattern pat <span class="keyword">:post</span>)
                        rest-args
                        alist
                        unify-subst)
                      (declare (ignore unify-subst))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) geneqv)
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp geneqv)
                            (<a class="sym-link local-def" href="#def-reduce-geneqv-for-equiv" data-sym="REDUCE-GENEQV-FOR-EQUIV" title="(defun reduce-geneqv-for-equiv (equiv wrld geneqv)
  (cond ((endp geneqv) (mv nil nil))
        (t
         (mv-let (changedp rest)
                 (reduce-geneqv-for-equiv equiv wrld (cdr geneqv))
...">reduce-geneqv-for-equiv</a> equiv wrld geneqv)
                            (declare (ignore changedp))
                            (cons congruence-rule geneqv)))))))))))))))</pre>
  </div>

<div class="form-block function" id="def-geneqv-and-pequiv-info-for-rewrite" data-defines="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" data-references="PEQUIV-INFO-FOR-REWRITE,CDR,GENEQV-FOR-REWRITE,MV,WRLD,SHALLOW-PEQUIV-LST,DEEP-PEQUIV-LST,CHILD-GENEQV,PARENT-GENEQV,ALIST,ARGS,REWRITTEN-ARGS-REV,BKPTR,FN,DEFUN" data-used-by="REWRITE" data-part-name="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" data-part-args="WRLD,SHALLOW-PEQUIV-LST,DEEP-PEQUIV-LST,CHILD-GENEQV,PARENT-GENEQV,ALIST,ARGS,REWRITTEN-ARGS-REV,BKPTR,FN" data-part-body="DEEP-PEQUIV-LST,PARENT-GENEQV,PEQUIV-INFO-FOR-REWRITE,CHILD-GENEQV,WRLD,ALIST,ARGS,CDR,REWRITTEN-ARGS-REV,BKPTR,FN,SHALLOW-PEQUIV-LST,GENEQV-FOR-REWRITE,MV" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE">geneqv-and-pequiv-info-for-rewrite</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-geneqv-and-pequiv-info-for-rewrite" data-sym="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" title="(defun geneqv-and-pequiv-info-for-rewrite
       (fn bkptr rewritten-args-rev args alist parent-geneqv child-geneqv
        deep-pequiv-lst shallow-pequiv-lst wrld)
  (mv
   (geneqv-for-rewrite shallow-pequiv-lst fn bkptr rewritten-args-rev
...">geneqv-and-pequiv-info-for-rewrite</a>
  (fn bkptr
    rewritten-args-rev
    <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
    alist
    parent-geneqv
    child-geneqv
    deep-pequiv-lst
    shallow-pequiv-lst
    wrld)
  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link local-def" href="#def-geneqv-for-rewrite" data-sym="GENEQV-FOR-REWRITE" title="(defun geneqv-for-rewrite
       (shallow-pequiv-lst fn bkptr rewritten-args-rev rest-args alist wrld
        geneqv)
  (cond ((null shallow-pequiv-lst) geneqv)
        (t
...">geneqv-for-rewrite</a> shallow-pequiv-lst
      fn
      bkptr
      rewritten-args-rev
      (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
      alist
      wrld
      child-geneqv)
    (<a class="sym-link local-def" href="#def-pequiv-info-for-rewrite" data-sym="PEQUIV-INFO-FOR-REWRITE" title="(defun pequiv-info-for-rewrite
       (fn bkptr rewritten-args-rev args alist geneqv deep-pequiv-lst)
  (cond
   ((or (null deep-pequiv-lst) (flambdap fn) (variablep (car args))
        (fquotep (car args)))
...">pequiv-info-for-rewrite</a> fn
      bkptr
      rewritten-args-rev
      <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
      alist
      parent-geneqv
      deep-pequiv-lst)))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-ffnnamesp" data-defines="FFNNAMESP" data-references="CDR,CAR,NULL,IF,L,T,MEMBER-EQ,FARGS,FFNNAMESP-LST,LAMBDA-BODY,FFN-SYMB,MEMBER-EQUAL,OR,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,TERM,FNS,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FFNNAMESP">ffnnamesp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ffnnamesp" data-sym="FFNNAMESP" title="(mutual-recursion
 (defun ffnnamesp (fns term)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (member-equal (ffn-symb term) fns)
...">ffnnamesp</a>
    (fns term)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) nil)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fns)
          (<a class="sym-link local-def" href="#def-ffnnamesp" data-sym="FFNNAMESP" title="(mutual-recursion
 (defun ffnnamesp (fns term)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (member-equal (ffn-symb term) fns)
...">ffnnamesp</a> fns (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
          (ffnnamesp-lst fns (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term))))
      ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fns) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (ffnnamesp-lst fns (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> ffnnamesp-lst
    (fns l)
    (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l)
      nil
      (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-ffnnamesp" data-sym="FFNNAMESP" title="(mutual-recursion
 (defun ffnnamesp (fns term)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (member-equal (ffn-symb term) fns)
...">ffnnamesp</a> fns (car l)) (ffnnamesp-lst fns (cdr l))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-collect-ffnnames" data-defines="COLLECT-FFNNAMES" data-references="CAR,CDR,NULL,L,ADD-TO-SET-EQ,MEMBER-EQ,T,ADD-TO-SET-EQUAL,MEMBER-EQUAL,IF,FARGS,COLLECT-FFNNAMES-LST,FFN-SYMB,LAMBDA-BODY,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,ANS,TERM,FNS,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-FFNNAMES">collect-ffnnames</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-ffnnames" data-sym="COLLECT-FFNNAMES" title="(mutual-recursion
 (defun collect-ffnnames (fns term ans)
   (cond ((variablep term) ans) ((fquotep term) ans)
         ((flambda-applicationp term)
          (collect-ffnnames fns (lambda-body (ffn-symb term))
...">collect-ffnnames</a>
    (fns term ans)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) ans)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) ans)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link local-def" href="#def-collect-ffnnames" data-sym="COLLECT-FFNNAMES" title="(mutual-recursion
 (defun collect-ffnnames (fns term ans)
   (cond ((variablep term) ans) ((fquotep term) ans)
         ((flambda-applicationp term)
          (collect-ffnnames fns (lambda-body (ffn-symb term))
...">collect-ffnnames</a> fns
          (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
          (collect-ffnnames-lst fns
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
            (if (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fns)
              (<a class="sym-link system" href="axioms.html#def-add-to-set-equal" data-sym="ADD-TO-SET-EQUAL">add-to-set-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) ans)
              ans))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (collect-ffnnames-lst fns
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
          (if (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fns)
            (<a class="sym-link system" href="axioms.html#def-add-to-set-eq" data-sym="ADD-TO-SET-EQ">add-to-set-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) ans)
            ans)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> collect-ffnnames-lst
    (fns l ans)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) ans)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (collect-ffnnames-lst fns
          (cdr l)
          (<a class="sym-link local-def" href="#def-collect-ffnnames" data-sym="COLLECT-FFNNAMES" title="(mutual-recursion
 (defun collect-ffnnames (fns term ans)
   (cond ((variablep term) ans) ((fquotep term) ans)
         ((flambda-applicationp term)
          (collect-ffnnames fns (lambda-body (ffn-symb term))
...">collect-ffnnames</a> fns (car l) ans))))))</pre>
  </div>

<div class="form-block function" id="def-comm-equal" data-defines="COMM-EQUAL" data-references="FARGN,EQUAL,IF,FFN-SYMB,EQ,FQUOTEP,NOT,NVARIABLEP,AND,TERM,RHS,LHS,FN,DEFUN" data-used-by="MEMBER-COMPLEMENT-TERM2,MEMBER-TERM2" data-part-name="COMM-EQUAL" data-part-args="TERM,RHS,LHS,FN" data-part-body="LHS,FARGN,RHS,EQUAL,IF,FFN-SYMB,FN,EQ,FQUOTEP,NOT,TERM,NVARIABLEP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMM-EQUAL">comm-equal</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-comm-equal" data-sym="COMM-EQUAL" title="(defun comm-equal (fn lhs rhs term)
  (and (nvariablep term) (not (fquotep term)) (eq fn (ffn-symb term))
       (if (equal rhs (fargn term 2))
           (equal lhs (fargn term 1))
           (and (equal rhs (fargn term 1)) (equal lhs (fargn term 2))))))">comm-equal</a>
  (fn lhs rhs term)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> term)
    (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term))
    (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
    (if (equal rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
      (equal lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (equal lhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))))))</pre>
  </div>

<div class="form-block function" id="def-member-term2" data-defines="MEMBER-TERM2" data-references="CDR,T,CAR,COMM-EQUAL,NULL,COND,CL,RHS,LHS,FN,DEFUN" data-used-by="MEMBER-TERM" data-part-name="MEMBER-TERM2" data-part-args="CL,RHS,LHS,FN" data-part-body="CDR,MEMBER-TERM2,T,CAR,RHS,LHS,FN,COMM-EQUAL,CL,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-TERM2">member-term2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-term2" data-sym="MEMBER-TERM2" title="(defun member-term2 (fn lhs rhs cl)
  (cond ((null cl) nil) ((comm-equal fn lhs rhs (car cl)) cl)
        (t (member-term2 fn lhs rhs (cdr cl)))))">member-term2</a>
  (fn lhs rhs cl)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl) nil)
    ((<a class="sym-link local-def" href="#def-comm-equal" data-sym="COMM-EQUAL" title="(defun comm-equal (fn lhs rhs term)
  (and (nvariablep term) (not (fquotep term)) (eq fn (ffn-symb term))
       (if (equal rhs (fargn term 2))
           (equal lhs (fargn term 1))
           (and (equal rhs (fargn term 1)) (equal lhs (fargn term 2))))))">comm-equal</a> fn lhs rhs (car cl)) cl)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-member-term2" data-sym="MEMBER-TERM2" title="(defun member-term2 (fn lhs rhs cl)
  (cond ((null cl) nil) ((comm-equal fn lhs rhs (car cl)) cl)
        (t (member-term2 fn lhs rhs (cdr cl)))))">member-term2</a> fn lhs rhs (cdr cl)))))</pre>
  </div>

<div class="form-block function" id="def-member-complement-term2" data-defines="MEMBER-COMPLEMENT-TERM2" data-references="CDR,T,FARGN,COMM-EQUAL,NOT,QUOTE,CAR,FFN-SYMB-P,AND,NULL,COND,CL,RHS,LHS,FN,DEFUN" data-used-by="MEMBER-TERM" data-part-name="MEMBER-COMPLEMENT-TERM2" data-part-args="CL,RHS,LHS,FN" data-part-body="CDR,MEMBER-COMPLEMENT-TERM2,T,FARGN,RHS,LHS,FN,COMM-EQUAL,NOT,QUOTE,CAR,FFN-SYMB-P,AND,CL,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-COMPLEMENT-TERM2">member-complement-term2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-complement-term2" data-sym="MEMBER-COMPLEMENT-TERM2" title="(defun member-complement-term2 (fn lhs rhs cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not)
              (comm-equal fn lhs rhs (fargn (car cl) 1)))
         cl)">member-complement-term2</a>
  (fn lhs rhs cl)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (car cl) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
       (<a class="sym-link local-def" href="#def-comm-equal" data-sym="COMM-EQUAL" title="(defun comm-equal (fn lhs rhs term)
  (and (nvariablep term) (not (fquotep term)) (eq fn (ffn-symb term))
       (if (equal rhs (fargn term 2))
           (equal lhs (fargn term 1))
           (and (equal rhs (fargn term 1)) (equal lhs (fargn term 2))))))">comm-equal</a> fn lhs rhs (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car cl) <span class="number">1</span>))) cl)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-member-complement-term2" data-sym="MEMBER-COMPLEMENT-TERM2" title="(defun member-complement-term2 (fn lhs rhs cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not)
              (comm-equal fn lhs rhs (fargn (car cl) 1)))
         cl)">member-complement-term2</a> fn lhs rhs (cdr cl)))))</pre>
  </div>

<div class="form-block function" id="def-member-complement-term1" data-defines="MEMBER-COMPLEMENT-TERM1" data-references="CDR,T,FARGN,EQUAL,NOT,QUOTE,CAR,FFN-SYMB-P,AND,NULL,COND,CL,LIT,DEFUN" data-used-by="MEMBER-TERM" data-part-name="MEMBER-COMPLEMENT-TERM1" data-part-args="CL,LIT" data-part-body="CDR,MEMBER-COMPLEMENT-TERM1,T,FARGN,LIT,EQUAL,NOT,QUOTE,CAR,FFN-SYMB-P,AND,CL,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-COMPLEMENT-TERM1">member-complement-term1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-complement-term1" data-sym="MEMBER-COMPLEMENT-TERM1" title="(defun member-complement-term1 (lit cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not) (equal lit (fargn (car cl) 1))) cl)
        (t (member-complement-term1 lit (cdr cl)))))">member-complement-term1</a>
  (lit cl)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (car cl) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
       (equal lit (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car cl) <span class="number">1</span>))) cl)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-member-complement-term1" data-sym="MEMBER-COMPLEMENT-TERM1" title="(defun member-complement-term1 (lit cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not) (equal lit (fargn (car cl) 1))) cl)
        (t (member-complement-term1 lit (cdr cl)))))">member-complement-term1</a> lit (cdr cl)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-member-term" data-defines="MEMBER-TERM" data-references="AND,MEMBER-COMPLEMENT-TERM2,MEMBER-COMPLEMENT-TERM1,T,MEMBER-COMPLEMENT-TERM,NOT,FARGN,MEMBER-TERM2,IFF,EQUAL,QUOTE,FFN-SYMB,EQ,OR,MEMBER-EQUAL,FQUOTEP,MEMBER-EQ,VARIABLEP,COND,CL,LIT,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-TERM">member-term</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-term" data-sym="MEMBER-TERM" title="(mutual-recursion
 (defun member-term (lit cl)
   (cond ((variablep lit) (member-eq lit cl))
         ((fquotep lit) (member-equal lit cl))
         ((or (eq (ffn-symb lit) &#39;equal) (eq (ffn-symb lit) &#39;iff))
...">member-term</a>
    (lit cl)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> lit) (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> lit cl))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> lit) (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> lit cl))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) 'equal) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>)) (<a class="sym-link local-def" href="#def-member-term2" data-sym="MEMBER-TERM2" title="(defun member-term2 (fn lhs rhs cl)
  (cond ((null cl) nil) ((comm-equal fn lhs rhs (car cl)) cl)
        (t (member-term2 fn lhs rhs (cdr cl)))))">member-term2</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">2</span>) cl))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (member-complement-term (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">1</span>) cl))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> lit cl))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> member-complement-term
    (lit cl)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> lit) (<a class="sym-link local-def" href="#def-member-complement-term1" data-sym="MEMBER-COMPLEMENT-TERM1" title="(defun member-complement-term1 (lit cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not) (equal lit (fargn (car cl) 1))) cl)
        (t (member-complement-term1 lit (cdr cl)))))">member-complement-term1</a> lit cl))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> lit) (<a class="sym-link local-def" href="#def-member-complement-term1" data-sym="MEMBER-COMPLEMENT-TERM1" title="(defun member-complement-term1 (lit cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not) (equal lit (fargn (car cl) 1))) cl)
        (t (member-complement-term1 lit (cdr cl)))))">member-complement-term1</a> lit cl))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) 'equal) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>)) (<a class="sym-link local-def" href="#def-member-complement-term2" data-sym="MEMBER-COMPLEMENT-TERM2" title="(defun member-complement-term2 (fn lhs rhs cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not)
              (comm-equal fn lhs rhs (fargn (car cl) 1)))
         cl)">member-complement-term2</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit)
          (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">1</span>)
          (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">2</span>)
          cl))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> lit) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
            (<a class="sym-link local-def" href="#def-member-term" data-sym="MEMBER-TERM" title="(mutual-recursion
 (defun member-term (lit cl)
   (cond ((variablep lit) (member-eq lit cl))
         ((fquotep lit) (member-equal lit cl))
         ((or (eq (ffn-symb lit) &#39;equal) (eq (ffn-symb lit) &#39;iff))
...">member-term</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">1</span>) cl))
          (<a class="sym-link local-def" href="#def-member-complement-term1" data-sym="MEMBER-COMPLEMENT-TERM1" title="(defun member-complement-term1 (lit cl)
  (cond ((null cl) nil)
        ((and (ffn-symb-p (car cl) &#39;not) (equal lit (fargn (car cl) 1))) cl)
        (t (member-complement-term1 lit (cdr cl)))))">member-complement-term1</a> lit cl))))))</pre>
  </div>

<div class="form-block function" id="def-instr-listp" data-defines="INSTR-LISTP" data-references="CDR,PSEUDO-TERM-LISTP,LST,RET,TERM,CALL,TEST,GO,PUSH-FRAME-PTR,N,PUSH-LOCAL,PSEUDO-TERMP,X,PUSH,QUOTE,CASE-MATCH,CARL,LET,CAR,INTEGERP,OR,AND,T,EQUAL,ATOM,COND,L,DEFUN" data-used-by="SPLICE-INSTRS,SPLICE-INSTRS1,NEXT-TAG" data-part-name="INSTR-LISTP" data-part-args="L" data-part-body="CDR,INSTR-LISTP,PSEUDO-TERM-LISTP,LST,RET,TERM,CALL,TEST,GO,PUSH-FRAME-PTR,N,PUSH-LOCAL,PSEUDO-TERMP,X,PUSH,QUOTE,CASE-MATCH,CARL,LET,CAR,INTEGERP,OR,AND,T,EQUAL,L,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INSTR-LISTP">instr-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-instr-listp" data-sym="INSTR-LISTP" title="(defun instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (or (integerp (car l))
...">instr-listp</a>
  (l)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> l) (equal l nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (integerp (car l))
          (let ((carl (car l)))
            (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> carl
              (('push . x) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> x))
              (('push-local . n) (integerp n))
              (('push-frame-ptr) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
              (('go . x) (integerp x))
              (('test . x) (integerp x))
              (('call . term) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term))
              (('ret . lst) (pseudo-term-listp lst)))))
        (<a class="sym-link local-def" href="#def-instr-listp" data-sym="INSTR-LISTP" title="(defun instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (or (integerp (car l))
...">instr-listp</a> (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-spliced-instr-listp" data-defines="SPLICED-INSTR-LISTP" data-references="CDR,PSEUDO-TERM-LISTP,LST,RET,TERM,CALL,TEST,PUSH-FRAME-PTR,INTEGERP,N,PUSH-LOCAL,PSEUDO-TERMP,X,PUSH,QUOTE,CASE-MATCH,CAR,CARL,LET,AND,T,EQUAL,ATOM,COND,L,DEFUN" data-part-name="SPLICED-INSTR-LISTP" data-part-args="L" data-part-body="CDR,PSEUDO-TERM-LISTP,LST,RET,TERM,CALL,SPLICED-INSTR-LISTP,TEST,PUSH-FRAME-PTR,INTEGERP,N,PUSH-LOCAL,PSEUDO-TERMP,X,PUSH,QUOTE,CASE-MATCH,CAR,CARL,LET,AND,T,EQUAL,L,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLICED-INSTR-LISTP">spliced-instr-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-spliced-instr-listp" data-sym="SPLICED-INSTR-LISTP" title="(defun spliced-instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (let ((carl (car l)))
...">spliced-instr-listp</a>
  (l)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> l) (equal l nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (let ((carl (car l)))
          (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> carl
            (('push . x) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> x))
            (('push-local . n) (integerp n))
            (('push-frame-ptr) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
            (('test . x) (<a class="sym-link local-def" href="#def-spliced-instr-listp" data-sym="SPLICED-INSTR-LISTP" title="(defun spliced-instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (let ((carl (car l)))
...">spliced-instr-listp</a> x))
            (('call . term) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term))
            (('ret . lst) (pseudo-term-listp lst))))
        (<a class="sym-link local-def" href="#def-spliced-instr-listp" data-sym="SPLICED-INSTR-LISTP" title="(defun spliced-instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (let ((carl (car l)))
...">spliced-instr-listp</a> (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-next-tag" data-defines="NEXT-TAG" data-references="T,CDR,+,TEST,QUOTE,CAAR,EQ,CAR,CONSP,AND,NULL,COND,INSTR-LISTP,XARGS,DECLARE,L,DEFUN" data-used-by="IF-COMPILE" data-part-name="NEXT-TAG" data-part-args="L" data-part-declare="L,INSTR-LISTP,XARGS,DECLARE" data-part-body="NEXT-TAG,T,CDR,+,TEST,QUOTE,CAAR,EQ,CAR,CONSP,AND,L,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEXT-TAG">next-tag</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-next-tag" data-sym="NEXT-TAG" title="(defun next-tag (l)
  (declare (xargs :guard (instr-listp l)))
  (cond ((null l) 1)
        ((and (consp (car l)) (eq (caar l) &#39;test)) (+ 2 (cdr (car l))))
        (t (next-tag (cdr l)))))">next-tag</a>
  (l)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-instr-listp" data-sym="INSTR-LISTP" title="(defun instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (or (integerp (car l))
...">instr-listp</a> l)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) <span class="number">1</span>)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (car l)) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> l) 'test)) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">2</span> (cdr (car l))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-next-tag" data-sym="NEXT-TAG" title="(defun next-tag (l)
  (declare (xargs :guard (instr-listp l)))
  (cond ((null l) 1)
        ((and (consp (car l)) (eq (caar l) &#39;test)) (+ 2 (cdr (car l))))
        (t (next-tag (cdr l)))))">next-tag</a> (cdr l)))))</pre>
  </div>

<div class="form-block function" id="def-if-compile-formal" data-defines="IF-COMPILE-FORMAL" data-references="1+,CDR,T,CAR,EQ,COND,MEMBER-EQ,TRUE-LISTP,SYMBOLP,AND,XARGS,DECLARE,I,RFORMALS,VAR,DEFUN" data-used-by="IF-COMPILE" data-part-name="IF-COMPILE-FORMAL" data-part-args="I,RFORMALS,VAR" data-part-declare="MEMBER-EQ,RFORMALS,TRUE-LISTP,VAR,SYMBOLP,AND,XARGS,DECLARE" data-part-body="1+,CDR,IF-COMPILE-FORMAL,T,I,RFORMALS,CAR,VAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-COMPILE-FORMAL">if-compile-formal</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-compile-formal" data-sym="IF-COMPILE-FORMAL" title="(defun if-compile-formal (var rformals i)
  (declare
   (xargs :guard
    (and (symbolp var) (true-listp rformals) (member-eq var rformals))))
  (cond ((eq var (car rformals)) i)">if-compile-formal</a>
  (var rformals i)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp var)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> rformals)
        (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> var rformals))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var (car rformals)) i)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-compile-formal" data-sym="IF-COMPILE-FORMAL" title="(defun if-compile-formal (var rformals i)
  (declare
   (xargs :guard
    (and (symbolp var) (true-listp rformals) (member-eq var rformals))))
  (cond ((eq var (car rformals)) i)">if-compile-formal</a> var (cdr rformals) (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> i)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-ffnnamep-hide" data-defines="FFNNAMEP-HIDE" data-references="CDR,CAR,NULL,IF,PSEUDO-TERM-LISTP,SYMBOLP,XARGS,DECLARE,L,HIDE,QUOTE,T,EQ,FARGS,FFNNAMEP-HIDE-LST,LAMBDA-BODY,AND,FFN-SYMB,EQUAL,OR,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,LAMBDA-EXP,TERM,FN,DEFUN,MUTUAL-RECURSION" data-used-by="PUSH-SPLITTER?,PUSH-LEMMA+,IF-COMPILE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FFNNAMEP-HIDE">ffnnamep-hide</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a>
    (fn term lambda-exp)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) nil)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (equal fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> lambda-exp
            (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> fn (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) lambda-exp))
          (ffnnamep-hide-lst fn (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp)))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fn) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (ffnnamep-hide-lst fn (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> ffnnamep-hide-lst
    (fn l lambda-exp)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp fn) (pseudo-term-listp l))))
    (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l)
      nil
      (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> fn (car l) lambda-exp)
        (ffnnamep-hide-lst fn (cdr l) lambda-exp)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-if-compile" data-defines="IF-COMPILE" data-references="CAR,CDR,NULL,PSEUDO-TERM-LISTP,L,TEST,GO,+,NEXT-TAG,N,FARGN,TEST-SEG,LET*,CALL,FFNNAMEP-HIDE-LST,REVAPPEND,FARGS,IF-COMPILE-LST,PUSH-FRAME-PTR,LAMBDA-FORMALS,RET,LAMBDA-BODY,IF,FFNNAMEP-HIDE,AND,FLAMBDAP,HIDE,FFN-SYMB,EQ,FQUOTEP,OR,PUSH,T,IF-COMPILE-FORMAL,PUSH-LOCAL,QUOTE,CONS,VARIABLEP,COND,PSEUDO-TERMP,XARGS,DECLARE,RFORMALS,AC,LAMBDA-EXP,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="IF-TAUTOLOGYP,STRIP-BRANCHES" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-COMPILE">if-compile</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a>
    (term lambda-exp ac rformals)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rformals (cons (cons 'push-local (<a class="sym-link local-def" href="#def-if-compile-formal" data-sym="IF-COMPILE-FORMAL" title="(defun if-compile-formal (var rformals i)
  (declare
   (xargs :guard
    (and (symbolp var) (true-listp rformals) (member-eq var rformals))))
  (cond ((eq var (car rformals)) i)">if-compile-formal</a> term rformals <span class="number">0</span>))
              ac))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons 'push term) ac))))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>)) (cons (cons 'push term) ac))
      ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> lambda-exp
             (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> 'if (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) lambda-exp)) (cons (cons 'ret (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
              (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
                lambda-exp
                (cons '(push-frame-ptr)
                  (if-compile-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp ac rformals))
                (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) nil))))
          ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ffnnamep-hide-lst 'if (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp)
             rformals) (cons (cons 'call term)
              (if-compile-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp ac rformals)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons 'push term) ac))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((test-seg (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) lambda-exp ac rformals)) (n (<a class="sym-link local-def" href="#def-next-tag" data-sym="NEXT-TAG" title="(defun next-tag (l)
  (declare (xargs :guard (instr-listp l)))
  (cond ((null l) 1)
        ((and (consp (car l)) (eq (caar l) &#39;test)) (+ 2 (cdr (car l))))
        (t (next-tag (cdr l)))))">next-tag</a> test-seg)))
          (cons (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> n <span class="number">1</span>)
            (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)
              lambda-exp
              (cons n
                (cons (cons 'go (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> n <span class="number">1</span>))
                  (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                    lambda-exp
                    (cons (cons 'test n) test-seg)
                    rformals)))
              rformals))))
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (ffnnamep-hide-lst 'if (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp)
         rformals) (cons (cons 'call term)
          (if-compile-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) lambda-exp ac rformals)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons 'push term) ac))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> if-compile-lst
    (l lambda-exp ac rformals)
    (declare (xargs <span class="keyword">:guard</span> (pseudo-term-listp l)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) ac)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (if-compile-lst (cdr l)
          lambda-exp
          (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> (car l) lambda-exp ac rformals)
          rformals)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assume-true" data-defines="IF-INTERP-ASSUME-TRUE" data-references="T,FARGN,NOT,QUOTE,FFN-SYMB,EQ,CONS,IF,VARIABLEP,COND,ASSUMPTIONS,TERM,NOT-FLG,DEFUN" data-used-by="IF-INTERP,CONVERT-CLAUSE-TO-ASSUMPTIONS" data-part-name="IF-INTERP-ASSUME-TRUE" data-part-args="ASSUMPTIONS,TERM,NOT-FLG" data-part-body="T,FARGN,IF-INTERP-ASSUME-TRUE,NOT,QUOTE,FFN-SYMB,EQ,ASSUMPTIONS,CONS,NOT-FLG,IF,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUME-TRUE">if-interp-assume-true</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assume-true" data-sym="IF-INTERP-ASSUME-TRUE" title="(defun if-interp-assume-true (not-flg term assumptions)
  (cond
   ((variablep term)
    (if not-flg
        (cons :not (cons term assumptions))
...">if-interp-assume-true</a>
  (not-flg term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (if not-flg
        (cons <span class="keyword">:not</span> (cons term assumptions))
        (cons term assumptions)))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (<a class="sym-link local-def" href="#def-if-interp-assume-true" data-sym="IF-INTERP-ASSUME-TRUE" title="(defun if-interp-assume-true (not-flg term assumptions)
  (cond
   ((variablep term)
    (if not-flg
        (cons :not (cons term assumptions))
...">if-interp-assume-true</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> not-flg)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
        assumptions))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (if not-flg
        (cons <span class="keyword">:not</span> (cons term assumptions))
        (cons term assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-switch" data-defines="IF-INTERP-SWITCH" data-references="CONS,T,CDR,CAR,EQ,COND,ASSUMPTIONS,DEFUN" data-used-by="IF-INTERP" data-part-name="IF-INTERP-SWITCH" data-part-args="ASSUMPTIONS" data-part-body="CONS,T,CDR,ASSUMPTIONS,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-SWITCH">if-interp-switch</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-switch" data-sym="IF-INTERP-SWITCH" title="(defun if-interp-switch (assumptions)
  (cond ((eq (car assumptions) :not) (cdr assumptions))
        (t (cons :not assumptions))))">if-interp-switch</a>
  (assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (cdr assumptions))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons <span class="keyword">:not</span> assumptions))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value0" data-defines="IF-INTERP-ASSUMED-VALUE0" data-references="CDR,CDDR,T,F,QUOTE,CADR,CAR,EQ,NULL,COND,ASSUMPTIONS,VAR,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE,IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE0" data-part-args="ASSUMPTIONS,VAR" data-part-body="CDR,CDDR,IF-INTERP-ASSUMED-VALUE0,T,F,QUOTE,CADR,VAR,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE0">if-interp-assumed-value0</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value0" data-sym="IF-INTERP-ASSUMED-VALUE0" title="(defun if-interp-assumed-value0 (var assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((eq var (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value0 var (cddr assumptions)))))
...">if-interp-assumed-value0</a>
  (var assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> var (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)) 'f)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value0" data-sym="IF-INTERP-ASSUMED-VALUE0" title="(defun if-interp-assumed-value0 (var assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((eq var (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value0 var (cddr assumptions)))))
...">if-interp-assumed-value0</a> var (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) var) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value0" data-sym="IF-INTERP-ASSUMED-VALUE0" title="(defun if-interp-assumed-value0 (var assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((eq var (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value0 var (cddr assumptions)))))
...">if-interp-assumed-value0</a> var (cdr assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value1" data-defines="IF-INTERP-ASSUMED-VALUE1" data-references="CDR,CDDR,T,F,QUOTE,CADR,EQUAL,CAR,EQ,NULL,COND,ASSUMPTIONS,TERM,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE1" data-part-args="ASSUMPTIONS,TERM" data-part-body="CDR,CDDR,IF-INTERP-ASSUMED-VALUE1,T,F,QUOTE,CADR,TERM,EQUAL,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE1">if-interp-assumed-value1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value1" data-sym="IF-INTERP-ASSUMED-VALUE1" title="(defun if-interp-assumed-value1 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value1 term (cddr assumptions)))))
...">if-interp-assumed-value1</a>
  (term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)) 'f)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value1" data-sym="IF-INTERP-ASSUMED-VALUE1" title="(defun if-interp-assumed-value1 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value1 term (cddr assumptions)))))
...">if-interp-assumed-value1</a> term (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))))
    ((equal (car assumptions) term) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value1" data-sym="IF-INTERP-ASSUMED-VALUE1" title="(defun if-interp-assumed-value1 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value1 term (cddr assumptions)))))
...">if-interp-assumed-value1</a> term (cdr assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value2-equal-constant" data-defines="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" data-references="NOT,QUOTEP,TERM-FN,CDR,T,F,FARGN,OR,FFN-SYMB,EQUAL,QUOTE,AND,CDDR,VARIABLEP,CADR,TERM,LET,CAR,EQ,NULL,COND,ASSUMPTIONS,CONST1,ARG,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" data-part-args="ASSUMPTIONS,CONST1,ARG" data-part-body="NOT,QUOTEP,TERM-FN,CDR,T,F,FARGN,OR,FFN-SYMB,EQUAL,QUOTE,AND,CDDR,CONST1,ARG,IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT,VARIABLEP,CADR,TERM,LET,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT">if-interp-assumed-value2-equal-constant</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a>
  (arg const1 assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (let ((term (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> arg
              const1
              (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> 'equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                 (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
               (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                 (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))))) 'f)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> arg
              const1
              (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((term (car assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> arg
              const1
              (cdr assumptions)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((term-fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term-fn 'equal) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                         (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
                       (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                         (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                    ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                         (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))))
                       (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                         (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal const1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))))) 'f)
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> arg
                        const1
                        (cdr assumptions)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> arg
                    const1
                    (cdr assumptions)))))))))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value2" data-defines="IF-INTERP-ASSUMED-VALUE2" data-references="CDR,NVARIABLEP,TERM-FN,LET*,T,F,QUOTE,FARGN,EQUAL,OR,FFN-SYMB,AND,CDDR,VARIABLEP,CADR,TERM,LET,CAR,EQ,NULL,COND,ASSUMPTIONS,ARG2,ARG1,FN,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE2" data-part-args="ASSUMPTIONS,ARG2,ARG1,FN" data-part-body="CDR,NVARIABLEP,TERM-FN,LET*,T,F,QUOTE,FARGN,EQUAL,OR,FFN-SYMB,AND,CDDR,ARG2,ARG1,FN,IF-INTERP-ASSUMED-VALUE2,VARIABLEP,CADR,TERM,LET,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE2">if-interp-assumed-value2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a>
  (fn arg1 arg2 assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (let ((term (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a> fn arg1 arg2 (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
                 (equal arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
               (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                 (equal arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))))) 'f)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a> fn arg1 arg2 (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions))))))
    ((<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((term (car assumptions)) (term-fn (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> term) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))))
       (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn term-fn)
         (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
             (equal arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
           (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal arg1 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
             (equal arg2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))))) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a> fn arg1 arg2 (cdr assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value3" data-defines="IF-INTERP-ASSUMED-VALUE3" data-references="CDR,FARGN,INTEGERP,FFN-SYMB-P,AND,CDDR,T,F,QUOTE,CADR,EQUAL,CAR,EQ,NULL,COND,ASSUMPTIONS,TERM,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE3" data-part-args="ASSUMPTIONS,TERM" data-part-body="CDR,FARGN,INTEGERP,FFN-SYMB-P,AND,CDDR,IF-INTERP-ASSUMED-VALUE3,T,F,QUOTE,CADR,TERM,EQUAL,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE3">if-interp-assumed-value3</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value3" data-sym="IF-INTERP-ASSUMED-VALUE3" title="(defun if-interp-assumed-value3 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value3 term (cddr assumptions)))))
...">if-interp-assumed-value3</a>
  (term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)) 'f)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value3" data-sym="IF-INTERP-ASSUMED-VALUE3" title="(defun if-interp-assumed-value3 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value3 term (cddr assumptions)))))
...">if-interp-assumed-value3</a> term (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))))
    ((equal (car assumptions) term) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (car assumptions) 'integerp)
       (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car assumptions) <span class="number">1</span>))) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value3" data-sym="IF-INTERP-ASSUMED-VALUE3" title="(defun if-interp-assumed-value3 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value3 term (cddr assumptions)))))
...">if-interp-assumed-value3</a> term (cdr assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value4" data-defines="IF-INTERP-ASSUMED-VALUE4" data-references="CDR,CDDR,T,FARGN,RATIONALP,FFN-SYMB-P,AND,F,QUOTE,CADR,EQUAL,CAR,EQ,NULL,COND,ASSUMPTIONS,TERM,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE-X" data-part-name="IF-INTERP-ASSUMED-VALUE4" data-part-args="ASSUMPTIONS,TERM" data-part-body="CDR,CDDR,IF-INTERP-ASSUMED-VALUE4,T,FARGN,RATIONALP,FFN-SYMB-P,AND,F,QUOTE,CADR,TERM,EQUAL,CAR,EQ,ASSUMPTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE4">if-interp-assumed-value4</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value4" data-sym="IF-INTERP-ASSUMED-VALUE4" title="(defun if-interp-assumed-value4 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               ((and (ffn-symb-p (cadr assumptions) &#39;rationalp)
...">if-interp-assumed-value4</a>
  (term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)) 'f)
        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions) 'rationalp)
           (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions) <span class="number">1</span>))) 'f)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value4" data-sym="IF-INTERP-ASSUMED-VALUE4" title="(defun if-interp-assumed-value4 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               ((and (ffn-symb-p (cadr assumptions) &#39;rationalp)
...">if-interp-assumed-value4</a> term (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)))))
    ((equal (car assumptions) term) '<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value4" data-sym="IF-INTERP-ASSUMED-VALUE4" title="(defun if-interp-assumed-value4 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               ((and (ffn-symb-p (cadr assumptions) &#39;rationalp)
...">if-interp-assumed-value4</a> term (cdr assumptions)))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value-x" data-defines="IF-INTERP-ASSUMED-VALUE-X" data-references="IF-INTERP-ASSUMED-VALUE1,IF-INTERP-ASSUMED-VALUE4,INTEGERP,IF-INTERP-ASSUMED-VALUE3,RATIONALP,IFF,IF-INTERP-ASSUMED-VALUE2,T,IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT,FARGN,QUOTEP,EQUAL,QUOTE,FFN-SYMB,EQ,IF-INTERP-ASSUMED-VALUE0,VARIABLEP,COND,ASSUMPTIONS,TERM,DEFUN" data-used-by="IF-INTERP-ASSUMED-VALUE" data-part-name="IF-INTERP-ASSUMED-VALUE-X" data-part-args="ASSUMPTIONS,TERM" data-part-body="IF-INTERP-ASSUMED-VALUE1,IF-INTERP-ASSUMED-VALUE4,INTEGERP,IF-INTERP-ASSUMED-VALUE3,RATIONALP,IFF,IF-INTERP-ASSUMED-VALUE2,T,IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT,FARGN,QUOTEP,EQUAL,QUOTE,FFN-SYMB,EQ,ASSUMPTIONS,IF-INTERP-ASSUMED-VALUE0,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE-X">if-interp-assumed-value-x</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value-x" data-sym="IF-INTERP-ASSUMED-VALUE-X" title="(defun if-interp-assumed-value-x (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;equal)
         (cond
          ((quotep (fargn term 1))
...">if-interp-assumed-value-x</a>
  (term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-if-interp-assumed-value0" data-sym="IF-INTERP-ASSUMED-VALUE0" title="(defun if-interp-assumed-value0 (var assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((eq var (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value0 var (cddr assumptions)))))
...">if-interp-assumed-value0</a> term assumptions))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'equal) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            assumptions))
        ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2-equal-constant" data-sym="IF-INTERP-ASSUMED-VALUE2-EQUAL-CONSTANT" title="(defun if-interp-assumed-value2-equal-constant (arg const1 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2-equal-constant</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
            assumptions))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
            (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
            assumptions))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>) (<a class="sym-link local-def" href="#def-if-interp-assumed-value2" data-sym="IF-INTERP-ASSUMED-VALUE2" title="(defun if-interp-assumed-value2 (fn arg1 arg2 assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (let ((term (cadr assumptions)))
           (cond
...">if-interp-assumed-value2</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
        assumptions))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'rationalp) (<a class="sym-link local-def" href="#def-if-interp-assumed-value3" data-sym="IF-INTERP-ASSUMED-VALUE3" title="(defun if-interp-assumed-value3 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value3 term (cddr assumptions)))))
...">if-interp-assumed-value3</a> term assumptions))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'integerp) (<a class="sym-link local-def" href="#def-if-interp-assumed-value4" data-sym="IF-INTERP-ASSUMED-VALUE4" title="(defun if-interp-assumed-value4 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               ((and (ffn-symb-p (cadr assumptions) &#39;rationalp)
...">if-interp-assumed-value4</a> term assumptions))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value1" data-sym="IF-INTERP-ASSUMED-VALUE1" title="(defun if-interp-assumed-value1 (term assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((equal term (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value1 term (cddr assumptions)))))
...">if-interp-assumed-value1</a> term assumptions))))</pre>
  </div>

<div class="form-block function" id="def-if-interp-assumed-value" data-defines="IF-INTERP-ASSUMED-VALUE" data-references="F,T,FARGN,IF-INTERP-ASSUMED-VALUE-X,TEMP,LET,NOT,QUOTE,FFN-SYMB,EQ,IF-INTERP-ASSUMED-VALUE0,VARIABLEP,COND,ASSUMPTIONS,TERM,DEFUN" data-used-by="IF-INTERP,CALL-STACK" data-part-name="IF-INTERP-ASSUMED-VALUE" data-part-args="ASSUMPTIONS,TERM" data-part-body="F,T,FARGN,IF-INTERP-ASSUMED-VALUE-X,TEMP,LET,NOT,QUOTE,FFN-SYMB,EQ,ASSUMPTIONS,IF-INTERP-ASSUMED-VALUE0,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ASSUMED-VALUE">if-interp-assumed-value</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a>
  (term assumptions)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-if-interp-assumed-value0" data-sym="IF-INTERP-ASSUMED-VALUE0" title="(defun if-interp-assumed-value0 (var assumptions)
  (cond ((null assumptions) nil)
        ((eq (car assumptions) :not)
         (cond ((eq var (cadr assumptions)) &#39;f)
               (t (if-interp-assumed-value0 var (cddr assumptions)))))
...">if-interp-assumed-value0</a> term assumptions))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (let ((temp (<a class="sym-link local-def" href="#def-if-interp-assumed-value-x" data-sym="IF-INTERP-ASSUMED-VALUE-X" title="(defun if-interp-assumed-value-x (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;equal)
         (cond
          ((quotep (fargn term 1))
...">if-interp-assumed-value-x</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) 'f) ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp 'f) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-assumed-value-x" data-sym="IF-INTERP-ASSUMED-VALUE-X" title="(defun if-interp-assumed-value-x (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;equal)
         (cond
          ((quotep (fargn term 1))
...">if-interp-assumed-value-x</a> term assumptions))))</pre>
  </div>

<div class="form-block function" id="def-convert-assumptions-to-clause-segment" data-defines="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" data-references="LIST,CONS,T,CDDR,CDR,NOT,ASSOC-EQUAL,TEMP,CONST2,X,LET*,FARGN,QUOTEP,EQUAL,QUOTE,FFN-SYMB-P,AND,CADR,TEST,LET,CAR,EQ,NULL,OR,COND,KNOWN-CONSTANTS,ANS,ASSUMPTIONS,DEFUN" data-used-by="IF-INTERP-ADD-CLAUSE" data-part-name="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" data-part-args="KNOWN-CONSTANTS,ANS,ASSUMPTIONS" data-part-body="LIST,CONS,T,CDDR,CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT,CDR,NOT,KNOWN-CONSTANTS,ASSOC-EQUAL,TEMP,CONST2,X,LET*,FARGN,QUOTEP,EQUAL,QUOTE,FFN-SYMB-P,AND,CADR,TEST,LET,ANS,CAR,EQ,ASSUMPTIONS,NULL,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT">convert-assumptions-to-clause-segment</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a>
  (assumptions ans known-constants)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> assumptions)
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:ignore-when-converting-to-clause</span>)) ans)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car assumptions) <span class="keyword">:not</span>) (let ((test (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> test 'equal)
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((x (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)) (const2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>))
                    (temp (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> x known-constants)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal const2 (cdr temp)))) (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
                        ans
                        known-constants))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
                        (cons test ans)
                        known-constants)))))
              ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((x (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) (const2 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>))
                    (temp (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> x known-constants)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal const2 (cdr temp)))) (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
                        ans
                        known-constants))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
                        (cons test ans)
                        known-constants)))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
                  (cons test ans)
                  known-constants))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> assumptions)
              (cons test ans)
              known-constants)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((test (car assumptions)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> test 'equal)
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (cdr assumptions)
                  (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> test) ans)
                  (cons (cons (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>)) known-constants)))
              ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)) (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (cdr assumptions)
                  (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> test) ans)
                  (cons (cons (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>)) known-constants)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (cdr assumptions)
                  (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> test) ans)
                  known-constants))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> (cdr assumptions)
              (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> test) ans)
              known-constants)))))))</pre>
  </div>

<div class="form-block function" id="def-convert-clause-to-assumptions" data-defines="CONVERT-CLAUSE-TO-ASSUMPTIONS" data-references="CAR,IF-INTERP-ASSUME-TRUE,CDR,T,CONS,NULL,COND,ANS,CLAUSE,DEFUN" data-part-name="CONVERT-CLAUSE-TO-ASSUMPTIONS" data-part-args="ANS,CLAUSE" data-part-body="CAR,IF-INTERP-ASSUME-TRUE,CDR,CONVERT-CLAUSE-TO-ASSUMPTIONS,T,ANS,CONS,CLAUSE,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONVERT-CLAUSE-TO-ASSUMPTIONS">convert-clause-to-assumptions</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-convert-clause-to-assumptions" data-sym="CONVERT-CLAUSE-TO-ASSUMPTIONS" title="(defun convert-clause-to-assumptions (clause ans)
  (cond ((null clause) (cons :ignore-when-converting-to-clause ans))
        (t
         (convert-clause-to-assumptions (cdr clause)
                                        (if-interp-assume-true t (car clause)">convert-clause-to-assumptions</a>
  (clause ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> clause) (cons <span class="keyword">:ignore-when-converting-to-clause</span> ans))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-convert-clause-to-assumptions" data-sym="CONVERT-CLAUSE-TO-ASSUMPTIONS" title="(defun convert-clause-to-assumptions (clause ans)
  (cond ((null clause) (cons :ignore-when-converting-to-clause ans))
        (t
         (convert-clause-to-assumptions (cdr clause)
                                        (if-interp-assume-true t (car clause)">convert-clause-to-assumptions</a> (cdr clause)
        (<a class="sym-link local-def" href="#def-if-interp-assume-true" data-sym="IF-INTERP-ASSUME-TRUE" title="(defun if-interp-assume-true (not-flg term assumptions)
  (cond
   ((variablep term)
    (if not-flg
        (cons :not (cons term assumptions))
...">if-interp-assume-true</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (car clause) ans)))))</pre>
  </div>

<div class="form-block function" id="def-simplifiable-mv-nth1" data-defines="SIMPLIFIABLE-MV-NTH1" data-references="1-,FARGN,=,IF,CONS,QUOTE,FFN-SYMB,EQ,NTH,KWOTE,LENGTH,>,CADR,TRUE-LISTP,AND,FQUOTEP,T,MV,IGNORE,DECLARE,CDR,REWRITEP,TERM1,MV-LET,ASSOC-EQ,TEMP,LET,VARIABLEP,COND,ALIST,CONS-TERM,N,DEFUN" data-used-by="SIMPLIFIABLE-MV-NTH" data-part-name="SIMPLIFIABLE-MV-NTH1" data-part-args="ALIST,CONS-TERM,N" data-part-body="1-,FARGN,=,IF,CONS,QUOTE,FFN-SYMB,EQ,NTH,KWOTE,LENGTH,>,CADR,TRUE-LISTP,AND,FQUOTEP,T,MV,IGNORE,DECLARE,CDR,N,SIMPLIFIABLE-MV-NTH1,REWRITEP,TERM1,MV-LET,ALIST,ASSOC-EQ,TEMP,LET,CONS-TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SIMPLIFIABLE-MV-NTH1">simplifiable-mv-nth1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-simplifiable-mv-nth1" data-sym="SIMPLIFIABLE-MV-NTH1" title="(defun simplifiable-mv-nth1 (n cons-term alist)
  (cond
   ((variablep cons-term)
    (let ((temp (assoc-eq cons-term alist)))
      (cond
...">simplifiable-mv-nth1</a>
  (n <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>) (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> alist)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term1 rewritep)
              (<a class="sym-link local-def" href="#def-simplifiable-mv-nth1" data-sym="SIMPLIFIABLE-MV-NTH1" title="(defun simplifiable-mv-nth1 (n cons-term alist)
  (cond
   ((variablep cons-term)
    (let ((temp (assoc-eq cons-term alist)))
      (cond
...">simplifiable-mv-nth1</a> n (cdr temp) nil)
              (declare (ignore rewritep))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term1 nil)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil)))))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>))
           (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>)) n)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> n (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a>) 'cons) (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>)
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> <span class="number">1</span>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (<a class="sym-link local-def" href="#def-simplifiable-mv-nth1" data-sym="SIMPLIFIABLE-MV-NTH1" title="(defun simplifiable-mv-nth1 (n cons-term alist)
  (cond
   ((variablep cons-term)
    (let ((temp (assoc-eq cons-term alist)))
      (cond
...">simplifiable-mv-nth1</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> <a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> <span class="number">2</span>) alist)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))</pre>
  </div>

<div class="form-block other" id="form-82" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> simplifiable-mv-nth-p nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-83" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> simplifiable-mv-nth-p
  <a class="sym-link system" href="axioms.html#def-constant-t-function-arity-0" data-sym="CONSTANT-T-FUNCTION-ARITY-0">constant-t-function-arity-0</a>)</pre>
  </div>

<div class="form-block function" id="def-simplifiable-mv-nth" data-defines="SIMPLIFIABLE-MV-NTH" data-references="MV,SIMPLIFIABLE-MV-NTH1,>=,CADR,INTEGERP,QUOTEP,AND,T,CDR,ASSOC-EQ,TEMP,FARGN,VARIABLEP,ARG1,LET,SIMPLIFIABLE-MV-NTH-P,COND,ALIST,TERM,DEFUN" data-used-by="REWRITE,CALL-STACK" data-part-name="SIMPLIFIABLE-MV-NTH" data-part-args="ALIST,TERM" data-part-body="MV,SIMPLIFIABLE-MV-NTH1,>=,CADR,INTEGERP,QUOTEP,AND,T,CDR,ALIST,ASSOC-EQ,TEMP,TERM,FARGN,VARIABLEP,ARG1,LET,SIMPLIFIABLE-MV-NTH-P,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SIMPLIFIABLE-MV-NTH">simplifiable-mv-nth</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-simplifiable-mv-nth" data-sym="SIMPLIFIABLE-MV-NTH" title="(defun simplifiable-mv-nth (term alist)
  (cond
   ((simplifiable-mv-nth-p)
    (let ((arg1
           (cond
...">simplifiable-mv-nth</a>
  (term alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((simplifiable-mv-nth-p) (let ((arg1 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)) (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist)))
                 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp (cdr temp)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))))
             (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1)
             (integerp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1))
             (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1) <span class="number">0</span>)) (<a class="sym-link local-def" href="#def-simplifiable-mv-nth1" data-sym="SIMPLIFIABLE-MV-NTH1" title="(defun simplifiable-mv-nth1 (n cons-term alist)
  (cond
   ((variablep cons-term)
    (let ((temp (assoc-eq cons-term alist)))
      (cond
...">simplifiable-mv-nth1</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) alist))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))</pre>
  </div>

<div class="form-block function" id="def-call-stack" data-defines="CALL-STACK" data-references="CDR,OR,IGNORE,SIMPLIFIABLE-MV-NTH,REWRITEP,TERM1,MV-LET,TERM,MV-NTH,TEMP2,TEMP1,ARG2,ARG1,IFF,CONS-TERM,RATIONALP,<,FCONS-TERM,FFN-SYMB-P,EQUAL,LIST,F,IF-INTERP-ASSUMED-VALUE,TEMP,T,*NIL*,*T*,CADR,IF,QUOTEP,CAR,X,LET,NOT,QUOTE,EQ,CONS,NULL,COND,LENGTH,>=,TRUE-LISTP,AND,XARGS,DECLARE,AC,ASSUMPTIONS,STACK,LST,FN,DEFUN" data-used-by="IF-INTERP" data-part-name="CALL-STACK" data-part-args="AC,ASSUMPTIONS,STACK,LST,FN" data-part-declare="LENGTH,>=,STACK,LST,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CDR,CALL-STACK,STACK,OR,IGNORE,DECLARE,SIMPLIFIABLE-MV-NTH,REWRITEP,TERM1,MV-LET,TERM,MV-NTH,TEMP2,TEMP1,ARG2,ARG1,IFF,CONS-TERM,RATIONALP,<,FCONS-TERM,FFN-SYMB-P,AND,EQUAL,LIST,F,ASSUMPTIONS,IF-INTERP-ASSUMED-VALUE,TEMP,T,*NIL*,*T*,CADR,IF,QUOTEP,AC,CAR,X,LET,NOT,QUOTE,FN,EQ,CONS,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CALL-STACK">call-stack</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-call-stack" data-sym="CALL-STACK" title="(defun call-stack (fn lst stack assumptions ac)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp stack)
         (&gt;= (length stack) (length lst)))))
...">call-stack</a>
  (fn lst stack assumptions ac)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> lst)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> stack)
        (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> stack) (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> lst)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>) (let ((x (car ac)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> x) (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x) nil)
                    <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
                    <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp (<a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a> x assumptions)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp 'f) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> x))))))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'equal) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (car ac) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac)) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (car ac)) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac))) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (car ac) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac) 'equal)) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac))
              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> (car ac) 'equal)) (car ac))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-fcons-term" data-sym="FCONS-TERM">fcons-term</a> fn ac))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '&lt;) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (car ac) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac)) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (car ac))
                 (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac))
                 (rationalp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car ac)))
                 (rationalp (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac)))) (if (&lt; (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car ac)) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac)))
                  <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
                  <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn ac))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a>) (let ((arg1 (car ac)) (arg2 (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> ac)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg1 arg2) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp1 (if (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg1)
                         (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg1) nil)
                           'f
                           <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                         (<a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a> arg1 assumptions))) (temp2 (if (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2)
                          (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> arg2) nil)
                            'f
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                          (<a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a> arg2 assumptions))))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp1 temp2) (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp1 temp2)
                          <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
                          <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-fcons-term" data-sym="FCONS-TERM">fcons-term</a> fn ac))))))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a>) (let ((term (<a class="sym-link system" href="basis-b.html#def-fcons-term" data-sym="FCONS-TERM">fcons-term</a> fn ac)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term1 rewritep)
                (<a class="sym-link local-def" href="#def-simplifiable-mv-nth" data-sym="SIMPLIFIABLE-MV-NTH" title="(defun simplifiable-mv-nth (term alist)
  (cond
   ((simplifiable-mv-nth-p)
    (let ((arg1
           (cond
...">simplifiable-mv-nth</a> term nil)
                (declare (ignore rewritep))
                (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> term1 term))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn ac)))
        stack))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-call-stack" data-sym="CALL-STACK" title="(defun call-stack (fn lst stack assumptions ac)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp stack)
         (&gt;= (length stack) (length lst)))))
...">call-stack</a> fn
        (cdr lst)
        (cdr stack)
        assumptions
        (cons (car stack) ac)))))</pre>
  </div>

<div class="form-block function" id="def-ret-stack" data-defines="RET-STACK" data-references="CDR,T,NULL,COND,STACK,LST,DEFUN" data-used-by="IF-INTERP" data-part-name="RET-STACK" data-part-args="STACK,LST" data-part-body="CDR,RET-STACK,T,STACK,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RET-STACK">ret-stack</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ret-stack" data-sym="RET-STACK" title="(defun ret-stack (lst stack)
  (cond ((null lst) stack) (t (ret-stack (cdr lst) (cdr stack)))))">ret-stack</a>
  (lst stack)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) stack)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-ret-stack" data-sym="RET-STACK" title="(defun ret-stack (lst stack)
  (cond ((null lst) stack) (t (ret-stack (cdr lst) (cdr stack)))))">ret-stack</a> (cdr lst) (cdr stack)))))</pre>
  </div>

<div class="form-block function" id="def-extra-info-lit-p" data-defines="EXTRA-INFO-LIT-P" data-references="*EXTRA-INFO-FN*,FFN-SYMB,EQ,NVARIABLEP,FARGN,ATM,LET,NOT,QUOTE,FFN-SYMB-P,AND,LIT,DEFUN" data-used-by="EXTRA-INFO-LITS,STORE-CLAUSE1,FIND-CLAUSES1,FILTER-WITH-AND-WITHOUT,ARG1-ALMOST-SUBSUMES-ARG2,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1,SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" data-part-name="EXTRA-INFO-LIT-P" data-part-args="LIT" data-part-body="*EXTRA-INFO-FN*,FFN-SYMB,EQ,NVARIABLEP,FARGN,ATM,LET,NOT,QUOTE,LIT,FFN-SYMB-P,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTRA-INFO-LIT-P">extra-info-lit-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a>
  (lit)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> lit '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a>)
    (let ((atm (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> lit <span class="number">1</span>)))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> atm) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> atm) <a class="sym-link system" href="axioms.html#def-_2Aextra-info-fn_2A" data-sym="*EXTRA-INFO-FN*">*extra-info-fn*</a>)))))</pre>
  </div>

<div class="form-block function" id="def-subsetp-equal-mod-extra-info-lits" data-defines="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" data-references="CDR,MEMBER-EQUAL,CAR,EXTRA-INFO-LIT-P,OR,T,ENDP,COND,TRUE-LISTP,AND,XARGS,DECLARE,Y,X,DEFUN" data-used-by="ARG1-ALMOST-SUBSUMES-ARG2,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" data-part-name="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" data-part-args="Y,X" data-part-declare="X,Y,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CDR,SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS,Y,MEMBER-EQUAL,CAR,EXTRA-INFO-LIT-P,OR,T,X,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS">subsetp-equal-mod-extra-info-lits</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subsetp-equal-mod-extra-info-lits" data-sym="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" title="(defun subsetp-equal-mod-extra-info-lits (x y)
  (declare (xargs :guard (and (true-listp y) (true-listp x))))
  (cond ((endp x) t)
        ((or (extra-info-lit-p (car x)) (member-equal (car x) y))
         (subsetp-equal-mod-extra-info-lits (cdr x) y))">subsetp-equal-mod-extra-info-lits</a>
  (x y)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> y) (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car x)) (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (car x) y)) (<a class="sym-link local-def" href="#def-subsetp-equal-mod-extra-info-lits" data-sym="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" title="(defun subsetp-equal-mod-extra-info-lits (x y)
  (declare (xargs :guard (and (true-listp y) (true-listp x))))
  (cond ((endp x) t)
        ((or (extra-info-lit-p (car x)) (member-equal (car x) y))
         (subsetp-equal-mod-extra-info-lits (cdr x) y))">subsetp-equal-mod-extra-info-lits</a> (cdr x) y))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-quick-and-dirty-subsumption-replacement-step1" data-defines="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" data-references="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS,COMPLEMENTARYP,AND,CONS,T,SYMBOLP,ANS,LET,EQUAL,SUBSUMED1,CDR,CAR,EXTRA-INFO-LIT-P,SUBSUMED2,QUOTE,NULL,COND,CL2,CL1,DEFUN" data-used-by="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" data-part-name="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" data-part-args="CL2,CL1" data-part-body="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS,COMPLEMENTARYP,AND,CONS,T,SYMBOLP,ANS,LET,EQUAL,SUBSUMED1,CL2,CDR,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1,CAR,EXTRA-INFO-LIT-P,SUBSUMED2,QUOTE,CL1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1">quick-and-dirty-subsumption-replacement-step1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step1" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" title="(defun quick-and-dirty-subsumption-replacement-step1 (cl1 cl2)
  (cond ((null cl1) &#39;subsumed2)
        ((extra-info-lit-p (car cl1))
         (quick-and-dirty-subsumption-replacement-step1 (cdr cl1) cl2))
        ((null cl2) &#39;subsumed1)
...">quick-and-dirty-subsumption-replacement-step1</a>
  (cl1 cl2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl1) 'subsumed2)
    ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car cl1)) (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step1" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" title="(defun quick-and-dirty-subsumption-replacement-step1 (cl1 cl2)
  (cond ((null cl1) &#39;subsumed2)
        ((extra-info-lit-p (car cl1))
         (quick-and-dirty-subsumption-replacement-step1 (cdr cl1) cl2))
        ((null cl2) &#39;subsumed1)
...">quick-and-dirty-subsumption-replacement-step1</a> (cdr cl1)
        cl2))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl2) 'subsumed1)
    ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car cl2)) (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step1" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" title="(defun quick-and-dirty-subsumption-replacement-step1 (cl1 cl2)
  (cond ((null cl1) &#39;subsumed2)
        ((extra-info-lit-p (car cl1))
         (quick-and-dirty-subsumption-replacement-step1 (cdr cl1) cl2))
        ((null cl2) &#39;subsumed1)
...">quick-and-dirty-subsumption-replacement-step1</a> cl1
        (cdr cl2)))
    ((equal (car cl1) (car cl2)) (let ((ans (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step1" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" title="(defun quick-and-dirty-subsumption-replacement-step1 (cl1 cl2)
  (cond ((null cl1) &#39;subsumed2)
        ((extra-info-lit-p (car cl1))
         (quick-and-dirty-subsumption-replacement-step1 (cdr cl1) cl2))
        ((null cl2) &#39;subsumed1)
...">quick-and-dirty-subsumption-replacement-step1</a> (cdr cl1)
             (cdr cl2))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp ans) ans) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car cl1) ans)))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (complementaryp (car cl1) (car cl2))
       (<a class="sym-link local-def" href="#def-subsetp-equal-mod-extra-info-lits" data-sym="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" title="(defun subsetp-equal-mod-extra-info-lits (x y)
  (declare (xargs :guard (and (true-listp y) (true-listp x))))
  (cond ((endp x) t)
        ((or (extra-info-lit-p (car x)) (member-equal (car x) y))
         (subsetp-equal-mod-extra-info-lits (cdr x) y))">subsetp-equal-mod-extra-info-lits</a> (cdr cl1) (cdr cl2))) (cdr cl2))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-quick-and-dirty-subsumption-replacement-step" data-defines="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" data-references="CONS,SUBSUMED2,CDR,ANS,SUBSUMED1,QUOTE,EQ,CAR,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1,CL3,LET,T,TIME-LIMIT5-REACHED-P,NULL,COND,LST,CL1,DEFUN" data-used-by="IF-INTERP-ADD-CLAUSE" data-part-name="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" data-part-args="LST,CL1" data-part-body="CONS,SUBSUMED2,CDR,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP,ANS,SUBSUMED1,QUOTE,EQ,CAR,CL1,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1,CL3,LET,T,TIME-LIMIT5-REACHED-P,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP">quick-and-dirty-subsumption-replacement-step</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" title="(defun quick-and-dirty-subsumption-replacement-step (cl1 lst)
  (cond ((null lst) nil)
        ((time-limit5-reached-p &quot;Out of time in subsumption ~
      (quick-and-dirty-subsumption-replacement-step).&quot;)
         nil)
...">quick-and-dirty-subsumption-replacement-step</a>
  (cl1 lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    ((<a class="sym-link system" href="axioms.html#def-time-limit5-reached-p" data-sym="TIME-LIMIT5-REACHED-P">time-limit5-reached-p</a> <span class="string">"Out of time in subsumption ~
      (quick-and-dirty-subsumption-replacement-step)."</span>) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((cl3 (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step1" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP1" title="(defun quick-and-dirty-subsumption-replacement-step1 (cl1 cl2)
  (cond ((null cl1) &#39;subsumed2)
        ((extra-info-lit-p (car cl1))
         (quick-and-dirty-subsumption-replacement-step1 (cdr cl1) cl2))
        ((null cl2) &#39;subsumed1)
...">quick-and-dirty-subsumption-replacement-step1</a> cl1
             (car lst))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> cl3 'subsumed1) 'subsumed1)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ans (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" title="(defun quick-and-dirty-subsumption-replacement-step (cl1 lst)
  (cond ((null lst) nil)
        ((time-limit5-reached-p &quot;Out of time in subsumption ~
      (quick-and-dirty-subsumption-replacement-step).&quot;)
         nil)
...">quick-and-dirty-subsumption-replacement-step</a> cl1 (cdr lst))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> cl3 'subsumed2) ans)
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ans 'subsumed1) ans)
                ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl3) (cons (car lst) ans))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons cl3 ans))))))))))</pre>
  </div>

<div class="form-block other" id="form-91" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> quick-and-dirty-srs (cl1 ac) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-quick-and-dirty-srs-builtin" data-defines="QUICK-AND-DIRTY-SRS-BUILTIN" data-references="T,XARGS,IGNORE,DECLARE,AC,CL1,DEFUN" data-part-name="QUICK-AND-DIRTY-SRS-BUILTIN" data-part-args="AC,CL1" data-part-declare="T,XARGS,AC,CL1,IGNORE,DECLARE" data-part-body="T" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="QUICK-AND-DIRTY-SRS-BUILTIN">quick-and-dirty-srs-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-quick-and-dirty-srs-builtin" data-sym="QUICK-AND-DIRTY-SRS-BUILTIN" title="(defun quick-and-dirty-srs-builtin (cl1 ac)
  (declare (ignore cl1 ac)
           (xargs :mode :logic :guard t))
  t)">quick-and-dirty-srs-builtin</a>
  (cl1 ac)
  (declare (ignore cl1 ac)
    (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-93" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> quick-and-dirty-srs <a class="sym-link local-def" href="#def-quick-and-dirty-srs-builtin" data-sym="QUICK-AND-DIRTY-SRS-BUILTIN" title="(defun quick-and-dirty-srs-builtin (cl1 ac)
  (declare (ignore cl1 ac)
           (xargs :mode :logic :guard t))
  t)">quick-and-dirty-srs-builtin</a>)</pre>
  </div>

<div class="form-block function" id="def-if-interp-add-clause" data-defines="IF-INTERP-ADD-CLAUSE" data-references="CONS,SUBSUMED1,QUOTE,EQ,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP,ANS,QUICK-AND-DIRTY-SRS,CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT,CL1,LET,T,COND,PFLG,AC,CL,ASSUMPTIONS,DEFUN" data-used-by="IF-INTERP" data-part-name="IF-INTERP-ADD-CLAUSE" data-part-args="PFLG,AC,CL,ASSUMPTIONS" data-part-body="CONS,SUBSUMED1,QUOTE,EQ,QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP,ANS,AC,QUICK-AND-DIRTY-SRS,CL,ASSUMPTIONS,CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT,CL1,LET,T,PFLG,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP-ADD-CLAUSE">if-interp-add-clause</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp-add-clause" data-sym="IF-INTERP-ADD-CLAUSE" title="(defun if-interp-add-clause (assumptions cl ac pflg)
  (cond (pflg t)
        (t
         (let ((cl1 (convert-assumptions-to-clause-segment assumptions cl nil)))
           (cond
...">if-interp-add-clause</a>
  (assumptions cl ac pflg)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pflg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((cl1 (<a class="sym-link local-def" href="#def-convert-assumptions-to-clause-segment" data-sym="CONVERT-ASSUMPTIONS-TO-CLAUSE-SEGMENT" title="(defun convert-assumptions-to-clause-segment (assumptions ans known-constants)
  (cond
   ((or (null assumptions)
        (eq (car assumptions) :ignore-when-converting-to-clause))
    ans)
...">convert-assumptions-to-clause-segment</a> assumptions cl nil)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((quick-and-dirty-srs cl1 ac) (let ((ans (<a class="sym-link local-def" href="#def-quick-and-dirty-subsumption-replacement-step" data-sym="QUICK-AND-DIRTY-SUBSUMPTION-REPLACEMENT-STEP" title="(defun quick-and-dirty-subsumption-replacement-step (cl1 lst)
  (cond ((null lst) nil)
        ((time-limit5-reached-p &quot;Out of time in subsumption ~
      (quick-and-dirty-subsumption-replacement-step).&quot;)
         nil)
...">quick-and-dirty-subsumption-replacement-step</a> cl1 ac)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ans 'subsumed1) ac) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons cl1 ans)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons cl1 ac)))))))</pre>
  </div>

<div class="form-block function" id="def-if-interp" data-defines="IF-INTERP" data-references="IF-INTERP-SWITCH,IF-INTERP-ASSUME-TRUE,TEMP,LET*,TEST,CDDR,CADR,CALL-STACK,CALL,RET-STACK,RET,PUSH-FRAME-PTR,NTH,PUSH-LOCAL,CONS,CDR,PUSH,CASE,1-F,CAAR,CAARINSTRS,ZPF,AND,LIST,F,QUOTE,EQ,IF-INTERP-ASSUMED-VALUE,ASSUMED-VAL,T,IF-INTERP-ADD-CLAUSE,*NIL*,EQUAL,QUOTEP,CAR,V,LET,COND,UNSIGNED-BYTE,NULL,OR,TYPE,DECLARE,PFLG,AC,ASSUMPTIONS,FRAME-PTR-STACK,STACK,INSTRS,DEFUN" data-used-by="IF-TAUTOLOGYP,STRIP-BRANCHES" data-part-name="IF-INTERP" data-part-args="PFLG,AC,ASSUMPTIONS,FRAME-PTR-STACK,STACK,INSTRS" data-part-declare="PFLG,UNSIGNED-BYTE,NULL,OR,TYPE,DECLARE" data-part-body="IF-INTERP-SWITCH,IF-INTERP-ASSUME-TRUE,TEMP,LET*,TEST,CDDR,CADR,CALL-STACK,CALL,RET-STACK,RET,PUSH-FRAME-PTR,NTH,PUSH-LOCAL,FRAME-PTR-STACK,CONS,CDR,IF-INTERP,PUSH,CASE,UNSIGNED-BYTE,TYPE,DECLARE,1-F,CAAR,CAARINSTRS,ZPF,AND,LIST,F,QUOTE,EQ,IF-INTERP-ASSUMED-VALUE,ASSUMED-VAL,T,PFLG,AC,ASSUMPTIONS,IF-INTERP-ADD-CLAUSE,*NIL*,EQUAL,QUOTEP,OR,STACK,CAR,V,LET,INSTRS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-INTERP">if-interp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a>
  (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (unsigned-byte <span class="number">60</span>)) pflg))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> instrs) (let ((v (car stack)))
        (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> v) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal v <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link local-def" href="#def-if-interp-add-clause" data-sym="IF-INTERP-ADD-CLAUSE" title="(defun if-interp-add-clause (assumptions cl ac pflg)
  (cond (pflg t)
        (t
         (let ((cl1 (convert-assumptions-to-clause-segment assumptions cl nil)))
           (cond
...">if-interp-add-clause</a> assumptions nil ac pflg))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ac)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((assumed-val (<a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a> v assumptions)))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> assumed-val <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) ac)
                  ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> assumed-val 'f) (<a class="sym-link local-def" href="#def-if-interp-add-clause" data-sym="IF-INTERP-ADD-CLAUSE" title="(defun if-interp-add-clause (assumptions cl ac pflg)
  (cond (pflg t)
        (t
         (let ((cl1 (convert-assumptions-to-clause-segment assumptions cl nil)))
           (cond
...">if-interp-add-clause</a> assumptions nil ac pflg))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp-add-clause" data-sym="IF-INTERP-ADD-CLAUSE" title="(defun if-interp-add-clause (assumptions cl ac pflg)
  (cond (pflg t)
        (t
         (let ((cl1 (convert-assumptions-to-clause-segment assumptions cl nil)))
           (cond
...">if-interp-add-clause</a> assumptions (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> v) ac pflg))))))
          pflg)))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> pflg (<a class="sym-link system" href="axioms.html#def-zpf" data-sym="ZPF">zpf</a> pflg)) <span class="number">0</span>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((caarinstrs (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> instrs)) (pflg (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> pflg (<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> pflg))))
        (declare (type (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (unsigned-byte <span class="number">60</span>)) pflg))
        (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> caarinstrs
          (push (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
              (cons (cdr (car instrs)) stack)
              frame-ptr-stack
              assumptions
              ac
              pflg))
          (push-local (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
              (cons (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (cdr (car instrs)) (car frame-ptr-stack)) stack)
              frame-ptr-stack
              assumptions
              ac
              pflg))
          (push-frame-ptr (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
              stack
              (cons stack frame-ptr-stack)
              assumptions
              ac
              pflg))
          (ret (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
              (cons (car stack)
                (<a class="sym-link local-def" href="#def-ret-stack" data-sym="RET-STACK" title="(defun ret-stack (lst stack)
  (cond ((null lst) stack) (t (ret-stack (cdr lst) (cdr stack)))))">ret-stack</a> (cdr (car instrs)) (cdr stack)))
              (cdr frame-ptr-stack)
              assumptions
              ac
              pflg))
          (call (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
              (<a class="sym-link local-def" href="#def-call-stack" data-sym="CALL-STACK" title="(defun call-stack (fn lst stack assumptions ac)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp stack)
         (&gt;= (length stack) (length lst)))))
...">call-stack</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car instrs))
                (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car instrs))
                stack
                assumptions
                nil)
              frame-ptr-stack
              assumptions
              ac
              pflg))
          (test (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((v (car stack)) (stack (cdr stack)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> v) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal v <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr (car instrs))
                        stack
                        frame-ptr-stack
                        assumptions
                        ac
                        pflg))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
                        stack
                        frame-ptr-stack
                        assumptions
                        ac
                        pflg))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp (<a class="sym-link local-def" href="#def-if-interp-assumed-value" data-sym="IF-INTERP-ASSUMED-VALUE" title="(defun if-interp-assumed-value (term assumptions)
  (cond ((variablep term) (if-interp-assumed-value0 term assumptions))
        ((eq (ffn-symb term) &#39;not)
         (let ((temp (if-interp-assumed-value-x (fargn term 1) assumptions)))
           (cond ((eq temp t) &#39;f) ((eq temp &#39;f) t) (t nil))))">if-interp-assumed-value</a> v assumptions)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp 'f) (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr (car instrs))
                          stack
                          frame-ptr-stack
                          assumptions
                          ac
                          pflg))
                      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> temp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
                          stack
                          frame-ptr-stack
                          assumptions
                          ac
                          pflg))
                      (pflg (let ((assumptions (<a class="sym-link local-def" href="#def-if-interp-assume-true" data-sym="IF-INTERP-ASSUME-TRUE" title="(defun if-interp-assume-true (not-flg term assumptions)
  (cond
   ((variablep term)
    (if not-flg
        (cons :not (cons term assumptions))
...">if-interp-assume-true</a> nil v assumptions)))
                          (let ((pflg (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
                                 stack
                                 frame-ptr-stack
                                 assumptions
                                 ac
                                 pflg)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pflg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr (car instrs))
                                  stack
                                  frame-ptr-stack
                                  (<a class="sym-link local-def" href="#def-if-interp-switch" data-sym="IF-INTERP-SWITCH" title="(defun if-interp-switch (assumptions)
  (cond ((eq (car assumptions) :not) (cdr assumptions))
        (t (cons :not assumptions))))">if-interp-switch</a> assumptions)
                                  ac
                                  pflg))))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((assumptions (<a class="sym-link local-def" href="#def-if-interp-assume-true" data-sym="IF-INTERP-ASSUME-TRUE" title="(defun if-interp-assume-true (not-flg term assumptions)
  (cond
   ((variablep term)
    (if not-flg
        (cons :not (cons term assumptions))
...">if-interp-assume-true</a> nil v assumptions)))
                          (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr instrs)
                            stack
                            frame-ptr-stack
                            assumptions
                            (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (cdr (car instrs))
                              stack
                              frame-ptr-stack
                              (<a class="sym-link local-def" href="#def-if-interp-switch" data-sym="IF-INTERP-SWITCH" title="(defun if-interp-switch (assumptions)
  (cond ((eq (car assumptions) :not) (cdr assumptions))
        (t (cons :not assumptions))))">if-interp-switch</a> assumptions)
                              ac
                              pflg)
                            pflg))))))))))))))</pre>
  </div>

<div class="form-block function" id="def-splice-instrs1" data-defines="SPLICE-INSTRS1" data-references="GO,ASSOC,QUOTE,TEST,RET,CALL,PUSH-FRAME-PTR,PUSH-LOCAL,PUSH,CASE,CAAR,CAARINSTRS,LET,T,CONS,CDR,CAR,ATOM,NULL,COND,INSTR-LISTP,XARGS,DECLARE,ALIST,ANS,INSTRS,DEFUN" data-used-by="SPLICE-INSTRS" data-part-name="SPLICE-INSTRS1" data-part-args="ALIST,ANS,INSTRS" data-part-declare="INSTRS,INSTR-LISTP,XARGS,DECLARE" data-part-body="GO,ASSOC,QUOTE,TEST,RET,CALL,PUSH-FRAME-PTR,PUSH-LOCAL,PUSH,CASE,CAAR,CAARINSTRS,LET,T,ALIST,CONS,CDR,SPLICE-INSTRS1,CAR,ATOM,ANS,INSTRS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLICE-INSTRS1">splice-instrs1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a>
  (instrs ans alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-instr-listp" data-sym="INSTR-LISTP" title="(defun instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (or (integerp (car l))
...">instr-listp</a> instrs)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> instrs) ans)
    ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> (car instrs)) (<a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a> (cdr instrs)
        ans
        (cons (cons (car instrs) ans) alist)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((caarinstrs (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> instrs)))
        (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> caarinstrs
          ((push push-local push-frame-ptr call ret) (<a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a> (cdr instrs) (cons (car instrs) ans) alist))
          (test (<a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a> (cdr instrs)
              (cons (cons 'test (cdr (<a class="sym-link system" href="axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (cdr (car instrs)) alist)))
                ans)
              alist))
          (go (<a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a> (cdr instrs)
              (cdr (<a class="sym-link system" href="axioms.html#def-assoc" data-sym="ASSOC">assoc</a> (cdr (car instrs)) alist))
              alist)))))))</pre>
  </div>

<div class="form-block function" id="def-splice-instrs" data-defines="SPLICE-INSTRS" data-references="SPLICE-INSTRS1,INSTR-LISTP,XARGS,DECLARE,INSTRS,DEFUN" data-used-by="IF-TAUTOLOGYP,STRIP-BRANCHES" data-part-name="SPLICE-INSTRS" data-part-args="INSTRS" data-part-declare="INSTRS,INSTR-LISTP,XARGS,DECLARE" data-part-body="INSTRS,SPLICE-INSTRS1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLICE-INSTRS">splice-instrs</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-splice-instrs" data-sym="SPLICE-INSTRS" title="(defun splice-instrs (instrs)
  (declare (xargs :guard (instr-listp instrs)))
  (splice-instrs1 instrs nil nil))">splice-instrs</a>
  (instrs)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-instr-listp" data-sym="INSTR-LISTP" title="(defun instr-listp (l)
  (cond ((atom l) (equal l nil))
        (t
         (and
          (or (integerp (car l))
...">instr-listp</a> instrs)))
  (<a class="sym-link local-def" href="#def-splice-instrs1" data-sym="SPLICE-INSTRS1" title="(defun splice-instrs1 (instrs ans alist)
  (declare (xargs :guard (instr-listp instrs)))
  (cond ((null instrs) ans)
        ((atom (car instrs))
         (splice-instrs1 (cdr instrs) ans
...">splice-instrs1</a> instrs nil nil))</pre>
  </div>

<div class="form-block function" id="def-strip-branches" data-defines="STRIP-BRANCHES" data-references="IF-COMPILE,SPLICE-INSTRS,IF-INTERP,T,UNION-EQUAL,*NIL*,FARGN,EQUAL,IF,QUOTE,FFN-SYMB-P,AND,COND,PSEUDO-TERMP,XARGS,DECLARE,LAMBDA-EXP,ASSUMPTIONS,TERM,DEFUN" data-used-by="CLAUSIFY" data-part-name="STRIP-BRANCHES" data-part-args="LAMBDA-EXP,ASSUMPTIONS,TERM" data-part-declare="TERM,PSEUDO-TERMP,XARGS,DECLARE" data-part-body="IF-COMPILE,SPLICE-INSTRS,IF-INTERP,T,LAMBDA-EXP,ASSUMPTIONS,STRIP-BRANCHES,UNION-EQUAL,*NIL*,FARGN,EQUAL,IF,QUOTE,TERM,FFN-SYMB-P,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STRIP-BRANCHES">strip-branches</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-strip-branches" data-sym="STRIP-BRANCHES" title="(defun strip-branches (term assumptions lambda-exp)
  (declare (xargs :guard (pseudo-termp term)))
  (cond
   ((and (ffn-symb-p term &#39;if) (equal (fargn term 3) *nil*))
    (union-equal (strip-branches (fargn term 1) assumptions lambda-exp)
...">strip-branches</a>
  (term assumptions lambda-exp)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'if) (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)) (<a class="sym-link system" href="axioms.html#def-union-equal" data-sym="UNION-EQUAL">union-equal</a> (<a class="sym-link local-def" href="#def-strip-branches" data-sym="STRIP-BRANCHES" title="(defun strip-branches (term assumptions lambda-exp)
  (declare (xargs :guard (pseudo-termp term)))
  (cond
   ((and (ffn-symb-p term &#39;if) (equal (fargn term 3) *nil*))
    (union-equal (strip-branches (fargn term 1) assumptions lambda-exp)
...">strip-branches</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) assumptions lambda-exp)
        (<a class="sym-link local-def" href="#def-strip-branches" data-sym="STRIP-BRANCHES" title="(defun strip-branches (term assumptions lambda-exp)
  (declare (xargs :guard (pseudo-termp term)))
  (cond
   ((and (ffn-symb-p term &#39;if) (equal (fargn term 3) *nil*))
    (union-equal (strip-branches (fargn term 1) assumptions lambda-exp)
...">strip-branches</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) assumptions lambda-exp)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (<a class="sym-link local-def" href="#def-splice-instrs" data-sym="SPLICE-INSTRS" title="(defun splice-instrs (instrs)
  (declare (xargs :guard (instr-listp instrs)))
  (splice-instrs1 instrs nil nil))">splice-instrs</a> (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> term lambda-exp nil nil))
        nil
        nil
        assumptions
        nil
        nil))))</pre>
  </div>

<div class="form-block function" id="def-merge-length" data-defines="MERGE-LENGTH" data-references="T,CDR,CONS,CAR,LENGTH,<=,NULL,COND,TRUE-LIST-LISTP,AND,XARGS,DECLARE,L2,L1,DEFUN" data-used-by="MERGE-SORT-LENGTH" data-part-name="MERGE-LENGTH" data-part-args="L2,L1" data-part-declare="L2,L1,TRUE-LIST-LISTP,AND,XARGS,DECLARE" data-part-body="T,CDR,MERGE-LENGTH,CONS,CAR,LENGTH,<=,L2,L1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-LENGTH">merge-length</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-length" data-sym="MERGE-LENGTH" title="(defun merge-length (l1 l2)
  (declare (xargs :guard (and (true-list-listp l1) (true-list-listp l2))))
  (cond ((null l1) l2) ((null l2) l1)
        ((&lt;= (length (car l1)) (length (car l2)))
         (cons (car l1) (merge-length (cdr l1) l2)))">merge-length</a>
  (l1 l2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-list-listp" data-sym="TRUE-LIST-LISTP">true-list-listp</a> l1) (<a class="sym-link system" href="axioms.html#def-true-list-listp" data-sym="TRUE-LIST-LISTP">true-list-listp</a> l2))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l1) l2)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l2) l1)
    ((<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (car l1)) (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (car l2))) (cons (car l1) (<a class="sym-link local-def" href="#def-merge-length" data-sym="MERGE-LENGTH" title="(defun merge-length (l1 l2)
  (declare (xargs :guard (and (true-list-listp l1) (true-list-listp l2))))
  (cond ((null l1) l2) ((null l2) l1)
        ((&lt;= (length (car l1)) (length (car l2)))
         (cons (car l1) (merge-length (cdr l1) l2)))">merge-length</a> (cdr l1) l2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car l2) (<a class="sym-link local-def" href="#def-merge-length" data-sym="MERGE-LENGTH" title="(defun merge-length (l1 l2)
  (declare (xargs :guard (and (true-list-listp l1) (true-list-listp l2))))
  (cond ((null l1) l2) ((null l2) l1)
        ((&lt;= (length (car l1)) (length (car l2)))
         (cons (car l1) (merge-length (cdr l1) l2)))">merge-length</a> l1 (cdr l2))))))</pre>
  </div>

<div class="form-block function" id="def-merge-sort-length" data-defines="MERGE-SORT-LENGTH" data-references="ODDS,EVENS,MERGE-LENGTH,T,CDR,NULL,COND,TRUE-LIST-LISTP,XARGS,DECLARE,L,DEFUN" data-used-by="CLAUSIFY,SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="MERGE-SORT-LENGTH" data-part-args="L" data-part-declare="L,TRUE-LIST-LISTP,XARGS,DECLARE" data-part-body="ODDS,EVENS,MERGE-SORT-LENGTH,MERGE-LENGTH,T,L,CDR,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-SORT-LENGTH">merge-sort-length</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-sort-length" data-sym="MERGE-SORT-LENGTH" title="(defun merge-sort-length (l)
  (declare (xargs :guard (true-list-listp l)))
  (cond ((null (cdr l)) l)
        (t
         (merge-length (merge-sort-length (evens l))">merge-sort-length</a>
  (l)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-true-list-listp" data-sym="TRUE-LIST-LISTP">true-list-listp</a> l)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr l)) l)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-length" data-sym="MERGE-LENGTH" title="(defun merge-length (l1 l2)
  (declare (xargs :guard (and (true-list-listp l1) (true-list-listp l2))))
  (cond ((null l1) l2) ((null l2) l1)
        ((&lt;= (length (car l1)) (length (car l2)))
         (cons (car l1) (merge-length (cdr l1) l2)))">merge-length</a> (<a class="sym-link local-def" href="#def-merge-sort-length" data-sym="MERGE-SORT-LENGTH" title="(defun merge-sort-length (l)
  (declare (xargs :guard (true-list-listp l)))
  (cond ((null (cdr l)) l)
        (t
         (merge-length (merge-sort-length (evens l))">merge-sort-length</a> (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> l))
        (<a class="sym-link local-def" href="#def-merge-sort-length" data-sym="MERGE-SORT-LENGTH" title="(defun merge-sort-length (l)
  (declare (xargs :guard (true-list-listp l)))
  (cond ((null (cdr l)) l)
        (t
         (merge-length (merge-sort-length (evens l))">merge-sort-length</a> (<a class="sym-link system" href="axioms.html#def-odds" data-sym="ODDS">odds</a> l))))))</pre>
  </div>

<div class="form-block function" id="def-member-equal-_2B-" data-defines="MEMBER-EQUAL-+-" data-references="CDR,T,-,COMPLEMENTARYP,+,QUOTE,CAR,EQUAL,NULL,COND,CLAUSE,LIT,DEFUN" data-used-by="REPLACE-CLAUSE1,STORE-CLAUSE1,FIND-CLAUSES1,FILTER-WITH-AND-WITHOUT,ARG1-ALMOST-SUBSUMES-ARG2" data-part-name="MEMBER-EQUAL-+-" data-part-args="CLAUSE,LIT" data-part-body="CDR,MEMBER-EQUAL-+-,T,-,COMPLEMENTARYP,+,QUOTE,CAR,LIT,EQUAL,CLAUSE,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-EQUAL-+-">member-equal-+-</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a>
  (lit clause)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> clause) nil)
    ((equal lit (car clause)) '<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a>)
    ((complementaryp lit (car clause)) '<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> lit (cdr clause)))))</pre>
  </div>

<div class="form-block function" id="def-arg1-almost-subsumes-arg2" data-defines="ARG1-ALMOST-SUBSUMES-ARG2" data-references="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS,+,EQ,MEMBER-EQUAL-+-,SIGN,LET,T,CDR,CAR,EXTRA-INFO-LIT-P,SUBSUMED,QUOTE,NULL,COND,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,ARG2,ARG1,DEFUN" data-used-by="FIND-SUBSUMER-REPLACEMENT-REC" data-part-name="ARG1-ALMOST-SUBSUMES-ARG2" data-part-args="ARG2,ARG1" data-part-declare="ARG2,ARG1,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS,+,EQ,MEMBER-EQUAL-+-,SIGN,LET,T,ARG2,CDR,ARG1-ALMOST-SUBSUMES-ARG2,CAR,EXTRA-INFO-LIT-P,SUBSUMED,QUOTE,ARG1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ARG1-ALMOST-SUBSUMES-ARG2">arg1-almost-subsumes-arg2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-arg1-almost-subsumes-arg2" data-sym="ARG1-ALMOST-SUBSUMES-ARG2" title="(defun arg1-almost-subsumes-arg2 (arg1 arg2)
  (declare
   (xargs :guard (and (pseudo-term-listp arg1) (pseudo-term-listp arg2))))
  (cond ((null arg1) &#39;subsumed)
        ((extra-info-lit-p (car arg1))
...">arg1-almost-subsumes-arg2</a>
  (arg1 arg2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp arg1) (pseudo-term-listp arg2))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> arg1) 'subsumed)
    ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car arg1)) (<a class="sym-link local-def" href="#def-arg1-almost-subsumes-arg2" data-sym="ARG1-ALMOST-SUBSUMES-ARG2" title="(defun arg1-almost-subsumes-arg2 (arg1 arg2)
  (declare
   (xargs :guard (and (pseudo-term-listp arg1) (pseudo-term-listp arg2))))
  (cond ((null arg1) &#39;subsumed)
        ((extra-info-lit-p (car arg1))
...">arg1-almost-subsumes-arg2</a> (cdr arg1) arg2))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((sign (<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> (car arg1) arg2)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> sign) nil)
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> sign '<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a>) (<a class="sym-link local-def" href="#def-arg1-almost-subsumes-arg2" data-sym="ARG1-ALMOST-SUBSUMES-ARG2" title="(defun arg1-almost-subsumes-arg2 (arg1 arg2)
  (declare
   (xargs :guard (and (pseudo-term-listp arg1) (pseudo-term-listp arg2))))
  (cond ((null arg1) &#39;subsumed)
        ((extra-info-lit-p (car arg1))
...">arg1-almost-subsumes-arg2</a> (cdr arg1) arg2))
          ((<a class="sym-link local-def" href="#def-subsetp-equal-mod-extra-info-lits" data-sym="SUBSETP-EQUAL-MOD-EXTRA-INFO-LITS" title="(defun subsetp-equal-mod-extra-info-lits (x y)
  (declare (xargs :guard (and (true-listp y) (true-listp x))))
  (cond ((endp x) t)
        ((or (extra-info-lit-p (car x)) (member-equal (car x) y))
         (subsetp-equal-mod-extra-info-lits (cdr x) y))">subsetp-equal-mod-extra-info-lits</a> (cdr arg1) arg2) arg1)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))))</pre>
  </div>

<div class="form-block function" id="def-find-subsumer-replacement-rec" data-defines="FIND-SUBSUMER-REPLACEMENT-REC" data-references="OR,CL0,RST,MV-LET,SUBSUMED,QUOTE,EQ,ARG1-ALMOST-SUBSUMES-ARG2,HERE,LET,T,CDR,CAR,LEN,>,MV,NULL,COND,LENGTH,EQUAL,PSEUDO-TERM-LIST-LISTP,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,LEN-CL,L,CL,DEFUN" data-used-by="FIND-SUBSUMER-REPLACEMENT" data-part-name="FIND-SUBSUMER-REPLACEMENT-REC" data-part-args="LEN-CL,L,CL" data-part-declare="LENGTH,LEN-CL,EQUAL,L,PSEUDO-TERM-LIST-LISTP,CL,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="OR,CL0,RST,MV-LET,SUBSUMED,QUOTE,EQ,ARG1-ALMOST-SUBSUMES-ARG2,HERE,LET,T,CDR,CL,FIND-SUBSUMER-REPLACEMENT-REC,LEN-CL,CAR,LEN,>,MV,L,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-SUBSUMER-REPLACEMENT-REC">find-subsumer-replacement-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-subsumer-replacement-rec" data-sym="FIND-SUBSUMER-REPLACEMENT-REC" title="(defun find-subsumer-replacement-rec (cl l len-cl)
  (declare
   (xargs :guard
    (and (pseudo-term-listp cl) (pseudo-term-list-listp l)
         (equal len-cl (length cl)))))
...">find-subsumer-replacement-rec</a>
  (cl l len-cl)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp cl)
        (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> l)
        (equal len-cl (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> cl)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    ((<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (car l)) len-cl) (<a class="sym-link local-def" href="#def-find-subsumer-replacement-rec" data-sym="FIND-SUBSUMER-REPLACEMENT-REC" title="(defun find-subsumer-replacement-rec (cl l len-cl)
  (declare
   (xargs :guard
    (and (pseudo-term-listp cl) (pseudo-term-list-listp l)
         (equal len-cl (length cl)))))
...">find-subsumer-replacement-rec</a> cl (cdr l) len-cl))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((here (<a class="sym-link local-def" href="#def-arg1-almost-subsumes-arg2" data-sym="ARG1-ALMOST-SUBSUMES-ARG2" title="(defun arg1-almost-subsumes-arg2 (arg1 arg2)
  (declare
   (xargs :guard (and (pseudo-term-listp arg1) (pseudo-term-listp arg2))))
  (cond ((null arg1) &#39;subsumed)
        ((extra-info-lit-p (car arg1))
...">arg1-almost-subsumes-arg2</a> (car l) cl)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> here 'subsumed) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> here (car l)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rst cl0)
              (<a class="sym-link local-def" href="#def-find-subsumer-replacement-rec" data-sym="FIND-SUBSUMER-REPLACEMENT-REC" title="(defun find-subsumer-replacement-rec (cl l len-cl)
  (declare
   (xargs :guard
    (and (pseudo-term-listp cl) (pseudo-term-list-listp l)
         (equal len-cl (length cl)))))
...">find-subsumer-replacement-rec</a> cl (cdr l) len-cl)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> rst 'subsumed) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> rst cl0))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> here rst) nil))))))))))</pre>
  </div>

<div class="form-block function" id="def-find-subsumer-replacement" data-defines="FIND-SUBSUMER-REPLACEMENT" data-references="LENGTH,FIND-SUBSUMER-REPLACEMENT-REC,PSEUDO-TERM-LIST-LISTP,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,L,CL,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="FIND-SUBSUMER-REPLACEMENT" data-part-args="L,CL" data-part-declare="L,PSEUDO-TERM-LIST-LISTP,CL,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="LENGTH,L,CL,FIND-SUBSUMER-REPLACEMENT-REC" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-SUBSUMER-REPLACEMENT">find-subsumer-replacement</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-subsumer-replacement" data-sym="FIND-SUBSUMER-REPLACEMENT" title="(defun find-subsumer-replacement (cl l)
  (declare
   (xargs :guard (and (pseudo-term-listp cl) (pseudo-term-list-listp l))))
  (find-subsumer-replacement-rec cl l (length cl)))">find-subsumer-replacement</a>
  (cl l)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp cl) (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> l))))
  (<a class="sym-link local-def" href="#def-find-subsumer-replacement-rec" data-sym="FIND-SUBSUMER-REPLACEMENT-REC" title="(defun find-subsumer-replacement-rec (cl l len-cl)
  (declare
   (xargs :guard
    (and (pseudo-term-listp cl) (pseudo-term-list-listp l)
         (equal len-cl (length cl)))))
...">find-subsumer-replacement-rec</a> cl l (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> cl)))</pre>
  </div>

<div class="form-block function" id="def-remove-one-complement" data-defines="REMOVE-ONE-COMPLEMENT" data-references="CONS,T,CDR,CAR,COMPLEMENTARYP,NULL,COND,PSEUDO-TERM-LISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,CL,LIT,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="REMOVE-ONE-COMPLEMENT" data-part-args="CL,LIT" data-part-declare="CL,PSEUDO-TERM-LISTP,LIT,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="REMOVE-ONE-COMPLEMENT,CONS,T,CDR,CAR,LIT,COMPLEMENTARYP,CL,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-ONE-COMPLEMENT">remove-one-complement</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-one-complement" data-sym="REMOVE-ONE-COMPLEMENT" title="(defun remove-one-complement (lit cl)
  (declare (xargs :guard (and (pseudo-termp lit) (pseudo-term-listp cl))))
  (cond ((null cl) nil) ((complementaryp lit (car cl)) (cdr cl))
        (t (cons (car cl) (remove-one-complement lit (cdr cl))))))">remove-one-complement</a>
  (lit cl)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> lit) (pseudo-term-listp cl))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cl) nil)
    ((complementaryp lit (car cl)) (cdr cl))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car cl) (<a class="sym-link local-def" href="#def-remove-one-complement" data-sym="REMOVE-ONE-COMPLEMENT" title="(defun remove-one-complement (lit cl)
  (declare (xargs :guard (and (pseudo-termp lit) (pseudo-term-listp cl))))
  (cond ((null cl) nil) ((complementaryp lit (car cl)) (cdr cl))
        (t (cons (car cl) (remove-one-complement lit (cdr cl))))))">remove-one-complement</a> lit (cdr cl))))))</pre>
  </div>

<div class="form-block function" id="def-weak-disc-tree" data-defines="WEAK-DISC-TREE" data-references="CDR,PSEUDO-TERM-LIST-LISTP,T,CADDDR,CADDR,CADR,PSEUDO-TERMP,LENGTH,TRUE-LISTP,NODE,QUOTE,CAR,COND,EQUAL,CONSP,OR,AND,X,DEFUN" data-used-by="SWEEP-CLAUSES,SWEEP-CLAUSES1" data-part-name="WEAK-DISC-TREE" data-part-args="X" data-part-body="CDR,PSEUDO-TERM-LIST-LISTP,T,CADDDR,CADDR,WEAK-DISC-TREE,CADR,PSEUDO-TERMP,LENGTH,TRUE-LISTP,NODE,QUOTE,CAR,COND,EQUAL,X,CONSP,OR,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WEAK-DISC-TREE">weak-disc-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-weak-disc-tree" data-sym="WEAK-DISC-TREE" title="(defun weak-disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">weak-disc-tree</a>
  (x)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (consp x) (equal x nil))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (car x) 'node) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x)
          (equal (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> x) <span class="number">4</span>)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
          (<a class="sym-link local-def" href="#def-weak-disc-tree" data-sym="WEAK-DISC-TREE" title="(defun weak-disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">weak-disc-tree</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> x))
          (<a class="sym-link local-def" href="#def-weak-disc-tree" data-sym="WEAK-DISC-TREE" title="(defun weak-disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">weak-disc-tree</a> (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> x))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-sweep-clauses1" data-defines="SWEEP-CLAUSES1" data-references="CDR,APPEND,T,CADDDR,CADDR,NODE,QUOTE,CAR,EQ,COND,WEAK-DISC-TREE,XARGS,DECLARE,AC,TREE,DEFUN" data-used-by="SWEEP-CLAUSES" data-part-name="SWEEP-CLAUSES1" data-part-args="AC,TREE" data-part-declare="TREE,WEAK-DISC-TREE,XARGS,DECLARE" data-part-body="CDR,APPEND,T,AC,CADDDR,CADDR,SWEEP-CLAUSES1,NODE,QUOTE,TREE,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SWEEP-CLAUSES1">sweep-clauses1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sweep-clauses1" data-sym="SWEEP-CLAUSES1" title="(defun sweep-clauses1 (tree ac)
  (declare (xargs :guard (weak-disc-tree tree)))
  (cond
   ((eq (car tree) &#39;node)
    (sweep-clauses1 (caddr tree) (sweep-clauses1 (cadddr tree) ac)))">sweep-clauses1</a>
  (tree ac)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-weak-disc-tree" data-sym="WEAK-DISC-TREE" title="(defun weak-disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">weak-disc-tree</a> tree)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car tree) 'node) (<a class="sym-link local-def" href="#def-sweep-clauses1" data-sym="SWEEP-CLAUSES1" title="(defun sweep-clauses1 (tree ac)
  (declare (xargs :guard (weak-disc-tree tree)))
  (cond
   ((eq (car tree) &#39;node)
    (sweep-clauses1 (caddr tree) (sweep-clauses1 (cadddr tree) ac)))">sweep-clauses1</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree)
        (<a class="sym-link local-def" href="#def-sweep-clauses1" data-sym="SWEEP-CLAUSES1" title="(defun sweep-clauses1 (tree ac)
  (declare (xargs :guard (weak-disc-tree tree)))
  (cond
   ((eq (car tree) &#39;node)
    (sweep-clauses1 (caddr tree) (sweep-clauses1 (cadddr tree) ac)))">sweep-clauses1</a> (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree) ac)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (cdr tree) ac))))</pre>
  </div>

<div class="form-block function" id="def-sweep-clauses" data-defines="SWEEP-CLAUSES" data-references="SWEEP-CLAUSES1,WEAK-DISC-TREE,XARGS,DECLARE,TREE,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP,DISC-TREE" data-part-name="SWEEP-CLAUSES" data-part-args="TREE" data-part-declare="TREE,WEAK-DISC-TREE,XARGS,DECLARE" data-part-body="TREE,SWEEP-CLAUSES1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SWEEP-CLAUSES">sweep-clauses</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sweep-clauses" data-sym="SWEEP-CLAUSES" title="(defun sweep-clauses (tree)
  (declare (xargs :guard (weak-disc-tree tree)))
  (sweep-clauses1 tree nil))">sweep-clauses</a>
  (tree)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-weak-disc-tree" data-sym="WEAK-DISC-TREE" title="(defun weak-disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">weak-disc-tree</a> tree)))
  (<a class="sym-link local-def" href="#def-sweep-clauses1" data-sym="SWEEP-CLAUSES1" title="(defun sweep-clauses1 (tree ac)
  (declare (xargs :guard (weak-disc-tree tree)))
  (cond
   ((eq (car tree) &#39;node)
    (sweep-clauses1 (caddr tree) (sweep-clauses1 (cadddr tree) ac)))">sweep-clauses1</a> tree nil))</pre>
  </div>

<div class="form-block function" id="def-filter-with-and-without" data-defines="FILTER-WITH-AND-WITHOUT" data-references="T,CONS,CDR,CAR,MEMBER-EQUAL-+-,EXTRA-INFO-LIT-P,OR,MV,NULL,COND,WITHOUT-LST,WITH-LST,L,X,DEFUN" data-used-by="STORE-CLAUSE1,DISC-TREE" data-part-name="FILTER-WITH-AND-WITHOUT" data-part-args="WITHOUT-LST,WITH-LST,L,X" data-part-body="T,CONS,CDR,FILTER-WITH-AND-WITHOUT,CAR,MEMBER-EQUAL-+-,X,EXTRA-INFO-LIT-P,OR,WITHOUT-LST,WITH-LST,MV,L,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FILTER-WITH-AND-WITHOUT">filter-with-and-without</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a>
  (x l with-lst without-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> with-lst without-lst))
    ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> x) (<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> x (car l))) (<a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a> x
        (cdr l)
        (cons (car l) with-lst)
        without-lst))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a> x
        (cdr l)
        with-lst
        (cons (car l) without-lst)))))</pre>
  </div>

<div class="form-block function" id="def-disc-tree" data-defines="DISC-TREE" data-references="CDR,PSEUDO-TERM-LIST-LISTP,T,NULL,IGNORE,DECLARE,SWEEP-CLAUSES,FILTER-WITH-AND-WITHOUT,WITHOUT-LST,WITH-LST,MV-LET,CADDDR,CADDR,CADR,PSEUDO-TERMP,LENGTH,TRUE-LISTP,NODE,QUOTE,CAR,COND,EQUAL,CONSP,OR,AND,X,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP,REPLACE-CLAUSE,REPLACE-CLAUSE1,STORE-CLAUSE1,FIND-CLAUSES1" data-part-name="DISC-TREE" data-part-args="X" data-part-body="CDR,PSEUDO-TERM-LIST-LISTP,T,NULL,IGNORE,DECLARE,SWEEP-CLAUSES,FILTER-WITH-AND-WITHOUT,WITHOUT-LST,WITH-LST,MV-LET,CADDDR,CADDR,DISC-TREE,CADR,PSEUDO-TERMP,LENGTH,TRUE-LISTP,NODE,QUOTE,CAR,COND,EQUAL,X,CONSP,OR,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DISC-TREE">disc-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a>
  (x)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (consp x) (equal x nil))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (car x) 'node) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x)
          (equal (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> x) <span class="number">4</span>)
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x))
          (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> x))
          (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> x))
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (with-lst without-lst)
            (<a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x)
              (<a class="sym-link local-def" href="#def-sweep-clauses" data-sym="SWEEP-CLAUSES" title="(defun sweep-clauses (tree)
  (declare (xargs :guard (weak-disc-tree tree)))
  (sweep-clauses1 tree nil))">sweep-clauses</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> x))
              nil
              nil)
            (declare (ignore with-lst))
            (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> without-lst))
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (with-lst without-lst)
            (<a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> x)
              (<a class="sym-link local-def" href="#def-sweep-clauses" data-sym="SWEEP-CLAUSES" title="(defun sweep-clauses (tree)
  (declare (xargs :guard (weak-disc-tree tree)))
  (sweep-clauses1 tree nil))">sweep-clauses</a> (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> x))
              nil
              nil)
            (declare (ignore without-lst))
            (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> with-lst))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-find-clauses1" data-defines="FIND-CLAUSES1" data-references="CDR,APPEND,T,CADDDR,CADDR,MEMBER-EQUAL-+-,CADR,EXTRA-INFO-LIT-P,OR,NODE,QUOTE,CAR,EQ,COND,PSEUDO-TERM-LIST-LISTP,PSEUDO-TERM-LISTP,DISC-TREE,AND,XARGS,DECLARE,AC,TREE,CLAUSE,DEFUN" data-used-by="FIND-CLAUSES" data-part-name="FIND-CLAUSES1" data-part-args="AC,TREE,CLAUSE" data-part-declare="AC,PSEUDO-TERM-LIST-LISTP,CLAUSE,PSEUDO-TERM-LISTP,TREE,DISC-TREE,AND,XARGS,DECLARE" data-part-body="CDR,APPEND,T,AC,CADDDR,CADDR,FIND-CLAUSES1,CLAUSE,MEMBER-EQUAL-+-,CADR,EXTRA-INFO-LIT-P,OR,NODE,QUOTE,TREE,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-CLAUSES1">find-clauses1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-clauses1" data-sym="FIND-CLAUSES1" title="(defun find-clauses1 (clause tree ac)
  (declare
   (xargs :guard
    (and (disc-tree tree) (pseudo-term-listp clause)
         (pseudo-term-list-listp ac))))
...">find-clauses1</a>
  (clause tree ac)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> tree)
        (pseudo-term-listp clause)
        (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> ac))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car tree) 'node) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree))
           (<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree) clause)) (<a class="sym-link local-def" href="#def-find-clauses1" data-sym="FIND-CLAUSES1" title="(defun find-clauses1 (clause tree ac)
  (declare
   (xargs :guard
    (and (disc-tree tree) (pseudo-term-listp clause)
         (pseudo-term-list-listp ac))))
...">find-clauses1</a> clause
            (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree)
            (<a class="sym-link local-def" href="#def-find-clauses1" data-sym="FIND-CLAUSES1" title="(defun find-clauses1 (clause tree ac)
  (declare
   (xargs :guard
    (and (disc-tree tree) (pseudo-term-listp clause)
         (pseudo-term-list-listp ac))))
...">find-clauses1</a> clause (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree) ac)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-clauses1" data-sym="FIND-CLAUSES1" title="(defun find-clauses1 (clause tree ac)
  (declare
   (xargs :guard
    (and (disc-tree tree) (pseudo-term-listp clause)
         (pseudo-term-list-listp ac))))
...">find-clauses1</a> clause (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree) ac))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (cdr tree) ac))))</pre>
  </div>

<div class="form-block function" id="def-find-clauses" data-defines="FIND-CLAUSES" data-references="FIND-CLAUSES1,TREE,CLAUSE,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="FIND-CLAUSES" data-part-args="TREE,CLAUSE" data-part-body="TREE,CLAUSE,FIND-CLAUSES1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-CLAUSES">find-clauses</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-clauses" data-sym="FIND-CLAUSES" title="(defun find-clauses (clause tree) (find-clauses1 clause tree nil))">find-clauses</a>
  (clause tree)
  (<a class="sym-link local-def" href="#def-find-clauses1" data-sym="FIND-CLAUSES1" title="(defun find-clauses1 (clause tree ac)
  (declare
   (xargs :guard
    (and (disc-tree tree) (pseudo-term-listp clause)
         (pseudo-term-list-listp ac))))
...">find-clauses1</a> clause tree nil))</pre>
  </div>

<div class="form-block function" id="def-remove-one-_2B-" data-defines="REMOVE-ONE-+-" data-references="CONS,T,COMPLEMENTARYP,CDR,CAR,EQUAL,NULL,COND,L,X,DEFUN" data-used-by="REPLACE-CLAUSE1,STORE-CLAUSE1" data-part-name="REMOVE-ONE-+-" data-part-args="L,X" data-part-body="REMOVE-ONE-+-,CONS,T,COMPLEMENTARYP,CDR,CAR,X,EQUAL,L,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-ONE-+-">remove-one-+-</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-one-_2B-" data-sym="REMOVE-ONE-+-" title="(defun remove-one-+- (x l)
  (cond ((null l) nil) ((equal x (car l)) (cdr l))
        ((complementaryp x (car l)) (cdr l))
        (t (cons (car l) (remove-one-+- x (cdr l))))))">remove-one-+-</a>
  (x l)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l) nil)
    ((equal x (car l)) (cdr l))
    ((complementaryp x (car l)) (cdr l))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car l) (<a class="sym-link local-def" href="#def-remove-one-_2B-" data-sym="REMOVE-ONE-+-" title="(defun remove-one-+- (x l)
  (cond ((null l) nil) ((equal x (car l)) (cdr l))
        ((complementaryp x (car l)) (cdr l))
        (t (cons (car l) (remove-one-+- x (cdr l))))))">remove-one-+-</a> x (cdr l))))))</pre>
  </div>

<div class="form-block function" id="def-store-clause1" data-defines="STORE-CLAUSE1" data-references="FILTER-WITH-AND-WITHOUT,WITHOUT-LST,WITH-LST,MV-LET,CDR,TIP,CONS,NULL,T,REMOVE-ONE-+-,MEMBER-EQUAL-+-,CADDDR,CADDR,LIST,CADR,EXTRA-INFO-LIT-P,NODE,QUOTE,CAR,EQ,COND,DISC-TREE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,TREE,UNDISC-LITS,CLAUSE,DEFUN" data-used-by="STORE-CLAUSE" data-part-name="STORE-CLAUSE1" data-part-args="TREE,UNDISC-LITS,CLAUSE" data-part-declare="TREE,DISC-TREE,UNDISC-LITS,CLAUSE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="FILTER-WITH-AND-WITHOUT,WITHOUT-LST,WITH-LST,MV-LET,CDR,TIP,CONS,NULL,T,REMOVE-ONE-+-,MEMBER-EQUAL-+-,CADDDR,CADDR,UNDISC-LITS,CLAUSE,STORE-CLAUSE1,LIST,CADR,EXTRA-INFO-LIT-P,NODE,QUOTE,TREE,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STORE-CLAUSE1">store-clause1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a>
  (clause undisc-lits tree)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp clause)
        (pseudo-term-listp undisc-lits)
        (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> tree))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car tree) 'node) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)
            (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> clause undisc-lits (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree))
            (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree)))
        ((<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree) clause) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)
            (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> clause
              (<a class="sym-link local-def" href="#def-remove-one-_2B-" data-sym="REMOVE-ONE-+-" title="(defun remove-one-+- (x l)
  (cond ((null l) nil) ((equal x (car l)) (cdr l))
        ((complementaryp x (car l)) (cdr l))
        (t (cons (car l) (remove-one-+- x (cdr l))))))">remove-one-+-</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree) undisc-lits)
              (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree))
            (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)
            (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree)
            (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> clause undisc-lits (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree))))))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> undisc-lits) (cons 'tip (cons clause (cdr tree))))
    ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car undisc-lits)) (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> clause (cdr undisc-lits) tree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (with-lst without-lst)
        (<a class="sym-link local-def" href="#def-filter-with-and-without" data-sym="FILTER-WITH-AND-WITHOUT" title="(defun filter-with-and-without (x l with-lst without-lst)
  (cond ((null l) (mv with-lst without-lst))
        ((or (extra-info-lit-p x) (member-equal-+- x (car l)))
         (filter-with-and-without x (cdr l) (cons (car l) with-lst)
                                  without-lst))
...">filter-with-and-without</a> (car undisc-lits)
          (cdr tree)
          nil
          nil)
        (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> clause
          undisc-lits
          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (car undisc-lits)
            (cons 'tip with-lst)
            (cons 'tip without-lst)))))))</pre>
  </div>

<div class="form-block function" id="def-store-clause" data-defines="STORE-CLAUSE" data-references="STORE-CLAUSE1,TREE,CL,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="STORE-CLAUSE" data-part-args="TREE,CL" data-part-body="TREE,CL,STORE-CLAUSE1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STORE-CLAUSE">store-clause</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-store-clause" data-sym="STORE-CLAUSE" title="(defun store-clause (cl tree) (store-clause1 cl cl tree))">store-clause</a> (cl tree) (<a class="sym-link local-def" href="#def-store-clause1" data-sym="STORE-CLAUSE1" title="(defun store-clause1 (clause undisc-lits tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">store-clause1</a> cl cl tree))</pre>
  </div>

<div class="form-block function" id="def-substitute1-ac" data-defines="SUBSTITUTE1-AC" data-references="T,CDR,CONS,REVAPPEND,CAR,EQUAL,SUBSTITUTE,QUOTE,HARD,ER,ENDP,COND,MEMBER-EQUAL,TRUE-LISTP,AND,XARGS,DECLARE,ACC,SEQ,OLD,NEW,DEFUN" data-used-by="SUBSTITUTE1" data-part-name="SUBSTITUTE1-AC" data-part-args="ACC,SEQ,OLD,NEW" data-part-declare="OLD,MEMBER-EQUAL,SEQ,ACC,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="SUBSTITUTE1-AC,T,CDR,CONS,ACC,REVAPPEND,CAR,EQUAL,OLD,NEW,SUBSTITUTE,QUOTE,HARD,ER,SEQ,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBSTITUTE1-AC">substitute1-ac</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-substitute1-ac" data-sym="SUBSTITUTE1-AC" title="(defun substitute1-ac (new old seq acc)
  (declare
   (xargs :guard
    (and (true-listp acc) (true-listp seq) (member-equal old seq))))
  (cond
...">substitute1-ac</a>
  (new old seq acc)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> acc)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> seq)
        (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> old seq))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> seq) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link system" href="axioms.html#def-substitute" data-sym="SUBSTITUTE">substitute</a>
        <span class="string">"Attempted to substitute ~x0 for ~x1 into a sequence in which the ~
         latter was not an element."</span>
        new
        old))
    ((equal old (car seq)) (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> acc (cons new (cdr seq))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-substitute1-ac" data-sym="SUBSTITUTE1-AC" title="(defun substitute1-ac (new old seq acc)
  (declare
   (xargs :guard
    (and (true-listp acc) (true-listp seq) (member-equal old seq))))
  (cond
...">substitute1-ac</a> new old (cdr seq) (cons (car seq) acc)))))</pre>
  </div>

<div class="form-block function" id="def-substitute1" data-defines="SUBSTITUTE1" data-references="SUBSTITUTE1-AC,MEMBER-EQUAL,TRUE-LISTP,AND,XARGS,DECLARE,SEQ,OLD,NEW,DEFUN" data-used-by="REPLACE-CLAUSE1" data-part-name="SUBSTITUTE1" data-part-args="SEQ,OLD,NEW" data-part-declare="OLD,MEMBER-EQUAL,SEQ,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="SEQ,OLD,NEW,SUBSTITUTE1-AC" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBSTITUTE1">substitute1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-substitute1" data-sym="SUBSTITUTE1" title="(defun substitute1 (new old seq)
  (declare (xargs :guard (and (true-listp seq) (member-equal old seq))))
  (substitute1-ac new old seq nil))">substitute1</a>
  (new old seq)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> seq) (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> old seq))))
  (<a class="sym-link local-def" href="#def-substitute1-ac" data-sym="SUBSTITUTE1-AC" title="(defun substitute1-ac (new old seq acc)
  (declare
   (xargs :guard
    (and (true-listp acc) (true-listp seq) (member-equal old seq))))
  (cond
...">substitute1-ac</a> new old seq nil))</pre>
  </div>

<div class="form-block function" id="def-replace-clause1" data-defines="REPLACE-CLAUSE1" data-references="SUBSTITUTE1,CONS,CDR,MEMBER-EQUAL,T,CADDDR,CADDR,REMOVE-ONE-+-,LIST,CADR,MEMBER-EQUAL-+-,NODE,QUOTE,CAR,EQ,COND,DISC-TREE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,TREE,NEW-CLAUSE,UNDISC-LITS,CLAUSE,DEFUN" data-used-by="REPLACE-CLAUSE" data-part-name="REPLACE-CLAUSE1" data-part-args="TREE,NEW-CLAUSE,UNDISC-LITS,CLAUSE" data-part-declare="TREE,DISC-TREE,UNDISC-LITS,CLAUSE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="SUBSTITUTE1,CONS,CDR,MEMBER-EQUAL,T,CADDDR,CADDR,NEW-CLAUSE,UNDISC-LITS,REMOVE-ONE-+-,REPLACE-CLAUSE1,LIST,CLAUSE,CADR,MEMBER-EQUAL-+-,NODE,QUOTE,TREE,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REPLACE-CLAUSE1">replace-clause1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-replace-clause1" data-sym="REPLACE-CLAUSE1" title="(defun replace-clause1 (clause undisc-lits new-clause tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">replace-clause1</a>
  (clause undisc-lits new-clause tree)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp clause)
        (pseudo-term-listp undisc-lits)
        (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> tree))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car tree) 'node) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-member-equal-_2B-" data-sym="MEMBER-EQUAL-+-" title="(defun member-equal-+- (lit clause)
  (cond ((null clause) nil) ((equal lit (car clause)) &#39;+)
        ((complementaryp lit (car clause)) &#39;-)
        (t (member-equal-+- lit (cdr clause)))))">member-equal-+-</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree) clause) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)
            (<a class="sym-link local-def" href="#def-replace-clause1" data-sym="REPLACE-CLAUSE1" title="(defun replace-clause1 (clause undisc-lits new-clause tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">replace-clause1</a> clause
              (<a class="sym-link local-def" href="#def-remove-one-_2B-" data-sym="REMOVE-ONE-+-" title="(defun remove-one-+- (x l)
  (cond ((null l) nil) ((equal x (car l)) (cdr l))
        ((complementaryp x (car l)) (cdr l))
        (t (cons (car l) (remove-one-+- x (cdr l))))))">remove-one-+-</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree) undisc-lits)
              new-clause
              (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree))
            (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> 'node
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> tree)
            (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> tree)
            (<a class="sym-link local-def" href="#def-replace-clause1" data-sym="REPLACE-CLAUSE1" title="(defun replace-clause1 (clause undisc-lits new-clause tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">replace-clause1</a> clause
              undisc-lits
              new-clause
              (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> tree))))))
    ((<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> clause (cdr tree)) (cons (car tree) (<a class="sym-link local-def" href="#def-substitute1" data-sym="SUBSTITUTE1" title="(defun substitute1 (new old seq)
  (declare (xargs :guard (and (true-listp seq) (member-equal old seq))))
  (substitute1-ac new old seq nil))">substitute1</a> new-clause clause (cdr tree))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> tree)))</pre>
  </div>

<div class="form-block function" id="def-replace-clause" data-defines="REPLACE-CLAUSE" data-references="REPLACE-CLAUSE1,DISC-TREE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,TREE,NEW-CLAUSE,CLAUSE,DEFUN" data-used-by="MERGE-EXTRA-INFO-LITS" data-part-name="REPLACE-CLAUSE" data-part-args="TREE,NEW-CLAUSE,CLAUSE" data-part-declare="TREE,DISC-TREE,CLAUSE,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="TREE,NEW-CLAUSE,CLAUSE,REPLACE-CLAUSE1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REPLACE-CLAUSE">replace-clause</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-replace-clause" data-sym="REPLACE-CLAUSE" title="(defun replace-clause (clause new-clause tree)
  (declare (xargs :guard (and (pseudo-term-listp clause) (disc-tree tree))))
  (replace-clause1 clause clause new-clause tree))">replace-clause</a>
  (clause new-clause tree)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp clause) (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> tree))))
  (<a class="sym-link local-def" href="#def-replace-clause1" data-sym="REPLACE-CLAUSE1" title="(defun replace-clause1 (clause undisc-lits new-clause tree)
  (declare
   (xargs :guard
    (and (pseudo-term-listp clause) (pseudo-term-listp undisc-lits)
         (disc-tree tree))))
...">replace-clause1</a> clause clause new-clause tree))</pre>
  </div>

<div class="form-block function" id="def-extra-info-lits" data-defines="EXTRA-INFO-LITS" data-references="T,CONS,CDR,CAR,EXTRA-INFO-LIT-P,ENDP,COND,ACC,CL,DEFUN" data-used-by="MERGE-EXTRA-INFO-LITS" data-part-name="EXTRA-INFO-LITS" data-part-args="ACC,CL" data-part-body="T,CONS,CDR,EXTRA-INFO-LITS,CAR,EXTRA-INFO-LIT-P,ACC,CL,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTRA-INFO-LITS">extra-info-lits</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extra-info-lits" data-sym="EXTRA-INFO-LITS" title="(defun extra-info-lits (cl acc)
  (cond ((endp cl) acc)
        ((extra-info-lit-p (car cl))
         (extra-info-lits (cdr cl) (cons (car cl) acc)))
        (t (extra-info-lits (cdr cl) acc))))">extra-info-lits</a>
  (cl acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> cl) acc)
    ((<a class="sym-link local-def" href="#def-extra-info-lit-p" data-sym="EXTRA-INFO-LIT-P" title="(defun extra-info-lit-p (lit)
  (and (ffn-symb-p lit &#39;not)
       (let ((atm (fargn lit 1)))
         (and (nvariablep atm) (eq (ffn-symb atm) *extra-info-fn*)))))">extra-info-lit-p</a> (car cl)) (<a class="sym-link local-def" href="#def-extra-info-lits" data-sym="EXTRA-INFO-LITS" title="(defun extra-info-lits (cl acc)
  (cond ((endp cl) acc)
        ((extra-info-lit-p (car cl))
         (extra-info-lits (cdr cl) (cons (car cl) acc)))
        (t (extra-info-lits (cdr cl) acc))))">extra-info-lits</a> (cdr cl) (cons (car cl) acc)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-extra-info-lits" data-sym="EXTRA-INFO-LITS" title="(defun extra-info-lits (cl acc)
  (cond ((endp cl) acc)
        ((extra-info-lit-p (car cl))
         (extra-info-lits (cdr cl) (cons (car cl) acc)))
        (t (extra-info-lits (cdr cl) acc))))">extra-info-lits</a> (cdr cl) acc))))</pre>
  </div>

<div class="form-block function" id="def-merge-extra-info-lits" data-defines="MERGE-EXTRA-INFO-LITS" data-references="T,REV-UNION-EQUAL,REPLACE-CLAUSE,COND,EXTRA-INFO-LITS,LITS,LET,TREE,CL0,CL,DEFUN" data-used-by="SUBSUMPTION-REPLACEMENT-LOOP" data-part-name="MERGE-EXTRA-INFO-LITS" data-part-args="TREE,CL0,CL" data-part-body="T,TREE,REV-UNION-EQUAL,CL0,REPLACE-CLAUSE,COND,CL,EXTRA-INFO-LITS,LITS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-EXTRA-INFO-LITS">merge-extra-info-lits</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-extra-info-lits" data-sym="MERGE-EXTRA-INFO-LITS" title="(defun merge-extra-info-lits (cl cl0 tree)
  (let ((lits (extra-info-lits cl nil)))
    (cond (lits (replace-clause cl0 (rev-union-equal lits cl0) tree))
          (t tree))))">merge-extra-info-lits</a>
  (cl cl0 tree)
  (let ((lits (<a class="sym-link local-def" href="#def-extra-info-lits" data-sym="EXTRA-INFO-LITS" title="(defun extra-info-lits (cl acc)
  (cond ((endp cl) acc)
        ((extra-info-lit-p (car cl))
         (extra-info-lits (cdr cl) (cons (car cl) acc)))
        (t (extra-info-lits (cdr cl) acc))))">extra-info-lits</a> cl nil)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (lits (<a class="sym-link local-def" href="#def-replace-clause" data-sym="REPLACE-CLAUSE" title="(defun replace-clause (clause new-clause tree)
  (declare (xargs :guard (and (pseudo-term-listp clause) (disc-tree tree))))
  (replace-clause1 clause clause new-clause tree))">replace-clause</a> cl0 (rev-union-equal lits cl0) tree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> tree))))</pre>
  </div>

<div class="form-block function" id="def-subsumption-replacement-loop" data-defines="SUBSUMPTION-REPLACEMENT-LOOP" data-references="REMOVE-ONE-COMPLEMENT,MERGE-EXTRA-INFO-LITS,SUBSUMED,QUOTE,EQ,STORE-CLAUSE,CDR,FIND-CLAUSES,CAR,FIND-SUBSUMER-REPLACEMENT,CL0,X,MV-LET,SWEEP-CLAUSES,MERGE-SORT-LENGTH,T,TIME-LIMIT5-REACHED-P,NULL,COND,DISC-TREE,PSEUDO-TERM-LIST-LISTP,AND,XARGS,DECLARE,AGAIN-FLG,DONE-TREE,TODO,DEFUN" data-used-by="CLAUSIFY" data-part-name="SUBSUMPTION-REPLACEMENT-LOOP" data-part-args="AGAIN-FLG,DONE-TREE,TODO" data-part-declare="DONE-TREE,DISC-TREE,TODO,PSEUDO-TERM-LIST-LISTP,AND,XARGS,DECLARE" data-part-body="REMOVE-ONE-COMPLEMENT,MERGE-EXTRA-INFO-LITS,SUBSUMED,QUOTE,EQ,STORE-CLAUSE,CDR,FIND-CLAUSES,CAR,FIND-SUBSUMER-REPLACEMENT,CL0,X,MV-LET,DONE-TREE,SWEEP-CLAUSES,MERGE-SORT-LENGTH,SUBSUMPTION-REPLACEMENT-LOOP,T,TIME-LIMIT5-REACHED-P,AGAIN-FLG,TODO,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SUBSUMPTION-REPLACEMENT-LOOP">subsumption-replacement-loop</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a>
  (todo done-tree again-flg)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-term-list-listp" data-sym="PSEUDO-TERM-LIST-LISTP">pseudo-term-list-listp</a> todo) (<a class="sym-link local-def" href="#def-disc-tree" data-sym="DISC-TREE" title="(defun disc-tree (x)
  (and (or (consp x) (equal x nil))
       (cond
        ((equal (car x) &#39;node)
         (and (true-listp x) (equal (length x) 4) (pseudo-termp (cadr x))
...">disc-tree</a> done-tree))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> todo) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (again-flg (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-time-limit5-reached-p" data-sym="TIME-LIMIT5-REACHED-P">time-limit5-reached-p</a> <span class="string">"Out of time in subsumption (subsumption-replacement-loop)."</span>) nil)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a> (<a class="sym-link local-def" href="#def-merge-sort-length" data-sym="MERGE-SORT-LENGTH" title="(defun merge-sort-length (l)
  (declare (xargs :guard (true-list-listp l)))
  (cond ((null (cdr l)) l)
        (t
         (merge-length (merge-sort-length (evens l))">merge-sort-length</a> (<a class="sym-link local-def" href="#def-sweep-clauses" data-sym="SWEEP-CLAUSES" title="(defun sweep-clauses (tree)
  (declare (xargs :guard (weak-disc-tree tree)))
  (sweep-clauses1 tree nil))">sweep-clauses</a> done-tree))
                nil
                nil))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sweep-clauses" data-sym="SWEEP-CLAUSES" title="(defun sweep-clauses (tree)
  (declare (xargs :guard (weak-disc-tree tree)))
  (sweep-clauses1 tree nil))">sweep-clauses</a> done-tree))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (x cl0)
        (<a class="sym-link local-def" href="#def-find-subsumer-replacement" data-sym="FIND-SUBSUMER-REPLACEMENT" title="(defun find-subsumer-replacement (cl l)
  (declare
   (xargs :guard (and (pseudo-term-listp cl) (pseudo-term-list-listp l))))
  (find-subsumer-replacement-rec cl l (length cl)))">find-subsumer-replacement</a> (car todo)
          (<a class="sym-link local-def" href="#def-find-clauses" data-sym="FIND-CLAUSES" title="(defun find-clauses (clause tree) (find-clauses1 clause tree nil))">find-clauses</a> (car todo) done-tree))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x) (<a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a> (cdr todo)
              (<a class="sym-link local-def" href="#def-store-clause" data-sym="STORE-CLAUSE" title="(defun store-clause (cl tree) (store-clause1 cl cl tree))">store-clause</a> (car todo) done-tree)
              again-flg))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x 'subsumed) (<a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a> (cdr todo)
              (<a class="sym-link local-def" href="#def-merge-extra-info-lits" data-sym="MERGE-EXTRA-INFO-LITS" title="(defun merge-extra-info-lits (cl cl0 tree)
  (let ((lits (extra-info-lits cl nil)))
    (cond (lits (replace-clause cl0 (rev-union-equal lits cl0) tree))
          (t tree))))">merge-extra-info-lits</a> (car todo) cl0 done-tree)
              again-flg))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a> (cdr todo)
              (<a class="sym-link local-def" href="#def-store-clause" data-sym="STORE-CLAUSE" title="(defun store-clause (cl tree) (store-clause1 cl cl tree))">store-clause</a> (<a class="sym-link local-def" href="#def-remove-one-complement" data-sym="REMOVE-ONE-COMPLEMENT" title="(defun remove-one-complement (lit cl)
  (declare (xargs :guard (and (pseudo-termp lit) (pseudo-term-listp cl))))
  (cond ((null cl) nil) ((complementaryp lit (car cl)) (cdr cl))
        (t (cons (car cl) (remove-one-complement lit (cdr cl))))))">remove-one-complement</a> (car x) (car todo))
                done-tree)
              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-clausify" data-defines="CLAUSIFY" data-references="T,MERGE-SORT-LENGTH,SUBSUMPTION-REPLACEMENT-LOOP,LENGTH,<=,NULL,OR,COND,STRIP-BRANCHES,PSTK,CLAUSES,LET,PSEUDO-TERMP,XARGS,DECLARE,SR-LIMIT,LAMBDA-EXP,ASSUMPTIONS,TERM,DEFUN" data-part-name="CLAUSIFY" data-part-args="SR-LIMIT,LAMBDA-EXP,ASSUMPTIONS,TERM" data-part-declare="TERM,PSEUDO-TERMP,XARGS,DECLARE" data-part-body="T,MERGE-SORT-LENGTH,SUBSUMPTION-REPLACEMENT-LOOP,LENGTH,<=,SR-LIMIT,NULL,OR,COND,LAMBDA-EXP,ASSUMPTIONS,TERM,STRIP-BRANCHES,PSTK,CLAUSES,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CLAUSIFY">clausify</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-clausify" data-sym="CLAUSIFY" title="(defun clausify (term assumptions lambda-exp sr-limit)
  (declare (xargs :guard (pseudo-termp term)))
  (let ((clauses (pstk (strip-branches term assumptions lambda-exp))))
    (cond
     ((or (null sr-limit) (&lt;= (length clauses) sr-limit))
...">clausify</a>
  (term assumptions lambda-exp <a class="sym-link system" href="axioms.html#def-sr-limit" data-sym="SR-LIMIT">sr-limit</a>)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
  (let ((clauses (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-strip-branches" data-sym="STRIP-BRANCHES" title="(defun strip-branches (term assumptions lambda-exp)
  (declare (xargs :guard (pseudo-termp term)))
  (cond
   ((and (ffn-symb-p term &#39;if) (equal (fargn term 3) *nil*))
    (union-equal (strip-branches (fargn term 1) assumptions lambda-exp)
...">strip-branches</a> term assumptions lambda-exp))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="axioms.html#def-sr-limit" data-sym="SR-LIMIT">sr-limit</a>) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> clauses) <a class="sym-link system" href="axioms.html#def-sr-limit" data-sym="SR-LIMIT">sr-limit</a>)) (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-subsumption-replacement-loop" data-sym="SUBSUMPTION-REPLACEMENT-LOOP" title="(defun subsumption-replacement-loop (todo done-tree again-flg)
  (declare
   (xargs :guard (and (pseudo-term-list-listp todo) (disc-tree done-tree))))
  (cond
   ((null todo)
...">subsumption-replacement-loop</a> (<a class="sym-link local-def" href="#def-merge-sort-length" data-sym="MERGE-SORT-LENGTH" title="(defun merge-sort-length (l)
  (declare (xargs :guard (true-list-listp l)))
  (cond ((null (cdr l)) l)
        (t
         (merge-length (merge-sort-length (evens l))">merge-sort-length</a> clauses)
            nil
            nil)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> clauses))))</pre>
  </div>

<div class="form-block function" id="def-find-rewriting-equivalence" data-defines="FIND-REWRITING-EQUIVALENCE" data-references="CDR,PUSH-LEMMA,CDDR,CONS-TAG-TREES,EQUAL,GENEQV-REFINEMENTP,FLAMBDAP,RUNE,EQUIV-TERM,LET*,*TS-T*,TS=,*TS-NIL*,CADR,TS-DISJOINTP,IF,REWRITE-EQUIV,FARGN,HIDE,QUOTE,FFN-SYMB,EQ,AND,RW-EQUIVP,VARIABLEP,NOT,CAR,ENTRY,LET,T,MV,NULL,COND,TTREE,WRLD,GENEQV,TYPE-ALIST,LHS,DEFUN" data-used-by="REWRITE-SOLIDIFY-REC" data-part-name="FIND-REWRITING-EQUIVALENCE" data-part-args="TTREE,WRLD,GENEQV,TYPE-ALIST,LHS" data-part-body="CDR,FIND-REWRITING-EQUIVALENCE,PUSH-LEMMA,CDDR,CONS-TAG-TREES,LHS,EQUAL,WRLD,GENEQV,GENEQV-REFINEMENTP,FLAMBDAP,RUNE,EQUIV-TERM,LET*,*TS-T*,TS=,*TS-NIL*,CADR,TS-DISJOINTP,IF,REWRITE-EQUIV,FARGN,HIDE,QUOTE,FFN-SYMB,EQ,AND,RW-EQUIVP,VARIABLEP,NOT,CAR,ENTRY,LET,T,TTREE,MV,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-REWRITING-EQUIVALENCE">find-rewriting-equivalence</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-rewriting-equivalence" data-sym="FIND-REWRITING-EQUIVALENCE" title="(defun find-rewriting-equivalence (lhs type-alist geneqv wrld ttree)
  (cond ((null type-alist) (mv nil nil ttree))
        (t
         (let ((entry (car type-alist)))
           (cond
...">find-rewriting-equivalence</a>
  (lhs type-alist geneqv wrld ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((entry (car type-alist)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car entry))) (let ((rw-equivp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car entry)) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>)
                      (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car entry) <span class="number">1</span>)))
                      (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car entry) <span class="number">1</span>)) '<a class="sym-link system" href="axioms.html#def-rewrite-equiv" data-sym="REWRITE-EQUIV">rewrite-equiv</a>)) (car entry)))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((if rw-equivp
                   (<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> entry) *ts-nil*)
                   (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> entry) *ts-t*)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((equiv-term (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rw-equivp (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> (car entry) <span class="number">1</span>) <span class="number">1</span>))
                         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (car entry)))) (rune (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> equiv-term)))
                          (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> equiv-term) geneqv wrld))))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rune (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> equiv-term <span class="number">1</span>) lhs)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> rw-equivp
                          equiv-term
                          (cons-tag-trees (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> entry) (push-lemma rune ttree))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-rewriting-equivalence" data-sym="FIND-REWRITING-EQUIVALENCE" title="(defun find-rewriting-equivalence (lhs type-alist geneqv wrld ttree)
  (cond ((null type-alist) (mv nil nil ttree))
        (t
         (let ((entry (car type-alist)))
           (cond
...">find-rewriting-equivalence</a> lhs
                          (cdr type-alist)
                          geneqv
                          wrld
                          ttree)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-rewriting-equivalence" data-sym="FIND-REWRITING-EQUIVALENCE" title="(defun find-rewriting-equivalence (lhs type-alist geneqv wrld ttree)
  (cond ((null type-alist) (mv nil nil ttree))
        (t
         (let ((entry (car type-alist)))
           (cond
...">find-rewriting-equivalence</a> lhs
                    (cdr type-alist)
                    geneqv
                    wrld
                    ttree)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-rewriting-equivalence" data-sym="FIND-REWRITING-EQUIVALENCE" title="(defun find-rewriting-equivalence (lhs type-alist geneqv wrld ttree)
  (cond ((null type-alist) (mv nil nil ttree))
        (t
         (let ((entry (car type-alist)))
           (cond
...">find-rewriting-equivalence</a> lhs
              (cdr type-alist)
              geneqv
              wrld
              ttree)))))))</pre>
  </div>

<div class="form-block function" id="def-obj-table" data-defines="OBJ-TABLE" data-references="PUSH-LEMMA,TS-SUBSETP,IFF,QUOTE,GENEQV-REFINEMENTP,RUNE,LET,T,*0*,*TS-ZERO*,*NIL*,*TS-NIL*,CONS-TAG-TREES,*T*,MV,*TS-T*,TS=,COND,IGNORE,DECLARE,TTREE,WRLD,GENEQV,OBJ,TS-TTREE,TS,TERM,DEFUN" data-used-by="REWRITE-SOLIDIFY-REC" data-part-name="OBJ-TABLE" data-part-args="TTREE,WRLD,GENEQV,OBJ,TS-TTREE,TS,TERM" data-part-declare="OBJ,IGNORE,DECLARE" data-part-body="PUSH-LEMMA,TERM,TS-SUBSETP,WRLD,GENEQV,IFF,QUOTE,GENEQV-REFINEMENTP,RUNE,LET,T,*0*,*TS-ZERO*,*NIL*,*TS-NIL*,TTREE,TS-TTREE,CONS-TAG-TREES,*T*,MV,*TS-T*,TS,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="OBJ-TABLE">obj-table</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-obj-table" data-sym="OBJ-TABLE" title="(defun obj-table (term ts ts-ttree obj geneqv wrld ttree)
  (declare (ignore obj))
  (cond ((ts= ts *ts-t*) (mv *t* (cons-tag-trees ts-ttree ttree)))
        ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
        ((ts= ts *ts-zero*) (mv *0* (cons-tag-trees ts-ttree ttree)))
...">obj-table</a>
  (term ts ts-ttree obj geneqv wrld ttree)
  (declare (ignore obj))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-t*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (cons-tag-trees ts-ttree ttree)))
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (cons-tag-trees ts-ttree ttree)))
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-zero*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2A0_2A" data-sym="*0*">*0*</a> (cons-tag-trees ts-ttree ttree)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((rune (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rune (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp *ts-nil* ts) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (push-lemma rune (cons-tag-trees ts-ttree ttree))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree)))))))</pre>
  </div>

<div class="form-block function" id="def-rewrite-solidify-rec" data-defines="REWRITE-SOLIDIFY-REC" data-references="OBJ-TABLE,NULL,ASSOC-TYPE-ALIST,TYPE-SET,?,EQ,TS-TTREE,TS,1-F,REWRITE-SOLIDIFY,HARD,ER,ZPF,NOT,NEW-BOUND,FIND-REWRITING-EQUIVALENCE,ETERM,RW-EQUIVP,MV-LET,FN-RUNE-NUME,&,EQUIVALENCE-RELATIONP,PROG2$,X,EQUIV,REWRITE-EQUIV,CASE-MATCH,FARGN,E,HIDE,AND,IF,FFN-SYMB-P,PUSH-LEMMA,*T*,IFF,QUOTE,GENEQV-REFINEMENTP,RUNE,LET,T,MV,*NIL*,EQUAL,QUOTEP,COND,UNSIGNED-BYTE,TYPE,DECLARE,PT,POT-LST,TTREE,WRLD,ENS,GENEQV,OBJ,TYPE-ALIST,TERM,BOUND,DEFUN" data-used-by="REWRITE-SOLIDIFY" data-part-name="REWRITE-SOLIDIFY-REC" data-part-args="PT,POT-LST,TTREE,WRLD,ENS,GENEQV,OBJ,TYPE-ALIST,TERM,BOUND" data-part-declare="BOUND,UNSIGNED-BYTE,TYPE,DECLARE" data-part-body="OBJ-TABLE,NULL,ASSOC-TYPE-ALIST,TYPE-SET,?,EQ,TS-TTREE,TS,PT,POT-LST,ENS,OBJ,REWRITE-SOLIDIFY-REC,UNSIGNED-BYTE,TYPE,DECLARE,1-F,REWRITE-SOLIDIFY,HARD,ER,ZPF,BOUND,NOT,NEW-BOUND,TYPE-ALIST,FIND-REWRITING-EQUIVALENCE,ETERM,RW-EQUIVP,MV-LET,FN-RUNE-NUME,&,EQUIVALENCE-RELATIONP,PROG2$,X,EQUIV,REWRITE-EQUIV,CASE-MATCH,FARGN,E,HIDE,AND,IF,FFN-SYMB-P,PUSH-LEMMA,*T*,WRLD,GENEQV,IFF,QUOTE,GENEQV-REFINEMENTP,RUNE,LET,T,TTREE,MV,*NIL*,EQUAL,TERM,QUOTEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-SOLIDIFY-REC">rewrite-solidify-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-solidify-rec" data-sym="REWRITE-SOLIDIFY-REC" title="(defun rewrite-solidify-rec
       (bound term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (declare (type (unsigned-byte 60) bound))
  (cond
   ((quotep term)
...">rewrite-solidify-rec</a>
  (bound term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (declare (type (unsigned-byte <span class="number">60</span>) bound))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> term) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> ttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((rune (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rune (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (push-lemma rune ttree)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree)))))))
    ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term 'if) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>)
       (let ((e (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))
         (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> e
           (('<a class="sym-link system" href="axioms.html#def-rewrite-equiv" data-sym="REWRITE-EQUIV">rewrite-equiv</a> (equiv x x)) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> x (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> equiv wrld)))
           (&amp; nil)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
        (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld)
          (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-rewrite-equiv" data-sym="REWRITE-EQUIV">rewrite-equiv</a> nil nil wrld)
            ttree))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rw-equivp eterm ttree)
        (<a class="sym-link local-def" href="#def-find-rewriting-equivalence" data-sym="FIND-REWRITING-EQUIVALENCE" title="(defun find-rewriting-equivalence (lhs type-alist geneqv wrld ttree)
  (cond ((null type-alist) (mv nil nil ttree))
        (t
         (let ((entry (car type-alist)))
           (cond
...">find-rewriting-equivalence</a> term
          type-alist
          geneqv
          wrld
          ttree)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (eterm (let ((new-bound (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> rw-equivp) bound)
                   ((<a class="sym-link system" href="axioms.html#def-zpf" data-sym="ZPF">zpf</a> bound) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                         '<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a>
                         <span class="string">"You appear to have hit the unusual case ~
                                    of a loop in the replacement of terms by ~
                                    equivalent terms using rewrite-equiv.  ~
                                    The term ~x0 is involved in the loop."</span>
                         rw-equivp)
                       <span class="number">0</span>))
                   (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> bound)))))
              (declare (type (unsigned-byte <span class="number">60</span>) new-bound))
              (<a class="sym-link local-def" href="#def-rewrite-solidify-rec" data-sym="REWRITE-SOLIDIFY-REC" title="(defun rewrite-solidify-rec
       (bound term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (declare (type (unsigned-byte 60) bound))
  (cond
   ((quotep term)
...">rewrite-solidify-rec</a> new-bound
                (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> eterm <span class="number">2</span>)
                type-alist
                obj
                geneqv
                ens
                wrld
                ttree
                pot-lst
                pt)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ts-ttree)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj '?)) (type-set term nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> type-alist ens wrld nil pot-lst pt))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (assoc-type-alist term type-alist wrld)))
              (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ts)
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree)
                (<a class="sym-link local-def" href="#def-obj-table" data-sym="OBJ-TABLE" title="(defun obj-table (term ts ts-ttree obj geneqv wrld ttree)
  (declare (ignore obj))
  (cond ((ts= ts *ts-t*) (mv *t* (cons-tag-trees ts-ttree ttree)))
        ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
        ((ts= ts *ts-zero*) (mv *0* (cons-tag-trees ts-ttree ttree)))
...">obj-table</a> term ts ts-ttree obj geneqv wrld ttree)))))))))</pre>
  </div>

<div class="form-block constant" id="def-_2Arewrite-equiv-solidify-iteration-bound_2A" data-defines="*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*" data-references="DEFCONST" data-used-by="REWRITE-SOLIDIFY" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*">*rewrite-equiv-solidify-iteration-bound*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Arewrite-equiv-solidify-iteration-bound_2A" data-sym="*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*" title="(defconst *rewrite-equiv-solidify-iteration-bound* 100)">*rewrite-equiv-solidify-iteration-bound*</a> <span class="number">100</span>)</pre>
  </div>

<div class="form-block function" id="def-rewrite-solidify" data-defines="REWRITE-SOLIDIFY" data-references="*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*,REWRITE-SOLIDIFY-REC,PT,POT-LST,TTREE,WRLD,ENS,GENEQV,OBJ,TYPE-ALIST,TERM,DEFUN" data-used-by="REWRITE,REWRITE-SOLIDIFY-REC" data-part-name="REWRITE-SOLIDIFY" data-part-args="PT,POT-LST,TTREE,WRLD,ENS,GENEQV,OBJ,TYPE-ALIST,TERM" data-part-body="PT,POT-LST,TTREE,WRLD,ENS,GENEQV,OBJ,TYPE-ALIST,TERM,*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*,REWRITE-SOLIDIFY-REC" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-SOLIDIFY">rewrite-solidify</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a>
  (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (<a class="sym-link local-def" href="#def-rewrite-solidify-rec" data-sym="REWRITE-SOLIDIFY-REC" title="(defun rewrite-solidify-rec
       (bound term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (declare (type (unsigned-byte 60) bound))
  (cond
   ((quotep term)
...">rewrite-solidify-rec</a> <a class="sym-link local-def" href="#def-_2Arewrite-equiv-solidify-iteration-bound_2A" data-sym="*REWRITE-EQUIV-SOLIDIFY-ITERATION-BOUND*" title="(defconst *rewrite-equiv-solidify-iteration-bound* 100)">*rewrite-equiv-solidify-iteration-bound*</a>
    term
    type-alist
    obj
    geneqv
    ens
    wrld
    ttree
    pot-lst
    pt))</pre>
  </div>

<div class="form-block function" id="def-rewrite-if11" data-defines="REWRITE-IF11" data-references="T,*T*,TS-DISJOINTP,*GENEQV-IFF*,EQUAL,AND,CONS-TAG-TREES,*NIL*,MV,*TS-NIL*,TS=,COND,LOOK-IN-TYPE-ALIST,TS-TTREE,TS,MV-LET,TTREE,WRLD,GENEQV,TYPE-ALIST,TERM,DEFUN" data-used-by="REWRITE,REWRITE-IF1" data-part-name="REWRITE-IF11" data-part-args="TTREE,WRLD,GENEQV,TYPE-ALIST,TERM" data-part-body="T,*T*,TS-DISJOINTP,*GENEQV-IFF*,GENEQV,EQUAL,AND,TTREE,CONS-TAG-TREES,*NIL*,MV,*TS-NIL*,TS=,COND,WRLD,TYPE-ALIST,TERM,LOOK-IN-TYPE-ALIST,TS-TTREE,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-IF11">rewrite-if11</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-if11" data-sym="REWRITE-IF11" title="(defun rewrite-if11 (term type-alist geneqv wrld ttree)
  (mv-let (ts ts-ttree) (look-in-type-alist term type-alist wrld)
          (cond ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
                ((and (equal geneqv *geneqv-iff*) (ts-disjointp ts *ts-nil*))
                 (mv *t* (cons-tag-trees ts-ttree ttree)))">rewrite-if11</a>
  (term type-alist geneqv wrld ttree)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ts-ttree)
    (look-in-type-alist term type-alist wrld)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (cons-tag-trees ts-ttree ttree)))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal geneqv <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>) (<a class="sym-link system" href="basis-b.html#def-ts-disjointp" data-sym="TS-DISJOINTP">ts-disjointp</a> ts *ts-nil*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (cons-tag-trees ts-ttree ttree)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree)))))</pre>
  </div>

<div class="form-block other" id="form-130" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> rewrite-if-avoid-swap nil =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block other" id="form-131" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (rewrite-if-avoid-swap <a class="sym-link system" href="axioms.html#def-constant-nil-function-arity-0" data-sym="CONSTANT-NIL-FUNCTION-ARITY-0">constant-nil-function-arity-0</a>))</pre>
  </div>

<div class="form-block function" id="def-rewrite-if1" data-defines="REWRITE-IF1" data-references="NOT,FCONS-TERM*,REWRITE-IF11,*TS-BOOLEAN*,TS-SUBSETP,TYPE-SET,TS-TTREE,TS,MV-LET,*T*,*NIL*,MV,EQUAL,T,DUMB-NEGATE-LIT,IF,QUOTE,MCONS-TERM*,REWRITE-IF-AVOID-SWAP,AND,COND,IF-CALL,FLET,TTREE,WRLD,OK-TO-FORCE,ENS,GENEQV,TYPE-ALIST,SWAPPED-P,RIGHT,LEFT,TEST,DEFUN" data-used-by="REWRITE" data-part-name="REWRITE-IF1" data-part-args="TTREE,WRLD,OK-TO-FORCE,ENS,GENEQV,TYPE-ALIST,SWAPPED-P,RIGHT,LEFT,TEST" data-part-body="NOT,FCONS-TERM*,GENEQV,REWRITE-IF11,*TS-BOOLEAN*,TS-SUBSETP,WRLD,ENS,TYPE-ALIST,OK-TO-FORCE,TYPE-SET,TS-TTREE,TS,MV-LET,*T*,*NIL*,TTREE,MV,EQUAL,T,DUMB-NEGATE-LIT,IF,QUOTE,MCONS-TERM*,REWRITE-IF-AVOID-SWAP,AND,COND,SWAPPED-P,RIGHT,LEFT,TEST,IF-CALL,FLET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-IF1">rewrite-if1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-if1" data-sym="REWRITE-IF1" title="(defun rewrite-if1
       (test left right swapped-p type-alist geneqv ens ok-to-force wrld ttree)
  (flet ((if-call (test left right swapped-p)
           (cond
            ((and swapped-p (rewrite-if-avoid-swap))
...">rewrite-if1</a>
  (test left
    right
    swapped-p
    type-alist
    geneqv
    ens
    <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
    wrld
    ttree)
  (flet ((if-call (test left right swapped-p)
       (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> swapped-p (rewrite-if-avoid-swap)) (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> test) right left))
         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if test left right)))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal left right) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> left ttree))
      ((equal right <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal test left) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> test ttree))
          ((equal left <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ts-ttree)
              (type-set test
                <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                nil
                type-alist
                ens
                wrld
                ttree
                nil
                nil)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((ts-subsetp ts *ts-boolean*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> test ts-ttree))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-if11" data-sym="REWRITE-IF11" title="(defun rewrite-if11 (term type-alist geneqv wrld ttree)
  (mv-let (ts ts-ttree) (look-in-type-alist term type-alist wrld)
          (cond ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
                ((and (equal geneqv *geneqv-iff*) (ts-disjointp ts *ts-nil*))
                 (mv *t* (cons-tag-trees ts-ttree ttree)))">rewrite-if11</a> (if-call test left right swapped-p)
                    type-alist
                    geneqv
                    wrld
                    ttree)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-if11" data-sym="REWRITE-IF11" title="(defun rewrite-if11 (term type-alist geneqv wrld ttree)
  (mv-let (ts ts-ttree) (look-in-type-alist term type-alist wrld)
          (cond ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
                ((and (equal geneqv *geneqv-iff*) (ts-disjointp ts *ts-nil*))
                 (mv *t* (cons-tag-trees ts-ttree ttree)))">rewrite-if11</a> (if-call test left right swapped-p)
              type-alist
              geneqv
              wrld
              ttree))))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> swapped-p
         (equal left <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
         (equal right <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
         (rewrite-if-avoid-swap)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> test) ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-if11" data-sym="REWRITE-IF11" title="(defun rewrite-if11 (term type-alist geneqv wrld ttree)
  (mv-let (ts ts-ttree) (look-in-type-alist term type-alist wrld)
          (cond ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
                ((and (equal geneqv *geneqv-iff*) (ts-disjointp ts *ts-nil*))
                 (mv *t* (cons-tag-trees ts-ttree ttree)))">rewrite-if11</a> (if-call test left right swapped-p)
          type-alist
          geneqv
          wrld
          ttree)))))</pre>
  </div>

<div class="form-block function" id="def-member-equal-mod-alist" data-defines="MEMBER-EQUAL-MOD-ALIST" data-references="CDR,T,CAR,EQUAL-MOD-ALIST,ENDP,COND,TERM2-LST,ALIST1,TERM1,DEFUN" data-used-by="NOT-TO-BE-REWRITTENP" data-part-name="MEMBER-EQUAL-MOD-ALIST" data-part-args="TERM2-LST,ALIST1,TERM1" data-part-body="CDR,MEMBER-EQUAL-MOD-ALIST,T,CAR,ALIST1,TERM1,EQUAL-MOD-ALIST,TERM2-LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMBER-EQUAL-MOD-ALIST">member-equal-mod-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-member-equal-mod-alist" data-sym="MEMBER-EQUAL-MOD-ALIST" title="(defun member-equal-mod-alist (term1 alist1 term2-lst)
  (cond ((endp term2-lst) nil)
        ((equal-mod-alist term1 alist1 (car term2-lst)) t)
        (t (member-equal-mod-alist term1 alist1 (cdr term2-lst)))))">member-equal-mod-alist</a>
  (term1 alist1 term2-lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> term2-lst) nil)
    ((<a class="sym-link local-def" href="#def-equal-mod-alist" data-sym="EQUAL-MOD-ALIST" title="(mutual-recursion
 (defun equal-mod-alist (term1 alist1 term2)
   (cond
    ((variablep term1)
     (let ((temp (assoc-eq term1 alist1)))
...">equal-mod-alist</a> term1 alist1 (car term2-lst)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-member-equal-mod-alist" data-sym="MEMBER-EQUAL-MOD-ALIST" title="(defun member-equal-mod-alist (term1 alist1 term2-lst)
  (cond ((endp term2-lst) nil)
        ((equal-mod-alist term1 alist1 (car term2-lst)) t)
        (t (member-equal-mod-alist term1 alist1 (cdr term2-lst)))))">member-equal-mod-alist</a> term1 alist1 (cdr term2-lst)))))</pre>
  </div>

<div class="form-block function" id="def-not-to-be-rewrittenp1" data-defines="NOT-TO-BE-REWRITTENP1" data-references="CDR,T,CAR,FFN-SYMB,EQUAL,NULL,COND,LST,FN,DEFUN" data-used-by="NOT-TO-BE-REWRITTENP" data-part-name="NOT-TO-BE-REWRITTENP1" data-part-args="LST,FN" data-part-body="CDR,NOT-TO-BE-REWRITTENP1,T,CAR,FFN-SYMB,FN,EQUAL,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOT-TO-BE-REWRITTENP1">not-to-be-rewrittenp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-not-to-be-rewrittenp1" data-sym="NOT-TO-BE-REWRITTENP1" title="(defun not-to-be-rewrittenp1 (fn lst)
  (cond ((null lst) nil) ((equal fn (ffn-symb (car lst))) t)
        (t (not-to-be-rewrittenp1 fn (cdr lst)))))">not-to-be-rewrittenp1</a>
  (fn lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    ((equal fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car lst))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-not-to-be-rewrittenp1" data-sym="NOT-TO-BE-REWRITTENP1" title="(defun not-to-be-rewrittenp1 (fn lst)
  (cond ((null lst) nil) ((equal fn (ffn-symb (car lst))) t)
        (t (not-to-be-rewrittenp1 fn (cdr lst)))))">not-to-be-rewrittenp1</a> fn (cdr lst)))))</pre>
  </div>

<div class="form-block function" id="def-not-to-be-rewrittenp" data-defines="NOT-TO-BE-REWRITTENP" data-references="T,MEMBER-EQUAL-MOD-ALIST,FFN-SYMB,NOT-TO-BE-REWRITTENP1,COND,TERMS-TO-BE-IGNORED-BY-REWRITE,ALIST,TERM,DEFUN" data-used-by="REWRITE" data-part-name="NOT-TO-BE-REWRITTENP" data-part-args="TERMS-TO-BE-IGNORED-BY-REWRITE,ALIST,TERM" data-part-body="T,ALIST,MEMBER-EQUAL-MOD-ALIST,TERMS-TO-BE-IGNORED-BY-REWRITE,TERM,FFN-SYMB,NOT-TO-BE-REWRITTENP1,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOT-TO-BE-REWRITTENP">not-to-be-rewrittenp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-not-to-be-rewrittenp" data-sym="NOT-TO-BE-REWRITTENP" title="(defun not-to-be-rewrittenp (term alist terms-to-be-ignored-by-rewrite)
  (cond
   ((not-to-be-rewrittenp1 (ffn-symb term) terms-to-be-ignored-by-rewrite)
    (member-equal-mod-alist term alist terms-to-be-ignored-by-rewrite))
   (t nil)))">not-to-be-rewrittenp</a>
  (term alist terms-to-be-ignored-by-rewrite)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-not-to-be-rewrittenp1" data-sym="NOT-TO-BE-REWRITTENP1" title="(defun not-to-be-rewrittenp1 (fn lst)
  (cond ((null lst) nil) ((equal fn (ffn-symb (car lst))) t)
        (t (not-to-be-rewrittenp1 fn (cdr lst)))))">not-to-be-rewrittenp1</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
       terms-to-be-ignored-by-rewrite) (<a class="sym-link local-def" href="#def-member-equal-mod-alist" data-sym="MEMBER-EQUAL-MOD-ALIST" title="(defun member-equal-mod-alist (term1 alist1 term2-lst)
  (cond ((endp term2-lst) nil)
        ((equal-mod-alist term1 alist1 (car term2-lst)) t)
        (t (member-equal-mod-alist term1 alist1 (cdr term2-lst)))))">member-equal-mod-alist</a> term
        alist
        terms-to-be-ignored-by-rewrite))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-rewrite-recognizer" data-defines="REWRITE-RECOGNIZER" data-references="*NIL*,PUSH-LEMMA,*T*,T,MCONS-TERM*,MV,RECOGNIZER-TUPLE,ACCESS,TS-INTERSECTP,COND,TYPE-SET,TTREE+,TS,MV-LET,PT,POT-LST,TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,ARG,RECOG-TUPLE,DEFUN" data-used-by="REWRITE" data-part-name="REWRITE-RECOGNIZER" data-part-args="PT,POT-LST,TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,ARG,RECOG-TUPLE" data-part-body="*NIL*,PUSH-LEMMA,*T*,T,MCONS-TERM*,MV,RECOG-TUPLE,RECOGNIZER-TUPLE,ACCESS,TS-INTERSECTP,COND,PT,POT-LST,TTREE,WRLD,ENS,TYPE-ALIST,FORCE-FLG,ARG,TYPE-SET,TTREE+,TS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-RECOGNIZER">rewrite-recognizer</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-recognizer" data-sym="REWRITE-RECOGNIZER" title="(defun rewrite-recognizer
       (recog-tuple arg type-alist ens force-flg wrld ttree pot-lst pt)
  (mv-let (ts ttree+)
          (type-set arg force-flg nil type-alist ens wrld ttree pot-lst pt)
          (cond
...">rewrite-recognizer</a>
  (recog-tuple arg
    type-alist
    ens
    force-flg
    wrld
    ttree
    pot-lst
    pt)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts ttree+)
    (type-set arg
      force-flg
      nil
      type-alist
      ens
      wrld
      ttree
      pot-lst
      pt)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:true-ts</span>)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts-intersectp" data-sym="TS-INTERSECTP">ts-intersectp</a> ts
             (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:false-ts</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:fn</span>) arg)
              ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
              (push-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:rune</span>)
                ttree+)))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>
          (push-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple recog-tuple <span class="keyword">:rune</span>)
            ttree+))))))</pre>
  </div>

<div class="form-block function" id="def-remove-invisible-fncalls" data-defines="REMOVE-INVISIBLE-FNCALLS" data-references="T,FARGN,FFN-SYMB,MEMBER-EQ,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,OR,COND,INVISIBLE-FNS,TERM,DEFUN" data-used-by="TERM-ORDER+" data-part-name="REMOVE-INVISIBLE-FNCALLS" data-part-args="INVISIBLE-FNS,TERM" data-part-body="T,FARGN,REMOVE-INVISIBLE-FNCALLS,INVISIBLE-FNS,FFN-SYMB,MEMBER-EQ,FLAMBDA-APPLICATIONP,FQUOTEP,TERM,VARIABLEP,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE-INVISIBLE-FNCALLS">remove-invisible-fncalls</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove-invisible-fncalls" data-sym="REMOVE-INVISIBLE-FNCALLS" title="(defun remove-invisible-fncalls (term invisible-fns)
  (cond ((or (variablep term) (fquotep term) (flambda-applicationp term)) term)
        ((member-eq (ffn-symb term) invisible-fns)
         (remove-invisible-fncalls (fargn term 1) invisible-fns))
        (t term)))">remove-invisible-fncalls</a>
  (term <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term)
       (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)
       (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term)) term)
    ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>) (<a class="sym-link local-def" href="#def-remove-invisible-fncalls" data-sym="REMOVE-INVISIBLE-FNCALLS" title="(defun remove-invisible-fncalls (term invisible-fns)
  (cond ((or (variablep term) (fquotep term) (flambda-applicationp term)) term)
        ((member-eq (ffn-symb term) invisible-fns)
         (remove-invisible-fncalls (fargn term 1) invisible-fns))
        (t term)))">remove-invisible-fncalls</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term)))</pre>
  </div>

<div class="form-block function" id="def-term-order_2B" data-defines="TERM-ORDER+" data-references="T,TERM-ORDER,EQUAL,COND,X2-GUTS,REMOVE-INVISIBLE-FNCALLS,X1-GUTS,LET,INVISIBLE-FNS,X2,X1,DEFUN" data-used-by="LOOP-STOPPERP-REC" data-part-name="TERM-ORDER+" data-part-args="INVISIBLE-FNS,X2,X1" data-part-body="T,TERM-ORDER,EQUAL,COND,X2,X2-GUTS,INVISIBLE-FNS,X1,REMOVE-INVISIBLE-FNCALLS,X1-GUTS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERM-ORDER+">term-order+</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-term-order_2B" data-sym="TERM-ORDER+" title="(defun term-order+ (x1 x2 invisible-fns)
  (let ((x1-guts (remove-invisible-fncalls x1 invisible-fns))
        (x2-guts (remove-invisible-fncalls x2 invisible-fns)))
    (cond ((equal x1-guts x2-guts) (term-order x1 x2))
          (t (term-order x1-guts x2-guts)))))">term-order+</a>
  (x1 x2 <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>)
  (let ((x1-guts (<a class="sym-link local-def" href="#def-remove-invisible-fncalls" data-sym="REMOVE-INVISIBLE-FNCALLS" title="(defun remove-invisible-fncalls (term invisible-fns)
  (cond ((or (variablep term) (fquotep term) (flambda-applicationp term)) term)
        ((member-eq (ffn-symb term) invisible-fns)
         (remove-invisible-fncalls (fargn term 1) invisible-fns))
        (t term)))">remove-invisible-fncalls</a> x1 <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>)) (x2-guts (<a class="sym-link local-def" href="#def-remove-invisible-fncalls" data-sym="REMOVE-INVISIBLE-FNCALLS" title="(defun remove-invisible-fncalls (term invisible-fns)
  (cond ((or (variablep term) (fquotep term) (flambda-applicationp term)) term)
        ((member-eq (ffn-symb term) invisible-fns)
         (remove-invisible-fncalls (fargn term 1) invisible-fns))
        (t term)))">remove-invisible-fncalls</a> x2 <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal x1-guts x2-guts) (term-order x1 x2))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (term-order x1-guts x2-guts)))))</pre>
  </div>

<div class="form-block function" id="def-invisible-fns" data-defines="INVISIBLE-FNS" data-references="INTERSECTION-EQ,CAR,ASSOC-EQ,CDR,IF,NULL,COND,T,EQ,TRUE-LISTP,OR,SYMBOL-LISTP,AND,XARGS,DECLARE,ACC,ALIST,FNS,DEFUN" data-used-by="LOOP-STOPPERP-REC,TERM-ORDER+,REMOVE-INVISIBLE-FNCALLS" data-part-name="INVISIBLE-FNS" data-part-args="ACC,ALIST,FNS" data-part-declare="T,EQ,ACC,TRUE-LISTP,OR,FNS,SYMBOL-LISTP,AND,XARGS,DECLARE" data-part-body="INTERSECTION-EQ,CAR,ASSOC-EQ,ALIST,CDR,INVISIBLE-FNS,T,ACC,EQ,IF,FNS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INVISIBLE-FNS">invisible-fns</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a>
  (fns alist acc)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> fns) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> acc) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> acc <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fns) (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> acc <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        nil
        acc))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> acc <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a> (cdr fns)
        alist
        (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car fns) alist))))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> acc) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a> (cdr fns)
        alist
        (<a class="sym-link system" href="axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car fns) alist)) acc)))))</pre>
  </div>

<div class="form-block function" id="def-loop-stopperp-rec" data-defines="LOOP-STOPPERP-REC" data-references="INVISIBLE-FNS-TABLE,CDDR,INVISIBLE-FNS,TERM-ORDER+,EQUAL,CADR,POST,CAR,ASSOC-EQ,CDR,PRE,LET,T,NULL,COND,WRLD,SBST,LOOP-STOPPER,DEFUN" data-used-by="LOOP-STOPPERP" data-part-name="LOOP-STOPPERP-REC" data-part-args="WRLD,SBST,LOOP-STOPPER" data-part-body="INVISIBLE-FNS-TABLE,CDDR,INVISIBLE-FNS,TERM-ORDER+,WRLD,LOOP-STOPPERP-REC,EQUAL,CADR,POST,SBST,CAR,ASSOC-EQ,CDR,PRE,LET,T,LOOP-STOPPER,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOOP-STOPPERP-REC">loop-stopperp-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-loop-stopperp-rec" data-sym="LOOP-STOPPERP-REC" title="(defun loop-stopperp-rec (loop-stopper sbst wrld)
  (cond ((null loop-stopper) nil)
        (t
         (let ((pre (cdr (assoc-eq (car (car loop-stopper)) sbst)))
               (post (cdr (assoc-eq (cadr (car loop-stopper)) sbst))))
...">loop-stopperp-rec</a>
  (<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a> sbst wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((pre (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car (car <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>)) sbst))) (post (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>)) sbst))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal pre post) (<a class="sym-link local-def" href="#def-loop-stopperp-rec" data-sym="LOOP-STOPPERP-REC" title="(defun loop-stopperp-rec (loop-stopper sbst wrld)
  (cond ((null loop-stopper) nil)
        (t
         (let ((pre (cdr (assoc-eq (car (car loop-stopper)) sbst)))
               (post (cdr (assoc-eq (cadr (car loop-stopper)) sbst))))
...">loop-stopperp-rec</a> (cdr <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>) sbst wrld))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-term-order_2B" data-sym="TERM-ORDER+" title="(defun term-order+ (x1 x2 invisible-fns)
  (let ((x1-guts (remove-invisible-fncalls x1 invisible-fns))
        (x2-guts (remove-invisible-fncalls x2 invisible-fns)))
    (cond ((equal x1-guts x2-guts) (term-order x1 x2))
          (t (term-order x1-guts x2-guts)))))">term-order+</a> post
              pre
              (<a class="sym-link local-def" href="#def-invisible-fns" data-sym="INVISIBLE-FNS" title="(defun invisible-fns (fns alist acc)
  (declare
   (xargs :guard (and (symbol-listp fns) (or (true-listp acc) (eq acc t)))))
  (cond
   ((null fns)
...">invisible-fns</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>))
                (<a class="sym-link system" href="axioms.html#def-invisible-fns-table" data-sym="INVISIBLE-FNS-TABLE">invisible-fns-table</a> wrld)
                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))))))</pre>
  </div>

<div class="form-block function" id="def-loop-stopperp" data-defines="LOOP-STOPPERP" data-references="LOOP-STOPPERP-REC,NULL,OR,WRLD,SBST,LOOP-STOPPER,DEFUN" data-used-by="REWRITE" data-part-name="LOOP-STOPPERP" data-part-args="WRLD,SBST,LOOP-STOPPER" data-part-body="WRLD,SBST,LOOP-STOPPERP-REC,LOOP-STOPPER,NULL,OR" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LOOP-STOPPERP">loop-stopperp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-loop-stopperp" data-sym="LOOP-STOPPERP" title="(defun loop-stopperp (loop-stopper sbst wrld)
  (or (null loop-stopper) (loop-stopperp-rec loop-stopper sbst wrld)))">loop-stopperp</a>
  (<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a> sbst wrld)
  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>)
    (<a class="sym-link local-def" href="#def-loop-stopperp-rec" data-sym="LOOP-STOPPERP-REC" title="(defun loop-stopperp-rec (loop-stopper sbst wrld)
  (cond ((null loop-stopper) nil)
        (t
         (let ((pre (cdr (assoc-eq (car (car loop-stopper)) sbst)))
               (post (cdr (assoc-eq (cadr (car loop-stopper)) sbst))))
...">loop-stopperp-rec</a> <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a> sbst wrld)))</pre>
  </div>

<div class="form-block other" id="form-142" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> rewrite-rule
  (rune nume
    hyps
    equiv
    lhs
    rhs
    subclass
    heuristic-info
    backchain-limit-lst
    var-info . match-free)
  nil)</pre>
  </div>

<div class="form-block function" id="def-relevant-ground-lemmas" data-defines="RELEVANT-GROUND-LEMMAS" data-references="LEMMAS,QUOTE,FFN-SYMB,GETPROPC,T,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,IGNORE,DECLARE,STRIP-NOT,NOT-FLG,MV-LET,WRLD,HYP,DEFUN" data-used-by="REWRITE,SEARCH-GROUND-UNITS" data-part-name="RELEVANT-GROUND-LEMMAS" data-part-args="WRLD,HYP" data-part-body="WRLD,LEMMAS,QUOTE,FFN-SYMB,GETPROPC,T,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,IGNORE,DECLARE,STRIP-NOT,HYP,NOT-FLG,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RELEVANT-GROUND-LEMMAS">relevant-ground-lemmas</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-relevant-ground-lemmas" data-sym="RELEVANT-GROUND-LEMMAS" title="(defun relevant-ground-lemmas (hyp wrld)
  (mv-let (not-flg hyp) (strip-not hyp) (declare (ignore not-flg))
          (cond ((variablep hyp) nil) ((fquotep hyp) nil)
                ((flambda-applicationp hyp) nil)
                (t (getpropc (ffn-symb hyp) &#39;lemmas nil wrld)))))">relevant-ground-lemmas</a>
  (hyp wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg hyp)
    (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> hyp)
    (declare (ignore not-flg))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> hyp) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> hyp) nil)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> hyp) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) 'lemmas nil wrld)))))</pre>
  </div>

<div class="form-block function" id="def-search-ground-units1" data-defines="SEARCH-GROUND-UNITS1" data-references="CDR,PUSH-LEMMA,T,FINAL-LEMMAS,FINAL-TTREE,FINAL-UNIFY-SUBST,FLG,WITH-ACCUMULATED-PERSISTENCE,RUNE,LET,ONE-WAY-UNIFY1,ANS,KNOWN-WHETHER-NIL,NILP-TTREE,NILP,KNOWNP,MV-LET,*GENEQV-IFF*,GENEQV-REFINEMENTP,META,QUOTE,EQ,NOT,CAR,REWRITE-RULE,ACCESS,ENABLED-NUMEP,AND,MV,NULL,COND,TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,LEMMAS,UNIFY-SUBST,HYP,DEFUN" data-used-by="REWRITE,SEARCH-GROUND-UNITS" data-part-name="SEARCH-GROUND-UNITS1" data-part-args="TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,LEMMAS,UNIFY-SUBST,HYP" data-part-body="SEARCH-GROUND-UNITS1,CDR,PUSH-LEMMA,T,FINAL-LEMMAS,FINAL-TTREE,FINAL-UNIFY-SUBST,FLG,WITH-ACCUMULATED-PERSISTENCE,RUNE,LET,HYP,ONE-WAY-UNIFY1,ANS,FORCE-FLG,TYPE-ALIST,KNOWN-WHETHER-NIL,NILP-TTREE,NILP,KNOWNP,MV-LET,WRLD,*GENEQV-IFF*,GENEQV-REFINEMENTP,META,QUOTE,EQ,NOT,ENS,CAR,REWRITE-RULE,ACCESS,ENABLED-NUMEP,AND,TTREE,UNIFY-SUBST,MV,LEMMAS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-GROUND-UNITS1">search-ground-units1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a>
  (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lemmas) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil unify-subst ttree nil))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:nume</span>) ens)
       (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:subclass</span>) 'meta))
       (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:hyps</span>))
       (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:var-info</span>))
       (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:equiv</span>)
         <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
         wrld)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (knownp nilp nilp-ttree)
        (known-whether-nil (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:rhs</span>)
          type-alist
          ens
          force-flg
          nil
          wrld
          ttree)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> knownp (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> nilp)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans unify-subst)
              (one-way-unify1 hyp
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:lhs</span>)
                unify-subst)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (let ((rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:rune</span>)))
                    (with-accumulated-persistence rune
                      (flg final-unify-subst final-ttree final-lemmas)
                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                        unify-subst
                        (push-lemma (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:equiv</span>)
                            <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                            wrld)
                          (push-lemma rune nilp-ttree))
                        (cdr lemmas)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a> hyp
                    unify-subst
                    (cdr lemmas)
                    type-alist
                    ens
                    force-flg
                    wrld
                    ttree)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a> hyp
              unify-subst
              (cdr lemmas)
              type-alist
              ens
              force-flg
              wrld
              ttree)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a> hyp
        unify-subst
        (cdr lemmas)
        type-alist
        ens
        force-flg
        wrld
        ttree))))</pre>
  </div>

<div class="form-block function" id="def-search-ground-units" data-defines="SEARCH-GROUND-UNITS" data-references="MV,IGNORE,DECLARE,SEARCH-GROUND-UNITS1,REST-LEMMAS,WINP,MV-LET,RELEVANT-GROUND-LEMMAS,LEMMAS,LET,TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,UNIFY-SUBST,HYP,DEFUN" data-part-name="SEARCH-GROUND-UNITS" data-part-args="TTREE,WRLD,FORCE-FLG,ENS,TYPE-ALIST,UNIFY-SUBST,HYP" data-part-body="MV,IGNORE,DECLARE,FORCE-FLG,ENS,TYPE-ALIST,SEARCH-GROUND-UNITS1,REST-LEMMAS,TTREE,UNIFY-SUBST,WINP,MV-LET,WRLD,HYP,RELEVANT-GROUND-LEMMAS,LEMMAS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-GROUND-UNITS">search-ground-units</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-ground-units" data-sym="SEARCH-GROUND-UNITS" title="(defun search-ground-units
       (hyp unify-subst type-alist ens force-flg wrld ttree)
  (let ((lemmas (relevant-ground-lemmas hyp wrld)))
    (mv-let (winp unify-subst ttree rest-lemmas)
            (search-ground-units1 hyp unify-subst lemmas type-alist ens
...">search-ground-units</a>
  (hyp unify-subst type-alist ens force-flg wrld ttree)
  (let ((lemmas (<a class="sym-link local-def" href="#def-relevant-ground-lemmas" data-sym="RELEVANT-GROUND-LEMMAS" title="(defun relevant-ground-lemmas (hyp wrld)
  (mv-let (not-flg hyp) (strip-not hyp) (declare (ignore not-flg))
          (cond ((variablep hyp) nil) ((fquotep hyp) nil)
                ((flambda-applicationp hyp) nil)
                (t (getpropc (ffn-symb hyp) &#39;lemmas nil wrld)))))">relevant-ground-lemmas</a> hyp wrld)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (winp unify-subst ttree rest-lemmas)
      (<a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a> hyp
        unify-subst
        lemmas
        type-alist
        ens
        force-flg
        wrld
        ttree)
      (declare (ignore rest-lemmas))
      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> winp unify-subst ttree))))</pre>
  </div>

<div class="form-block function" id="def-if-tautologyp" data-defines="IF-TAUTOLOGYP" data-references="T,IF-COMPILE,SPLICE-INSTRS,IF-INTERP,POSP,PSEUDO-TERMP,XARGS,DECLARE,TERM,DEFUN" data-used-by="REWRITE,TAUTOLOGYP" data-part-name="IF-TAUTOLOGYP" data-part-args="TERM" data-part-declare="TERM,PSEUDO-TERMP,XARGS,DECLARE" data-part-body="T,TERM,IF-COMPILE,SPLICE-INSTRS,IF-INTERP,POSP" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="IF-TAUTOLOGYP">if-tautologyp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-if-tautologyp" data-sym="IF-TAUTOLOGYP" title="(defun if-tautologyp (term)
  (declare (xargs :guard (pseudo-termp term)))
  (posp
   (if-interp (splice-instrs (if-compile term t nil nil)) nil nil nil nil
              100000)))">if-tautologyp</a>
  (term)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
  (<a class="sym-link system" href="axioms.html#def-posp" data-sym="POSP">posp</a> (<a class="sym-link local-def" href="#def-if-interp" data-sym="IF-INTERP" title="(defun if-interp (instrs stack frame-ptr-stack assumptions ac pflg)
  (declare (type (or null (unsigned-byte 60)) pflg))
  (cond
   ((null instrs)
    (let ((v (car stack)))
...">if-interp</a> (<a class="sym-link local-def" href="#def-splice-instrs" data-sym="SPLICE-INSTRS" title="(defun splice-instrs (instrs)
  (declare (xargs :guard (instr-listp instrs)))
  (splice-instrs1 instrs nil nil))">splice-instrs</a> (<a class="sym-link local-def" href="#def-if-compile" data-sym="IF-COMPILE" title="(mutual-recursion
 (defun if-compile (term lambda-exp ac rformals)
   (declare (xargs :guard (pseudo-termp term)))
   (cond
    ((variablep term)
...">if-compile</a> term <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil nil))
      nil
      nil
      nil
      nil
      <span class="number">100000</span>)))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-expand-some-non-rec-fns" data-defines="EXPAND-SOME-NON-REC-FNS" data-references="CDR,CAR,CONS,NULL,LST,CONS-TERM,BBODY,FORMALS,SUBCOR-VAR,FFN-SYMB,MEMBER-EQUAL,FARGS,EXPAND-SOME-NON-REC-FNS-LST,ARGS,LET,T,FQUOTEP,VARIABLEP,COND,WRLD,TERM,FNS,DEFUN,MUTUAL-RECURSION" data-used-by="TAUTOLOGYP" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPAND-SOME-NON-REC-FNS">expand-some-non-rec-fns</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-expand-some-non-rec-fns" data-sym="EXPAND-SOME-NON-REC-FNS" title="(mutual-recursion
 (defun expand-some-non-rec-fns (fns term wrld)
   (cond ((variablep term) term) ((fquotep term) term)
         (t
          (let ((args (expand-some-non-rec-fns-lst fns (fargs term) wrld)))
...">expand-some-non-rec-fns</a>
    (fns term wrld)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) term)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) term)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> (expand-some-non-rec-fns-lst fns (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) wrld)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fns) (<a class="sym-link system" href="basis-b.html#def-subcor-var" data-sym="SUBCOR-VAR">subcor-var</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld)
                <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
                (<a class="sym-link system" href="axioms.html#def-bbody" data-sym="BBODY">bbody</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> expand-some-non-rec-fns-lst
    (fns lst wrld)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-expand-some-non-rec-fns" data-sym="EXPAND-SOME-NON-REC-FNS" title="(mutual-recursion
 (defun expand-some-non-rec-fns (fns term wrld)
   (cond ((variablep term) term) ((fquotep term) term)
         (t
          (let ((args (expand-some-non-rec-fns-lst fns (fargs term) wrld)))
...">expand-some-non-rec-fns</a> fns (car lst) wrld)
          (expand-some-non-rec-fns-lst fns (cdr lst) wrld))))))</pre>
  </div>

<div class="form-block function" id="def-tautologyp" data-defines="TAUTOLOGYP" data-references="DOUBLE-REWRITE,CASE-SPLIT,FORCE,WORMHOLE-EVAL,CONS-WITH-HINT,MV-LIST,LISTP,MINUSP,PLUSP,RETURN-LAST,SYNP,ZEROP,NULL,/=,=,EQL,ATOM,EQ,IFF,EXPAND-SOME-NON-REC-FNS,IF-TAUTOLOGYP,T,FARGN,EQUAL,IMPLIES,QUOTE,FFN-SYMB-P,AND,COND,WRLD,TERM,DEFUN" data-part-name="TAUTOLOGYP" data-part-args="WRLD,TERM" data-part-body="WRLD,DOUBLE-REWRITE,CASE-SPLIT,FORCE,WORMHOLE-EVAL,CONS-WITH-HINT,MV-LIST,LISTP,MINUSP,PLUSP,RETURN-LAST,SYNP,ZEROP,NULL,/=,=,EQL,ATOM,EQ,IFF,EXPAND-SOME-NON-REC-FNS,IF-TAUTOLOGYP,T,FARGN,EQUAL,IMPLIES,QUOTE,TERM,FFN-SYMB-P,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TAUTOLOGYP">tautologyp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tautologyp" data-sym="TAUTOLOGYP" title="(defun tautologyp (term wrld)
  (cond
   ((and (ffn-symb-p term &#39;implies) (equal (fargn term 1) (fargn term 2))) t)
   (t
    (if-tautologyp
...">tautologyp</a>
  (term wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> term '<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a>)
       (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-if-tautologyp" data-sym="IF-TAUTOLOGYP" title="(defun if-tautologyp (term)
  (declare (xargs :guard (pseudo-termp term)))
  (posp
   (if-interp (splice-instrs (if-compile term t nil nil)) nil nil nil nil
              100000)))">if-tautologyp</a> (<a class="sym-link local-def" href="#def-expand-some-non-rec-fns" data-sym="EXPAND-SOME-NON-REC-FNS" title="(mutual-recursion
 (defun expand-some-non-rec-fns (fns term wrld)
   (cond ((variablep term) term) ((fquotep term) term)
         (t
          (let ((args (expand-some-non-rec-fns-lst fns (fargs term) wrld)))
...">expand-some-non-rec-fns</a> '(<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> <a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a>
            <a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a>
            <a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a>
            <a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a>
            <a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a>
            <a class="sym-link system" href="axioms.html#def-_2F_3D" data-sym="/=">/=</a>
            <a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a>
            zerop
            <a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>
            <a class="sym-link system" href="axioms.html#def-return-last" data-sym="RETURN-LAST">return-last</a>
            plusp
            minusp
            <a class="sym-link system" href="axioms.html#def-listp" data-sym="LISTP">listp</a>
            <a class="sym-link system" href="axioms.html#def-mv-list" data-sym="MV-LIST">mv-list</a>
            <a class="sym-link system" href="axioms.html#def-cons-with-hint" data-sym="CONS-WITH-HINT">cons-with-hint</a>
            <a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a>
            <a class="sym-link system" href="axioms.html#def-force" data-sym="FORCE">force</a>
            <a class="sym-link system" href="axioms.html#def-case-split" data-sym="CASE-SPLIT">case-split</a>
            <a class="sym-link system" href="axioms.html#def-double-rewrite" data-sym="DOUBLE-REWRITE">double-rewrite</a>)
          term
          wrld)))))</pre>
  </div>

<div class="form-block function" id="def-being-openedp-rec" data-defines="BEING-OPENEDP-REC" data-references="T,CDR,CAAR,EQ,OR,CAR,CONSP,NULL,COND,FNSTACK,FN,DEFUN" data-used-by="BEING-OPENEDP" data-part-name="BEING-OPENEDP-REC" data-part-args="FNSTACK,FN" data-part-body="T,CDR,BEING-OPENEDP-REC,CAAR,FN,EQ,OR,CAR,CONSP,FNSTACK,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BEING-OPENEDP-REC">being-openedp-rec</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-being-openedp-rec" data-sym="BEING-OPENEDP-REC" title="(defun being-openedp-rec (fn fnstack)
  (cond ((null fnstack) nil)
        ((consp (car fnstack))
         (or (eq fn (caar fnstack)) (being-openedp-rec fn (cdr fnstack))))
        (t (or (eq fn (car fnstack)) (being-openedp-rec fn (cdr fnstack))))))">being-openedp-rec</a>
  (fn fnstack)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fnstack) nil)
    ((consp (car fnstack)) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> fnstack))
        (<a class="sym-link local-def" href="#def-being-openedp-rec" data-sym="BEING-OPENEDP-REC" title="(defun being-openedp-rec (fn fnstack)
  (cond ((null fnstack) nil)
        ((consp (car fnstack))
         (or (eq fn (caar fnstack)) (being-openedp-rec fn (cdr fnstack))))
        (t (or (eq fn (car fnstack)) (being-openedp-rec fn (cdr fnstack))))))">being-openedp-rec</a> fn (cdr fnstack))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (car fnstack))
        (<a class="sym-link local-def" href="#def-being-openedp-rec" data-sym="BEING-OPENEDP-REC" title="(defun being-openedp-rec (fn fnstack)
  (cond ((null fnstack) nil)
        ((consp (car fnstack))
         (or (eq fn (caar fnstack)) (being-openedp-rec fn (cdr fnstack))))
        (t (or (eq fn (car fnstack)) (being-openedp-rec fn (cdr fnstack))))))">being-openedp-rec</a> fn (cdr fnstack))))))</pre>
  </div>

<div class="form-block other" id="form-150" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> being-openedp-limited-for-nonrec nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-151" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> being-openedp-limited-for-nonrec
  <a class="sym-link system" href="axioms.html#def-constant-t-function-arity-0" data-sym="CONSTANT-T-FUNCTION-ARITY-0">constant-t-function-arity-0</a>)</pre>
  </div>

<div class="form-block macro" id="def-being-openedp" data-defines="BEING-OPENEDP" data-references="CAR,IF,BEING-OPENEDP-REC,BEING-OPENEDP-LIMITED-FOR-NONREC,NOT,OR,LET,AND,QUASIQUOTE,SYMBOLP,XARGS,DECLARE,SETTLED-DOWN-P,CLIQUE,FNSTACK,FN,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BEING-OPENEDP">being-openedp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-being-openedp" data-sym="BEING-OPENEDP" title="(defmacro being-openedp (fn fnstack clique settled-down-p)
  (declare (xargs :guard (symbolp fnstack)))
  `(and ,fnstack
        (let ((clique ,clique))
          (and
...">being-openedp</a>
  (fn fnstack clique settled-down-p)
  (declare (xargs <span class="keyword">:guard</span> (symbolp fnstack)))
  `(<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,FNSTACK
    (let ((clique ,CLIQUE))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> clique
          (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> ,SETTLED-DOWN-P)
          (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (being-openedp-limited-for-nonrec)))
        (<a class="sym-link local-def" href="#def-being-openedp-rec" data-sym="BEING-OPENEDP-REC" title="(defun being-openedp-rec (fn fnstack)
  (cond ((null fnstack) nil)
        ((consp (car fnstack))
         (or (eq fn (caar fnstack)) (being-openedp-rec fn (cdr fnstack))))
        (t (or (eq fn (car fnstack)) (being-openedp-rec fn (cdr fnstack))))))">being-openedp-rec</a> (if clique
            (car clique)
            ,FN)
          ,FNSTACK)))))</pre>
  </div>

<div class="form-block function" id="def-recursive-fn-on-fnstackp" data-defines="RECURSIVE-FN-ON-FNSTACKP" data-references="CDR,T,CAAR,EQ,NOT,CAR,CONSP,AND,NULL,COND,FNSTACK,DEFUN" data-used-by="REWRITE" data-part-name="RECURSIVE-FN-ON-FNSTACKP" data-part-args="FNSTACK" data-part-body="CDR,RECURSIVE-FN-ON-FNSTACKP,T,CAAR,EQ,NOT,CAR,CONSP,AND,FNSTACK,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECURSIVE-FN-ON-FNSTACKP">recursive-fn-on-fnstackp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a>
  (fnstack)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fnstack) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (car fnstack)) (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> fnstack) <span class="keyword">:term</span>))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a> (cdr fnstack)))))</pre>
  </div>

<div class="form-block function" id="def-fnstack-term-member" data-defines="FNSTACK-TERM-MEMBER" data-references="CDR,T,CDAR,EQUAL,CAAR,EQ,CAR,CONSP,AND,NULL,COND,FNSTACK,TERM,DEFUN" data-used-by="REWRITE" data-part-name="FNSTACK-TERM-MEMBER" data-part-args="FNSTACK,TERM" data-part-body="CDR,FNSTACK-TERM-MEMBER,T,TERM,CDAR,EQUAL,CAAR,EQ,CAR,CONSP,AND,FNSTACK,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FNSTACK-TERM-MEMBER">fnstack-term-member</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fnstack-term-member" data-sym="FNSTACK-TERM-MEMBER" title="(defun fnstack-term-member (term fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (eq (caar fnstack) :term)
              (equal (cdar fnstack) term))
         t)">fnstack-term-member</a>
  (term fnstack)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> fnstack) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (car fnstack))
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> fnstack) <span class="keyword">:term</span>)
       (equal (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> fnstack) term)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-fnstack-term-member" data-sym="FNSTACK-TERM-MEMBER" title="(defun fnstack-term-member (term fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (eq (caar fnstack) :term)
              (equal (cdar fnstack) term))
         t)">fnstack-term-member</a> term (cdr fnstack)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-var-counts1" data-defines="VAR-COUNTS1" data-references="CAR,CDR,ENDP,PSEUDO-TERM-LISTP,LST,FARGS,VAR-COUNTS1-LST,T,FARGN,MAX,IF,QUOTE,FFN-SYMB,EQ,FQUOTEP,VARIABLEP,1+,EQUAL,COND,NATP,PSEUDO-TERMP,AND,XARGS,DECLARE,ACC,RHS,ARG,DEFUN,MUTUAL-RECURSION" data-used-by="VAR-COUNTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="VAR-COUNTS1">var-counts1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-var-counts1" data-sym="VAR-COUNTS1" title="(mutual-recursion
 (defun var-counts1 (arg rhs acc)
   (declare
    (xargs :guard (and (pseudo-termp rhs) (natp acc)) :verify-guards nil))
   (cond ((equal arg rhs) (1+ acc)) ((variablep rhs) acc) ((fquotep rhs) acc)
...">var-counts1</a>
    (arg rhs acc)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> rhs) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> acc))
        <span class="keyword">:verify-guards</span> nil))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal arg rhs) (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> acc))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> rhs) acc)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> rhs) acc)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> rhs) 'if) (max (<a class="sym-link local-def" href="#def-var-counts1" data-sym="VAR-COUNTS1" title="(mutual-recursion
 (defun var-counts1 (arg rhs acc)
   (declare
    (xargs :guard (and (pseudo-termp rhs) (natp acc)) :verify-guards nil))
   (cond ((equal arg rhs) (1+ acc)) ((variablep rhs) acc) ((fquotep rhs) acc)
...">var-counts1</a> arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">2</span>) acc)
          (<a class="sym-link local-def" href="#def-var-counts1" data-sym="VAR-COUNTS1" title="(mutual-recursion
 (defun var-counts1 (arg rhs acc)
   (declare
    (xargs :guard (and (pseudo-termp rhs) (natp acc)) :verify-guards nil))
   (cond ((equal arg rhs) (1+ acc)) ((variablep rhs) acc) ((fquotep rhs) acc)
...">var-counts1</a> arg (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> rhs <span class="number">3</span>) acc)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (var-counts1-lst arg (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> rhs) acc))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> var-counts1-lst
    (arg lst acc)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp lst) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> acc))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) acc)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (var-counts1-lst arg
          (cdr lst)
          (<a class="sym-link local-def" href="#def-var-counts1" data-sym="VAR-COUNTS1" title="(mutual-recursion
 (defun var-counts1 (arg rhs acc)
   (declare
    (xargs :guard (and (pseudo-termp rhs) (natp acc)) :verify-guards nil))
   (cond ((equal arg rhs) (1+ acc)) ((variablep rhs) acc) ((fquotep rhs) acc)
...">var-counts1</a> arg (car lst) acc))))))</pre>
  </div>

<div class="form-block function" id="def-var-counts" data-defines="VAR-COUNTS" data-references="CDR,CAR,VAR-COUNTS1,CONS,T,ENDP,COND,PSEUDO-TERMP,TRUE-LISTP,AND,XARGS,DECLARE,RHS,LHS-ARGS,DEFUN" data-used-by="REWRITE" data-part-name="VAR-COUNTS" data-part-args="RHS,LHS-ARGS" data-part-declare="RHS,PSEUDO-TERMP,LHS-ARGS,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CDR,VAR-COUNTS,RHS,CAR,VAR-COUNTS1,CONS,T,LHS-ARGS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="VAR-COUNTS">var-counts</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-var-counts" data-sym="VAR-COUNTS" title="(defun var-counts (lhs-args rhs)
  (declare (xargs :guard (and (true-listp lhs-args) (pseudo-termp rhs))))
  (cond ((endp lhs-args) nil)
        (t
         (cons (var-counts1 (car lhs-args) rhs 0)">var-counts</a>
  (lhs-args rhs)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> lhs-args) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> rhs))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lhs-args) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-var-counts1" data-sym="VAR-COUNTS1" title="(mutual-recursion
 (defun var-counts1 (arg rhs acc)
   (declare
    (xargs :guard (and (pseudo-termp rhs) (natp acc)) :verify-guards nil))
   (cond ((equal arg rhs) (1+ acc)) ((variablep rhs) acc) ((fquotep rhs) acc)
...">var-counts1</a> (car lhs-args) rhs <span class="number">0</span>)
        (<a class="sym-link local-def" href="#def-var-counts" data-sym="VAR-COUNTS" title="(defun var-counts (lhs-args rhs)
  (declare (xargs :guard (and (true-listp lhs-args) (pseudo-termp rhs))))
  (cond ((endp lhs-args) nil)
        (t
         (cons (var-counts1 (car lhs-args) rhs 0)">var-counts</a> (cdr lhs-args) rhs)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-count-ifs" data-defines="COUNT-IFS" data-references="CDR,CAR,ENDP,PSEUDO-TERM-LISTP,LST,FARGS,COUNT-IFS-LST,T,FARGN,+,IF,HIDE,QUOTE,FFN-SYMB,EQ,FQUOTEP,VARIABLEP,COND,PSEUDO-TERMP,XARGS,DECLARE,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="TOO-MANY-IFS1,TOO-MANY-IFS0" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="COUNT-IFS">count-ifs</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a>
    (term)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) <span class="number">0</span>)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) <span class="number">0</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>) <span class="number">0</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span>
          (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>))
          (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
          (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (count-ifs-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> count-ifs-lst
    (lst)
    (declare (xargs <span class="keyword">:guard</span> (pseudo-term-listp lst)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) <span class="number">0</span>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (car lst)) (count-ifs-lst (cdr lst)))))))</pre>
  </div>

<div class="form-block function" id="def-too-many-ifs0" data-defines="TOO-MANY-IFS0" data-references="1-,*,+,UNSIGNED-BYTE,COUNT-IFS,THE-FIXNUM!,COUNT1,LET,T,CDR,CAR,EQL,>,ENDP,COND,LEN,EQUAL,INTEGER-LISTP,PSEUDO-TERM-LISTP,AND,XARGS,SIGNED-BYTE,TYPE,DECLARE,CTX,DIFF,COUNTS,ARGS,DEFUN" data-used-by="TOO-MANY-IFS-PRE-REWRITE-BUILTIN" data-part-name="TOO-MANY-IFS0" data-part-args="CTX,DIFF,COUNTS,ARGS" data-part-declare="LEN,EQUAL,COUNTS,INTEGER-LISTP,ARGS,PSEUDO-TERM-LISTP,AND,XARGS,DIFF,SIGNED-BYTE,TYPE,DECLARE" data-part-body="1-,*,+,UNSIGNED-BYTE,TYPE,DECLARE,COUNT-IFS,THE-FIXNUM!,COUNT1,LET,T,CTX,CDR,TOO-MANY-IFS0,COUNTS,CAR,EQL,DIFF,>,ARGS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOO-MANY-IFS0">too-many-ifs0</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-too-many-ifs0" data-sym="TOO-MANY-IFS0" title="(defun too-many-ifs0 (args counts diff ctx)
  (declare (type (signed-byte 61) diff)
           (xargs :guard
            (and (pseudo-term-listp args) (integer-listp counts)
                 (equal (len args) (len counts)))))
...">too-many-ifs0</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> counts diff ctx)
  (declare (type (signed-byte <span class="number">61</span>) diff)
    (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (<a class="sym-link system" href="axioms.html#def-integer-listp" data-sym="INTEGER-LISTP">integer-listp</a> counts)
        (equal (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> counts)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> diff <span class="number">0</span>))
    ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (car counts) <span class="number">1</span>) (<a class="sym-link local-def" href="#def-too-many-ifs0" data-sym="TOO-MANY-IFS0" title="(defun too-many-ifs0 (args counts diff ctx)
  (declare (type (signed-byte 61) diff)
           (xargs :guard
            (and (pseudo-term-listp args) (integer-listp counts)
                 (equal (len args) (len counts)))))
...">too-many-ifs0</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (cdr counts) diff ctx))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((count1 (<a class="sym-link system" href="basis-a.html#def-the-fixnum_21" data-sym="THE-FIXNUM!">the-fixnum!</a> (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)) ctx)))
        (declare (type (unsigned-byte <span class="number">60</span>) count1))
        (<a class="sym-link local-def" href="#def-too-many-ifs0" data-sym="TOO-MANY-IFS0" title="(defun too-many-ifs0 (args counts diff ctx)
  (declare (type (signed-byte 61) diff)
           (xargs :guard
            (and (pseudo-term-listp args) (integer-listp counts)
                 (equal (len args) (len counts)))))
...">too-many-ifs0</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
          (cdr counts)
          (<a class="sym-link system" href="basis-a.html#def-the-fixnum_21" data-sym="THE-FIXNUM!">the-fixnum!</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="basis-a.html#def-the-fixnum_21" data-sym="THE-FIXNUM!">the-fixnum!</a> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> count1 (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (car counts))) ctx) diff)
            ctx)
          ctx)))))</pre>
  </div>

<div class="form-block other" id="form-159" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> too-many-ifs-pre-rewrite (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block function" id="def-too-many-ifs-pre-rewrite-builtin" data-defines="TOO-MANY-IFS-PRE-REWRITE-BUILTIN" data-references="TOO-MANY-IFS-PRE-REWRITE,QUOTE,TOO-MANY-IFS0,LEN,EQUAL,INTEGER-LISTP,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,COUNTS,ARGS,DEFUN" data-part-name="TOO-MANY-IFS-PRE-REWRITE-BUILTIN" data-part-args="COUNTS,ARGS" data-part-declare="LEN,EQUAL,COUNTS,INTEGER-LISTP,ARGS,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="TOO-MANY-IFS-PRE-REWRITE,QUOTE,COUNTS,ARGS,TOO-MANY-IFS0" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOO-MANY-IFS-PRE-REWRITE-BUILTIN">too-many-ifs-pre-rewrite-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-too-many-ifs-pre-rewrite-builtin" data-sym="TOO-MANY-IFS-PRE-REWRITE-BUILTIN" title="(defun too-many-ifs-pre-rewrite-builtin (args counts)
  (declare
   (xargs :guard
    (and (pseudo-term-listp args) (integer-listp counts)
         (equal (len args) (len counts)))))">too-many-ifs-pre-rewrite-builtin</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> counts)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (<a class="sym-link system" href="axioms.html#def-integer-listp" data-sym="INTEGER-LISTP">integer-listp</a> counts)
        (equal (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> counts)))))
  (<a class="sym-link local-def" href="#def-too-many-ifs0" data-sym="TOO-MANY-IFS0" title="(defun too-many-ifs0 (args counts diff ctx)
  (declare (type (signed-byte 61) diff)
           (xargs :guard
            (and (pseudo-term-listp args) (integer-listp counts)
                 (equal (len args) (len counts)))))
...">too-many-ifs0</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> counts <span class="number">0</span> 'too-many-ifs-pre-rewrite))</pre>
  </div>

<div class="form-block other" id="form-161" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (too-many-ifs-pre-rewrite <a class="sym-link local-def" href="#def-too-many-ifs-pre-rewrite-builtin" data-sym="TOO-MANY-IFS-PRE-REWRITE-BUILTIN" title="(defun too-many-ifs-pre-rewrite-builtin (args counts)
  (declare
   (xargs :guard
    (and (pseudo-term-listp args) (integer-listp counts)
         (equal (len args) (len counts)))))">too-many-ifs-pre-rewrite-builtin</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block mutual-recursion" id="def-occur-cnt-bounded" data-defines="OCCUR-CNT-BOUNDED" data-references="CDR,EQL,CAR,NEW,LET,ENDP,PSEUDO-TERM-LISTP,LST,FARGS,OCCUR-CNT-BOUNDED-LST,T,FQUOTEP,VARIABLEP,IF,EQUAL,COND,THE-FIXNUM,<=,+,*FIXNUM-BITS*,SIGNED-BYTE-P,PSEUDO-TERMP,AND,ACL2-COUNT,XARGS,SIGNED-BYTE,TYPE,DECLARE,BOUND-M,M,A,TERM2,TERM1,DEFUN,MUTUAL-RECURSION" data-used-by="TOO-MANY-IFS1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="OCCUR-CNT-BOUNDED">occur-cnt-bounded</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-occur-cnt-bounded" data-sym="OCCUR-CNT-BOUNDED" title="(mutual-recursion
 (defun occur-cnt-bounded (term1 term2 a m bound-m)
   (declare (type (signed-byte 61) a m bound-m)
            (xargs :measure (acl2-count term2) :ruler-extenders (:lambdas)
             :guard
...">occur-cnt-bounded</a>
    (term1 term2 a m bound-m)
    (declare (type (signed-byte <span class="number">61</span>) a m bound-m)
      (xargs <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> term2)
        <span class="keyword">:ruler-extenders</span> (<span class="keyword">:lambdas</span>)
        <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term2)
          (<a class="sym-link system" href="axioms.html#def-signed-byte-p" data-sym="SIGNED-BYTE-P">signed-byte-p</a> <a class="sym-link system" href="axioms.html#def-_2Afixnum-bits_2A" data-sym="*FIXNUM-BITS*">*fixnum-bits*</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> bound-m m))
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> a)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> m)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> bound-m)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> a (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> bound-m m)))
        <span class="keyword">:verify-guards</span> nil))
    (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term1 term2) (if (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> a bound-m)
            (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> a m))
            <span class="number">-1</span>))
        ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term2) a)
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term2) a)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (occur-cnt-bounded-lst term1 (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term2) a m bound-m)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> occur-cnt-bounded-lst
    (term1 lst a m bound-m)
    (declare (type (signed-byte <span class="number">61</span>) a m bound-m)
      (xargs <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> lst)
        <span class="keyword">:ruler-extenders</span> (<span class="keyword">:lambdas</span>)
        <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp lst)
          (<a class="sym-link system" href="axioms.html#def-signed-byte-p" data-sym="SIGNED-BYTE-P">signed-byte-p</a> <a class="sym-link system" href="axioms.html#def-_2Afixnum-bits_2A" data-sym="*FIXNUM-BITS*">*fixnum-bits*</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> bound-m m))
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> a)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> m)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> bound-m)
          (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> a (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> bound-m m)))))
    (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) a)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new (<a class="sym-link local-def" href="#def-occur-cnt-bounded" data-sym="OCCUR-CNT-BOUNDED" title="(mutual-recursion
 (defun occur-cnt-bounded (term1 term2 a m bound-m)
   (declare (type (signed-byte 61) a m bound-m)
            (xargs :measure (acl2-count term2) :ruler-extenders (:lambdas)
             :guard
...">occur-cnt-bounded</a> term1 (car lst) a m bound-m)))
            (declare (type (signed-byte <span class="number">61</span>) new))
            (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> new <span class="number">-1</span>)
              <span class="number">-1</span>
              (occur-cnt-bounded-lst term1 (cdr lst) new m bound-m))))))))</pre>
  </div>

<div class="form-block function" id="def-too-many-ifs1" data-defines="TOO-MANY-IFS1" data-references="IF,-,THE-FIXNUM,OCCUR-CNT-BOUNDED,CDR,EQL,CAR,COUNT-IFS,THE-FIXNUM!,X,LET,T,ENDP,COND,COUNT-IFS-LST,<=,PSEUDO-TERMP,PSEUDO-TERM-LISTP,AND,XARGS,SIGNED-BYTE,TYPE,DECLARE,CTX,RHS,LHS,VAL,ARGS,DEFUN" data-used-by="TOO-MANY-IFS-POST-REWRITE-BUILTIN" data-part-name="TOO-MANY-IFS1" data-part-args="CTX,RHS,LHS,VAL,ARGS" data-part-declare="COUNT-IFS-LST,<=,VAL,PSEUDO-TERMP,ARGS,PSEUDO-TERM-LISTP,AND,XARGS,RHS,LHS,SIGNED-BYTE,TYPE,DECLARE" data-part-body="IF,-,THE-FIXNUM,OCCUR-CNT-BOUNDED,RHS,LHS,VAL,CDR,TOO-MANY-IFS1,EQL,SIGNED-BYTE,TYPE,DECLARE,CTX,CAR,COUNT-IFS,THE-FIXNUM!,X,LET,T,ARGS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOO-MANY-IFS1">too-many-ifs1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-too-many-ifs1" data-sym="TOO-MANY-IFS1" title="(defun too-many-ifs1 (args val lhs rhs ctx)
  (declare (type (signed-byte 61) lhs rhs)
           (xargs :guard
            (and (pseudo-term-listp args) (pseudo-termp val) (&lt;= 0 lhs)
                 (&lt;= lhs rhs) (&lt;= (count-ifs-lst args) rhs))))
...">too-many-ifs1</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> val lhs rhs ctx)
  (declare (type (signed-byte <span class="number">61</span>) lhs rhs)
    (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> val)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <span class="number">0</span> lhs)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> lhs rhs)
        (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (count-ifs-lst <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) rhs))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((x (<a class="sym-link system" href="basis-a.html#def-the-fixnum_21" data-sym="THE-FIXNUM!">the-fixnum!</a> (<a class="sym-link local-def" href="#def-count-ifs" data-sym="COUNT-IFS" title="(mutual-recursion
 (defun count-ifs (term)
   (declare (xargs :guard (pseudo-termp term)))
   (cond ((variablep term) 0) ((fquotep term) 0) ((eq (ffn-symb term) &#39;hide) 0)
         ((eq (ffn-symb term) &#39;if)
...">count-ifs</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)) ctx)))
        (declare (type (signed-byte <span class="number">61</span>) x))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> x <span class="number">0</span>) (<a class="sym-link local-def" href="#def-too-many-ifs1" data-sym="TOO-MANY-IFS1" title="(defun too-many-ifs1 (args val lhs rhs ctx)
  (declare (type (signed-byte 61) lhs rhs)
           (xargs :guard
            (and (pseudo-term-listp args) (pseudo-termp val) (&lt;= 0 lhs)
                 (&lt;= lhs rhs) (&lt;= (count-ifs-lst args) rhs))))
...">too-many-ifs1</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) val lhs rhs ctx))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((lhs (<a class="sym-link local-def" href="#def-occur-cnt-bounded" data-sym="OCCUR-CNT-BOUNDED" title="(mutual-recursion
 (defun occur-cnt-bounded (term1 term2 a m bound-m)
   (declare (type (signed-byte 61) a m bound-m)
            (xargs :measure (acl2-count term2) :ruler-extenders (:lambdas)
             :guard
...">occur-cnt-bounded</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                   val
                   lhs
                   x
                   (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> rhs x)))))
              (declare (type (signed-byte <span class="number">61</span>) lhs))
              (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> lhs <span class="number">-1</span>)
                <span class="number">-1</span>
                (<a class="sym-link local-def" href="#def-too-many-ifs1" data-sym="TOO-MANY-IFS1" title="(defun too-many-ifs1 (args val lhs rhs ctx)
  (declare (type (signed-byte 61) lhs rhs)
           (xargs :guard
            (and (pseudo-term-listp args) (pseudo-termp val) (&lt;= 0 lhs)
                 (&lt;= lhs rhs) (&lt;= (count-ifs-lst args) rhs))))
...">too-many-ifs1</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) val lhs rhs ctx)))))))))</pre>
  </div>

<div class="form-block other" id="form-164" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> too-many-ifs-post-rewrite (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block function" id="def-too-many-ifs-post-rewrite-builtin" data-defines="TOO-MANY-IFS-POST-REWRITE-BUILTIN" data-references="TOO-MANY-IFS1,T,INT=,COND,COUNT-IFS-LST,THE-FIXNUM!,RHS,QUOTE,CTX,LET*,PSEUDO-TERMP,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,VAL,ARGS,DEFUN" data-part-name="TOO-MANY-IFS-POST-REWRITE-BUILTIN" data-part-args="VAL,ARGS" data-part-declare="VAL,PSEUDO-TERMP,ARGS,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="VAL,TOO-MANY-IFS1,T,INT=,COND,ARGS,COUNT-IFS-LST,THE-FIXNUM!,RHS,TOO-MANY-IFS-POST-REWRITE-BUILTIN,QUOTE,CTX,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOO-MANY-IFS-POST-REWRITE-BUILTIN">too-many-ifs-post-rewrite-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-too-many-ifs-post-rewrite-builtin" data-sym="TOO-MANY-IFS-POST-REWRITE-BUILTIN" title="(defun too-many-ifs-post-rewrite-builtin (args val)
  (declare (xargs :guard (and (pseudo-term-listp args) (pseudo-termp val))))
  (let* ((ctx &#39;too-many-ifs-post-rewrite-builtin)
         (rhs (the-fixnum! (count-ifs-lst args) ctx)))
    (cond ((int= rhs 0) nil) (t (too-many-ifs1 args val 0 rhs ctx)))))">too-many-ifs-post-rewrite-builtin</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> val)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> val))))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ctx '<a class="sym-link local-def" href="#def-too-many-ifs-post-rewrite-builtin" data-sym="TOO-MANY-IFS-POST-REWRITE-BUILTIN" title="(defun too-many-ifs-post-rewrite-builtin (args val)
  (declare (xargs :guard (and (pseudo-term-listp args) (pseudo-termp val))))
  (let* ((ctx &#39;too-many-ifs-post-rewrite-builtin)
         (rhs (the-fixnum! (count-ifs-lst args) ctx)))
    (cond ((int= rhs 0) nil) (t (too-many-ifs1 args val 0 rhs ctx)))))">too-many-ifs-post-rewrite-builtin</a>) (rhs (<a class="sym-link system" href="basis-a.html#def-the-fixnum_21" data-sym="THE-FIXNUM!">the-fixnum!</a> (count-ifs-lst <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ctx)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-int_3D" data-sym="INT=">int=</a> rhs <span class="number">0</span>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-too-many-ifs1" data-sym="TOO-MANY-IFS1" title="(defun too-many-ifs1 (args val lhs rhs ctx)
  (declare (type (signed-byte 61) lhs rhs)
           (xargs :guard
            (and (pseudo-term-listp args) (pseudo-termp val) (&lt;= 0 lhs)
                 (&lt;= lhs rhs) (&lt;= (count-ifs-lst args) rhs))))
...">too-many-ifs1</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> val <span class="number">0</span> rhs ctx)))))</pre>
  </div>

<div class="form-block other" id="form-166" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (too-many-ifs-post-rewrite <a class="sym-link local-def" href="#def-too-many-ifs-post-rewrite-builtin" data-sym="TOO-MANY-IFS-POST-REWRITE-BUILTIN" title="(defun too-many-ifs-post-rewrite-builtin (args val)
  (declare (xargs :guard (and (pseudo-term-listp args) (pseudo-termp val))))
  (let* ((ctx &#39;too-many-ifs-post-rewrite-builtin)
         (rhs (the-fixnum! (count-ifs-lst args) ctx)))
    (cond ((int= rhs 0) nil) (t (too-many-ifs1 args val 0 rhs ctx)))))">too-many-ifs-post-rewrite-builtin</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-all-args-occur-in-top-clausep" data-defines="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP" data-references="CDR,CAR,DUMB-OCCUR-LST,AND,T,NULL,COND,TOP-CLAUSE,ARGS,DEFUN" data-used-by="REWRITE-FNCALLP" data-part-name="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP" data-part-args="TOP-CLAUSE,ARGS" data-part-body="CDR,ALL-ARGS-OCCUR-IN-TOP-CLAUSEP,TOP-CLAUSE,CAR,DUMB-OCCUR-LST,AND,T,ARGS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP">all-args-occur-in-top-clausep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-args-occur-in-top-clausep" data-sym="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP" title="(defun all-args-occur-in-top-clausep (args top-clause)
  (cond ((null args) t)
        (t
         (and (dumb-occur-lst (car args) top-clause)
              (all-args-occur-in-top-clausep (cdr args) top-clause)))))">all-args-occur-in-top-clausep</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> top-clause)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (dumb-occur-lst (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) top-clause)
        (<a class="sym-link local-def" href="#def-all-args-occur-in-top-clausep" data-sym="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP" title="(defun all-args-occur-in-top-clausep (args top-clause)
  (cond ((null args) t)
        (t
         (and (dumb-occur-lst (car args) top-clause)
              (all-args-occur-in-top-clausep (cdr args) top-clause)))))">all-args-occur-in-top-clausep</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) top-clause)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-max-form-count" data-defines="MAX-FORM-COUNT" data-references="CAR,+F,CDR,NULL,FN-COUNT-EVG-MAX-VAL,>=,TYPE,DECLARE,ACC,LST,FARGS,MAX-FORM-COUNT-LST,T,FARGN,MAX,IF,QUOTE,FFN-SYMB,EQ,CADR,CONS-COUNT-BOUNDED,FQUOTEP,VARIABLEP,COND,UNSIGNED-BYTE,THE,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="CONTROLLER-COMPLEXITY1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAX-FORM-COUNT">max-form-count</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-max-form-count" data-sym="MAX-FORM-COUNT" title="(mutual-recursion
 (defun max-form-count (term)
   (the (unsigned-byte 60)
        (cond ((variablep term) 0)
              ((fquotep term) (cons-count-bounded (cadr term)))
...">max-form-count</a>
    (term)
    (<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (unsigned-byte <span class="number">60</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) <span class="number">0</span>)
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (cons-count-bounded (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> term)))
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (max (<a class="sym-link local-def" href="#def-max-form-count" data-sym="MAX-FORM-COUNT" title="(mutual-recursion
 (defun max-form-count (term)
   (the (unsigned-byte 60)
        (cond ((variablep term) 0)
              ((fquotep term) (cons-count-bounded (cadr term)))
...">max-form-count</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
            (<a class="sym-link local-def" href="#def-max-form-count" data-sym="MAX-FORM-COUNT" title="(mutual-recursion
 (defun max-form-count (term)
   (the (unsigned-byte 60)
        (cond ((variablep term) 0)
              ((fquotep term) (cons-count-bounded (cadr term)))
...">max-form-count</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (max-form-count-lst (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) <span class="number">1</span>)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> max-form-count-lst
    (lst acc)
    (declare (type (unsigned-byte <span class="number">60</span>) acc))
    (<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (unsigned-byte <span class="number">60</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> acc (fn-count-evg-max-val)) (fn-count-evg-max-val))
        ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) acc)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (max-form-count-lst (cdr lst)
            (<a class="sym-link system" href="basis-a.html#def-_2Bf" data-sym="+F">+f</a> acc (<a class="sym-link local-def" href="#def-max-form-count" data-sym="MAX-FORM-COUNT" title="(mutual-recursion
 (defun max-form-count (term)
   (the (unsigned-byte 60)
        (cond ((variablep term) 0)
              ((fquotep term) (cons-count-bounded (cadr term)))
...">max-form-count</a> (car lst)))))))))</pre>
  </div>

<div class="form-block function" id="def-controller-complexity1" data-defines="CONTROLLER-COMPLEXITY1" data-references="T,CDR,MAX-FORM-COUNT,+,CAR,EQ,NULL,COND,CONTROLLER-POCKET,ARGS,FLG,DEFUN" data-used-by="CONTROLLER-COMPLEXITY" data-part-name="CONTROLLER-COMPLEXITY1" data-part-args="CONTROLLER-POCKET,ARGS,FLG" data-part-body="T,CDR,CONTROLLER-COMPLEXITY1,MAX-FORM-COUNT,+,FLG,CONTROLLER-POCKET,CAR,EQ,ARGS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONTROLLER-COMPLEXITY1">controller-complexity1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-controller-complexity1" data-sym="CONTROLLER-COMPLEXITY1" title="(defun controller-complexity1 (flg args controller-pocket)
  (cond ((null args) 0)
        ((eq (car controller-pocket) flg)
         (+ (max-form-count (car args))
            (controller-complexity1 flg (cdr args) (cdr controller-pocket))))">controller-complexity1</a>
  (flg <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> controller-pocket)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) <span class="number">0</span>)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car controller-pocket) flg) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link local-def" href="#def-max-form-count" data-sym="MAX-FORM-COUNT" title="(mutual-recursion
 (defun max-form-count (term)
   (the (unsigned-byte 60)
        (cond ((variablep term) 0)
              ((fquotep term) (cons-count-bounded (cadr term)))
...">max-form-count</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
        (<a class="sym-link local-def" href="#def-controller-complexity1" data-sym="CONTROLLER-COMPLEXITY1" title="(defun controller-complexity1 (flg args controller-pocket)
  (cond ((null args) 0)
        ((eq (car controller-pocket) flg)
         (+ (max-form-count (car args))
            (controller-complexity1 flg (cdr args) (cdr controller-pocket))))">controller-complexity1</a> flg
          (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
          (cdr controller-pocket))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-controller-complexity1" data-sym="CONTROLLER-COMPLEXITY1" title="(defun controller-complexity1 (flg args controller-pocket)
  (cond ((null args) 0)
        ((eq (car controller-pocket) flg)
         (+ (max-form-count (car args))
            (controller-complexity1 flg (cdr args) (cdr controller-pocket))))">controller-complexity1</a> flg
        (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (cdr controller-pocket)))))</pre>
  </div>

<div class="form-block function" id="def-controller-complexity" data-defines="CONTROLLER-COMPLEXITY" data-references="FFN-SYMB,ASSOC-EQ,CDR,FARGS,CONTROLLER-COMPLEXITY1,CONTROLLER-ALIST,TERM,FLG,DEFUN" data-used-by="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP,CONTROLLER-POCKET-SIMPLERP" data-part-name="CONTROLLER-COMPLEXITY" data-part-args="CONTROLLER-ALIST,TERM,FLG" data-part-body="CONTROLLER-ALIST,FFN-SYMB,ASSOC-EQ,CDR,TERM,FARGS,FLG,CONTROLLER-COMPLEXITY1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONTROLLER-COMPLEXITY">controller-complexity</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-controller-complexity" data-sym="CONTROLLER-COMPLEXITY" title="(defun controller-complexity (flg term controller-alist)
  (controller-complexity1 flg (fargs term)
                          (cdr (assoc-eq (ffn-symb term) controller-alist))))">controller-complexity</a>
  (flg term controller-alist)
  (<a class="sym-link local-def" href="#def-controller-complexity1" data-sym="CONTROLLER-COMPLEXITY1" title="(defun controller-complexity1 (flg args controller-pocket)
  (cond ((null args) 0)
        ((eq (car controller-pocket) flg)
         (+ (max-form-count (car args))
            (controller-complexity1 flg (cdr args) (cdr controller-pocket))))">controller-complexity1</a> flg
    (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
    (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) controller-alist))))</pre>
  </div>

<div class="form-block function" id="def-controller-pocket-simplerp" data-defines="CONTROLLER-POCKET-SIMPLERP" data-references="T,CONTROLLER-COMPLEXITY,<,CONTROLLER-ALIST,RESULT,CALL,DEFUN" data-used-by="REWRITE-FNCALLP" data-part-name="CONTROLLER-POCKET-SIMPLERP" data-part-args="CONTROLLER-ALIST,RESULT,CALL" data-part-body="CALL,CONTROLLER-ALIST,RESULT,T,CONTROLLER-COMPLEXITY,<" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONTROLLER-POCKET-SIMPLERP">controller-pocket-simplerp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-controller-pocket-simplerp" data-sym="CONTROLLER-POCKET-SIMPLERP" title="(defun controller-pocket-simplerp (call result controller-alist)
  (&lt; (controller-complexity t result controller-alist)
     (controller-complexity t call controller-alist)))">controller-pocket-simplerp</a>
  (call result controller-alist)
  (&lt; (<a class="sym-link local-def" href="#def-controller-complexity" data-sym="CONTROLLER-COMPLEXITY" title="(defun controller-complexity (flg term controller-alist)
  (controller-complexity1 flg (fargs term)
                          (cdr (assoc-eq (ffn-symb term) controller-alist))))">controller-complexity</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> result controller-alist)
    (<a class="sym-link local-def" href="#def-controller-complexity" data-sym="CONTROLLER-COMPLEXITY" title="(defun controller-complexity (flg term controller-alist)
  (controller-complexity1 flg (fargs term)
                          (cdr (assoc-eq (ffn-symb term) controller-alist))))">controller-complexity</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> call controller-alist)))</pre>
  </div>

<div class="form-block function" id="def-constant-controller-pocketp1" data-defines="CONSTANT-CONTROLLER-POCKETP1" data-references="CDR,QUOTEP,AND,CAR,T,NULL,COND,CONTROLLER-POCKET,ARGS,DEFUN" data-used-by="CONSTANT-CONTROLLER-POCKETP" data-part-name="CONSTANT-CONTROLLER-POCKETP1" data-part-args="CONTROLLER-POCKET,ARGS" data-part-body="CDR,CONSTANT-CONTROLLER-POCKETP1,QUOTEP,AND,CONTROLLER-POCKET,CAR,T,ARGS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONSTANT-CONTROLLER-POCKETP1">constant-controller-pocketp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-constant-controller-pocketp1" data-sym="CONSTANT-CONTROLLER-POCKETP1" title="(defun constant-controller-pocketp1 (args controller-pocket)
  (cond ((null args) t)
        ((car controller-pocket)
         (and (quotep (car args))
              (constant-controller-pocketp1 (cdr args)
...">constant-controller-pocketp1</a>
  (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> controller-pocket)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((car controller-pocket) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
        (<a class="sym-link local-def" href="#def-constant-controller-pocketp1" data-sym="CONSTANT-CONTROLLER-POCKETP1" title="(defun constant-controller-pocketp1 (args controller-pocket)
  (cond ((null args) t)
        ((car controller-pocket)
         (and (quotep (car args))
              (constant-controller-pocketp1 (cdr args)
...">constant-controller-pocketp1</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
          (cdr controller-pocket))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-constant-controller-pocketp1" data-sym="CONSTANT-CONTROLLER-POCKETP1" title="(defun constant-controller-pocketp1 (args controller-pocket)
  (cond ((null args) t)
        ((car controller-pocket)
         (and (quotep (car args))
              (constant-controller-pocketp1 (cdr args)
...">constant-controller-pocketp1</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (cdr controller-pocket)))))</pre>
  </div>

<div class="form-block function" id="def-constant-controller-pocketp" data-defines="CONSTANT-CONTROLLER-POCKETP" data-references="FFN-SYMB,ASSOC-EQ,CDR,FARGS,CONSTANT-CONTROLLER-POCKETP1,CONTROLLER-ALIST,TERM,DEFUN" data-used-by="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP" data-part-name="CONSTANT-CONTROLLER-POCKETP" data-part-args="CONTROLLER-ALIST,TERM" data-part-body="CONTROLLER-ALIST,FFN-SYMB,ASSOC-EQ,CDR,TERM,FARGS,CONSTANT-CONTROLLER-POCKETP1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONSTANT-CONTROLLER-POCKETP">constant-controller-pocketp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-constant-controller-pocketp" data-sym="CONSTANT-CONTROLLER-POCKETP" title="(defun constant-controller-pocketp (term controller-alist)
  (constant-controller-pocketp1 (fargs term)
                                (cdr
                                 (assoc-eq (ffn-symb term) controller-alist))))">constant-controller-pocketp</a>
  (term controller-alist)
  (<a class="sym-link local-def" href="#def-constant-controller-pocketp1" data-sym="CONSTANT-CONTROLLER-POCKETP1" title="(defun constant-controller-pocketp1 (args controller-pocket)
  (cond ((null args) t)
        ((car controller-pocket)
         (and (quotep (car args))
              (constant-controller-pocketp1 (cdr args)
...">constant-controller-pocketp1</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
    (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) controller-alist))))</pre>
  </div>

<div class="form-block function" id="def-some-controller-pocket-constant-and-non-controller-simplerp" data-defines="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP" data-references="CONTROLLER-COMPLEXITY,<,CONSTANT-CONTROLLER-POCKETP,AND,CONTROLLER-ALIST,RESULT,CALL,DEFUN" data-used-by="REWRITE-FNCALLP" data-part-name="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP" data-part-args="CONTROLLER-ALIST,RESULT,CALL" data-part-body="CALL,CONTROLLER-COMPLEXITY,<,CONTROLLER-ALIST,RESULT,CONSTANT-CONTROLLER-POCKETP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP">some-controller-pocket-constant-and-non-controller-simplerp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-some-controller-pocket-constant-and-non-controller-simplerp" data-sym="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP" title="(defun some-controller-pocket-constant-and-non-controller-simplerp
       (call result controller-alist)
  (and (constant-controller-pocketp result controller-alist)
       (&lt; (controller-complexity nil result controller-alist)
          (controller-complexity nil call controller-alist))))">some-controller-pocket-constant-and-non-controller-simplerp</a>
  (call result controller-alist)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-constant-controller-pocketp" data-sym="CONSTANT-CONTROLLER-POCKETP" title="(defun constant-controller-pocketp (term controller-alist)
  (constant-controller-pocketp1 (fargs term)
                                (cdr
                                 (assoc-eq (ffn-symb term) controller-alist))))">constant-controller-pocketp</a> result controller-alist)
    (&lt; (<a class="sym-link local-def" href="#def-controller-complexity" data-sym="CONTROLLER-COMPLEXITY" title="(defun controller-complexity (flg term controller-alist)
  (controller-complexity1 flg (fargs term)
                          (cdr (assoc-eq (ffn-symb term) controller-alist))))">controller-complexity</a> nil result controller-alist)
      (<a class="sym-link local-def" href="#def-controller-complexity" data-sym="CONTROLLER-COMPLEXITY" title="(defun controller-complexity (flg term controller-alist)
  (controller-complexity1 flg (fargs term)
                          (cdr (assoc-eq (ffn-symb term) controller-alist))))">controller-complexity</a> nil call controller-alist))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-rewrite-fncallp" data-defines="REWRITE-FNCALLP" data-references="CDR,CAR,NULL,LST,SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP,CONTROLLER-POCKET-SIMPLERP,DUMB-OCCUR-LST,ALL-ARGS-OCCUR-IN-TOP-CLAUSEP,OR,AND,EQ,FFN-SYMB,MEMBER-EQ,IF,FARGS,REWRITE-FNCALLP-LISTP,FLAMBDA-APPLICATIONP,FQUOTEP,T,VARIABLEP,COND,CONTROLLER-ALIST,CURRENT-CLAUSE,TOP-CLAUSE,CLIQUEP,RESULT,CALL,DEFUN,MUTUAL-RECURSION" data-used-by="REWRITE,*BRKPT2-ALIASES*,TILDE-@-FAILURE-REASON-FREE-PHRASE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-FNCALLP">rewrite-fncallp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a>
    (call result
      cliquep
      top-clause
      current-clause
      controller-alist)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> result) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> result) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> result) (rewrite-fncallp-listp call
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> result)
          cliquep
          top-clause
          current-clause
          controller-alist))
      ((if cliquep
         (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> result) cliquep)
         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> result) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> call))) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-all-args-occur-in-top-clausep" data-sym="ALL-ARGS-OCCUR-IN-TOP-CLAUSEP" title="(defun all-args-occur-in-top-clausep (args top-clause)
  (cond ((null args) t)
        (t
         (and (dumb-occur-lst (car args) top-clause)
              (all-args-occur-in-top-clausep (cdr args) top-clause)))))">all-args-occur-in-top-clausep</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> result) top-clause)
            (dumb-occur-lst result current-clause)
            (<a class="sym-link local-def" href="#def-controller-pocket-simplerp" data-sym="CONTROLLER-POCKET-SIMPLERP" title="(defun controller-pocket-simplerp (call result controller-alist)
  (&lt; (controller-complexity t result controller-alist)
     (controller-complexity t call controller-alist)))">controller-pocket-simplerp</a> call result controller-alist)
            (<a class="sym-link local-def" href="#def-some-controller-pocket-constant-and-non-controller-simplerp" data-sym="SOME-CONTROLLER-POCKET-CONSTANT-AND-NON-CONTROLLER-SIMPLERP" title="(defun some-controller-pocket-constant-and-non-controller-simplerp
       (call result controller-alist)
  (and (constant-controller-pocketp result controller-alist)
       (&lt; (controller-complexity nil result controller-alist)
          (controller-complexity nil call controller-alist))))">some-controller-pocket-constant-and-non-controller-simplerp</a> call
              result
              controller-alist))
          (rewrite-fncallp-listp call
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> result)
            cliquep
            top-clause
            current-clause
            controller-alist)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (rewrite-fncallp-listp call
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> result)
          cliquep
          top-clause
          current-clause
          controller-alist))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-fncallp-listp
    (call lst
      cliquep
      top-clause
      current-clause
      controller-alist)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a> call
            (car lst)
            cliquep
            top-clause
            current-clause
            controller-alist)
          (rewrite-fncallp-listp call
            (cdr lst)
            cliquep
            top-clause
            current-clause
            controller-alist))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-contains-rewritable-callp" data-defines="CONTAINS-REWRITABLE-CALLP" data-references="CDR,CAR,OR,NULL,LST,T,MEMBER-EQUAL,NOT,EQ,FFN-SYMB,MEMBER-EQ,IF,AND,FARGS,CONTAINS-REWRITABLE-CALLP-LST,FLAMBDA-APPLICATIONP,FQUOTEP,VARIABLEP,COND,TERMS-TO-BE-IGNORED-BY-REWRITE,CLIQUEP,TERM,FN,DEFUN,MUTUAL-RECURSION" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONTAINS-REWRITABLE-CALLP">contains-rewritable-callp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-contains-rewritable-callp" data-sym="CONTAINS-REWRITABLE-CALLP" title="(mutual-recursion
 (defun contains-rewritable-callp
        (fn term cliquep terms-to-be-ignored-by-rewrite)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
...">contains-rewritable-callp</a>
    (fn term cliquep terms-to-be-ignored-by-rewrite)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) nil)
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) nil)
      ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (contains-rewritable-callp-lst fn
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
          cliquep
          terms-to-be-ignored-by-rewrite))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if cliquep
           (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) cliquep)
           (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) fn))
         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> term terms-to-be-ignored-by-rewrite))) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (contains-rewritable-callp-lst fn
          (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
          cliquep
          terms-to-be-ignored-by-rewrite))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> contains-rewritable-callp-lst
    (fn lst cliquep terms-to-be-ignored-by-rewrite)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-contains-rewritable-callp" data-sym="CONTAINS-REWRITABLE-CALLP" title="(mutual-recursion
 (defun contains-rewritable-callp
        (fn term cliquep terms-to-be-ignored-by-rewrite)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
...">contains-rewritable-callp</a> fn
            (car lst)
            cliquep
            terms-to-be-ignored-by-rewrite)
          (contains-rewritable-callp-lst fn
            (cdr lst)
            cliquep
            terms-to-be-ignored-by-rewrite))))))</pre>
  </div>

<div class="form-block other" id="form-177" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> linear-lemma
  ((nume . hyps) max-term
    concl
    backchain-limit-lst
    rune . match-free)
  nil)</pre>
  </div>

<div class="form-block other" id="form-178" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> current-literal (not-flg . atm) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-179" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> rewrite-constant
  ((((current-enabled-structure . pt) nonlinearp . <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>) (heavy-linearp . oncep-override)
     rewriter-state . backchain-limit-rw) ((restrictions-alist . current-literal) <a class="sym-link system" href="axioms.html#def-case-split-limitations" data-sym="CASE-SPLIT-LIMITATIONS">case-split-limitations</a> . expand-lst)
    ((terms-to-be-ignored-by-rewrite . active-theory) fns-to-be-ignored-by-rewrite . top-clause)
    (force-info . current-clause)
    rw-cache-state . <a class="sym-link system" href="prove.html#def-splitter-output" data-sym="SPLITTER-OUTPUT">splitter-output</a>)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block constant" id="def-_2Adefault-rw-cache-state_2A" data-defines="*DEFAULT-RW-CACHE-STATE*" data-references="DEFCONST" data-used-by="*EMPTY-REWRITE-CONSTANT*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*DEFAULT-RW-CACHE-STATE*">*default-rw-cache-state*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Adefault-rw-cache-state_2A" data-sym="*DEFAULT-RW-CACHE-STATE*" title="(defconst *default-rw-cache-state* :atom)">*default-rw-cache-state*</a> <span class="keyword">:atom</span>)</pre>
  </div>

<div class="form-block constant" id="def-_2Aempty-rewrite-constant_2A" data-defines="*EMPTY-REWRITE-CONSTANT*" data-references="*DEFAULT-RW-CACHE-STATE*,T,REWRITE-CONSTANT,MAKE,DEFCONST" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*EMPTY-REWRITE-CONSTANT*">*empty-rewrite-constant*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Aempty-rewrite-constant_2A" data-sym="*EMPTY-REWRITE-CONSTANT*" title="(defconst *empty-rewrite-constant*
          (make rewrite-constant :active-theory :standard :rewriter-state nil
                :case-split-limitations nil :forbidden-fns nil :splitter-output
                t :current-clause nil :current-enabled-structure nil
                :current-literal nil :expand-lst nil
...">*empty-rewrite-constant*</a>
  (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> rewrite-constant
    <span class="keyword">:active-theory</span> <span class="keyword">:standard</span> <span class="keyword">:rewriter-state</span> nil
    <span class="keyword">:case-split-limitations</span> nil
    <span class="keyword">:forbidden-fns</span> nil
    <span class="keyword">:splitter-output</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    <span class="keyword">:current-clause</span> nil
    <span class="keyword">:current-enabled-structure</span> nil
    <span class="keyword">:current-literal</span> nil
    <span class="keyword">:expand-lst</span> nil
    <span class="keyword">:fns-to-be-ignored-by-rewrite</span> nil
    <span class="keyword">:force-info</span> nil
    <span class="keyword">:nonlinearp</span> nil
    <span class="keyword">:heavy-linearp</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    <span class="keyword">:oncep-override</span> <span class="keyword">:clear</span> <span class="keyword">:pt</span> nil
    <span class="keyword">:restrictions-alist</span> nil
    <span class="keyword">:rw-cache-state</span> <a class="sym-link local-def" href="#def-_2Adefault-rw-cache-state_2A" data-sym="*DEFAULT-RW-CACHE-STATE*" title="(defconst *default-rw-cache-state* :atom)">*default-rw-cache-state*</a>
    <span class="keyword">:terms-to-be-ignored-by-rewrite</span> nil
    <span class="keyword">:top-clause</span> nil
    <span class="keyword">:backchain-limit-rw</span> nil))</pre>
  </div>

<div class="form-block other" id="form-182" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> heavy-linear-p nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-183" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> heavy-linear-p <a class="sym-link system" href="axioms.html#def-constant-nil-function-arity-0" data-sym="CONSTANT-NIL-FUNCTION-ARITY-0">constant-nil-function-arity-0</a>)</pre>
  </div>

<div class="form-block other" id="form-184" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> metafunction-context
  (rdepth type-alist
    obj
    geneqv
    wrld
    fnstack
    ancestors
    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
    simplify-clause-pot-lst
    rcnst
    gstack
    ttree
    unify-subst)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-ok-to-force" data-defines="OK-TO-FORCE" data-references="HARD,ER,WEAK,QUOTE,*FORCE-XNUME*,ENABLED-NUMEP,AND,T,EQ,COND,REWRITE-CONSTANT,ACCESS,FORCE-INFO,LET,RCNST,DEFUN" data-used-by="REWRITE,PUSH-WARRANTS,REWRITE-IF1" data-part-name="OK-TO-FORCE" data-part-args="RCNST" data-part-body="OK-TO-FORCE,HARD,ER,WEAK,QUOTE,*FORCE-XNUME*,ENABLED-NUMEP,AND,T,EQ,COND,RCNST,REWRITE-CONSTANT,ACCESS,FORCE-INFO,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="OK-TO-FORCE">ok-to-force</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
  (rcnst)
  (let ((force-info (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:force-info</span>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> force-info <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (enabled-numep <a class="sym-link system" href="axioms.html#def-_2Aforce-xnume_2A" data-sym="*FORCE-XNUME*">*force-xnume*</a>
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> force-info 'weak) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          '<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
          <span class="string">"OK-TO-FORCE called on apparently uninitialized rewrite constant, ~
           ~x0."</span>
          rcnst)))))</pre>
  </div>

<div class="form-block function" id="def-plist-to-alist" data-defines="PLIST-TO-ALIST" data-references="CDDR,CADR,CAR,CONS,T,NULL,COND,LST,DEFUN" data-used-by="REWRITE-ENTRY" data-part-name="PLIST-TO-ALIST" data-part-args="LST" data-part-body="CDDR,PLIST-TO-ALIST,CADR,CAR,CONS,T,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PLIST-TO-ALIST">plist-to-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-plist-to-alist" data-sym="PLIST-TO-ALIST" title="(defun plist-to-alist (lst)
  (cond ((null lst) nil)
        (t (cons (cons (car lst) (cadr lst)) (plist-to-alist (cddr lst))))))">plist-to-alist</a>
  (lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (car lst) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> lst))
        (<a class="sym-link local-def" href="#def-plist-to-alist" data-sym="PLIST-TO-ALIST" title="(defun plist-to-alist (lst)
  (cond ((null lst) nil)
        (t (cons (cons (car lst) (cadr lst)) (plist-to-alist (cddr lst))))))">plist-to-alist</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> lst))))))</pre>
  </div>

<div class="form-block macro" id="def-adjust-rdepth" data-defines="ADJUST-RDEPTH" data-references="1-F,QUASIQUOTE,RDEPTH,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADJUST-RDEPTH">adjust-rdepth</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> (rdepth) `(<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> ,RDEPTH))</pre>
  </div>

<div class="form-block function" id="def-add-rewrite-args" data-defines="ADD-REWRITE-ARGS" data-references="CDR,CAR,ASSOC-EQ,PAIR,LET,CONS,T,NULL,COND,ALIST,KEYWORD-EXTRA-FORMALS,EXTRA-FORMALS,DEFUN" data-used-by="REWRITE-ENTRY" data-part-name="ADD-REWRITE-ARGS" data-part-args="ALIST,KEYWORD-EXTRA-FORMALS,EXTRA-FORMALS" data-part-body="ADD-REWRITE-ARGS,CDR,ALIST,KEYWORD-EXTRA-FORMALS,CAR,ASSOC-EQ,PAIR,LET,CONS,T,EXTRA-FORMALS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-REWRITE-ARGS">add-rewrite-args</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-rewrite-args" data-sym="ADD-REWRITE-ARGS" title="(defun add-rewrite-args (extra-formals keyword-extra-formals alist)
  (cond ((null extra-formals) nil)
        (t
         (cons
          (let ((pair (assoc-eq (car keyword-extra-formals) alist)))
...">add-rewrite-args</a>
  (extra-formals keyword-extra-formals alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> extra-formals) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car keyword-extra-formals) alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair (cdr pair)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (car extra-formals))))
        (<a class="sym-link local-def" href="#def-add-rewrite-args" data-sym="ADD-REWRITE-ARGS" title="(defun add-rewrite-args (extra-formals keyword-extra-formals alist)
  (cond ((null extra-formals) nil)
        (t
         (cons
          (let ((pair (assoc-eq (car keyword-extra-formals) alist)))
...">add-rewrite-args</a> (cdr extra-formals)
          (cdr keyword-extra-formals)
          alist)))))</pre>
  </div>

<div class="form-block other" id="form-189" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> step-limit-record (start strictp . sub-limit) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-step-limit-start" data-defines="STEP-LIMIT-START" data-references="W,STEP-LIMIT-FROM-TABLE,T,ACCESS,COND,STEP-LIMIT-RECORD,QUOTE,F-GET-GLOBAL,REC,LET,STATE,DEFUN" data-used-by="STEP-LIMIT-ERROR" data-part-name="STEP-LIMIT-START" data-part-args="STATE" data-part-body="W,STEP-LIMIT-FROM-TABLE,T,ACCESS,COND,STATE,STEP-LIMIT-RECORD,QUOTE,F-GET-GLOBAL,REC,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STEP-LIMIT-START">step-limit-start</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-step-limit-start" data-sym="STEP-LIMIT-START" title="(defun step-limit-start (state)
  (let ((rec (f-get-global &#39;step-limit-record state)))
    (cond (rec (access step-limit-record rec :start))
          (t (step-limit-from-table (w state))))))">step-limit-start</a>
  (state)
  (let ((rec (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'step-limit-record state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rec (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> step-limit-record rec <span class="keyword">:start</span>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-step-limit-from-table" data-sym="STEP-LIMIT-FROM-TABLE">step-limit-from-table</a> (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state))))))</pre>
  </div>

<div class="form-block function" id="def-step-limit-strictp" data-defines="STEP-LIMIT-STRICTP" data-references="T,ACCESS,COND,STEP-LIMIT-RECORD,QUOTE,F-GET-GLOBAL,REC,LET,STATE,DEFUN" data-used-by="DECREMENT-STEP-LIMIT" data-part-name="STEP-LIMIT-STRICTP" data-part-args="STATE" data-part-body="T,ACCESS,COND,STATE,STEP-LIMIT-RECORD,QUOTE,F-GET-GLOBAL,REC,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STEP-LIMIT-STRICTP">step-limit-strictp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-step-limit-strictp" data-sym="STEP-LIMIT-STRICTP" title="(defun step-limit-strictp (state)
  (let ((rec (f-get-global &#39;step-limit-record state)))
    (cond (rec (access step-limit-record rec :strictp)) (t nil))))">step-limit-strictp</a>
  (state)
  (let ((rec (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'step-limit-record state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rec (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> step-limit-record rec <span class="keyword">:strictp</span>)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))</pre>
  </div>

<div class="form-block function" id="def-initial-step-limit" data-defines="INITIAL-STEP-LIMIT" data-references="STEP-LIMIT-FROM-TABLE,T,ACCESS,COND,F-GET-GLOBAL,REC,LAST-STEP-LIMIT,STEP-LIMIT-RECORD,BOUNDP-GLOBAL,STATE-P,*DEFAULT-STEP-LIMIT*,<=,NATP,NULL,OR,ASSOC-EQ,CDR,VAL,LET,ACL2-DEFAULTS-TABLE,QUOTE,TABLE-ALIST,ALISTP,PLIST-WORLDP,AND,XARGS,DECLARE,STATE,WRLD,DEFUN" data-part-name="INITIAL-STEP-LIMIT" data-part-args="STATE,WRLD" data-part-declare="LAST-STEP-LIMIT,STEP-LIMIT-RECORD,BOUNDP-GLOBAL,STATE,STATE-P,*DEFAULT-STEP-LIMIT*,<=,NATP,NULL,OR,ASSOC-EQ,CDR,VAL,LET,ACL2-DEFAULTS-TABLE,QUOTE,TABLE-ALIST,ALISTP,WRLD,PLIST-WORLDP,AND,XARGS,DECLARE" data-part-body="WRLD,STEP-LIMIT-FROM-TABLE,T,LAST-STEP-LIMIT,ACCESS,OR,COND,STATE,STEP-LIMIT-RECORD,QUOTE,F-GET-GLOBAL,REC,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INITIAL-STEP-LIMIT">initial-step-limit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-initial-step-limit" data-sym="INITIAL-STEP-LIMIT" title="(defun initial-step-limit (wrld state)
  (declare
   (xargs :guard
    (and (plist-worldp wrld)
         (alistp (table-alist (quote acl2-defaults-table) wrld))
...">initial-step-limit</a>
  (wrld state)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld)
        (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'acl2-defaults-table wrld))
        (let ((val (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:step-limit</span> (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'acl2-defaults-table wrld)))))
          (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> val)
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> val) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> val <a class="sym-link system" href="axioms.html#def-_2Adefault-step-limit_2A" data-sym="*DEFAULT-STEP-LIMIT*">*default-step-limit*</a>))))
        (<a class="sym-link system" href="axioms.html#def-state-p" data-sym="STATE-P">state-p</a> state)
        (<a class="sym-link system" href="axioms.html#def-boundp-global" data-sym="BOUNDP-GLOBAL">boundp-global</a> 'step-limit-record state)
        (<a class="sym-link system" href="axioms.html#def-boundp-global" data-sym="BOUNDP-GLOBAL">boundp-global</a> 'last-step-limit state))))
  (let ((rec (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'step-limit-record state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rec (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> step-limit-record rec <span class="keyword">:sub-limit</span>)
          (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'last-step-limit state)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-step-limit-from-table" data-sym="STEP-LIMIT-FROM-TABLE">step-limit-from-table</a> wrld)))))</pre>
  </div>

<div class="form-block function" id="def-step-limit-error1" data-defines="STEP-LIMIT-ERROR1" data-references="HARD?,ER,PROG2$,SIGNED-BYTE,THE,IGNORABLE,DECLARE,STATE,WHERE,START,STR,CTX,DEFUN" data-used-by="STEP-LIMIT-ERROR" data-part-name="STEP-LIMIT-ERROR1" data-part-args="STATE,WHERE,START,STR,CTX" data-part-declare="STATE,IGNORABLE,DECLARE" data-part-body="WHERE,START,STR,CTX,HARD?,ER,PROG2$,SIGNED-BYTE,THE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STEP-LIMIT-ERROR1">step-limit-error1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-step-limit-error1" data-sym="STEP-LIMIT-ERROR1" title="(defun step-limit-error1 (ctx str start where state)
  (declare (ignorable state))
  (the (signed-byte 61) (prog2$ (er hard? ctx str start where) -1)))">step-limit-error1</a>
  (ctx str start where state)
  (declare (ignorable state))
  (<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>)
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard? ctx str start where) <span class="number">-1</span>)))</pre>
  </div>

<div class="form-block macro" id="def-step-limit-error" data-defines="STEP-LIMIT-ERROR" data-references="STEP-LIMIT-ERROR1,THE-FIXNUM,T,STATE,STEP-LIMIT-START,ER-SOFT,QUASIQUOTE,COND,STEP-LIMIT,QUOTE,CTX,STR,LET,SUPERIOR-CONTEXT-P,DEFMACRO" data-used-by="DECREMENT-STEP-LIMIT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="STEP-LIMIT-ERROR">step-limit-error</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-step-limit-error" data-sym="STEP-LIMIT-ERROR" title="(defmacro step-limit-error (superior-context-p)
  (let ((str
         &quot;The prover step-limit, which is ~x0 in the ~@1, has been ~
              exceeded.  See :DOC set-prover-step-limit.&quot;)
        (ctx &#39;&#39;step-limit))
...">step-limit-error</a>
  (superior-context-p)
  (let ((str <span class="string">"The prover step-limit, which is ~x0 in the ~@1, has been ~
              exceeded.  See :DOC set-prover-step-limit."</span>) (ctx ''step-limit))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (superior-context-p `(<a class="sym-link system" href="basis-a.html#def-er-soft" data-sym="ER-SOFT">er-soft</a> ,CTX
          <span class="string">"Step-limit"</span>
          ,STR
          (<a class="sym-link local-def" href="#def-step-limit-start" data-sym="STEP-LIMIT-START" title="(defun step-limit-start (state)
  (let ((rec (f-get-global &#39;step-limit-record state)))
    (cond (rec (access step-limit-record rec :start))
          (t (step-limit-from-table (w state))))))">step-limit-start</a> state)
          <span class="string">"context immediately above the one just completed"</span>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> `(<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> (<a class="sym-link local-def" href="#def-step-limit-error1" data-sym="STEP-LIMIT-ERROR1" title="(defun step-limit-error1 (ctx str start where state)
  (declare (ignorable state))
  (the (signed-byte 61) (prog2$ (er hard? ctx str start where) -1)))">step-limit-error1</a> ,CTX
            ,STR
            (<a class="sym-link local-def" href="#def-step-limit-start" data-sym="STEP-LIMIT-START" title="(defun step-limit-start (state)
  (let ((rec (f-get-global &#39;step-limit-record state)))
    (cond (rec (access step-limit-record rec :start))
          (t (step-limit-from-table (w state))))))">step-limit-start</a> state)
            <span class="string">"current context"</span>
            state))))))</pre>
  </div>

<div class="form-block macro" id="def-decrement-step-limit" data-defines="DECREMENT-STEP-LIMIT" data-references="STEP-LIMIT-ERROR,STATE,STEP-LIMIT-STRICTP,ASSERT$,T,EQL,1-F,THE-FIXNUM,<,COND,SIGNED-BYTE,THE,QUASIQUOTE,SYMBOLP,XARGS,DECLARE,STEP-LIMIT,DEFMACRO" data-used-by="REWRITE-ENTRY" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECREMENT-STEP-LIMIT">decrement-step-limit</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-decrement-step-limit" data-sym="DECREMENT-STEP-LIMIT" title="(defmacro decrement-step-limit (step-limit)
  (declare (xargs :guard (symbolp step-limit)))
  `(the (signed-byte 61)
        (cond ((&lt; 0 (the-fixnum ,step-limit)) (|1-F| ,step-limit))
              ((eql -1 (the-fixnum ,step-limit)) -1)
...">decrement-step-limit</a>
  (step-limit)
  (declare (xargs <span class="keyword">:guard</span> (symbolp step-limit)))
  `(<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((&lt; <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> ,STEP-LIMIT)) (<a class="sym-link system" href="basis-a.html#def-1-f" data-sym="1-F">1-f</a> ,STEP-LIMIT))
      ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> <span class="number">-1</span> (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> ,STEP-LIMIT)) <span class="number">-1</span>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> ,STEP-LIMIT))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-step-limit-strictp" data-sym="STEP-LIMIT-STRICTP" title="(defun step-limit-strictp (state)
  (let ((rec (f-get-global &#39;step-limit-record state)))
    (cond (rec (access step-limit-record rec :strictp)) (t nil))))">step-limit-strictp</a> state) (<a class="sym-link local-def" href="#def-step-limit-error" data-sym="STEP-LIMIT-ERROR" title="(defmacro step-limit-error (superior-context-p)
  (let ((str
         &quot;The prover step-limit, which is ~x0 in the ~@1, has been ~
              exceeded.  See :DOC set-prover-step-limit.&quot;)
        (ctx &#39;&#39;step-limit))
...">step-limit-error</a> nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="number">-1</span>)))))))</pre>
  </div>

<div class="form-block macro" id="def-rewrite-entry" data-defines="REWRITE-ENTRY" data-references="ASSOC-KEYWORD,STEP-LIMIT-TAIL,SIGNED-BYTE,TYPE,DECREMENT-STEP-LIMIT,QUASIQUOTE,CALL1,LET,T,NOT,COND,CALL,REMOVE-KEYWORD,REWRITE,CAAR,EQ,IF,PLIST-TO-ALIST,TTREE,GSTACK,RCNST,SIMPLIFY-CLAUSE-POT-LST,BACKCHAIN-LIMIT,ANCESTORS,FNSTACK,STATE,WRLD,PEQUIV-INFO,GENEQV,OBJ,TYPE-ALIST,STEP-LIMIT,RDEPTH,QUOTE,ADD-REWRITE-ARGS,APPEND,CALL0,LET*,CDR,KEYWORD-VALUE-LISTP,CAR,CONSP,TRUE-LISTP,AND,XARGS,DECLARE,ARGS,&REST,DEFMACRO" data-used-by="REWRITE,REWRITE-STANDARD-EXIT,REWRITE-ENTRY-EXTENDING-FAILURE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-ENTRY">rewrite-entry</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a>
  (&amp;rest <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
        (consp (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
        (<a class="sym-link system" href="axioms.html#def-keyword-value-listp" data-sym="KEYWORD-VALUE-LISTP">keyword-value-listp</a> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)))))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((call0 (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
         (<a class="sym-link local-def" href="#def-add-rewrite-args" data-sym="ADD-REWRITE-ARGS" title="(defun add-rewrite-args (extra-formals keyword-extra-formals alist)
  (cond ((null extra-formals) nil)
        (t
         (cons
          (let ((pair (assoc-eq (car keyword-extra-formals) alist)))
...">add-rewrite-args</a> '(rdepth step-limit
             type-alist
             obj
             geneqv
             pequiv-info
             wrld
             state
             fnstack
             ancestors
             <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
             simplify-clause-pot-lst
             rcnst
             gstack
             ttree)
           '(<span class="keyword">:rdepth</span> <span class="keyword">:step-limit</span> <span class="keyword">:type-alist</span> <span class="keyword">:obj</span> <span class="keyword">:geneqv</span> <span class="keyword">:pequiv-info</span> <span class="keyword">:wrld</span> <span class="keyword">:state</span> <span class="keyword">:fnstack</span> <span class="keyword">:ancestors</span> <span class="keyword">:backchain-limit</span> <span class="keyword">:simplify-clause-pot-lst</span> <span class="keyword">:rcnst</span> <span class="keyword">:gstack</span> <span class="keyword">:ttree</span>)
           (<a class="sym-link local-def" href="#def-plist-to-alist" data-sym="PLIST-TO-ALIST" title="(defun plist-to-alist (lst)
  (cond ((null lst) nil)
        (t (cons (cons (car lst) (cadr lst)) (plist-to-alist (cddr lst))))))">plist-to-alist</a> (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) '<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a>)
               (remove-keyword <span class="keyword">:step-limit</span> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))
               (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)))))) (call (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) '<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a>)) call0)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((call1 `(let ((step-limit (<a class="sym-link local-def" href="#def-decrement-step-limit" data-sym="DECREMENT-STEP-LIMIT" title="(defmacro decrement-step-limit (step-limit)
  (declare (xargs :guard (symbolp step-limit)))
  `(the (signed-byte 61)
        (cond ((&lt; 0 (the-fixnum ,step-limit)) (|1-F| ,step-limit))
              ((eql -1 (the-fixnum ,step-limit)) -1)
...">decrement-step-limit</a> step-limit)))
                   (declare (type (signed-byte <span class="number">61</span>) step-limit))
                   ,CALL0)) (step-limit-tail (<a class="sym-link system" href="axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> <span class="keyword">:step-limit</span> (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (step-limit-tail `(let ((step-limit ,(CADR STEP-LIMIT-TAIL)))
                    ,CALL1))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> call1)))))))
    call))</pre>
  </div>

<div class="form-block constant" id="def-_2Afake-rune-for-linear_2A" data-defines="*FAKE-RUNE-FOR-LINEAR*" data-references="QUOTE,DEFCONST" data-used-by="REWRITE,*FAKE-RUNE-ALIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*FAKE-RUNE-FOR-LINEAR*">*fake-rune-for-linear*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear_2A" data-sym="*FAKE-RUNE-FOR-LINEAR*" title="(defconst *fake-rune-for-linear* &#39;(:fake-rune-for-linear nil))">*fake-rune-for-linear*</a>
  '(<span class="keyword">:fake-rune-for-linear</span> nil))</pre>
  </div>

<div class="form-block constant" id="def-_2Afake-rune-for-linear-equalities_2A" data-defines="*FAKE-RUNE-FOR-LINEAR-EQUALITIES*" data-references="QUOTE,DEFCONST" data-used-by="*FAKE-RUNE-ALIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*FAKE-RUNE-FOR-LINEAR-EQUALITIES*">*fake-rune-for-linear-equalities*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear-equalities_2A" data-sym="*FAKE-RUNE-FOR-LINEAR-EQUALITIES*" title="(defconst *fake-rune-for-linear-equalities*
          &#39;(:fake-rune-for-linear-equalities nil))">*fake-rune-for-linear-equalities*</a>
  '(<span class="keyword">:fake-rune-for-linear-equalities</span> nil))</pre>
  </div>

<div class="form-block other" id="form-199" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> gframe (sys-fn bkptr . <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block macro" id="def-push-gframe" data-defines="PUSH-GFRAME" data-references="T,GSTACK,LIST*,GFRAME,MAKE,CONS,DMRP,STATE,GSTACKP,QUOTE,F-GET-GLOBAL,OR,COND,QUASIQUOTE,ARGS,&REST,BKPTR,SYS-FN,DEFMACRO" data-used-by="REWRITE,RELIEVE-HYP-SYNP,INITIAL-GSTACK" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-GFRAME">push-gframe</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a>
  (sys-fn bkptr &amp;rest <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
  `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
       (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'dmrp state)) (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> gframe
          <span class="keyword">:sys-fn</span> ,SYS-FN
          <span class="keyword">:bkptr</span> ,BKPTR
          <span class="keyword">:args</span> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> ,@ARGS))
        gstack))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block macro" id="def-initial-gstack" data-defines="INITIAL-GSTACK" data-references="PUSH-GFRAME,GSTACK,LET,QUASIQUOTE,ARGS,&REST,BKPTR,SYS-FN,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="INITIAL-GSTACK">initial-gstack</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-initial-gstack" data-sym="INITIAL-GSTACK" title="(defmacro initial-gstack (sys-fn bkptr &amp;rest args)
  `(let ((gstack nil))
     (push-gframe ,sys-fn ,bkptr ,@args)))">initial-gstack</a>
  (sys-fn bkptr &amp;rest <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
  `(let ((gstack nil))
    (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> ,SYS-FN ,BKPTR ,@ARGS)))</pre>
  </div>

<div class="form-block function" id="def-tilde-_40-bkptr-phrase" data-defines="TILDE-@-BKPTR-PHRASE" data-references="SYNP,NON-LINEAR-ARITHMETIC,ADD-TERMS-AND-LEMMAS,SETUP-SIMPLIFY-CLAUSE-POT-LST,HARD,ER,OTHERWISE,PROOF-BUILDER,FORCED-ASSUMPTION,MULTIPLY-ALISTS2,NTH-UPDATE,META,RHS,EQUAL-CONSP-HACK-CDR,EQUAL-CONSP-HACK-CAR,EXPANSION,REWRITTEN-BODY,LAMBDA-OBJECT-BODY,LAMBDA-BODY,BODY,SYMBOLP,CDR,CONSP,T,SIMPLIFY-CLAUSE,EQ,LIST,MSG,ADD-LINEAR-LEMMA,REWRITE-QUOTED-CONSTANT-WITH-LEMMA,REWRITE-WITH-LEMMA,QUOTE,MEMBER-EQ,INTEGERP,COND,REWRITE,CASE,BKPTR,CALLED-SYS-FN,CALLING-SYS-FN,DEFUN" data-used-by="CW-GFRAME" data-part-name="TILDE-@-BKPTR-PHRASE" data-part-args="BKPTR,CALLED-SYS-FN,CALLING-SYS-FN" data-part-body="SYNP,NON-LINEAR-ARITHMETIC,ADD-TERMS-AND-LEMMAS,SETUP-SIMPLIFY-CLAUSE-POT-LST,TILDE-@-BKPTR-PHRASE,HARD,ER,OTHERWISE,PROOF-BUILDER,FORCED-ASSUMPTION,MULTIPLY-ALISTS2,NTH-UPDATE,META,RHS,EQUAL-CONSP-HACK-CDR,EQUAL-CONSP-HACK-CAR,EXPANSION,REWRITTEN-BODY,LAMBDA-OBJECT-BODY,LAMBDA-BODY,BODY,SYMBOLP,CDR,CONSP,T,SIMPLIFY-CLAUSE,EQ,LIST,MSG,ADD-LINEAR-LEMMA,REWRITE-QUOTED-CONSTANT-WITH-LEMMA,REWRITE-WITH-LEMMA,QUOTE,CALLING-SYS-FN,MEMBER-EQ,BKPTR,INTEGERP,COND,REWRITE,CALLED-SYS-FN,CASE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-@-BKPTR-PHRASE">tilde-@-bkptr-phrase</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_40-bkptr-phrase" data-sym="TILDE-@-BKPTR-PHRASE" title="(defun tilde-@-bkptr-phrase (calling-sys-fn called-sys-fn bkptr)
  (case called-sys-fn
    (rewrite
     (cond
      ((integerp bkptr)
...">tilde-@-bkptr-phrase</a>
  (calling-sys-fn called-sys-fn bkptr)
  (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> called-sys-fn
    (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((integerp bkptr) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> calling-sys-fn
               '(rewrite-with-lemma rewrite-quoted-constant-with-lemma
                 add-linear-lemma)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">" the atom of the ~n0 hypothesis"</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> bkptr)))
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> calling-sys-fn 'simplify-clause) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">" the atom of the ~n0 literal"</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> bkptr)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">" the ~n0 argument"</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> bkptr)))))
        ((consp bkptr) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">" the rhs of the ~n0 hypothesis"</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cdr bkptr))))
        ((symbolp bkptr) (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> bkptr
            (<a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> <span class="string">" the body"</span>)
            (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> <span class="string">" the lambda body"</span>)
            (<a class="sym-link system" href="axioms.html#def-lambda-object-body" data-sym="LAMBDA-OBJECT-BODY">lambda-object-body</a> <span class="string">" the body of the lambda object"</span>)
            (rewritten-body <span class="string">" the rewritten body"</span>)
            (expansion <span class="string">" the expansion"</span>)
            (equal-consp-hack-car <span class="string">" the equality of the cars"</span>)
            (equal-consp-hack-cdr <span class="string">" the equality of the cdrs"</span>)
            (rhs <span class="string">" the rhs of the conclusion"</span>)
            (meta <span class="string">" the result of the metafunction"</span>)
            (nth-update <span class="string">" the result of the nth/update rewriter"</span>)
            (multiply-alists2 <span class="string">" the product of two polys"</span>)
            (forced-assumption <span class="string">" a forced assumption"</span>)
            (proof-builder <span class="string">" proof-builder top level"</span>)
            (otherwise (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                '<a class="sym-link local-def" href="#def-tilde-_40-bkptr-phrase" data-sym="TILDE-@-BKPTR-PHRASE" title="(defun tilde-@-bkptr-phrase (calling-sys-fn called-sys-fn bkptr)
  (case called-sys-fn
    (rewrite
     (cond
      ((integerp bkptr)
...">tilde-@-bkptr-phrase</a>
                <span class="string">"When ~x0 calls ~x1 we get an unrecognized ~
                                      bkptr, ~x2."</span>
                calling-sys-fn
                called-sys-fn
                bkptr))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
            '<a class="sym-link local-def" href="#def-tilde-_40-bkptr-phrase" data-sym="TILDE-@-BKPTR-PHRASE" title="(defun tilde-@-bkptr-phrase (calling-sys-fn called-sys-fn bkptr)
  (case called-sys-fn
    (rewrite
     (cond
      ((integerp bkptr)
...">tilde-@-bkptr-phrase</a>
            <span class="string">"When ~x0 calls ~x1 we get an unrecognized bkptr, ~x2."</span>
            calling-sys-fn
            called-sys-fn
            bkptr))))
    ((rewrite-with-lemma setup-simplify-clause-pot-lst
       simplify-clause
       add-terms-and-lemmas
       add-linear-lemma
       non-linear-arithmetic
       <a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>) <span class="string">""</span>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-tilde-_40-bkptr-phrase" data-sym="TILDE-@-BKPTR-PHRASE" title="(defun tilde-@-bkptr-phrase (calling-sys-fn called-sys-fn bkptr)
  (case called-sys-fn
    (rewrite
     (cond
      ((integerp bkptr)
...">tilde-@-bkptr-phrase</a>
        <span class="string">"When ~x0 calls ~x1 we get an unrecognized bkptr, ~x2."</span>
        calling-sys-fn
        called-sys-fn
        bkptr))))</pre>
  </div>

<div class="form-block macro" id="def-get-rule-field" data-defines="GET-RULE-FIELD" data-references="HARD,ER,T,LINEAR-LEMMA,REWRITE-RULE,RECORD-TYPE,EQ,COND,QUASIQUOTE,MEMBER-EQ,NOT,AND,QUOTE,FIELDS,LET,XARGS,DECLARE,FIELD,X,DEFMACRO" data-used-by="BRKPT2,BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1,*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,TILDE-@-FAILURE-REASON-FREE-PHRASE,CW-GFRAME" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-RULE-FIELD">get-rule-field</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a>
  (x field)
  (declare (xargs <span class="keyword">:guard</span> (let ((fields '(<span class="keyword">:rune</span> <span class="keyword">:hyps</span> <span class="keyword">:lhs</span> <span class="keyword">:rhs</span> <span class="keyword">:max-term</span>)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> x fields)) (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> field fields)))))
  `(let ((x ,X))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> x) 'rewrite-rule) ,(COND
  ((MEMBER-EQ FIELD &#39;(:LHS :RHS))
   `(COND
     ((AND (EQ (ACCESS REWRITE-RULE X :SUBCLASS) &#39;REWRITE-QUOTED-CONSTANT)
           (EQL (CAR (ACCESS REWRITE-RULE X :HEURISTIC-INFO)) 2))
      (ACCESS REWRITE-RULE X
              ,(IF (EQ FIELD :LHS)
                   :RHS
                   :LHS)))
     (T (ACCESS REWRITE-RULE X ,FIELD))))
  ((EQ FIELD &#39;:MAX-TERM) :GET-RULE-FIELD-NONE)
  (T `(ACCESS REWRITE-RULE X ,FIELD))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> x) 'linear-lemma) ,(COND ((MEMBER-EQ FIELD &#39;(:LHS :RHS)) :GET-RULE-FIELD-NONE)
       (T `(ACCESS LINEAR-LEMMA X ,FIELD))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          '<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a>
          <span class="string">"The object ~x0 is neither a rewrite-rule record nor a ~
                 linear-lemma record."</span>
          x)))))</pre>
  </div>

<div class="form-block function" id="def-show-geneqv" data-defines="SHOW-GENEQV" data-references="CDR,CADR,IFF-IS-AN-EQUIVALENCE,EQUAL,OR,NON-PRIMS,QUOTE,CAR,CONGRUENCE-RULE,ACCESS,LIST,EQ,CONS,T,ENDP,COND,WITH-RUNES-P,X,DEFUN" data-used-by="REFINEMENT-FAILURE-BRKPT1,*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,CW-GFRAME" data-part-name="SHOW-GENEQV" data-part-args="WITH-RUNES-P,X" data-part-body="CDR,SHOW-GENEQV,CADR,IFF-IS-AN-EQUIVALENCE,EQUAL,OR,NON-PRIMS,QUOTE,CAR,CONGRUENCE-RULE,ACCESS,LIST,WITH-RUNES-P,EQ,CONS,T,X,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-GENEQV">show-geneqv</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a>
  (x with-runes-p)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> with-runes-p <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:equiv</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>)))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> with-runes-p 'non-prims) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>))
                   <span class="keyword">:fake-rune-for-anonymous-enabled-rule</span>)
                 (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>)
                   '(<span class="keyword">:equivalence</span> <a class="sym-link system" href="axioms.html#def-iff-is-an-equivalence" data-sym="IFF-IS-AN-EQUIVALENCE">iff-is-an-equivalence</a>))) (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:equiv</span>))
              ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>))
                 <span class="keyword">:congruence</span>) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:equiv</span>)
                  (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:equiv</span>)
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:rune</span>)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car x) <span class="keyword">:equiv</span>)))
        (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> (cdr x) with-runes-p)))))</pre>
  </div>

<div class="form-block function" id="def-cw-gframe" data-defines="CW-GFRAME" data-references="HARD,ER,OTHERWISE,SYNP-FN,SYNP,LENGTH,NON-LINEAR-ARITHMETIC,MSG,ADD-TERMS-AND-LEMMAS,CDR,ADD-LINEAR-LEMMA,EQUAL,REWRITE-RULE,GET-RULE-FIELD,CDDR,LEMMA,REWRITE-QUOTED-CONSTANT-WITH-LEMMA,REWRITE-WITH-LEMMA,NON-PRIMS,SHOW-GENEQV,T,EQ,COND,TILDE-*-ALIST-PHRASE,IF,QUOTE,TILDE-@-BKPTR-PHRASE,CDDDR,GENEQV,CADDR,OBJ,CADR,ALIST,CAR,TERM,LET,REWRITE,SETUP-SIMPLIFY-CLAUSE-POT-LST,CW,SIMPLIFY-CLAUSE,GFRAME,ACCESS,CASE,EVISC-TUPLE,FRAME,CALLING-SYS-FN,I,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,CW-GSTACK1" data-part-name="CW-GFRAME" data-part-args="EVISC-TUPLE,FRAME,CALLING-SYS-FN,I" data-part-body="CW-GFRAME,HARD,ER,OTHERWISE,SYNP-FN,SYNP,LENGTH,NON-LINEAR-ARITHMETIC,MSG,ADD-TERMS-AND-LEMMAS,CDR,ADD-LINEAR-LEMMA,EQUAL,REWRITE-RULE,GET-RULE-FIELD,CDDR,LEMMA,REWRITE-QUOTED-CONSTANT-WITH-LEMMA,REWRITE-WITH-LEMMA,NON-PRIMS,SHOW-GENEQV,T,EQ,COND,TILDE-*-ALIST-PHRASE,IF,QUOTE,CALLING-SYS-FN,TILDE-@-BKPTR-PHRASE,CDDDR,GENEQV,CADDR,OBJ,CADR,ALIST,CAR,TERM,LET,REWRITE,SETUP-SIMPLIFY-CLAUSE-POT-LST,EVISC-TUPLE,I,CW,SIMPLIFY-CLAUSE,FRAME,GFRAME,ACCESS,CASE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GFRAME">cw-gframe</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a>
  (i calling-sys-fn frame <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:sys-fn</span>)
    (simplify-clause (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Simplifying the clause~%     ~Y12"</span>
        i
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)
        <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
    (setup-simplify-clause-pot-lst (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Setting up the linear pot list for the clause~%     ~Y12"</span>
        i
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)
        <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
    (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (let ((term (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))) (alist (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)))
          (obj (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)))
          (geneqv (<a class="sym-link system" href="axioms.html#def-cdddr" data-sym="CDDDR">cdddr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))))
        (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Rewriting (to ~@6)~@1,~%     ~Y23,~#4~[~/   under the ~
                substitution~%~*5~]~#7~[~/~|   Geneqv: ~y8~]"</span>
          i
          (<a class="sym-link local-def" href="#def-tilde-_40-bkptr-phrase" data-sym="TILDE-@-BKPTR-PHRASE" title="(defun tilde-@-bkptr-phrase (calling-sys-fn called-sys-fn bkptr)
  (case called-sys-fn
    (rewrite
     (cond
      ((integerp bkptr)
...">tilde-@-bkptr-phrase</a> calling-sys-fn
            '<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a>
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:bkptr</span>))
          term
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
          (if alist
            <span class="number">1</span>
            <span class="number">0</span>)
          (tilde-*-alist-phrase alist <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <span class="number">5</span>)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj nil) <span class="string">"falsify"</span>)
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <span class="string">"establish"</span>)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">"simplify"</span>))
          (if geneqv
            <span class="number">1</span>
            <span class="number">0</span>)
          (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> geneqv 'non-prims))))
    ((rewrite-with-lemma rewrite-quoted-constant-with-lemma) (let ((term (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))) (lemma (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)))
          (geneqv (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))))
        (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Attempting to apply ~F1 to~%     ~Y23~|~#4~[~/   Preserving: ~x5~]~|~#6~[~/   Geneqv: ~y7~]"</span>
          i
          (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>)
          term
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
          (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>) 'equal)
            <span class="number">0</span>
            <span class="number">1</span>)
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
          (if geneqv
            <span class="number">1</span>
            <span class="number">0</span>)
          (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> geneqv 'non-prims))))
    (add-linear-lemma (let ((term (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))) (lemma (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))))
        (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Attempting to apply ~F1 to~%     ~Y23"</span>
          i
          (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>)
          term
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))
    (add-terms-and-lemmas (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Attempting to apply linear arithmetic to ~@1~%     ~Y23"</span>
        i
        (let ((obj (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj nil) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"falsify the term list"</span>))
            ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <span class="string">"establish the term list"</span>)
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">"the clause"</span>)))
        (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))
        <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
    (non-linear-arithmetic (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Attempting to apply non-linear arithmetic to the list of ~
              ~x1 var~#2~[~/s~]:~%     ~Y23"</span>
        i
        (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>))
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)
        <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
    (<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a> (let ((synp-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:args</span>)))
        (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0. Entering ~x1 for hypothesis ~x2~%"</span>
          i
          synp-fn
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:bkptr</span>))))
    (otherwise (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a>
        <span class="string">"Unrecognized sys-fn, ~x0"</span>
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe frame <span class="keyword">:sys-fn</span>)))))</pre>
  </div>

<div class="form-block function" id="def-cw-gstack1" data-defines="CW-GSTACK1" data-references="CDR,GFRAME,ACCESS,1+,CAR,CW-GFRAME,PROG2$,T,NULL,COND,EVISC-TUPLE,LST,CALLING-SYS-FN,I,DEFUN" data-used-by="CW-GSTACK-FOR-TERM-FN,CW-GSTACK-FN" data-part-name="CW-GSTACK1" data-part-args="EVISC-TUPLE,LST,CALLING-SYS-FN,I" data-part-body="CDR,GFRAME,ACCESS,1+,CW-GSTACK1,EVISC-TUPLE,CAR,CALLING-SYS-FN,I,CW-GFRAME,PROG2$,T,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK1">cw-gstack1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gstack1" data-sym="CW-GSTACK1" title="(defun cw-gstack1 (i calling-sys-fn lst evisc-tuple)
  (cond ((null lst) nil)
        (t
         (prog2$ (cw-gframe i calling-sys-fn (car lst) evisc-tuple)
                 (cw-gstack1 (1+ i) (access gframe (car lst) :sys-fn) (cdr lst)">cw-gstack1</a>
  (i calling-sys-fn lst <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> i calling-sys-fn (car lst) <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
        (<a class="sym-link local-def" href="#def-cw-gstack1" data-sym="CW-GSTACK1" title="(defun cw-gstack1 (i calling-sys-fn lst evisc-tuple)
  (cond ((null lst) nil)
        (t
         (prog2$ (cw-gframe i calling-sys-fn (car lst) evisc-tuple)
                 (cw-gstack1 (1+ i) (access gframe (car lst) :sys-fn) (cdr lst)">cw-gstack1</a> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> i)
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe (car lst) <span class="keyword">:sys-fn</span>)
          (cdr lst)
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))))</pre>
  </div>

<div class="form-block function" id="def-cw-gstack-fn" data-defines="CW-GSTACK-FN" data-references="TAKE,1-,NTHCDR,IF,MIN,N,LEN,REV-GSTACK,LET*,REVERSE,CW-GSTACK1,START,T,<=,CADR,CAR,NATP,LENGTH,EQL,TRUE-LISTP,<,INTEGERP,OR,HARD,ER,STANDARD-EVISC-TUPLEP,NOT,AND,CW,NULL,COND,CW-GSTACK,QUOTE,CTX,GSTACK,LET,FRAMES,EVISC-TUPLE,DEFUN" data-used-by="CW-GSTACK" data-part-name="CW-GSTACK-FN" data-part-args="FRAMES,EVISC-TUPLE" data-part-body="TAKE,1-,NTHCDR,IF,MIN,N,LEN,REV-GSTACK,LET*,REVERSE,CW-GSTACK1,START,T,<=,CADR,CAR,NATP,LENGTH,EQL,TRUE-LISTP,<,INTEGERP,FRAMES,OR,HARD,ER,STANDARD-EVISC-TUPLEP,NOT,EVISC-TUPLE,AND,CW,NULL,COND,CW-GSTACK,QUOTE,CTX,GSTACK,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FN">cw-gstack-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gstack-fn" data-sym="CW-GSTACK-FN" title="(defun cw-gstack-fn (evisc-tuple frames)
  (let ((gstack nil) (ctx &#39;cw-gstack))
    (cond
     ((null gstack)
      (cw &quot;There is no gstack to print.  If you have enabled stack monitoring ~
...">cw-gstack-fn</a>
  (<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> frames)
  (let ((gstack nil) (ctx '<a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> gstack) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"There is no gstack to print.  If you have enabled stack monitoring ~
           with ``:BRR t&#39;&#39; this is likely due to the loop you wish to ~
           investigate occurring in so-called preprocessing, where monitoring ~
           is not done, rather than in the rewriter proper.  You may obtain ~
           better results by replaying the problematic event with a hint ~
           of:~%((&quot;Goal&quot; :DO-NOT &#39;(preprocess)).~%See :DOC hints, in ~
           particular the discussion of :DO-NOT.~%"</span>))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-standard-evisc-tuplep" data-sym="STANDARD-EVISC-TUPLEP">standard-evisc-tuplep</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          ctx
          <span class="string">"Illegal :evisc-tuple argument to ~x0: ~x1.  See :DOC cw-gstack."</span>
          '<a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a>
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
      ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> frames)
           (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp frames) (&lt; <span class="number">0</span> frames))
           (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> frames)
             (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> frames) <span class="number">2</span>)
             (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (car frames))
             (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> frames))
             (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (car frames) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> frames))))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          ctx
          <span class="string">"Illegal :frames argument to ~x0: ~x1.  See :DOC cw-gstack."</span>
          '<a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a>
          frames))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((start (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> frames) (integerp frames)) <span class="number">1</span>)
               ((<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (car frames) (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> gstack)) (car frames))
               (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> gstack)))))
          (<a class="sym-link local-def" href="#def-cw-gstack1" data-sym="CW-GSTACK1" title="(defun cw-gstack1 (i calling-sys-fn lst evisc-tuple)
  (cond ((null lst) nil)
        (t
         (prog2$ (cw-gframe i calling-sys-fn (car lst) evisc-tuple)
                 (cw-gstack1 (1+ i) (access gframe (car lst) :sys-fn) (cdr lst)">cw-gstack1</a> start
            nil
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> frames) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> gstack))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rev-gstack (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> gstack)) (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> gstack))
                    (n (min (if (integerp frames)
                          frames
                          (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> frames))
                        <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a>)))
                  (<a class="sym-link system" href="axioms.html#def-nthcdr" data-sym="NTHCDR">nthcdr</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> start) (<a class="sym-link system" href="axioms.html#def-take" data-sym="TAKE">take</a> n rev-gstack)))))
            <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))))))</pre>
  </div>

<div class="form-block macro" id="def-cw-gstack" data-defines="CW-GSTACK" data-references="CW-GSTACK-FN,QUASIQUOTE,T,XARGS,DECLARE,FRAMES,EVISC-TUPLEP,QUOTE,EVISC-TUPLE,&KEY,DEFMACRO" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,CW-GSTACK-FN" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK">cw-gstack</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a>
  (&amp;key (<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> 'nil evisc-tuplep) (frames 'nil))
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  `(<a class="sym-link local-def" href="#def-cw-gstack-fn" data-sym="CW-GSTACK-FN" title="(defun cw-gstack-fn (evisc-tuple frames)
  (let ((gstack nil) (ctx &#39;cw-gstack))
    (cond
     ((null gstack)
      (cw &quot;There is no gstack to print.  If you have enabled stack monitoring ~
...">cw-gstack-fn</a> ,(IF EVISC-TUPLEP
     EVISC-TUPLE
     &#39;(TERM-EVISC-TUPLE T STATE))
    ,FRAMES))</pre>
  </div>

<div class="form-block other" id="form-209" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> brr-status
  (entry-code (brr-monitored-runes . brr-gstack)
    brr-local-alist . brr-previous-status)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-make-initial-brr-status" data-defines="MAKE-INITIAL-BRR-STATUS" data-references="BRR-STATUS,MAKE,MONITORED-RUNES,DEFUN" data-used-by="TOP-LEVEL-BRR-STATUS" data-part-name="MAKE-INITIAL-BRR-STATUS" data-part-args="MONITORED-RUNES" data-part-body="MONITORED-RUNES,BRR-STATUS,MAKE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-INITIAL-BRR-STATUS">make-initial-brr-status</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-initial-brr-status" data-sym="MAKE-INITIAL-BRR-STATUS" title="(defun make-initial-brr-status (monitored-runes)
  (make brr-status :entry-code :enter :brr-monitored-runes monitored-runes
        :brr-gstack nil :brr-local-alist nil :brr-previous-status nil))">make-initial-brr-status</a>
  (<a class="sym-link system" href="defthm.html#def-monitored-runes" data-sym="MONITORED-RUNES">monitored-runes</a>)
  (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> brr-status
    <span class="keyword">:entry-code</span> <span class="keyword">:enter</span> <span class="keyword">:brr-monitored-runes</span> <a class="sym-link system" href="defthm.html#def-monitored-runes" data-sym="MONITORED-RUNES">monitored-runes</a>
    <span class="keyword">:brr-gstack</span> nil
    <span class="keyword">:brr-local-alist</span> nil
    <span class="keyword">:brr-previous-status</span> nil))</pre>
  </div>

<div class="form-block function" id="def-dive-to-deepest-brr-status" data-defines="DIVE-TO-DEEPEST-BRR-STATUS" data-references="NULL,IF,BRR-STATUS,ACCESS,PREV-WHS,LET,WHS,DEFUN" data-used-by="TOP-LEVEL-BRR-STATUS" data-part-name="DIVE-TO-DEEPEST-BRR-STATUS" data-part-args="WHS" data-part-body="DIVE-TO-DEEPEST-BRR-STATUS,NULL,IF,WHS,BRR-STATUS,ACCESS,PREV-WHS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DIVE-TO-DEEPEST-BRR-STATUS">dive-to-deepest-brr-status</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-dive-to-deepest-brr-status" data-sym="DIVE-TO-DEEPEST-BRR-STATUS" title="(defun dive-to-deepest-brr-status (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        whs
        (dive-to-deepest-brr-status prev-whs))))">dive-to-deepest-brr-status</a>
  (whs)
  (let ((prev-whs (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-previous-status</span>)))
    (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-whs)
      whs
      (<a class="sym-link local-def" href="#def-dive-to-deepest-brr-status" data-sym="DIVE-TO-DEEPEST-BRR-STATUS" title="(defun dive-to-deepest-brr-status (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        whs
        (dive-to-deepest-brr-status prev-whs))))">dive-to-deepest-brr-status</a> prev-whs))))</pre>
  </div>

<div class="form-block function" id="def-top-level-brr-status" data-defines="TOP-LEVEL-BRR-STATUS" data-references="DIVE-TO-DEEPEST-BRR-STATUS,BRR-STATUS,ACCESS,MAKE-INITIAL-BRR-STATUS,WHS,DEFUN" data-used-by="SEMI-INITIALIZE-BRR-WORMHOLE" data-part-name="TOP-LEVEL-BRR-STATUS" data-part-args="WHS" data-part-body="WHS,DIVE-TO-DEEPEST-BRR-STATUS,BRR-STATUS,ACCESS,MAKE-INITIAL-BRR-STATUS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TOP-LEVEL-BRR-STATUS">top-level-brr-status</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-top-level-brr-status" data-sym="TOP-LEVEL-BRR-STATUS" title="(defun top-level-brr-status (whs)
  (make-initial-brr-status
   (access brr-status (dive-to-deepest-brr-status whs) :brr-monitored-runes)))">top-level-brr-status</a>
  (whs)
  (<a class="sym-link local-def" href="#def-make-initial-brr-status" data-sym="MAKE-INITIAL-BRR-STATUS" title="(defun make-initial-brr-status (monitored-runes)
  (make brr-status :entry-code :enter :brr-monitored-runes monitored-runes
        :brr-gstack nil :brr-local-alist nil :brr-previous-status nil))">make-initial-brr-status</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
      (<a class="sym-link local-def" href="#def-dive-to-deepest-brr-status" data-sym="DIVE-TO-DEEPEST-BRR-STATUS" title="(defun dive-to-deepest-brr-status (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        whs
        (dive-to-deepest-brr-status prev-whs))))">dive-to-deepest-brr-status</a> whs)
      <span class="keyword">:brr-monitored-runes</span>)))</pre>
  </div>

<div class="form-block function" id="def-brr-depth1" data-defines="BRR-DEPTH1" data-references="+,T,NULL,COND,BRR-STATUS,ACCESS,PREV-WHS,LET,WHS,DEFUN" data-used-by="BRR-DEPTH" data-part-name="BRR-DEPTH1" data-part-args="WHS" data-part-body="BRR-DEPTH1,+,T,NULL,COND,WHS,BRR-STATUS,ACCESS,PREV-WHS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DEPTH1">brr-depth1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-depth1" data-sym="BRR-DEPTH1" title="(defun brr-depth1 (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (cond ((null prev-whs) 0) (t (+ 1 (brr-depth1 prev-whs))))))">brr-depth1</a>
  (whs)
  (let ((prev-whs (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-previous-status</span>)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-whs) <span class="number">0</span>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> (<a class="sym-link local-def" href="#def-brr-depth1" data-sym="BRR-DEPTH1" title="(defun brr-depth1 (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (cond ((null prev-whs) 0) (t (+ 1 (brr-depth1 prev-whs))))))">brr-depth1</a> prev-whs))))))</pre>
  </div>

<div class="form-block function" id="def-brr-depth" data-defines="BRR-DEPTH" data-references="WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,BRR-DEPTH1,STATE,DEFUN" data-used-by="BRKPT2,BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1,BRR-PROMPT" data-part-name="BRR-DEPTH" data-part-args="STATE" data-part-body="STATE,WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,BRR-DEPTH1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DEPTH">brr-depth</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a>
  (state)
  (<a class="sym-link local-def" href="#def-brr-depth1" data-sym="BRR-DEPTH1" title="(defun brr-depth1 (whs)
  (let ((prev-whs (access brr-status whs :brr-previous-status)))
    (cond ((null prev-whs) 0) (t (+ 1 (brr-depth1 prev-whs))))))">brr-depth1</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)))</pre>
  </div>

<div class="form-block macro" id="def-brr-wormhole" data-defines="BRR-WORMHOLE" data-references="T,MSG,DISABLE-UBT,WITH-OUTPUT,SET-LD-ERROR-ACTION,HARD,ER,COND,VAL,ERP,MV-LET,STATE,BRR-PROMPT,SET-LD-PROMPT,SET-LD-KEYWORD-ALIASES!,ER-PROGN,BRR,WORMHOLE,QUIT,VALUE,EXIT,CW,PROG2$,LAMBDA,QUOTE,APPEND,QUASIQUOTE,LET,ALIASES,TEST-FORM,INPUT-ALIST,ENTRY-LAMBDA,DEFMACRO" data-used-by="BRKPT2,BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-WORMHOLE">brr-wormhole</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a>
  (entry-lambda input-alist test-form aliases)
  (let ((aliases `(<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> ,ALIASES
         '((<span class="keyword">:exit</span> <span class="number">0</span>
            (lambda nil
              (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"The keyword command :EXIT is ~
                                              disabled inside BRR.  Exit BRR ~
                                              with :ok or :go, or use :a! to ~
                                              abort; or exit ACL2 entirely ~
                                              with ~x0.~%"</span>
                  '(<a class="sym-link system" href="basis-a.html#def-exit" data-sym="EXIT">exit</a>))
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))) (<span class="keyword">:quit</span> <span class="number">0</span>
             (lambda nil
               (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"The keyword command :QUIT is ~
                                              disabled inside BRR.  Quit BRR ~
                                              with :ok or :go, or use :a! to ~
                                              abort; or quit ACL2 entirely ~
                                              with ~x0.~%"</span>
                   '(<a class="sym-link system" href="basis-a.html#def-quit" data-sym="QUIT">quit</a>))
                 (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))))))
    `(<a class="sym-link system" href="basis-a.html#def-wormhole" data-sym="WORMHOLE">wormhole</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a>
      ,ENTRY-LAMBDA
      ,INPUT-ALIST
      `(<a class="sym-link system" href="axioms.html#def-er-progn" data-sym="ER-PROGN">er-progn</a> (<a class="sym-link system" href="basis-b.html#def-set-ld-keyword-aliases_21" data-sym="SET-LD-KEYWORD-ALIASES!">set-ld-keyword-aliases!</a> ,,ALIASES)
        (<a class="sym-link system" href="basis-b.html#def-set-ld-prompt" data-sym="SET-LD-PROMPT">set-ld-prompt</a> '<a class="sym-link local-def" href="#def-brr-prompt" data-sym="BRR-PROMPT" title="(defun brr-prompt (channel state)
  (the2s (unsigned-byte 60)
         (fmt1 &quot;~F0 ~s1~sr ~@2&gt;&quot;
               (list (cons #\0 (brr-depth state))
                     (cons #\1 (f-get-global &#39;current-package state))
...">brr-prompt</a> state)
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val state)
          ,,TEST-FORM
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                  '<a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a>
                  <span class="string">"The test-form provided to brr-wormhole has ~
                           signalled an error.  This is a programming error ~
                           by the ACL2 developers.  Please report this."</span>)))
            (val (<a class="sym-link system" href="axioms.html#def-er-progn" data-sym="ER-PROGN">er-progn</a> (<a class="sym-link system" href="basis-b.html#def-set-ld-error-action" data-sym="SET-LD-ERROR-ACTION">set-ld-error-action</a> <span class="keyword">:continue</span> state)
                (<a class="sym-link system" href="axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:off</span> <span class="keyword">:all</span> (disable-ubt (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Note that ~x0 was executed when an interactive ~
                               break occurred due to a monitored rule; see ~
                               :DOC break-rewrite."</span>
                      'disable-ubt)))
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:q</span>)))))
      <span class="keyword">:ld-prompt</span> nil
      <span class="keyword">:ld-missing-input-ok</span> nil
      <span class="keyword">:ld-always-skip-top-level-locals</span> nil
      <span class="keyword">:ld-pre-eval-filter</span> <span class="keyword">:all</span> <span class="keyword">:ld-pre-eval-print</span> nil
      <span class="keyword">:ld-post-eval-print</span> <span class="keyword">:command-conventions</span> <span class="keyword">:ld-error-triples</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:ld-error-action</span> <span class="keyword">:error</span> <span class="keyword">:ld-query-control-alist</span> nil
      <span class="keyword">:ld-verbose</span> nil)))</pre>
  </div>

<div class="form-block function" id="def-get-brr-local" data-defines="GET-BRR-LOCAL" data-references="BRR-STATUS,ACCESS,ASSOC-EQ,CDR,WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,WHS,LET,STATE,VAR,DEFUN" data-used-by="BRKPT2,BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1,EXPLAIN-NEAR-MISS1,*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,BRR-RESULT,TILDE-@-FAILURE-REASON-FREE-PHRASE,SHOW-ANCESTORS-STACK-MSG" data-part-name="GET-BRR-LOCAL" data-part-args="STATE,VAR" data-part-body="BRR-STATUS,ACCESS,VAR,ASSOC-EQ,CDR,STATE,WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,WHS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-BRR-LOCAL">get-brr-local</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a>
  (var state)
  (let ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)))
    (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> var (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-local-alist</span>)))))</pre>
  </div>

<div class="form-block function" id="def-put-brr-local" data-defines="PUT-BRR-LOCAL" data-references="CONS,LIST,ILLEGAL,PROG2$,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,PUT-ASSOC-EQ,CHANGE,NEW-WHS,BRR-STATUS,ACCESS,ALIST,WORMHOLE-STATUS,WHS,LET*,BRR,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,IF,STATE,VAL,VAR,DEFUN" data-part-name="PUT-BRR-LOCAL" data-part-args="STATE,VAL,VAR" data-part-body="CONS,LIST,PUT-BRR-LOCAL,ILLEGAL,PROG2$,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,VAL,VAR,PUT-ASSOC-EQ,CHANGE,NEW-WHS,BRR-STATUS,ACCESS,ALIST,WORMHOLE-STATUS,WHS,LET*,BRR,STATE,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-BRR-LOCAL">put-brr-local</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-brr-local" data-sym="PUT-BRR-LOCAL" title="(defun put-brr-local (var val state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-local</a>
  (var val state)
  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-name state) '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a>)
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (alist (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-local-alist</span>))
        (new-whs (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-status
            whs
            <span class="keyword">:brr-local-alist</span> (<a class="sym-link system" href="axioms.html#def-put-assoc-eq" data-sym="PUT-ASSOC-EQ">put-assoc-eq</a> var val alist))))
      (<a class="sym-link system" href="basis-a.html#def-set-persistent-whs-and-ephemeral-whs" data-sym="SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS">set-persistent-whs-and-ephemeral-whs</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> new-whs state))
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-illegal" data-sym="ILLEGAL">illegal</a> '<a class="sym-link local-def" href="#def-put-brr-local" data-sym="PUT-BRR-LOCAL" title="(defun put-brr-local (var val state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-local</a>
        <span class="string">"It is illegal to call put-brr-local unless you are under ~
                 break-rewrite and you are not.  The arguments to ~
                 put-brr-local were ~x0 and ~x1"</span>
        (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 var) (cons #\1 val)))
      state)))</pre>
  </div>

<div class="form-block function" id="def-put-brr-locals" data-defines="PUT-BRR-LOCALS" data-references="CONS,LIST,ILLEGAL,PROG2$,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,PUT-ASSOC-EQ-ALIST,CHANGE,NEW-WHS,BRR-STATUS,ACCESS,ALIST1,WORMHOLE-STATUS,WHS,LET*,BRR,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,IF,STATE,ALIST,DEFUN" data-used-by="BRKPT2" data-part-name="PUT-BRR-LOCALS" data-part-args="STATE,ALIST" data-part-body="CONS,LIST,PUT-BRR-LOCALS,ILLEGAL,PROG2$,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,ALIST,PUT-ASSOC-EQ-ALIST,CHANGE,NEW-WHS,BRR-STATUS,ACCESS,ALIST1,WORMHOLE-STATUS,WHS,LET*,BRR,STATE,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-BRR-LOCALS">put-brr-locals</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-brr-locals" data-sym="PUT-BRR-LOCALS" title="(defun put-brr-locals (alist state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist1 (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-locals</a>
  (alist state)
  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-name state) '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a>)
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (alist1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-local-alist</span>))
        (new-whs (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-status
            whs
            <span class="keyword">:brr-local-alist</span> (put-assoc-eq-alist alist1 alist))))
      (<a class="sym-link system" href="basis-a.html#def-set-persistent-whs-and-ephemeral-whs" data-sym="SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS">set-persistent-whs-and-ephemeral-whs</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> new-whs state))
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-illegal" data-sym="ILLEGAL">illegal</a> '<a class="sym-link local-def" href="#def-put-brr-locals" data-sym="PUT-BRR-LOCALS" title="(defun put-brr-locals (alist state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist1 (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-locals</a>
        <span class="string">"It is illegal to call put-brr-locals unless you are under ~
                 break-rewrite and you are not.  The alist argument to ~
                 put-brr-locals was ~x0."</span>
        (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 alist)))
      state)))</pre>
  </div>

<div class="form-block function" id="def-push-brr-status" data-defines="PUSH-BRR-STATUS" data-references="BRR,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,BRR-STATUS,CHANGE,NEW-WHS,WORMHOLE-STATUS,WHS,BRR-LOCAL-ALIST,ALIST,BRR-GSTACK,ASSOC-EQ,CDR,GSTACK,WORMHOLE-INPUT,QUOTE,F-GET-GLOBAL,INPUT,LET*,STATE,DEFUN" data-used-by="BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" data-part-name="PUSH-BRR-STATUS" data-part-args="STATE" data-part-body="BRR,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,BRR-STATUS,CHANGE,NEW-WHS,WORMHOLE-STATUS,WHS,BRR-LOCAL-ALIST,ALIST,BRR-GSTACK,ASSOC-EQ,CDR,GSTACK,STATE,WORMHOLE-INPUT,QUOTE,F-GET-GLOBAL,INPUT,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-BRR-STATUS">push-brr-status</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-brr-status" data-sym="PUSH-BRR-STATUS" title="(defun push-brr-status (state)
  (let* ((input (f-get-global &#39;wormhole-input state))
         (gstack (cdr (assoc-eq &#39;brr-gstack input)))
         (alist (cdr (assoc-eq &#39;brr-local-alist input)))
         (whs (f-get-global &#39;wormhole-status state))
...">push-brr-status</a>
  (state)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((input (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-input state)) (gstack (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'brr-gstack input)))
      (alist (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'brr-local-alist input)))
      (whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state))
      (new-whs (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-status
          whs
          <span class="keyword">:brr-gstack</span> gstack
          <span class="keyword">:brr-local-alist</span> alist
          <span class="keyword">:brr-previous-status</span> whs)))
    (<a class="sym-link system" href="basis-a.html#def-set-persistent-whs-and-ephemeral-whs" data-sym="SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS">set-persistent-whs-and-ephemeral-whs</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> new-whs state)))</pre>
  </div>

<div class="form-block function" id="def-pop-brr-status" data-defines="POP-BRR-STATUS" data-references="BRR,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,NULL,IF,BRR-STATUS,ACCESS,PREV-WHS,WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,WHS,LET*,STATE,DEFUN" data-used-by="BRKPT2,BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" data-part-name="POP-BRR-STATUS" data-part-args="STATE" data-part-body="BRR,SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS,NULL,IF,BRR-STATUS,ACCESS,PREV-WHS,STATE,WORMHOLE-STATUS,QUOTE,F-GET-GLOBAL,WHS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POP-BRR-STATUS">pop-brr-status</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a>
  (state)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (prev-whs (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-previous-status</span>)))
    (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> prev-whs)
      state
      (<a class="sym-link system" href="basis-a.html#def-set-persistent-whs-and-ephemeral-whs" data-sym="SET-PERSISTENT-WHS-AND-EPHEMERAL-WHS">set-persistent-whs-and-ephemeral-whs</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> prev-whs state))))</pre>
  </div>

<div class="form-block function" id="def-decode-type-alist" data-defines="DECODE-TYPE-ALIST" data-references="CDR,CADAR,DECODE-TYPE-SET,CAAR,CONS,T,NULL,COND,TYPE-ALIST,DEFUN" data-used-by="SHOW-BRR-DATA-1" data-part-name="DECODE-TYPE-ALIST" data-part-args="TYPE-ALIST" data-part-body="CDR,DECODE-TYPE-ALIST,CADAR,DECODE-TYPE-SET,CAAR,CONS,T,TYPE-ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECODE-TYPE-ALIST">decode-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-decode-type-alist" data-sym="DECODE-TYPE-ALIST" title="(defun decode-type-alist (type-alist)
  (cond ((null type-alist) nil)
        (t
         (cons (cons (caar type-alist) (decode-type-set (cadar type-alist)))
               (decode-type-alist (cdr type-alist))))))">decode-type-alist</a>
  (type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> type-alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)
          (decode-type-set (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist)))
        (<a class="sym-link local-def" href="#def-decode-type-alist" data-sym="DECODE-TYPE-ALIST" title="(defun decode-type-alist (type-alist)
  (cond ((null type-alist) nil)
        (t
         (cons (cons (caar type-alist) (decode-type-set (cadar type-alist)))
               (decode-type-alist (cdr type-alist))))))">decode-type-alist</a> (cdr type-alist))))))</pre>
  </div>

<div class="form-block function" id="def-translate-break-condition" data-defines="TRANSLATE-BREAK-CONDITION" data-references="VALUE,REVERSE,CDR,IF,SOFT,ER,COND,SET-DIFFERENCE-EQ,BAD-VARS,ALL-VARS,USED-VARS,LET*,W,T,QUOTE,TRANSLATE,TERM,ER-LET*,STATE,CTX,XTERM,DEFUN" data-part-name="TRANSLATE-BREAK-CONDITION" data-part-args="STATE,CTX,XTERM" data-part-body="VALUE,REVERSE,CDR,IF,SOFT,ER,COND,SET-DIFFERENCE-EQ,BAD-VARS,ALL-VARS,USED-VARS,LET*,STATE,W,CTX,T,QUOTE,XTERM,TRANSLATE,TERM,ER-LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TRANSLATE-BREAK-CONDITION">translate-break-condition</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-translate-break-condition" data-sym="TRANSLATE-BREAK-CONDITION" title="(defun translate-break-condition (xterm ctx state)
  (er-let* ((term (translate xterm &#39;(nil) nil t ctx (w state) state)))
           (let* ((used-vars (all-vars term))
                  (bad-vars (set-difference-eq used-vars &#39;(state))))
             (cond
...">translate-break-condition</a>
  (xterm ctx state)
  (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((term (translate xterm '(nil) nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ctx (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state) state)))
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((used-vars (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> term)) (bad-vars (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> used-vars '(state))))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bad-vars (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
            ctx
            <span class="string">"The only variable allowed in a break condition ~
                    is STATE.  Your form, ~x0, contains the ~
                    variable~#1~[~/s~] ~&amp;2."</span>
            xterm
            (if (cdr bad-vars)
              <span class="number">1</span>
              <span class="number">0</span>)
            (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> bad-vars)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> term))))))</pre>
  </div>

<div class="form-block function" id="def-eval-break-condition" data-defines="EVAL-BREAK-CONDITION" data-references="CDR,CAR,ERROR-FMS,PPROGN,IGNORE,DECLARE,COERCE-STATE-TO-OBJECT,QUOTE,CONS,LIST,EV,LATCHES,OKP,ERP,MV-LET,SOFT,ER,W,TERMP,NOT,T,VALUE,*T*,EQUAL,COND,STATE,CTX,TERM,RUNE,DEFUN" data-used-by="BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" data-part-name="EVAL-BREAK-CONDITION" data-part-args="STATE,CTX,TERM,RUNE" data-part-body="CDR,CAR,ERROR-FMS,PPROGN,IGNORE,DECLARE,COERCE-STATE-TO-OBJECT,QUOTE,CONS,LIST,EV,LATCHES,OKP,ERP,MV-LET,RUNE,CTX,SOFT,ER,STATE,W,TERMP,NOT,T,VALUE,*T*,TERM,EQUAL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EVAL-BREAK-CONDITION">eval-break-condition</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-eval-break-condition" data-sym="EVAL-BREAK-CONDITION" title="(defun eval-break-condition (rune term ctx state)
  (cond ((equal term *t*) (value t))
        ((not (termp term (w state)))
         (er soft ctx
             &quot;The monitored rune ~x0 has a non-trivial break :condition, ~X12, ~
...">eval-break-condition</a>
  (rune term ctx state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal term <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (termp term (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
        ctx
        <span class="string">"The monitored rune ~x0 has a non-trivial break :condition, ~X12, ~
         which is no longer a term.  This is presumably because an undo ~
         erased some critical definition after the monitor was installed.  We ~
         are aborting this proof attempt and suggest you inspect ~
         :monitored-runes."</span>
        rune
        term
        nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp okp latches)
        (ev term
          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons 'state (<a class="sym-link system" href="axioms.html#def-coerce-state-to-object" data-sym="COERCE-STATE-TO-OBJECT">coerce-state-to-object</a> state)))
          state
          nil
          nil
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (declare (ignore latches))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="basis-a.html#def-error-fms" data-sym="ERROR-FMS">error-fms</a> nil ctx nil (car okp) (cdr okp) state)
              (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                ctx
                <span class="string">"The break condition installed on ~x0 could not be ~
                    evaluated.  We are aborting this proof attempt."</span>
                rune)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> okp)))))))</pre>
  </div>

<div class="form-block constant" id="def-_2Adefault-free-vars-display-limit_2A" data-defines="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*" data-references="DEFCONST" data-used-by="TILDE-@-FAILURE-REASON-FREE-PHRASE,FREE-VARS-DISPLAY-LIMIT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*">*default-free-vars-display-limit*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Adefault-free-vars-display-limit_2A" data-sym="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*" title="(defconst *default-free-vars-display-limit* 30)">*default-free-vars-display-limit*</a> <span class="number">30</span>)</pre>
  </div>

<div class="form-block macro" id="def-set-free-vars-display-limit" data-defines="SET-FREE-VARS-DISPLAY-LIMIT" data-references="STATE,FREE-VARS-DISPLAY-LIMIT,F-PUT-GLOBAL,QUOTE,HARD,ER,NATP,OR,PROG2$,LET,QUASIQUOTE,N,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-FREE-VARS-DISPLAY-LIMIT">set-free-vars-display-limit</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-free-vars-display-limit" data-sym="SET-FREE-VARS-DISPLAY-LIMIT" title="(defmacro set-free-vars-display-limit (n)
  `(let ((n ,n))
     (prog2$
      (or (natp n)
          (er hard &#39;set-free-vars-display-limit
...">set-free-vars-display-limit</a>
  (n)
  `(let ((n ,N))
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> n)
        (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          '<a class="sym-link local-def" href="#def-set-free-vars-display-limit" data-sym="SET-FREE-VARS-DISPLAY-LIMIT" title="(defmacro set-free-vars-display-limit (n)
  `(let ((n ,n))
     (prog2$
      (or (natp n)
          (er hard &#39;set-free-vars-display-limit
...">set-free-vars-display-limit</a>
          <span class="string">"The argument to set-free-vars-display-limit should ~
                     evaluate to a natural number, but it was given an ~
                     argument that evaluated to ~x0."</span>
          n))
      (<a class="sym-link system" href="axioms.html#def-f-put-global" data-sym="F-PUT-GLOBAL">f-put-global</a> '<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> n state))))</pre>
  </div>

<div class="form-block function" id="def-free-vars-display-limit" data-defines="FREE-VARS-DISPLAY-LIMIT" data-references="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*,NULL,NATP,OR,F-GET-GLOBAL,VAL,LET,QUOTE,F-BOUNDP-GLOBAL,IF,STATE,DEFUN" data-used-by="BRKPT2,*BRKPT2-ALIASES*,TILDE-@-FAILURE-REASON-PHRASE,TILDE-@-FAILURE-REASON-FREE-PHRASE,SET-FREE-VARS-DISPLAY-LIMIT" data-part-name="FREE-VARS-DISPLAY-LIMIT" data-part-args="STATE" data-part-body="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*,NULL,NATP,OR,F-GET-GLOBAL,VAL,LET,STATE,FREE-VARS-DISPLAY-LIMIT,QUOTE,F-BOUNDP-GLOBAL,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FREE-VARS-DISPLAY-LIMIT">free-vars-display-limit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
  (state)
  (if (<a class="sym-link system" href="axioms.html#def-f-boundp-global" data-sym="F-BOUNDP-GLOBAL">f-boundp-global</a> '<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> state)
    (let ((val (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> state)))
      (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> val) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> val))
        val
        <a class="sym-link local-def" href="#def-_2Adefault-free-vars-display-limit_2A" data-sym="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*" title="(defconst *default-free-vars-display-limit* 30)">*default-free-vars-display-limit*</a>))
    <a class="sym-link local-def" href="#def-_2Adefault-free-vars-display-limit_2A" data-sym="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*" title="(defconst *default-free-vars-display-limit* 30)">*default-free-vars-display-limit*</a>))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-limit-failure-reason" data-defines="LIMIT-FAILURE-REASON" data-references="CAAR,CONS,NOT,AND,CDR,REST-ALIST,FAILURES-REMAINING-2,CDAR,FAILURES-REMAINING-1,NULL,IF,&,LIST*,EQL,LIMIT-FAILURE-REASON-ALIST,NEW-ALIST,NEW-FAILURES-REMAINING,MV-LET,1-,HYP-VARS,CAR,EQ,T,ELIDED,LIST,MV,ZP,COND,ALIST,FREE-VARS,QUOTE,HYP,CASE-MATCH,NATP,XARGS,DECLARE,ELIDED-P,FAILURE-REASON,FAILURES-REMAINING,DEFUN,MUTUAL-RECURSION" data-used-by="TILDE-@-FAILURE-REASON-FREE-PHRASE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="LIMIT-FAILURE-REASON">limit-failure-reason</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-limit-failure-reason" data-sym="LIMIT-FAILURE-REASON" title="(mutual-recursion
 (defun limit-failure-reason (failures-remaining failure-reason elided-p)
   (declare (xargs :guard (natp failures-remaining)))
   (case-match failure-reason
               ((hyp &#39;free-vars . alist)
...">limit-failure-reason</a>
    (failures-remaining failure-reason elided-p)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> failures-remaining)))
    (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> failure-reason
      ((hyp 'free-vars . alist) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> failures-remaining) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="number">0</span> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> hyp 'free-vars 'elided) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car alist) 'hyp-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> failures-remaining) failure-reason elided-p))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-failures-remaining new-alist elided-p)
              (limit-failure-reason-alist (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> failures-remaining)
                alist
                elided-p)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> failures-remaining new-failures-remaining) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> failures-remaining failure-reason elided-p))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-failures-remaining
                    (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> hyp 'free-vars new-alist)
                    elided-p)))))))
      (&amp; (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (if (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> failures-remaining)
            failures-remaining
            (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> failures-remaining))
          failure-reason
          elided-p))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> limit-failure-reason-alist
    (failures-remaining alist elided-p)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> failures-remaining alist elided-p))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (failures-remaining-1 failure-reason elided-p)
          (<a class="sym-link local-def" href="#def-limit-failure-reason" data-sym="LIMIT-FAILURE-REASON" title="(mutual-recursion
 (defun limit-failure-reason (failures-remaining failure-reason elided-p)
   (declare (xargs :guard (natp failures-remaining)))
   (case-match failure-reason
               ((hyp &#39;free-vars . alist)
...">limit-failure-reason</a> failures-remaining
            (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)
            elided-p)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (failures-remaining-2 rest-alist elided-p)
            (limit-failure-reason-alist failures-remaining-1
              (cdr alist)
              elided-p)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> failures-remaining-2
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> failures-remaining))
                   (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> failures-remaining failures-remaining-2)) alist)
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> failures-remaining))
                         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> failures-remaining failures-remaining-1)) (car alist))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) failure-reason)))
                    rest-alist)))
              elided-p)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-fix-free-failure-reason" data-defines="FIX-FREE-FAILURE-REASON" data-references="CDAR,CAAR,CONS,CDR,T,ENDP,COND,ACC,X,FIX-FREE-FAILURE-REASON-ALIST,LIST*,FAILURE-REASON-LST,BKPTR,HYP-VARS,FREE-VARS,QUOTE,&,CASE-MATCH,FAILURE-REASON,DEFUN,MUTUAL-RECURSION" data-used-by="TILDE-@-FAILURE-REASON-PHRASE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIX-FREE-FAILURE-REASON">fix-free-failure-reason</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fix-free-failure-reason" data-sym="FIX-FREE-FAILURE-REASON" title="(mutual-recursion
 (defun fix-free-failure-reason (failure-reason)
   (case-match failure-reason ((&amp; &#39;free-vars &#39;hyp-vars . &amp;) failure-reason)
               ((bkptr &#39;free-vars . failure-reason-lst)
                (list* bkptr &#39;free-vars
...">fix-free-failure-reason</a>
    (failure-reason)
    (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> failure-reason
      ((&amp; 'free-vars 'hyp-vars . &amp;) failure-reason)
      ((bkptr 'free-vars . failure-reason-lst) (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> bkptr
          'free-vars
          (fix-free-failure-reason-alist failure-reason-lst nil)))
      (&amp; failure-reason)))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> fix-free-failure-reason-alist
    (x acc)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) acc)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (fix-free-failure-reason-alist (cdr x)
          (cons (cons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> x) (<a class="sym-link local-def" href="#def-fix-free-failure-reason" data-sym="FIX-FREE-FAILURE-REASON" title="(mutual-recursion
 (defun fix-free-failure-reason (failure-reason)
   (case-match failure-reason ((&amp; &#39;free-vars &#39;hyp-vars . &amp;) failure-reason)
               ((bkptr &#39;free-vars . failure-reason-lst)
                (list* bkptr &#39;free-vars
...">fix-free-failure-reason</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> x)))
            acc))))))</pre>
  </div>

<div class="form-block function" id="def-ancestor-backchain-rune" data-defines="ANCESTOR-BACKCHAIN-RUNE" data-references="CAR,CDR,NULL,ASSERT$,TOKENS,LET,ACCESS,AND,ANCESTOR,DEFUN" data-used-by="BACKCHAIN-LIMIT-ENFORCERS" data-part-name="ANCESTOR-BACKCHAIN-RUNE" data-part-args="ANCESTOR" data-part-body="CAR,CDR,NULL,ASSERT$,TOKENS,LET,ANCESTOR,ACCESS,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ANCESTOR-BACKCHAIN-RUNE">ancestor-backchain-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ancestor-backchain-rune" data-sym="ANCESTOR-BACKCHAIN-RUNE" title="(defun ancestor-backchain-rune (ancestor)
  (and (access ancestor ancestor :bkptr)
       (let ((tokens (access ancestor ancestor :tokens)))
         (assert$ (and tokens (null (cdr tokens))) (car tokens)))))">ancestor-backchain-rune</a>
  (ancestor)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor ancestor <span class="keyword">:bkptr</span>)
    (let ((tokens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor ancestor <span class="keyword">:tokens</span>)))
      (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> tokens (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr tokens))) (car tokens)))))</pre>
  </div>

<div class="form-block other" id="form-230" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> forward-chaining-rule
  ((rune . nume) trigger hyps concls . match-free)
  nil)</pre>
  </div>

<div class="form-block other" id="form-231" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> elim-rule
  (((nume . crucial-position) destructor-term . destructor-terms) (hyps . equiv)
    (lhs . rhs) . rune)
  nil)</pre>
  </div>

<div class="form-block other" id="form-232" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> generalize-rule (nume <a class="sym-link system" href="history-management.html#def-formula" data-sym="FORMULA">formula</a> . rune) nil)</pre>
  </div>

<div class="form-block other" id="form-233" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> induction-rule
  (nume (pattern . condition) scheme . rune)
  nil)</pre>
  </div>

<div class="form-block other" id="form-234" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> built-in-clause
  ((nume . all-fnnames) clause . rune)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-scan-to-defpkg" data-defines="SCAN-TO-DEFPKG" data-references="CDR,T,ACCESS-EVENT-TUPLE-NAMEX,EQUAL,DEFPKG,CDDAR,ACCESS-EVENT-TUPLE-TYPE,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,NULL,COND,WRLD,NAME,DEFUN" data-used-by="DECODE-LOGICAL-NAME" data-part-name="SCAN-TO-DEFPKG" data-part-args="WRLD,NAME" data-part-body="CDR,SCAN-TO-DEFPKG,T,ACCESS-EVENT-TUPLE-NAMEX,NAME,EQUAL,DEFPKG,CDDAR,ACCESS-EVENT-TUPLE-TYPE,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,WRLD,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SCAN-TO-DEFPKG">scan-to-defpkg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-scan-to-defpkg" data-sym="SCAN-TO-DEFPKG" title="(defun scan-to-defpkg (name wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (eq (access-event-tuple-type (cddar wrld)) &#39;defpkg)
              (equal name (access-event-tuple-namex (cddar wrld))))
...">scan-to-defpkg</a>
  (name wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> wrld) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> wrld) 'event-landmark)
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> wrld) 'global-value)
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (access-event-tuple-type (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> wrld)) '<a class="sym-link system" href="axioms.html#def-defpkg" data-sym="DEFPKG">defpkg</a>)
       (equal name (access-event-tuple-namex (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> wrld)))) wrld)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-scan-to-defpkg" data-sym="SCAN-TO-DEFPKG" title="(defun scan-to-defpkg (name wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (eq (access-event-tuple-type (cddar wrld)) &#39;defpkg)
              (equal name (access-event-tuple-namex (cddar wrld))))
...">scan-to-defpkg</a> name (cdr wrld)))))</pre>
  </div>

<div class="form-block function" id="def-multiple-assoc-terminal-substringp1" data-defines="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" data-references="T,CDR,CAR,CONS,LENGTH,1-,CAAR,TERMINAL-SUBSTRINGP,NULL,COND,ALIST,I,X,DEFUN" data-used-by="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP" data-part-name="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" data-part-args="ALIST,I,X" data-part-body="T,CDR,MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1,CAR,CONS,LENGTH,1-,I,CAAR,X,TERMINAL-SUBSTRINGP,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1">multiple-assoc-terminal-substringp1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-multiple-assoc-terminal-substringp1" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" title="(defun multiple-assoc-terminal-substringp1 (x i alist)
  (cond ((null alist) nil)
        ((terminal-substringp x (caar alist) i (1- (length (caar alist))))
         (cons (car alist)
               (multiple-assoc-terminal-substringp1 x i (cdr alist))))">multiple-assoc-terminal-substringp1</a>
  (x i alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) nil)
    ((terminal-substringp x
       (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)
       i
       (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)))) (cons (car alist)
        (<a class="sym-link local-def" href="#def-multiple-assoc-terminal-substringp1" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" title="(defun multiple-assoc-terminal-substringp1 (x i alist)
  (cond ((null alist) nil)
        ((terminal-substringp x (caar alist) i (1- (length (caar alist))))
         (cons (car alist)
               (multiple-assoc-terminal-substringp1 x i (cdr alist))))">multiple-assoc-terminal-substringp1</a> x i (cdr alist))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-multiple-assoc-terminal-substringp1" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" title="(defun multiple-assoc-terminal-substringp1 (x i alist)
  (cond ((null alist) nil)
        ((terminal-substringp x (caar alist) i (1- (length (caar alist))))
         (cons (car alist)
               (multiple-assoc-terminal-substringp1 x i (cdr alist))))">multiple-assoc-terminal-substringp1</a> x i (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-multiple-assoc-terminal-substringp" data-defines="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP" data-references="LENGTH,1-,MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1,ALIST,X,DEFUN" data-part-name="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP" data-part-args="ALIST,X" data-part-body="ALIST,LENGTH,1-,X,MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP">multiple-assoc-terminal-substringp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-multiple-assoc-terminal-substringp" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP" title="(defun multiple-assoc-terminal-substringp (x alist)
  (multiple-assoc-terminal-substringp1 x (1- (length x)) alist))">multiple-assoc-terminal-substringp</a>
  (x alist)
  (<a class="sym-link local-def" href="#def-multiple-assoc-terminal-substringp1" data-sym="MULTIPLE-ASSOC-TERMINAL-SUBSTRINGP1" title="(defun multiple-assoc-terminal-substringp1 (x i alist)
  (cond ((null alist) nil)
        ((terminal-substringp x (caar alist) i (1- (length (caar alist))))
         (cons (car alist)
               (multiple-assoc-terminal-substringp1 x i (cdr alist))))">multiple-assoc-terminal-substringp1</a> x
    (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> x))
    alist))</pre>
  </div>

<div class="form-block function" id="def-possibly-add-lisp-extension" data-defines="POSSIBLY-ADD-LISP-EXTENSION" data-references="STRING-APPEND,T,-,CHAR,EQL,>,AND,COND,LENGTH,LEN,LET,STR,DEFUN" data-part-name="POSSIBLY-ADD-LISP-EXTENSION" data-part-args="STR" data-part-body="STRING-APPEND,T,-,CHAR,EQL,>,AND,COND,STR,LENGTH,LEN,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="POSSIBLY-ADD-LISP-EXTENSION">possibly-add-lisp-extension</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-possibly-add-lisp-extension" data-sym="POSSIBLY-ADD-LISP-EXTENSION" title="(defun possibly-add-lisp-extension (str)
  (let ((len (length str)))
    (cond
     ((and (&gt; len 5) (eql (char str (- len 5)) #\.)
           (eql (char str (- len 4)) #\l) (eql (char str (- len 3)) #\i)
...">possibly-add-lisp-extension</a>
  (str)
  (let ((<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> str)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>)
         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">5</span>)) #\.)
         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">4</span>)) #\l)
         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">3</span>)) #\i)
         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">2</span>)) #\s)
         (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-char" data-sym="CHAR">char</a> str (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> <a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> <span class="number">1</span>)) #\p)) str)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-string-append" data-sym="STRING-APPEND">string-append</a> str <span class="string">".lisp"</span>)))))</pre>
  </div>

<div class="form-block function" id="def-stuff-standard-oi" data-defines="STUFF-STANDARD-OI" data-references="SET-LD-PRE-EVAL-PRINT,CONS,F-GET-GLOBAL,SYMBOLP,APPEND,STANDARD-OI,LD-PRE-EVAL-PRINT,QUOTE,F-PUT-GLOBAL,PPROGN,T,NULL,COND,TRUE-LISTP,XARGS,DECLARE,STATE,CMDS,DEFUN" data-used-by="BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" data-part-name="STUFF-STANDARD-OI" data-part-args="STATE,CMDS" data-part-declare="CMDS,TRUE-LISTP,XARGS,DECLARE" data-part-body="SET-LD-PRE-EVAL-PRINT,CONS,F-GET-GLOBAL,SYMBOLP,APPEND,STANDARD-OI,LD-PRE-EVAL-PRINT,QUOTE,F-PUT-GLOBAL,PPROGN,T,STATE,CMDS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="STUFF-STANDARD-OI">stuff-standard-oi</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a>
  (cmds state)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> cmds)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cmds) state)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="axioms.html#def-f-put-global" data-sym="F-PUT-GLOBAL">f-put-global</a> '<a class="sym-link system" href="basis-b.html#def-ld-pre-eval-print" data-sym="LD-PRE-EVAL-PRINT">ld-pre-eval-print</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state)
        (<a class="sym-link system" href="axioms.html#def-f-put-global" data-sym="F-PUT-GLOBAL">f-put-global</a> '<a class="sym-link system" href="basis-b.html#def-standard-oi" data-sym="STANDARD-OI">standard-oi</a>
          (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> cmds
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-b.html#def-standard-oi" data-sym="STANDARD-OI">standard-oi</a> state)) (cons '(<a class="sym-link system" href="basis-b.html#def-set-ld-pre-eval-print" data-sym="SET-LD-PRE-EVAL-PRINT">set-ld-pre-eval-print</a> nil state)
                  (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-b.html#def-standard-oi" data-sym="STANDARD-OI">standard-oi</a> state)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-b.html#def-standard-oi" data-sym="STANDARD-OI">standard-oi</a> state))))
          state)))))</pre>
  </div>

<div class="form-block function" id="def-defun-mode-prompt-string" data-defines="DEFUN-MODE-PROMPT-STRING" data-references="OTHERWISE,LD-SKIP-PROOFSP,GC-OFF,W,DEFAULT-DEFUN-MODE,CASE,RAW-MODE-P,IF,STATE,DEFUN" data-used-by="BRR-PROMPT" data-part-name="DEFUN-MODE-PROMPT-STRING" data-part-args="STATE" data-part-body="OTHERWISE,LD-SKIP-PROOFSP,GC-OFF,W,DEFAULT-DEFUN-MODE,CASE,STATE,RAW-MODE-P,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DEFUN-MODE-PROMPT-STRING">defun-mode-prompt-string</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-defun-mode-prompt-string" data-sym="DEFUN-MODE-PROMPT-STRING" title="(defun defun-mode-prompt-string (state)
  (if (raw-mode-p state)
      &quot;P&quot;
      (case (default-defun-mode (w state))
        (:logic
...">defun-mode-prompt-string</a>
  (state)
  (if (<a class="sym-link system" href="axioms.html#def-raw-mode-p" data-sym="RAW-MODE-P">raw-mode-p</a> state)
    <span class="string">"P"</span>
    (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="axioms.html#def-default-defun-mode" data-sym="DEFAULT-DEFUN-MODE">default-defun-mode</a> (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state))
      (<span class="keyword">:logic</span> (if (gc-off state)
          (if (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state)
            <span class="string">"s"</span>
            <span class="string">""</span>)
          (if (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state)
            <span class="string">"!s"</span>
            <span class="string">"!"</span>)))
      (otherwise (if (gc-off state)
          (if (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state)
            <span class="string">"ps"</span>
            <span class="string">"p"</span>)
          (if (<a class="sym-link system" href="axioms.html#def-ld-skip-proofsp" data-sym="LD-SKIP-PROOFSP">ld-skip-proofsp</a> state)
            <span class="string">"p!s"</span>
            <span class="string">"p!"</span>))))))</pre>
  </div>

<div class="form-block function" id="def-brr-prompt" data-defines="BRR-PROMPT" data-references="DEFUN-MODE-PROMPT-STRING,CURRENT-PACKAGE,QUOTE,F-GET-GLOBAL,BRR-DEPTH,CONS,LIST,FMT1,UNSIGNED-BYTE,THE2S,STATE,CHANNEL,DEFUN" data-used-by="BRR-WORMHOLE" data-part-name="BRR-PROMPT" data-part-args="STATE,CHANNEL" data-part-body="CHANNEL,DEFUN-MODE-PROMPT-STRING,CURRENT-PACKAGE,QUOTE,F-GET-GLOBAL,STATE,BRR-DEPTH,CONS,LIST,FMT1,UNSIGNED-BYTE,THE2S" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-PROMPT">brr-prompt</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-prompt" data-sym="BRR-PROMPT" title="(defun brr-prompt (channel state)
  (the2s (unsigned-byte 60)
         (fmt1 &quot;~F0 ~s1~sr ~@2&gt;&quot;
               (list (cons #\0 (brr-depth state))
                     (cons #\1 (f-get-global &#39;current-package state))
...">brr-prompt</a>
  (channel state)
  (<a class="sym-link system" href="axioms.html#def-the2s" data-sym="THE2S">the2s</a> (unsigned-byte <span class="number">60</span>)
    (<a class="sym-link system" href="basis-a.html#def-fmt1" data-sym="FMT1">fmt1</a> <span class="string">"~F0 ~s1~sr ~@2&gt;"</span>
      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state))
        (cons #\1 (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="axioms.html#def-current-package" data-sym="CURRENT-PACKAGE">current-package</a> state))
        (cons #\2 (<a class="sym-link local-def" href="#def-defun-mode-prompt-string" data-sym="DEFUN-MODE-PROMPT-STRING" title="(defun defun-mode-prompt-string (state)
  (if (raw-mode-p state)
      &quot;P&quot;
      (case (default-defun-mode (w state))
        (:logic
...">defun-mode-prompt-string</a> state))
        (cons #\r <span class="string">""</span>))
      <span class="number">0</span>
      channel
      state
      nil)))</pre>
  </div>

<div class="form-block function" id="def-ts_3C" data-defines="TS<" data-references="TS-SUBSETP,*TS-NIL*,*TS-NON-NIL*,T,*TS-T*,TS=,COND,Y,X,DEFUN" data-used-by="ADD-TO-TYPE-ALIST-SEGMENTS" data-part-name="TS<" data-part-args="Y,X" data-part-body="TS-SUBSETP,*TS-NIL*,*TS-NON-NIL*,T,*TS-T*,Y,X,TS=,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TS<">ts&lt;</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ts_3C" data-sym="TS&lt;" title="(defun ts&lt; (x y)
  (cond ((ts= x y) nil) ((ts= x *ts-t*) t) ((ts= y *ts-t*) nil)
        ((ts= x *ts-non-nil*) t) ((ts= y *ts-non-nil*) nil)
        ((ts= x *ts-nil*) t) ((ts= y *ts-nil*) nil) ((ts-subsetp x y) t)
        (t nil)))">ts&lt;</a>
  (x y)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x y) nil)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x *ts-t*) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> y *ts-t*) nil)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x *ts-non-nil*) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> y *ts-non-nil*) nil)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> x *ts-nil*) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> y *ts-nil*) nil)
    ((ts-subsetp x y) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-add-to-type-alist-segments" data-defines="ADD-TO-TYPE-ALIST-SEGMENTS" data-references="CAR,T,CDR,CDAR,TS=,LIST,CONS,CAAR,TS<,ENDP,OR,COND,SEGS,TERM,TS,DEFUN" data-used-by="TYPE-ALIST-SEGMENTS" data-part-name="ADD-TO-TYPE-ALIST-SEGMENTS" data-part-args="SEGS,TERM,TS" data-part-body="ADD-TO-TYPE-ALIST-SEGMENTS,CAR,T,CDR,CDAR,TS=,TERM,LIST,CONS,CAAR,TS,TS<,SEGS,ENDP,OR,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-TO-TYPE-ALIST-SEGMENTS">add-to-type-alist-segments</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-to-type-alist-segments" data-sym="ADD-TO-TYPE-ALIST-SEGMENTS" title="(defun add-to-type-alist-segments (ts term segs)
  (cond
   ((or (endp segs) (ts&lt; ts (caar segs))) (cons (cons ts (list term)) segs))
   ((ts= ts (caar segs)) (cons (cons ts (cons term (cdar segs))) (cdr segs)))
   (t (cons (car segs) (add-to-type-alist-segments ts term (cdr segs))))))">add-to-type-alist-segments</a>
  (ts term segs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> segs) (<a class="sym-link local-def" href="#def-ts_3C" data-sym="TS&lt;" title="(defun ts&lt; (x y)
  (cond ((ts= x y) nil) ((ts= x *ts-t*) t) ((ts= y *ts-t*) nil)
        ((ts= x *ts-non-nil*) t) ((ts= y *ts-non-nil*) nil)
        ((ts= x *ts-nil*) t) ((ts= y *ts-nil*) nil) ((ts-subsetp x y) t)
        (t nil)))">ts&lt;</a> ts (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> segs))) (cons (cons ts (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> term)) segs))
    ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> segs)) (cons (cons ts (cons term (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> segs))) (cdr segs)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car segs)
        (<a class="sym-link local-def" href="#def-add-to-type-alist-segments" data-sym="ADD-TO-TYPE-ALIST-SEGMENTS" title="(defun add-to-type-alist-segments (ts term segs)
  (cond
   ((or (endp segs) (ts&lt; ts (caar segs))) (cons (cons ts (list term)) segs))
   ((ts= ts (caar segs)) (cons (cons ts (cons term (cdar segs))) (cdr segs)))
   (t (cons (car segs) (add-to-type-alist-segments ts term (cdr segs))))))">add-to-type-alist-segments</a> ts term (cdr segs))))))</pre>
  </div>

<div class="form-block function" id="def-merge-term-order" data-defines="MERGE-TERM-ORDER" data-references="T,CDR,CONS,CAR,TERM-ORDER,ENDP,COND,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE,L2,L1,DEFUN" data-used-by="MERGE-SORT-TERM-ORDER" data-part-name="MERGE-TERM-ORDER" data-part-args="L2,L1" data-part-declare="L2,L1,PSEUDO-TERM-LISTP,AND,XARGS,DECLARE" data-part-body="T,CDR,MERGE-TERM-ORDER,CONS,CAR,TERM-ORDER,L2,L1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-TERM-ORDER">merge-term-order</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-term-order" data-sym="MERGE-TERM-ORDER" title="(defun merge-term-order (l1 l2)
  (declare (xargs :guard (and (pseudo-term-listp l1) (pseudo-term-listp l2))))
  (cond ((endp l1) l2) ((endp l2) l1)
        ((term-order (car l1) (car l2))
         (cons (car l1) (merge-term-order (cdr l1) l2)))">merge-term-order</a>
  (l1 l2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp l1) (pseudo-term-listp l2))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l1) l2)
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l2) l1)
    ((term-order (car l1) (car l2)) (cons (car l1) (<a class="sym-link local-def" href="#def-merge-term-order" data-sym="MERGE-TERM-ORDER" title="(defun merge-term-order (l1 l2)
  (declare (xargs :guard (and (pseudo-term-listp l1) (pseudo-term-listp l2))))
  (cond ((endp l1) l2) ((endp l2) l1)
        ((term-order (car l1) (car l2))
         (cons (car l1) (merge-term-order (cdr l1) l2)))">merge-term-order</a> (cdr l1) l2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car l2) (<a class="sym-link local-def" href="#def-merge-term-order" data-sym="MERGE-TERM-ORDER" title="(defun merge-term-order (l1 l2)
  (declare (xargs :guard (and (pseudo-term-listp l1) (pseudo-term-listp l2))))
  (cond ((endp l1) l2) ((endp l2) l1)
        ((term-order (car l1) (car l2))
         (cons (car l1) (merge-term-order (cdr l1) l2)))">merge-term-order</a> l1 (cdr l2))))))</pre>
  </div>

<div class="form-block function" id="def-merge-sort-term-order" data-defines="MERGE-SORT-TERM-ORDER" data-references="ODDS,EVENS,MERGE-TERM-ORDER,T,CDR,ENDP,COND,PSEUDO-TERM-LISTP,XARGS,DECLARE,L,DEFUN" data-used-by="SORT-TYPE-ALIST-SEGMENTS" data-part-name="MERGE-SORT-TERM-ORDER" data-part-args="L" data-part-declare="L,PSEUDO-TERM-LISTP,XARGS,DECLARE" data-part-body="ODDS,EVENS,MERGE-SORT-TERM-ORDER,MERGE-TERM-ORDER,T,L,CDR,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-SORT-TERM-ORDER">merge-sort-term-order</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-sort-term-order" data-sym="MERGE-SORT-TERM-ORDER" title="(defun merge-sort-term-order (l)
  (declare (xargs :guard (pseudo-term-listp l)))
  (cond ((endp (cdr l)) l)
        (t
         (merge-term-order (merge-sort-term-order (evens l))">merge-sort-term-order</a>
  (l)
  (declare (xargs <span class="keyword">:guard</span> (pseudo-term-listp l)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> (cdr l)) l)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-term-order" data-sym="MERGE-TERM-ORDER" title="(defun merge-term-order (l1 l2)
  (declare (xargs :guard (and (pseudo-term-listp l1) (pseudo-term-listp l2))))
  (cond ((endp l1) l2) ((endp l2) l1)
        ((term-order (car l1) (car l2))
         (cons (car l1) (merge-term-order (cdr l1) l2)))">merge-term-order</a> (<a class="sym-link local-def" href="#def-merge-sort-term-order" data-sym="MERGE-SORT-TERM-ORDER" title="(defun merge-sort-term-order (l)
  (declare (xargs :guard (pseudo-term-listp l)))
  (cond ((endp (cdr l)) l)
        (t
         (merge-term-order (merge-sort-term-order (evens l))">merge-sort-term-order</a> (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> l))
        (<a class="sym-link local-def" href="#def-merge-sort-term-order" data-sym="MERGE-SORT-TERM-ORDER" title="(defun merge-sort-term-order (l)
  (declare (xargs :guard (pseudo-term-listp l)))
  (cond ((endp (cdr l)) l)
        (t
         (merge-term-order (merge-sort-term-order (evens l))">merge-sort-term-order</a> (<a class="sym-link system" href="axioms.html#def-odds" data-sym="ODDS">odds</a> l))))))</pre>
  </div>

<div class="form-block function" id="def-sort-type-alist-segments" data-defines="SORT-TYPE-ALIST-SEGMENTS" data-references="CDR,CDAR,MERGE-SORT-TERM-ORDER,CAAR,CONS,ENDP,IF,SEGS,DEFUN" data-used-by="TYPE-ALIST-SEGMENTS" data-part-name="SORT-TYPE-ALIST-SEGMENTS" data-part-args="SEGS" data-part-body="CDR,SORT-TYPE-ALIST-SEGMENTS,CDAR,MERGE-SORT-TERM-ORDER,CAAR,CONS,SEGS,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-TYPE-ALIST-SEGMENTS">sort-type-alist-segments</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-type-alist-segments" data-sym="SORT-TYPE-ALIST-SEGMENTS" title="(defun sort-type-alist-segments (segs)
  (if (endp segs)
      nil
      (cons (cons (caar segs) (merge-sort-term-order (cdar segs)))
            (sort-type-alist-segments (cdr segs)))))">sort-type-alist-segments</a>
  (segs)
  (if (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> segs)
    nil
    (cons (cons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> segs) (<a class="sym-link local-def" href="#def-merge-sort-term-order" data-sym="MERGE-SORT-TERM-ORDER" title="(defun merge-sort-term-order (l)
  (declare (xargs :guard (pseudo-term-listp l)))
  (cond ((endp (cdr l)) l)
        (t
         (merge-term-order (merge-sort-term-order (evens l))">merge-sort-term-order</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> segs)))
      (<a class="sym-link local-def" href="#def-sort-type-alist-segments" data-sym="SORT-TYPE-ALIST-SEGMENTS" title="(defun sort-type-alist-segments (segs)
  (if (endp segs)
      nil
      (cons (cons (caar segs) (merge-sort-term-order (cdar segs)))
            (sort-type-alist-segments (cdr segs)))))">sort-type-alist-segments</a> (cdr segs)))))</pre>
  </div>

<div class="form-block function" id="def-type-alist-segments" data-defines="TYPE-ALIST-SEGMENTS" data-references="CAAR,CADAR,ADD-TO-TYPE-ALIST-SEGMENTS,CDR,SORT-TYPE-ALIST-SEGMENTS,ENDP,IF,ACC,TYPE-ALIST,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,PRINT-TYPE-ALIST" data-part-name="TYPE-ALIST-SEGMENTS" data-part-args="ACC,TYPE-ALIST" data-part-body="CAAR,CADAR,ADD-TO-TYPE-ALIST-SEGMENTS,CDR,TYPE-ALIST-SEGMENTS,ACC,SORT-TYPE-ALIST-SEGMENTS,TYPE-ALIST,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TYPE-ALIST-SEGMENTS">type-alist-segments</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-type-alist-segments" data-sym="TYPE-ALIST-SEGMENTS" title="(defun type-alist-segments (type-alist acc)
  (if (endp type-alist)
      (sort-type-alist-segments acc)
      (type-alist-segments (cdr type-alist)
                           (add-to-type-alist-segments (cadar type-alist)">type-alist-segments</a>
  (type-alist acc)
  (if (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> type-alist)
    (<a class="sym-link local-def" href="#def-sort-type-alist-segments" data-sym="SORT-TYPE-ALIST-SEGMENTS" title="(defun sort-type-alist-segments (segs)
  (if (endp segs)
      nil
      (cons (cons (caar segs) (merge-sort-term-order (cdar segs)))
            (sort-type-alist-segments (cdr segs)))))">sort-type-alist-segments</a> acc)
    (<a class="sym-link local-def" href="#def-type-alist-segments" data-sym="TYPE-ALIST-SEGMENTS" title="(defun type-alist-segments (type-alist acc)
  (if (endp type-alist)
      (sort-type-alist-segments acc)
      (type-alist-segments (cdr type-alist)
                           (add-to-type-alist-segments (cadar type-alist)">type-alist-segments</a> (cdr type-alist)
      (<a class="sym-link local-def" href="#def-add-to-type-alist-segments" data-sym="ADD-TO-TYPE-ALIST-SEGMENTS" title="(defun add-to-type-alist-segments (ts term segs)
  (cond
   ((or (endp segs) (ts&lt; ts (caar segs))) (cons (cons ts (list term)) segs))
   ((ts= ts (caar segs)) (cons (cons ts (cons term (cdar segs))) (cdr segs)))
   (t (cons (car segs) (add-to-type-alist-segments ts term (cdr segs))))))">add-to-type-alist-segments</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> type-alist)
        (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> type-alist)
        acc))))</pre>
  </div>

<div class="form-block function" id="def-print-terms" data-defines="PRINT-TERMS" data-references="CDR,CAR,UNTRANSLATE,CW,PROG2$,ENDP,IF,EVISC-TUPLE,WRLD,IFF-FLG,TERMS,DEFUN" data-used-by="PRINT-TYPE-ALIST-SEGMENTS" data-part-name="PRINT-TERMS" data-part-args="EVISC-TUPLE,WRLD,IFF-FLG,TERMS" data-part-body="CDR,PRINT-TERMS,EVISC-TUPLE,WRLD,IFF-FLG,CAR,UNTRANSLATE,CW,PROG2$,TERMS,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PRINT-TERMS">print-terms</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-print-terms" data-sym="PRINT-TERMS" title="(defun print-terms (terms iff-flg wrld evisc-tuple)
  (if (endp terms)
      terms
      (prog2$ (cw &quot;~Y01&quot; (untranslate (car terms) iff-flg wrld) evisc-tuple)
              (print-terms (cdr terms) iff-flg wrld evisc-tuple))))">print-terms</a>
  (terms iff-flg wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (if (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> terms)
    terms
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~Y01"</span>
        (untranslate (car terms) iff-flg wrld)
        <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
      (<a class="sym-link local-def" href="#def-print-terms" data-sym="PRINT-TERMS" title="(defun print-terms (terms iff-flg wrld evisc-tuple)
  (if (endp terms)
      terms
      (prog2$ (cw &quot;~Y01&quot; (untranslate (car terms) iff-flg wrld) evisc-tuple)
              (print-terms (cdr terms) iff-flg wrld evisc-tuple))))">print-terms</a> (cdr terms) iff-flg wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))))</pre>
  </div>

<div class="form-block function" id="def-print-type-alist-segments" data-defines="PRINT-TYPE-ALIST-SEGMENTS" data-references="CDR,*TS-BOOLEAN*,*TS-NIL*,*TS-NON-NIL*,*TS-T*,LIST,MEMBER,CDAR,PRINT-TERMS,CAAR,DECODE-TYPE-SET,CW,PROG2$,ENDP,IF,EVISC-TUPLE,WRLD,SEGS,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,PRINT-TYPE-ALIST" data-part-name="PRINT-TYPE-ALIST-SEGMENTS" data-part-args="EVISC-TUPLE,WRLD,SEGS" data-part-body="CDR,PRINT-TYPE-ALIST-SEGMENTS,EVISC-TUPLE,WRLD,*TS-BOOLEAN*,*TS-NIL*,*TS-NON-NIL*,*TS-T*,LIST,MEMBER,CDAR,PRINT-TERMS,CAAR,DECODE-TYPE-SET,CW,PROG2$,SEGS,ENDP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PRINT-TYPE-ALIST-SEGMENTS">print-type-alist-segments</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-print-type-alist-segments" data-sym="PRINT-TYPE-ALIST-SEGMENTS" title="(defun print-type-alist-segments (segs wrld evisc-tuple)
  (if (endp segs)
      segs
      (prog2$
       (cw &quot;-----~%Terms with type ~x0:~%&quot; (decode-type-set (caar segs)))
...">print-type-alist-segments</a>
  (segs wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (if (<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> segs)
    segs
    (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"-----~%Terms with type ~x0:~%"</span>
        (decode-type-set (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> segs)))
      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-print-terms" data-sym="PRINT-TERMS" title="(defun print-terms (terms iff-flg wrld evisc-tuple)
  (if (endp terms)
      terms
      (prog2$ (cw &quot;~Y01&quot; (untranslate (car terms) iff-flg wrld) evisc-tuple)
              (print-terms (cdr terms) iff-flg wrld evisc-tuple))))">print-terms</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> segs)
          (<a class="sym-link system" href="axioms.html#def-member" data-sym="MEMBER">member</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> segs)
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> *ts-t* *ts-non-nil* *ts-nil* *ts-boolean*))
          wrld
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
        (<a class="sym-link local-def" href="#def-print-type-alist-segments" data-sym="PRINT-TYPE-ALIST-SEGMENTS" title="(defun print-type-alist-segments (segs wrld evisc-tuple)
  (if (endp segs)
      segs
      (prog2$
       (cw &quot;-----~%Terms with type ~x0:~%&quot; (decode-type-set (caar segs)))
...">print-type-alist-segments</a> (cdr segs) wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))))</pre>
  </div>

<div class="form-block function" id="def-print-type-alist" data-defines="PRINT-TYPE-ALIST" data-references="TYPE-ALIST-SEGMENTS,PRINT-TYPE-ALIST-SEGMENTS,EVISC-TUPLE,WRLD,TYPE-ALIST,DEFUN" data-part-name="PRINT-TYPE-ALIST" data-part-args="EVISC-TUPLE,WRLD,TYPE-ALIST" data-part-body="EVISC-TUPLE,WRLD,TYPE-ALIST,TYPE-ALIST-SEGMENTS,PRINT-TYPE-ALIST-SEGMENTS" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PRINT-TYPE-ALIST">print-type-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-print-type-alist" data-sym="PRINT-TYPE-ALIST" title="(defun print-type-alist (type-alist wrld evisc-tuple)
  (print-type-alist-segments (type-alist-segments type-alist nil) wrld
                             evisc-tuple))">print-type-alist</a>
  (type-alist wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link local-def" href="#def-print-type-alist-segments" data-sym="PRINT-TYPE-ALIST-SEGMENTS" title="(defun print-type-alist-segments (segs wrld evisc-tuple)
  (if (endp segs)
      segs
      (prog2$
       (cw &quot;-----~%Terms with type ~x0:~%&quot; (decode-type-set (caar segs)))
...">print-type-alist-segments</a> (<a class="sym-link local-def" href="#def-type-alist-segments" data-sym="TYPE-ALIST-SEGMENTS" title="(defun type-alist-segments (type-alist acc)
  (if (endp type-alist)
      (sort-type-alist-segments acc)
      (type-alist-segments (cdr type-alist)
                           (add-to-type-alist-segments (cadar type-alist)">type-alist-segments</a> type-alist nil)
    wrld
    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))</pre>
  </div>

<div class="form-block function" id="def-print-pot-lst" data-defines="PRINT-POT-LST" data-references="CDR,SHOW-POLY-LST,APPEND,CAR,LINEAR-POT,ACCESS,PROG2$,T,CW,NULL,COND,EVISC-TUPLE,POT-LST,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*" data-part-name="PRINT-POT-LST" data-part-args="EVISC-TUPLE,POT-LST" data-part-body="CDR,PRINT-POT-LST,EVISC-TUPLE,SHOW-POLY-LST,APPEND,CAR,LINEAR-POT,ACCESS,PROG2$,T,CW,POT-LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PRINT-POT-LST">print-pot-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-print-pot-lst" data-sym="PRINT-POT-LST" title="(defun print-pot-lst (pot-lst evisc-tuple)
  (cond ((null pot-lst) (cw &quot;~%&quot;))
        (t
         (prog2$
          (cw
...">print-pot-lst</a>
  (pot-lst <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%"</span>))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"-----~|For maximal term ~X02~|the list of polynomials is:~|~X12~|"</span>
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst) <span class="keyword">:var</span>)
          (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (show-poly-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst) <span class="keyword">:negatives</span>)
              nil)
            (show-poly-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst) <span class="keyword">:positives</span>)
              nil))
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
        (<a class="sym-link local-def" href="#def-print-pot-lst" data-sym="PRINT-POT-LST" title="(defun print-pot-lst (pot-lst evisc-tuple)
  (cond ((null pot-lst) (cw &quot;~%&quot;))
        (t
         (prog2$
          (cw
...">print-pot-lst</a> (cdr pot-lst) <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))))</pre>
  </div>

<div class="form-block function" id="def-decode-logical-name" data-defines="DECODE-LOGICAL-NAME" data-references="SCAN-TO-DEFPKG,*INITIAL-KNOWN-PACKAGE-ALIST*,FIND-PACKAGE-ENTRY,KNOWN-PACKAGE-ALIST,GLOBAL-VAL,FIND-NON-HIDDEN-PACKAGE-ENTRY,STRINGP,AND,EVENT,LOOKUP-WORLD-INDEX,NULL,ABSOLUTE-EVENT-NUMBER,QUOTE,GETPROPC,N,LET,T,SCAN-TO-EVENT,EQ,SYMBOLP,COND,WRLD,NAME,DEFUN" data-used-by="FIND-RULES-OF-RUNE" data-part-name="DECODE-LOGICAL-NAME" data-part-args="WRLD,NAME" data-part-body="SCAN-TO-DEFPKG,*INITIAL-KNOWN-PACKAGE-ALIST*,FIND-PACKAGE-ENTRY,KNOWN-PACKAGE-ALIST,GLOBAL-VAL,FIND-NON-HIDDEN-PACKAGE-ENTRY,STRINGP,AND,EVENT,LOOKUP-WORLD-INDEX,NULL,ABSOLUTE-EVENT-NUMBER,QUOTE,GETPROPC,N,LET,T,WRLD,SCAN-TO-EVENT,EQ,NAME,SYMBOLP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="DECODE-LOGICAL-NAME">decode-logical-name</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-decode-logical-name" data-sym="DECODE-LOGICAL-NAME" title="(defun decode-logical-name (name wrld)
  (cond
   ((symbolp name)
    (cond ((eq name :here) (scan-to-event wrld))
          (t
...">decode-logical-name</a>
  (name wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp name) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> name <span class="keyword">:here</span>) (scan-to-event wrld))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((n (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> name 'absolute-event-number nil wrld)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> n) nil) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (lookup-world-index 'event n wrld)))))))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (stringp name)
       (<a class="sym-link system" href="axioms.html#def-find-non-hidden-package-entry" data-sym="FIND-NON-HIDDEN-PACKAGE-ENTRY">find-non-hidden-package-entry</a> name
         (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> '<a class="sym-link system" href="axioms.html#def-known-package-alist" data-sym="KNOWN-PACKAGE-ALIST">known-package-alist</a> wrld))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-find-package-entry" data-sym="FIND-PACKAGE-ENTRY">find-package-entry</a> name <a class="sym-link system" href="axioms.html#def-_2Ainitial-known-package-alist_2A" data-sym="*INITIAL-KNOWN-PACKAGE-ALIST*">*initial-known-package-alist*</a>) (lookup-world-index 'event <span class="number">0</span> wrld))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-scan-to-defpkg" data-sym="SCAN-TO-DEFPKG" title="(defun scan-to-defpkg (name wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (eq (access-event-tuple-type (cddar wrld)) &#39;defpkg)
              (equal name (access-event-tuple-namex (cddar wrld))))
...">scan-to-defpkg</a> name wrld))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-access-x-rule-rune" data-defines="ACCESS-X-RULE-RUNE" data-references="QUOTE,HARD,ER,OTHERWISE,TYPE-SET-INVERTER-RULE,INDUCTION-RULE,GENERALIZE-RULE,ELIM-RULE,BUILT-IN-CLAUSE,FORWARD-CHAINING-RULE,LINEAR-LEMMA,CDDR,WELL-FOUNDED-RELATION-RULE,REWRITE-RULE,PEQUIV,CONGRUENCE-RULE,TYPE-PRESCRIPTION,ACCESS,RECOGNIZER-TUPLE,CASE,RULE,X,DEFUN" data-used-by="SHOW-BRR-DATA-1,COLLECT-X-RULES-OF-RUNE" data-part-name="ACCESS-X-RULE-RUNE" data-part-args="RULE,X" data-part-body="ACCESS-X-RULE-RUNE,QUOTE,HARD,ER,OTHERWISE,TYPE-SET-INVERTER-RULE,INDUCTION-RULE,GENERALIZE-RULE,ELIM-RULE,BUILT-IN-CLAUSE,FORWARD-CHAINING-RULE,LINEAR-LEMMA,CDDR,WELL-FOUNDED-RELATION-RULE,REWRITE-RULE,PEQUIV,CONGRUENCE-RULE,TYPE-PRESCRIPTION,RULE,ACCESS,RECOGNIZER-TUPLE,X,CASE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCESS-X-RULE-RUNE">access-x-rule-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-access-x-rule-rune" data-sym="ACCESS-X-RULE-RUNE" title="(defun access-x-rule-rune (x rule)
  (case x
    (recognizer-tuple (access recognizer-tuple rule :rune))
    (type-prescription (access type-prescription rule :rune))
    (congruence-rule (access congruence-rule rule :rune))
...">access-x-rule-rune</a>
  (x rule)
  (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> x
    (recognizer-tuple (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> recognizer-tuple rule <span class="keyword">:rune</span>))
    (type-prescription (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-prescription rule <span class="keyword">:rune</span>))
    (congruence-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule rule <span class="keyword">:rune</span>))
    (pequiv (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequiv rule <span class="keyword">:congruence-rule</span>)
        <span class="keyword">:rune</span>))
    (rewrite-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:rune</span>))
    (well-founded-relation-rule (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> rule))
    (linear-lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma rule <span class="keyword">:rune</span>))
    (forward-chaining-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> forward-chaining-rule rule <span class="keyword">:rune</span>))
    (built-in-clause (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> built-in-clause rule <span class="keyword">:rune</span>))
    (elim-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> elim-rule rule <span class="keyword">:rune</span>))
    (generalize-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> generalize-rule rule <span class="keyword">:rune</span>))
    (induction-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> induction-rule rule <span class="keyword">:rune</span>))
    (type-set-inverter-rule (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> type-set-inverter-rule rule <span class="keyword">:rune</span>))
    (otherwise (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
        '<a class="sym-link local-def" href="#def-access-x-rule-rune" data-sym="ACCESS-X-RULE-RUNE" title="(defun access-x-rule-rune (x rule)
  (case x
    (recognizer-tuple (access recognizer-tuple rule :rune))
    (type-prescription (access type-prescription rule :rune))
    (congruence-rule (access congruence-rule rule :rune))
...">access-x-rule-rune</a>
        <span class="string">"Unrecognized rule class, ~x0."</span>
        x))))</pre>
  </div>

<div class="form-block function" id="def-collect-x-rules-of-rune" data-defines="COLLECT-X-RULES-OF-RUNE" data-references="T,ADD-TO-SET-EQUAL,CDR,CAR,ACCESS-X-RULE-RUNE,EQUAL,NULL,COND,ANS,LST,RUNE,X,DEFUN" data-used-by="FIND-RULES-OF-RUNE2,COLLECT-PEQUIVS-OF-RUNE,COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" data-part-name="COLLECT-X-RULES-OF-RUNE" data-part-args="ANS,LST,RUNE,X" data-part-body="T,ADD-TO-SET-EQUAL,CDR,COLLECT-X-RULES-OF-RUNE,CAR,X,ACCESS-X-RULE-RUNE,RUNE,EQUAL,ANS,LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-X-RULES-OF-RUNE">collect-x-rules-of-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a>
  (x rune lst ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) ans)
    ((equal rune (<a class="sym-link local-def" href="#def-access-x-rule-rune" data-sym="ACCESS-X-RULE-RUNE" title="(defun access-x-rule-rune (x rule)
  (case x
    (recognizer-tuple (access recognizer-tuple rule :rune))
    (type-prescription (access type-prescription rule :rune))
    (congruence-rule (access congruence-rule rule :rune))
...">access-x-rule-rune</a> x (car lst))) (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> x
        rune
        (cdr lst)
        (<a class="sym-link system" href="axioms.html#def-add-to-set-equal" data-sym="ADD-TO-SET-EQUAL">add-to-set-equal</a> (car lst) ans)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> x rune (cdr lst) ans))))</pre>
  </div>

<div class="form-block function" id="def-collect-congruence-rules-of-rune-in-geneqv-lst" data-defines="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" data-references="CAR,CONGRUENCE-RULE,QUOTE,COLLECT-X-RULES-OF-RUNE,CDR,T,NULL,COND,ANS,RUNE,GENEQV-LST,DEFUN" data-used-by="COLLECT-CONGRUENCE-RULES-OF-RUNE" data-part-name="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" data-part-args="ANS,RUNE,GENEQV-LST" data-part-body="CAR,CONGRUENCE-RULE,QUOTE,COLLECT-X-RULES-OF-RUNE,RUNE,CDR,COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST,T,ANS,GENEQV-LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST">collect-congruence-rules-of-rune-in-geneqv-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune-in-geneqv-lst" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" title="(defun collect-congruence-rules-of-rune-in-geneqv-lst (geneqv-lst rune ans)
  (cond ((null geneqv-lst) ans)
        (t
         (collect-congruence-rules-of-rune-in-geneqv-lst (cdr geneqv-lst) rune
                                                         (collect-x-rules-of-rune
...">collect-congruence-rules-of-rune-in-geneqv-lst</a>
  (<a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a> rune ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune-in-geneqv-lst" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" title="(defun collect-congruence-rules-of-rune-in-geneqv-lst (geneqv-lst rune ans)
  (cond ((null geneqv-lst) ans)
        (t
         (collect-congruence-rules-of-rune-in-geneqv-lst (cdr geneqv-lst) rune
                                                         (collect-x-rules-of-rune
...">collect-congruence-rules-of-rune-in-geneqv-lst</a> (cdr <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>)
        rune
        (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'congruence-rule
          rune
          (car <a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a>)
          ans)))))</pre>
  </div>

<div class="form-block function" id="def-collect-congruence-rules-of-rune" data-defines="COLLECT-CONGRUENCE-RULES-OF-RUNE" data-references="CAR,COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST,CDR,T,NULL,COND,ANS,RUNE,CONGRUENCES,DEFUN" data-used-by="FIND-RULES-OF-RUNE2" data-part-name="COLLECT-CONGRUENCE-RULES-OF-RUNE" data-part-args="ANS,RUNE,CONGRUENCES" data-part-body="CAR,COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST,RUNE,CDR,COLLECT-CONGRUENCE-RULES-OF-RUNE,T,ANS,CONGRUENCES,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE">collect-congruence-rules-of-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE" title="(defun collect-congruence-rules-of-rune (congruences rune ans)
  (cond ((null congruences) ans)
        (t
         (collect-congruence-rules-of-rune (cdr congruences) rune
                                           (collect-congruence-rules-of-rune-in-geneqv-lst
...">collect-congruence-rules-of-rune</a>
  (congruences rune ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> congruences) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE" title="(defun collect-congruence-rules-of-rune (congruences rune ans)
  (cond ((null congruences) ans)
        (t
         (collect-congruence-rules-of-rune (cdr congruences) rune
                                           (collect-congruence-rules-of-rune-in-geneqv-lst
...">collect-congruence-rules-of-rune</a> (cdr congruences)
        rune
        (<a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune-in-geneqv-lst" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE-IN-GENEQV-LST" title="(defun collect-congruence-rules-of-rune-in-geneqv-lst (geneqv-lst rune ans)
  (cond ((null geneqv-lst) ans)
        (t
         (collect-congruence-rules-of-rune-in-geneqv-lst (cdr geneqv-lst) rune
                                                         (collect-x-rules-of-rune
...">collect-congruence-rules-of-rune-in-geneqv-lst</a> (cdr (car congruences))
          rune
          ans)))))</pre>
  </div>

<div class="form-block function" id="def-collect-pequivs-of-rune" data-defines="COLLECT-PEQUIVS-OF-RUNE" data-references="CAR,PEQUIV,QUOTE,COLLECT-X-RULES-OF-RUNE,CDR,T,NULL,COND,ANS,RUNE,ALIST,DEFUN" data-used-by="FIND-RULES-OF-RUNE2" data-part-name="COLLECT-PEQUIVS-OF-RUNE" data-part-args="ANS,RUNE,ALIST" data-part-body="CAR,PEQUIV,QUOTE,COLLECT-X-RULES-OF-RUNE,RUNE,CDR,COLLECT-PEQUIVS-OF-RUNE,T,ANS,ALIST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-PEQUIVS-OF-RUNE">collect-pequivs-of-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-pequivs-of-rune" data-sym="COLLECT-PEQUIVS-OF-RUNE" title="(defun collect-pequivs-of-rune (alist rune ans)
  (cond ((null alist) ans)
        (t
         (collect-pequivs-of-rune (cdr alist) rune
                                  (collect-x-rules-of-rune &#39;pequiv rune
...">collect-pequivs-of-rune</a>
  (alist rune ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-collect-pequivs-of-rune" data-sym="COLLECT-PEQUIVS-OF-RUNE" title="(defun collect-pequivs-of-rune (alist rune ans)
  (cond ((null alist) ans)
        (t
         (collect-pequivs-of-rune (cdr alist) rune
                                  (collect-x-rules-of-rune &#39;pequiv rune
...">collect-pequivs-of-rune</a> (cdr alist)
        rune
        (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'pequiv rune (cdr (car alist)) ans)))))</pre>
  </div>

<div class="form-block function" id="def-find-rules-of-rune2" data-defines="FIND-RULES-OF-RUNE2" data-references="RECOGNIZER-TUPLE,RECOGNIZER-ALIST,INDUCTION-RULE,INDUCTION-RULES,TYPE-PRESCRIPTION,TYPE-PRESCRIPTIONS,FORWARD-CHAINING-RULE,FORWARD-CHAINING-RULES,COARSENINGS,PEQUIVS-PROPERTY,ACCESS,COLLECT-PEQUIVS-OF-RUNE,PEQUIVS,COLLECT-CONGRUENCE-RULES-OF-RUNE,CONGRUENCES,ELIM-RULE,ELIMINATE-DESTRUCTORS-RULES,LINEAR-LEMMA,LINEAR-LEMMAS,REWRITE-RULE,MEMBER-EQ,LEMMAS,T,OTHERWISE,GENERALIZE-RULE,GENERALIZE-RULES,TYPE-SET-INVERTER-RULE,TYPE-SET-INVERTER-RULES,BUILT-IN-CLAUSE,BUILT-IN-CLAUSES,WELL-FOUNDED-RELATION-RULE,COLLECT-X-RULES-OF-RUNE,IF,WELL-FOUNDED-RELATION-ALIST,CASE,GLOBAL-VALUE,QUOTE,EQ,COND,CAR,TOKEN,LET,ANS,VAL,KEY,SYM,RUNE,DEFUN" data-used-by="FIND-RULES-OF-RUNE1" data-part-name="FIND-RULES-OF-RUNE2" data-part-args="ANS,VAL,KEY,SYM,RUNE" data-part-body="RECOGNIZER-TUPLE,RECOGNIZER-ALIST,INDUCTION-RULE,INDUCTION-RULES,TYPE-PRESCRIPTION,TYPE-PRESCRIPTIONS,FORWARD-CHAINING-RULE,FORWARD-CHAINING-RULES,COARSENINGS,PEQUIVS-PROPERTY,ACCESS,COLLECT-PEQUIVS-OF-RUNE,PEQUIVS,COLLECT-CONGRUENCE-RULES-OF-RUNE,CONGRUENCES,ELIM-RULE,ELIMINATE-DESTRUCTORS-RULES,LINEAR-LEMMA,LINEAR-LEMMAS,REWRITE-RULE,MEMBER-EQ,LEMMAS,T,OTHERWISE,GENERALIZE-RULE,GENERALIZE-RULES,TYPE-SET-INVERTER-RULE,TYPE-SET-INVERTER-RULES,BUILT-IN-CLAUSE,BUILT-IN-CLAUSES,ANS,VAL,WELL-FOUNDED-RELATION-RULE,COLLECT-X-RULES-OF-RUNE,IF,WELL-FOUNDED-RELATION-ALIST,SYM,CASE,GLOBAL-VALUE,QUOTE,KEY,EQ,COND,RUNE,CAR,TOKEN,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-RULES-OF-RUNE2">find-rules-of-rune2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-rules-of-rune2" data-sym="FIND-RULES-OF-RUNE2" title="(defun find-rules-of-rune2 (rune sym key val ans)
  (let ((token (car rune)))
    (cond
     ((eq key &#39;global-value)
      (case sym
...">find-rules-of-rune2</a>
  (rune sym key val ans)
  (let ((token (car rune)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> key 'global-value) (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> sym
          (well-founded-relation-alist (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:well-founded-relation</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'well-founded-relation-rule
                rune
                val
                ans)
              ans))
          (built-in-clauses (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:built-in-clause</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'built-in-clause rune val ans)
              ans))
          (type-set-inverter-rules (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:type-set-inverter</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'type-set-inverter-rule
                rune
                val
                ans)
              ans))
          (generalize-rules (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:generalize</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'generalize-rule rune val ans)
              ans))
          (otherwise ans)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> key
          (lemmas (if (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> token '(<span class="keyword">:rewrite</span> <span class="keyword">:meta</span> <span class="keyword">:definition</span>))
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'rewrite-rule rune val ans)
              ans))
          (linear-lemmas (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:linear</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'linear-lemma rune val ans)
              ans))
          (eliminate-destructors-rules (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:elim</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'elim-rule rune val ans)
              ans))
          (congruences (if (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> token '(<span class="keyword">:congruence</span> <span class="keyword">:equivalence</span>))
              (<a class="sym-link local-def" href="#def-collect-congruence-rules-of-rune" data-sym="COLLECT-CONGRUENCE-RULES-OF-RUNE" title="(defun collect-congruence-rules-of-rune (congruences rune ans)
  (cond ((null congruences) ans)
        (t
         (collect-congruence-rules-of-rune (cdr congruences) rune
                                           (collect-congruence-rules-of-rune-in-geneqv-lst
...">collect-congruence-rules-of-rune</a> val rune ans)
              ans))
          (pequivs (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:congruence</span>)
              (<a class="sym-link local-def" href="#def-collect-pequivs-of-rune" data-sym="COLLECT-PEQUIVS-OF-RUNE" title="(defun collect-pequivs-of-rune (alist rune ans)
  (cond ((null alist) ans)
        (t
         (collect-pequivs-of-rune (cdr alist) rune
                                  (collect-x-rules-of-rune &#39;pequiv rune
...">collect-pequivs-of-rune</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequivs-property val <span class="keyword">:deep</span>)
                rune
                (<a class="sym-link local-def" href="#def-collect-pequivs-of-rune" data-sym="COLLECT-PEQUIVS-OF-RUNE" title="(defun collect-pequivs-of-rune (alist rune ans)
  (cond ((null alist) ans)
        (t
         (collect-pequivs-of-rune (cdr alist) rune
                                  (collect-x-rules-of-rune &#39;pequiv rune
...">collect-pequivs-of-rune</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> pequivs-property val <span class="keyword">:shallow</span>)
                  rune
                  ans))
              ans))
          (coarsenings ans)
          (forward-chaining-rules (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:forward-chaining</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'forward-chaining-rule
                rune
                val
                ans)
              ans))
          (type-prescriptions (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:type-prescription</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'type-prescription rune val ans)
              ans))
          (induction-rules (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:induction</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'induction-rule rune val ans)
              ans))
          (recognizer-alist (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:compound-recognizer</span>)
              (<a class="sym-link local-def" href="#def-collect-x-rules-of-rune" data-sym="COLLECT-X-RULES-OF-RUNE" title="(defun collect-x-rules-of-rune (x rune lst ans)
  (cond ((null lst) ans)
        ((equal rune (access-x-rule-rune x (car lst)))
         (collect-x-rules-of-rune x rune (cdr lst)
                                  (add-to-set-equal (car lst) ans)))">collect-x-rules-of-rune</a> 'recognizer-tuple rune val ans)
              ans))
          (otherwise ans))))))</pre>
  </div>

<div class="form-block function" id="def-find-rules-of-rune1" data-defines="FIND-RULES-OF-RUNE1" data-references="CADAR,CAAR,FIND-RULES-OF-RUNE2,T,CDR,*ACL2-PROPERTY-UNBOUND*,CDDAR,EQ,NULL,COND,ANS,PROPS,RUNE,DEFUN" data-used-by="FIND-RULES-OF-RUNE" data-part-name="FIND-RULES-OF-RUNE1" data-part-args="ANS,PROPS,RUNE" data-part-body="CADAR,CAAR,FIND-RULES-OF-RUNE2,T,CDR,RUNE,FIND-RULES-OF-RUNE1,*ACL2-PROPERTY-UNBOUND*,CDDAR,EQ,ANS,PROPS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-RULES-OF-RUNE1">find-rules-of-rune1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-rules-of-rune1" data-sym="FIND-RULES-OF-RUNE1" title="(defun find-rules-of-rune1 (rune props ans)
  (cond ((null props) ans)
        ((eq (cddar props) *acl2-property-unbound*)
         (find-rules-of-rune1 rune (cdr props) ans))
        (t
...">find-rules-of-rune1</a>
  (rune <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a> ans)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) ans)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) <a class="sym-link system" href="axioms.html#def-_2Aacl2-property-unbound_2A" data-sym="*ACL2-PROPERTY-UNBOUND*">*acl2-property-unbound*</a>) (<a class="sym-link local-def" href="#def-find-rules-of-rune1" data-sym="FIND-RULES-OF-RUNE1" title="(defun find-rules-of-rune1 (rune props ans)
  (cond ((null props) ans)
        ((eq (cddar props) *acl2-property-unbound*)
         (find-rules-of-rune1 rune (cdr props) ans))
        (t
...">find-rules-of-rune1</a> rune (cdr <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) ans))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-find-rules-of-rune1" data-sym="FIND-RULES-OF-RUNE1" title="(defun find-rules-of-rune1 (rune props ans)
  (cond ((null props) ans)
        ((eq (cddar props) *acl2-property-unbound*)
         (find-rules-of-rune1 rune (cdr props) ans))
        (t
...">find-rules-of-rune1</a> rune
        (cdr <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
        (<a class="sym-link local-def" href="#def-find-rules-of-rune2" data-sym="FIND-RULES-OF-RUNE2" title="(defun find-rules-of-rune2 (rune sym key val ans)
  (let ((token (car rune)))
    (cond
     ((eq key &#39;global-value)
      (case sym
...">find-rules-of-rune2</a> rune
          (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
          (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
          (<a class="sym-link system" href="axioms.html#def-cddar" data-sym="CDDAR">cddar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
          ans)))))</pre>
  </div>

<div class="form-block function" id="def-world-to-next-event" data-defines="WORLD-TO-NEXT-EVENT" data-references="CDR,CAR,CONS,T,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,NULL,COND,WRLD,DEFUN" data-part-name="WORLD-TO-NEXT-EVENT" data-part-args="WRLD" data-part-body="CDR,WORLD-TO-NEXT-EVENT,CAR,CONS,T,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,WRLD,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORLD-TO-NEXT-EVENT">world-to-next-event</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-world-to-next-event" data-sym="WORLD-TO-NEXT-EVENT" title="(defun world-to-next-event (wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value))
         nil)
        (t (cons (car wrld) (world-to-next-event (cdr wrld))))))">world-to-next-event</a>
  (wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> wrld) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> wrld) 'event-landmark)
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> wrld) 'global-value)) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car wrld) (<a class="sym-link local-def" href="#def-world-to-next-event" data-sym="WORLD-TO-NEXT-EVENT" title="(defun world-to-next-event (wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value))
         nil)
        (t (cons (car wrld) (world-to-next-event (cdr wrld))))))">world-to-next-event</a> (cdr wrld))))))</pre>
  </div>

<div class="form-block function" id="def-world-to-next-non-deeper-event" data-defines="WORLD-TO-NEXT-NON-DEEPER-EVENT" data-references="CDR,CONS,T,CAR,CDDR,ACCESS-EVENT-TUPLE-DEPTH,<=,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,NULL,COND,WRLD,N,DEFUN" data-used-by="FIND-RULES-OF-RUNE" data-part-name="WORLD-TO-NEXT-NON-DEEPER-EVENT" data-part-args="WRLD,N" data-part-body="CDR,WORLD-TO-NEXT-NON-DEEPER-EVENT,CONS,T,N,CAR,CDDR,ACCESS-EVENT-TUPLE-DEPTH,<=,GLOBAL-VALUE,CADAR,EVENT-LANDMARK,QUOTE,CAAR,EQ,AND,WRLD,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="WORLD-TO-NEXT-NON-DEEPER-EVENT">world-to-next-non-deeper-event</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-world-to-next-non-deeper-event" data-sym="WORLD-TO-NEXT-NON-DEEPER-EVENT" title="(defun world-to-next-non-deeper-event (n wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (&lt;= (access-event-tuple-depth (cddr (car wrld))) n))
         nil)">world-to-next-non-deeper-event</a>
  (n wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> wrld) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> wrld) 'event-landmark)
       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> wrld) 'global-value)
       (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (access-event-tuple-depth (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car wrld))) n)) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car wrld)
        (<a class="sym-link local-def" href="#def-world-to-next-non-deeper-event" data-sym="WORLD-TO-NEXT-NON-DEEPER-EVENT" title="(defun world-to-next-non-deeper-event (n wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (&lt;= (access-event-tuple-depth (cddr (car wrld))) n))
         nil)">world-to-next-non-deeper-event</a> n (cdr wrld))))))</pre>
  </div>

<div class="form-block function" id="def-actual-props" data-defines="ACTUAL-PROPS" data-references="T,CONS,HONS-ACONS,*ACL2-PROPERTY-UNBOUND*,CAR,CDDR,EQ,CAAR,HONS-GET,CDR,CADAR,MEMBER-EQ,REVERSE,FAST-ALIST-FREE,PROG2$,NULL,COND,ACC,SEEN,PROPS,DEFUN" data-used-by="FIND-RULES-OF-RUNE" data-part-name="ACTUAL-PROPS" data-part-args="ACC,SEEN,PROPS" data-part-body="T,CONS,HONS-ACONS,*ACL2-PROPERTY-UNBOUND*,CAR,CDDR,EQ,ACTUAL-PROPS,CAAR,HONS-GET,CDR,CADAR,MEMBER-EQ,ACC,REVERSE,SEEN,FAST-ALIST-FREE,PROG2$,PROPS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTUAL-PROPS">actual-props</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-actual-props" data-sym="ACTUAL-PROPS" title="(defun actual-props (props seen acc)
  (cond ((null props) (prog2$ (fast-alist-free seen) (reverse acc)))
        ((member-eq (cadar props) (cdr (hons-get (caar props) seen)))
         (actual-props (cdr props) seen acc))
        ((eq (cddr (car props)) *acl2-property-unbound*)
...">actual-props</a>
  (<a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a> seen acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (fast-alist-free seen) (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> acc)))
    ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) (cdr (hons-get (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) seen))) (<a class="sym-link local-def" href="#def-actual-props" data-sym="ACTUAL-PROPS" title="(defun actual-props (props seen acc)
  (cond ((null props) (prog2$ (fast-alist-free seen) (reverse acc)))
        ((member-eq (cadar props) (cdr (hons-get (caar props) seen)))
         (actual-props (cdr props) seen acc))
        ((eq (cddr (car props)) *acl2-property-unbound*)
...">actual-props</a> (cdr <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) seen acc))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)) <a class="sym-link system" href="axioms.html#def-_2Aacl2-property-unbound_2A" data-sym="*ACL2-PROPERTY-UNBOUND*">*acl2-property-unbound*</a>) (<a class="sym-link local-def" href="#def-actual-props" data-sym="ACTUAL-PROPS" title="(defun actual-props (props seen acc)
  (cond ((null props) (prog2$ (fast-alist-free seen) (reverse acc)))
        ((member-eq (cadar props) (cdr (hons-get (caar props) seen)))
         (actual-props (cdr props) seen acc))
        ((eq (cddr (car props)) *acl2-property-unbound*)
...">actual-props</a> (cdr <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
        (hons-acons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
          (cons (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) (cdr (hons-get (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) seen)))
          seen)
        acc))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-actual-props" data-sym="ACTUAL-PROPS" title="(defun actual-props (props seen acc)
  (cond ((null props) (prog2$ (fast-alist-free seen) (reverse acc)))
        ((member-eq (cadar props) (cdr (hons-get (caar props) seen)))
         (actual-props (cdr props) seen acc))
        ((eq (cddr (car props)) *acl2-property-unbound*)
...">actual-props</a> (cdr <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
        (hons-acons (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>)
          (cons (<a class="sym-link system" href="axioms.html#def-cadar" data-sym="CADAR">cadar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) (cdr (hons-get (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) seen)))
          seen)
        (cons (car <a class="sym-link system" href="history-management.html#def-props" data-sym="PROPS">props</a>) acc)))))</pre>
  </div>

<div class="form-block function" id="def-find-rules-of-rune" data-defines="FIND-RULES-OF-RUNE" data-references="QUOTE,CDR,WORLD-TO-NEXT-NON-DEEPER-EVENT,ACTUAL-PROPS,FIND-RULES-OF-RUNE1,CAR,CDDR,ACCESS-EVENT-TUPLE-DEPTH,DEPTH,BASE-SYMBOL,DECODE-LOGICAL-NAME,WRLD-TAIL,LET*,RUNEP,PLIST-WORLDP,AND,XARGS,DECLARE,WRLD,RUNE,DEFUN" data-used-by="BACKCHAIN-LIMIT-ENFORCERS" data-part-name="FIND-RULES-OF-RUNE" data-part-args="WRLD,RUNE" data-part-declare="RUNE,RUNEP,WRLD,PLIST-WORLDP,AND,XARGS,DECLARE" data-part-body="QUOTE,CDR,WORLD-TO-NEXT-NON-DEEPER-EVENT,ACTUAL-PROPS,FIND-RULES-OF-RUNE1,CAR,CDDR,ACCESS-EVENT-TUPLE-DEPTH,DEPTH,WRLD,RUNE,BASE-SYMBOL,DECODE-LOGICAL-NAME,WRLD-TAIL,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FIND-RULES-OF-RUNE">find-rules-of-rune</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-find-rules-of-rune" data-sym="FIND-RULES-OF-RUNE" title="(defun find-rules-of-rune (rune wrld)
  (declare (xargs :guard (and (plist-worldp wrld) (runep rune wrld))))
  (let* ((wrld-tail (decode-logical-name (base-symbol rune) wrld))
         (depth (access-event-tuple-depth (cddr (car wrld-tail)))))
    (find-rules-of-rune1 rune
...">find-rules-of-rune</a>
  (rune wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-plist-worldp" data-sym="PLIST-WORLDP">plist-worldp</a> wrld) (runep rune wrld))))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((wrld-tail (<a class="sym-link local-def" href="#def-decode-logical-name" data-sym="DECODE-LOGICAL-NAME" title="(defun decode-logical-name (name wrld)
  (cond
   ((symbolp name)
    (cond ((eq name :here) (scan-to-event wrld))
          (t
...">decode-logical-name</a> (base-symbol rune) wrld)) (depth (access-event-tuple-depth (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> (car wrld-tail)))))
    (<a class="sym-link local-def" href="#def-find-rules-of-rune1" data-sym="FIND-RULES-OF-RUNE1" title="(defun find-rules-of-rune1 (rune props ans)
  (cond ((null props) ans)
        ((eq (cddar props) *acl2-property-unbound*)
         (find-rules-of-rune1 rune (cdr props) ans))
        (t
...">find-rules-of-rune1</a> rune
      (<a class="sym-link local-def" href="#def-actual-props" data-sym="ACTUAL-PROPS" title="(defun actual-props (props seen acc)
  (cond ((null props) (prog2$ (fast-alist-free seen) (reverse acc)))
        ((member-eq (cadar props) (cdr (hons-get (caar props) seen)))
         (actual-props (cdr props) seen acc))
        ((eq (cddr (car props)) *acl2-property-unbound*)
...">actual-props</a> (<a class="sym-link local-def" href="#def-world-to-next-non-deeper-event" data-sym="WORLD-TO-NEXT-NON-DEEPER-EVENT" title="(defun world-to-next-non-deeper-event (n wrld)
  (cond ((null wrld) nil)
        ((and (eq (caar wrld) &#39;event-landmark) (eq (cadar wrld) &#39;global-value)
              (&lt;= (access-event-tuple-depth (cddr (car wrld))) n))
         nil)">world-to-next-non-deeper-event</a> depth (cdr wrld-tail))
        '<a class="sym-link local-def" href="#def-find-rules-of-rune1" data-sym="FIND-RULES-OF-RUNE1" title="(defun find-rules-of-rune1 (rune props ans)
  (cond ((null props) ans)
        ((eq (cddar props) *acl2-property-unbound*)
         (find-rules-of-rune1 rune (cdr props) ans))
        (t
...">find-rules-of-rune1</a>
        nil)
      nil)))</pre>
  </div>

<div class="form-block function" id="def-backchain-limit-enforcers" data-defines="BACKCHAIN-LIMIT-ENFORCERS" data-references="CDR,CONS,1+,>=,1-,NTH,META,QUOTE,NOT,HYP-BACKCHAIN-LIMIT,ANCESTOR,BKPTR,REWRITE-RULE,LINEAR-LEMMA,ACCESS,IF,BACKCHAIN-LIMIT-LST,EQ,LINEARP,FIND-RULES-OF-RUNE,AND,RULE,CAR,ANCESTOR-BACKCHAIN-RUNE,RUNE,LET*,T,ENDP,COND,WRLD,ANCESTORS,POSITION,DEFUN" data-used-by="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" data-part-name="BACKCHAIN-LIMIT-ENFORCERS" data-part-args="WRLD,ANCESTORS,POSITION" data-part-body="CDR,BACKCHAIN-LIMIT-ENFORCERS,CONS,POSITION,1+,>=,1-,NTH,META,QUOTE,NOT,HYP-BACKCHAIN-LIMIT,ANCESTOR,BKPTR,REWRITE-RULE,LINEAR-LEMMA,ACCESS,IF,BACKCHAIN-LIMIT-LST,EQ,LINEARP,WRLD,FIND-RULES-OF-RUNE,AND,RULE,CAR,ANCESTOR-BACKCHAIN-RUNE,RUNE,LET*,T,ANCESTORS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BACKCHAIN-LIMIT-ENFORCERS">backchain-limit-enforcers</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-backchain-limit-enforcers" data-sym="BACKCHAIN-LIMIT-ENFORCERS" title="(defun backchain-limit-enforcers (position ancestors wrld)
  (cond ((endp ancestors) nil)
        (t
         (let* ((rune (ancestor-backchain-rune (car ancestors)))
                (rule (and rune (car (find-rules-of-rune rune wrld)))))
...">backchain-limit-enforcers</a>
  (<a class="sym-link system" href="axioms.html#def-position" data-sym="POSITION">position</a> ancestors wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> ancestors) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rune (<a class="sym-link local-def" href="#def-ancestor-backchain-rune" data-sym="ANCESTOR-BACKCHAIN-RUNE" title="(defun ancestor-backchain-rune (ancestor)
  (and (access ancestor ancestor :bkptr)
       (let ((tokens (access ancestor ancestor :tokens)))
         (assert$ (and tokens (null (cdr tokens))) (car tokens)))))">ancestor-backchain-rune</a> (car ancestors))) (rule (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rune (car (<a class="sym-link local-def" href="#def-find-rules-of-rune" data-sym="FIND-RULES-OF-RUNE" title="(defun find-rules-of-rune (rune wrld)
  (declare (xargs :guard (and (plist-worldp wrld) (runep rune wrld))))
  (let* ((wrld-tail (decode-logical-name (base-symbol rune) wrld))
         (depth (access-event-tuple-depth (cddr (car wrld-tail)))))
    (find-rules-of-rune1 rune
...">find-rules-of-rune</a> rune wrld)))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rule (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((linearp (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car rune) <span class="keyword">:linear</span>)) (backchain-limit-lst (if linearp
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma rule <span class="keyword">:backchain-limit-lst</span>)
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:backchain-limit-lst</span>)))
                (bkptr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:bkptr</span>))
                (hyp-backchain-limit (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> backchain-limit-lst
                    (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> linearp)
                        (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:subclass</span>) 'meta))
                      backchain-limit-lst
                      (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> bkptr) backchain-limit-lst)))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyp-backchain-limit
                   (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> <a class="sym-link system" href="axioms.html#def-position" data-sym="POSITION">position</a>) hyp-backchain-limit)) (cons (cons <a class="sym-link system" href="axioms.html#def-position" data-sym="POSITION">position</a> hyp-backchain-limit)
                    (<a class="sym-link local-def" href="#def-backchain-limit-enforcers" data-sym="BACKCHAIN-LIMIT-ENFORCERS" title="(defun backchain-limit-enforcers (position ancestors wrld)
  (cond ((endp ancestors) nil)
        (t
         (let* ((rune (ancestor-backchain-rune (car ancestors)))
                (rule (and rune (car (find-rules-of-rune rune wrld)))))
...">backchain-limit-enforcers</a> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> <a class="sym-link system" href="axioms.html#def-position" data-sym="POSITION">position</a>)
                      (cdr ancestors)
                      wrld)))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-backchain-limit-enforcers" data-sym="BACKCHAIN-LIMIT-ENFORCERS" title="(defun backchain-limit-enforcers (position ancestors wrld)
  (cond ((endp ancestors) nil)
        (t
         (let* ((rune (ancestor-backchain-rune (car ancestors)))
                (rule (and rune (car (find-rules-of-rune rune wrld)))))
...">backchain-limit-enforcers</a> (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> <a class="sym-link system" href="axioms.html#def-position" data-sym="POSITION">position</a>)
                    (cdr ancestors)
                    wrld))))))))))</pre>
  </div>

<div class="form-block function" id="def-tilde-_2A-ancestors-stack-msg1" data-defines="TILDE-*-ANCESTORS-STACK-MSG1" data-references="ANCESTOR,ACCESS,TOKENS,LET,CDR,+,ANCESTOR-BINDING-HYP/UNIFY-SUBST,T,ANCESTOR-BINDING-HYP/HYP,DUMB-NEGATE-LIT,UNTRANSLATE,MSG,CONS,CAR,ANCESTOR-BINDING-HYP-P,ENDP,COND,EVISC-TUPLE,WRLD,ANCESTORS,I,DEFUN" data-used-by="TILDE-*-ANCESTORS-STACK-MSG" data-part-name="TILDE-*-ANCESTORS-STACK-MSG1" data-part-args="EVISC-TUPLE,WRLD,ANCESTORS,I" data-part-body="ANCESTOR,ACCESS,TOKENS,LET,CDR,+,TILDE-*-ANCESTORS-STACK-MSG1,ANCESTOR-BINDING-HYP/UNIFY-SUBST,EVISC-TUPLE,WRLD,T,ANCESTOR-BINDING-HYP/HYP,DUMB-NEGATE-LIT,UNTRANSLATE,I,MSG,CONS,CAR,ANCESTOR-BINDING-HYP-P,ANCESTORS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-*-ANCESTORS-STACK-MSG1">tilde-*-ancestors-stack-msg1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg1" data-sym="TILDE-*-ANCESTORS-STACK-MSG1" title="(defun tilde-*-ancestors-stack-msg1 (i ancestors wrld evisc-tuple)
  (cond ((endp ancestors) nil)
        ((ancestor-binding-hyp-p (car ancestors))
         (cons
          (msg &quot;~c0. Binding Hyp: ~Q12~|~
...">tilde-*-ancestors-stack-msg1</a>
  (i ancestors wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> ancestors) nil)
    ((ancestor-binding-hyp-p (car ancestors)) (cons (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~c0. Binding Hyp: ~Q12~|~
                     ~ ~ ~ ~ ~ Unify-subst:  ~Q32~%"</span>
          (cons i <span class="number">2</span>)
          (untranslate (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> (ancestor-binding-hyp/hyp (car ancestors)))
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            wrld)
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
          (ancestor-binding-hyp/unify-subst (car ancestors)))
        (<a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg1" data-sym="TILDE-*-ANCESTORS-STACK-MSG1" title="(defun tilde-*-ancestors-stack-msg1 (i ancestors wrld evisc-tuple)
  (cond ((endp ancestors) nil)
        ((ancestor-binding-hyp-p (car ancestors))
         (cons
          (msg &quot;~c0. Binding Hyp: ~Q12~|~
...">tilde-*-ancestors-stack-msg1</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> i)
          (cdr ancestors)
          wrld
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (let ((tokens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:tokens</span>)))
          (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~c0. Hyp: ~Q12~|~
                         ~ ~ ~ ~ ~ Rune~#3~[:  ~x4~/s:  ~x3~]~%"</span>
            (cons i <span class="number">2</span>)
            (untranslate (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> ancestor (car ancestors) <span class="keyword">:lit</span>))
              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
              wrld)
            <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
            tokens
            (car tokens)))
        (<a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg1" data-sym="TILDE-*-ANCESTORS-STACK-MSG1" title="(defun tilde-*-ancestors-stack-msg1 (i ancestors wrld evisc-tuple)
  (cond ((endp ancestors) nil)
        ((ancestor-binding-hyp-p (car ancestors))
         (cons
          (msg &quot;~c0. Binding Hyp: ~Q12~|~
...">tilde-*-ancestors-stack-msg1</a> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> i)
          (cdr ancestors)
          wrld
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))))</pre>
  </div>

<div class="form-block function" id="def-tilde-_2A-ancestors-stack-msg" data-defines="TILDE-*-ANCESTORS-STACK-MSG" data-references="TILDE-*-ANCESTORS-STACK-MSG1,LIST,EVISC-TUPLE,WRLD,ANCESTORS,DEFUN" data-used-by="SHOW-ANCESTORS-STACK-MSG" data-part-name="TILDE-*-ANCESTORS-STACK-MSG" data-part-args="EVISC-TUPLE,WRLD,ANCESTORS" data-part-body="EVISC-TUPLE,WRLD,ANCESTORS,TILDE-*-ANCESTORS-STACK-MSG1,LIST" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-*-ANCESTORS-STACK-MSG">tilde-*-ancestors-stack-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg" data-sym="TILDE-*-ANCESTORS-STACK-MSG" title="(defun tilde-*-ancestors-stack-msg (ancestors wrld evisc-tuple)
  (list &quot;&quot; &quot;~@*&quot; &quot;~@*&quot; &quot;~@*&quot;
        (tilde-*-ancestors-stack-msg1 0 ancestors wrld evisc-tuple)))">tilde-*-ancestors-stack-msg</a>
  (ancestors wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="string">""</span>
    <span class="string">"~@*"</span>
    <span class="string">"~@*"</span>
    <span class="string">"~@*"</span>
    (<a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg1" data-sym="TILDE-*-ANCESTORS-STACK-MSG1" title="(defun tilde-*-ancestors-stack-msg1 (i ancestors wrld evisc-tuple)
  (cond ((endp ancestors) nil)
        ((ancestor-binding-hyp-p (car ancestors))
         (cons
          (msg &quot;~c0. Binding Hyp: ~Q12~|~
...">tilde-*-ancestors-stack-msg1</a> <span class="number">0</span> ancestors wrld <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))</pre>
  </div>

<div class="form-block function" id="def-semi-initialize-brr-wormhole" data-defines="SEMI-INITIALIZE-BRR-WORMHOLE" data-references="TOP-LEVEL-BRR-STATUS,ACCESS,BRR-STATUS,CHANGE,WHS,LAMBDA,WORMHOLE-EVAL,T,BRR,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,COND,STATE,DEFUN" data-part-name="SEMI-INITIALIZE-BRR-WORMHOLE" data-part-args="STATE" data-part-body="TOP-LEVEL-BRR-STATUS,ACCESS,BRR-STATUS,CHANGE,WHS,LAMBDA,WORMHOLE-EVAL,T,BRR,STATE,WORMHOLE-NAME,QUOTE,F-GET-GLOBAL,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEMI-INITIALIZE-BRR-WORMHOLE">semi-initialize-brr-wormhole</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-semi-initialize-brr-wormhole" data-sym="SEMI-INITIALIZE-BRR-WORMHOLE" title="(defun semi-initialize-brr-wormhole (state)
  (cond ((eq (f-get-global &#39;wormhole-name state) &#39;brr) nil)
        (t
         (wormhole-eval &#39;brr
                        &#39;(lambda (whs)
...">semi-initialize-brr-wormhole</a>
  (state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-name state) '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a>) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a>
        '(lambda (whs)
          (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-status
            whs
            <span class="keyword">:brr-monitored-runes</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
              (<a class="sym-link local-def" href="#def-top-level-brr-status" data-sym="TOP-LEVEL-BRR-STATUS" title="(defun top-level-brr-status (whs)
  (make-initial-brr-status
   (access brr-status (dive-to-deepest-brr-status whs) :brr-monitored-runes)))">top-level-brr-status</a> whs)
              <span class="keyword">:brr-monitored-runes</span>)
            <span class="keyword">:brr-gstack</span> nil
            <span class="keyword">:brr-local-alist</span> nil
            <span class="keyword">:brr-previous-status</span> nil))
        nil))))</pre>
  </div>

<div class="form-block function" id="def-show-ancestors-stack-msg" data-defines="SHOW-ANCESTORS-STACK-MSG" data-references="W,ANCESTORS,QUOTE,GET-BRR-LOCAL,TILDE-*-ANCESTORS-STACK-MSG,MSG,EVISC-TUPLE,STATE,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*,TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" data-part-name="SHOW-ANCESTORS-STACK-MSG" data-part-args="EVISC-TUPLE,STATE" data-part-body="EVISC-TUPLE,W,STATE,ANCESTORS,QUOTE,GET-BRR-LOCAL,TILDE-*-ANCESTORS-STACK-MSG,MSG" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-ANCESTORS-STACK-MSG">show-ancestors-stack-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-ancestors-stack-msg" data-sym="SHOW-ANCESTORS-STACK-MSG" title="(defun show-ancestors-stack-msg (state evisc-tuple)
  (msg &quot;Ancestors stack (most recent entry on top):~%~*0~%Use ~x1 to see ~
        actual ancestors stack.~%&quot;
       (tilde-*-ancestors-stack-msg (get-brr-local &#39;ancestors state) (w state)
                                    evisc-tuple)">show-ancestors-stack-msg</a>
  (state <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Ancestors stack (most recent entry on top):~%~*0~%Use ~x1 to see ~
        actual ancestors stack.~%"</span>
    (<a class="sym-link local-def" href="#def-tilde-_2A-ancestors-stack-msg" data-sym="TILDE-*-ANCESTORS-STACK-MSG" title="(defun tilde-*-ancestors-stack-msg (ancestors wrld evisc-tuple)
  (list &quot;&quot; &quot;~@*&quot; &quot;~@*&quot; &quot;~@*&quot;
        (tilde-*-ancestors-stack-msg1 0 ancestors wrld evisc-tuple)))">tilde-*-ancestors-stack-msg</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'ancestors state)
      (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)
      <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
    '(<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'ancestors state)))</pre>
  </div>

<div class="form-block function" id="def-tilde-_40-failure-reason-phrase1-backchain-limit" data-defines="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" data-references="SHOW-ANCESTORS-STACK-MSG,STRIP-CDRS,STRIP-CARS,T,BACKCHAIN-LIMIT,STR,NULL,COND,W,BACKCHAIN-LIMIT-ENFORCERS,PAIRS,LET,MSG,EVISC-TUPLE,STATE,ANCESTORS,HYP-NUMBER,DEFUN" data-used-by="TILDE-@-FAILURE-REASON-FREE-PHRASE" data-part-name="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" data-part-args="EVISC-TUPLE,STATE,ANCESTORS,HYP-NUMBER" data-part-body="EVISC-TUPLE,SHOW-ANCESTORS-STACK-MSG,STRIP-CDRS,STRIP-CARS,T,BACKCHAIN-LIMIT,STR,NULL,COND,STATE,W,ANCESTORS,BACKCHAIN-LIMIT-ENFORCERS,PAIRS,LET,HYP-NUMBER,MSG" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT">tilde-@-failure-reason-phrase1-backchain-limit</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase1-backchain-limit" data-sym="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" title="(defun tilde-@-failure-reason-phrase1-backchain-limit
       (hyp-number ancestors state evisc-tuple)
  (msg &quot;a backchain limit was reached while processing :HYP ~x0.  ~@1&quot;
       hyp-number
       (let ((pairs (backchain-limit-enforcers 0 ancestors (w state))))
...">tilde-@-failure-reason-phrase1-backchain-limit</a>
  (hyp-number ancestors state <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)
  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"a backchain limit was reached while processing :HYP ~x0.  ~@1"</span>
    hyp-number
    (let ((pairs (<a class="sym-link local-def" href="#def-backchain-limit-enforcers" data-sym="BACKCHAIN-LIMIT-ENFORCERS" title="(defun backchain-limit-enforcers (position ancestors wrld)
  (cond ((endp ancestors) nil)
        (t
         (let* ((rune (ancestor-backchain-rune (car ancestors)))
                (rule (and rune (car (find-rules-of-rune rune wrld)))))
...">backchain-limit-enforcers</a> <span class="number">0</span> ancestors (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state))))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pairs) (let ((str <span class="string">"  Note that the brr command, :ANCESTORS, will show you the ~
                   ancestors stack."</span>))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state) <span class="keyword">:rewrite</span>) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"This appears to be due to the global backchain-limit of ~
                      ~x0.~@1"</span>
                  (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state) <span class="keyword">:rewrite</span>)
                  str))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"Note that the limit is 0 for that :HYP."</span>)))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"The ancestors stack is below.  The ~#0~[entry~/entries~] at ~
             index ~&amp;0 ~#0~[shows~/each show~] a rune whose ~#0~[~/respective ~
             ~]backchain limit of ~v1 has been reached, for backchaining ~
             through its indicated hypothesis.~|~%~@2"</span>
            (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> pairs)
            (<a class="sym-link system" href="axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> pairs)
            (<a class="sym-link local-def" href="#def-show-ancestors-stack-msg" data-sym="SHOW-ANCESTORS-STACK-MSG" title="(defun show-ancestors-stack-msg (state evisc-tuple)
  (msg &quot;Ancestors stack (most recent entry on top):~%~*0~%Use ~x1 to see ~
        actual ancestors stack.~%&quot;
       (tilde-*-ancestors-stack-msg (get-brr-local &#39;ancestors state) (w state)
                                    evisc-tuple)">show-ancestors-stack-msg</a> state <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>)))))))</pre>
  </div>

<div class="form-block function" id="def-get-evg" data-defines="GET-EVG" data-references="HARD,ER,CADR,QUOTEP,IF,CTX,Q,DEFUN" data-used-by="RELIEVE-HYP-SYNP,BIND-FREE-INFO,EV-SYNP" data-part-name="GET-EVG" data-part-args="CTX,Q" data-part-body="CTX,HARD,ER,CADR,Q,QUOTEP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-EVG">get-evg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a>
  (q ctx)
  (if (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> q)
    (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> q)
    (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
      ctx
      <span class="string">"We expected a quotep in this context, variables, but ~x0 is not a ~
         quotep!"</span>
      q)))</pre>
  </div>

<div class="form-block function" id="def-get-brr-one-way-unify-info" data-defines="GET-BRR-ONE-WAY-UNIFY-INFO" data-references="LINEAR-LEMMA,ASSOC-EQUAL,CDR,ALISTP,REWRITE-CONSTANT,RESTRICTIONS-ALIST,CAR,EQL,CONSP,HEURISTIC-INFO,LET,REWRITE-QUOTED-CONSTANT,ACCESS,MV,REWRITE-RULE,QUOTE,RECORD-TYPE,EQ,IF,WEAK-REWRITE-CONSTANT-P,WEAK-LINEAR-LEMMA-P,WEAK-REWRITE-RULE-P,OR,AND,XARGS,DECLARE,RCNST,LEMMA,DEFUN" data-used-by="NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1,BUILT-IN-BRR-NEAR-MISSP" data-part-name="GET-BRR-ONE-WAY-UNIFY-INFO" data-part-args="RCNST,LEMMA" data-part-declare="RCNST,WEAK-REWRITE-CONSTANT-P,WEAK-LINEAR-LEMMA-P,LEMMA,WEAK-REWRITE-RULE-P,OR,AND,XARGS,DECLARE" data-part-body="LINEAR-LEMMA,ASSOC-EQUAL,CDR,ALISTP,RCNST,REWRITE-CONSTANT,RESTRICTIONS-ALIST,CAR,EQL,CONSP,HEURISTIC-INFO,LET,REWRITE-QUOTED-CONSTANT,AND,ACCESS,MV,REWRITE-RULE,QUOTE,LEMMA,RECORD-TYPE,EQ,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-BRR-ONE-WAY-UNIFY-INFO">get-brr-one-way-unify-info</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-brr-one-way-unify-info" data-sym="GET-BRR-ONE-WAY-UNIFY-INFO" title="(defun get-brr-one-way-unify-info (lemma rcnst)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (weak-rewrite-constant-p rcnst))))
...">get-brr-one-way-unify-info</a>
  (lemma rcnst)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
        (weak-rewrite-constant-p rcnst))))
  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'rewrite-rule)
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rune</span>)
      <span class="keyword">:lhs</span> (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:subclass</span>)
            'rewrite-quoted-constant)
          (let ((heuristic-info (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:heuristic-info</span>)))
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp heuristic-info) (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (car heuristic-info) <span class="number">2</span>))))
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>)
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:lhs</span>))
      (let ((restrictions-alist (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:restrictions-alist</span>)))
        (if (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> restrictions-alist)
          (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rune</span>)
              restrictions-alist))
          nil)))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:rune</span>)
      <span class="keyword">:max-term</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:max-term</span>)
      nil)))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-abstract-pat1" data-defines="ABSTRACT-PAT1" data-references="CDR,NEW-ARG,ENDP,PSEUDO-TERM-LISTP,PATS,FFN-SYMB,FCONS-TERM,FARGS,-,IF,ABSTRACT-PAT1-LST,NEW-VARS,NEW-ARGS,MV-LET,LAMBDA,CAR,UNQUOTE,CONSP,FQUOTEP,VARIABLEP,CONS,MV,BRR,QUOTE,GENVAR,NEW-VAR,LET,EQL,COND,ACL2-COUNT,TRUE-LISTP,PSEUDO-TERMP,NATP,T,EQ,OR,AND,XARGS,DECLARE,VARS,PAT,K-FLG,DEFUN,MUTUAL-RECURSION" data-used-by="ABSTRACT-PAT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ABSTRACT-PAT1">abstract-pat1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-abstract-pat1" data-sym="ABSTRACT-PAT1" title="(mutual-recursion
 (defun abstract-pat1 (k-flg pat vars)
   (declare
    (xargs :guard
     (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat) (true-listp vars))
...">abstract-pat1</a>
    (k-flg pat vars)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> k-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> k-flg))
          (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat)
          (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> vars))
        <span class="keyword">:verify-guards</span> nil
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> pat)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> k-flg <span class="number">0</span>) (let ((new-var (<a class="sym-link system" href="basis-b.html#def-genvar" data-sym="GENVAR">genvar</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> <span class="string">"GENSYM"</span> <span class="number">0</span> vars)))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-var (cons new-var vars))))
      ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> pat) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> pat vars))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> pat) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> k-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
             (consp (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> pat))
             (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> pat)) 'lambda)) (let ((new-var (<a class="sym-link system" href="basis-b.html#def-genvar" data-sym="GENVAR">genvar</a> '<a class="sym-link system" href="defthm.html#def-brr" data-sym="BRR">brr</a> <span class="string">"GENSYM"</span> <span class="number">0</span> vars)))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-var (cons new-var vars))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> pat vars))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-args new-vars)
          (abstract-pat1-lst (if (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> k-flg)
              (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> k-flg <span class="number">1</span>)
              k-flg)
            (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> pat)
            vars)
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-fcons-term" data-sym="FCONS-TERM">fcons-term</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> pat) new-args) new-vars)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> abstract-pat1-lst
    (k-flg pats vars)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> k-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> k-flg))
          (pseudo-term-listp pats)
          (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> vars))
        <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> pats)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> pats) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil vars))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-arg new-vars)
          (<a class="sym-link local-def" href="#def-abstract-pat1" data-sym="ABSTRACT-PAT1" title="(mutual-recursion
 (defun abstract-pat1 (k-flg pat vars)
   (declare
    (xargs :guard
     (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat) (true-listp vars))
...">abstract-pat1</a> k-flg (car pats) vars)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-args new-vars)
            (abstract-pat1-lst k-flg (cdr pats) new-vars)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons new-arg new-args) new-vars)))))))</pre>
  </div>

<div class="form-block function" id="def-abstract-pat" data-defines="ABSTRACT-PAT" data-references="IGNORE,ALL-VARS,ABSTRACT-PAT1,VARS,NEW-PAT,MV-LET,PSEUDO-TERMP,NATP,T,EQ,OR,AND,XARGS,DECLARE,PAT,K-FLG,DEFUN" data-used-by="BUILT-IN-BRR-NEAR-MISSP,MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" data-part-name="ABSTRACT-PAT" data-part-args="PAT,K-FLG" data-part-declare="PAT,PSEUDO-TERMP,NATP,T,K-FLG,EQ,OR,AND,XARGS,DECLARE" data-part-body="IGNORE,DECLARE,ALL-VARS,PAT,K-FLG,ABSTRACT-PAT1,VARS,NEW-PAT,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ABSTRACT-PAT">abstract-pat</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-abstract-pat" data-sym="ABSTRACT-PAT" title="(defun abstract-pat (k-flg pat)
  (declare
   (xargs :guard (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat))))
  (mv-let (new-pat vars) (abstract-pat1 k-flg pat (all-vars pat))
          (declare (ignore vars)) new-pat))">abstract-pat</a>
  (k-flg pat)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> k-flg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> k-flg)) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat))))
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-pat vars)
    (<a class="sym-link local-def" href="#def-abstract-pat1" data-sym="ABSTRACT-PAT1" title="(mutual-recursion
 (defun abstract-pat1 (k-flg pat vars)
   (declare
    (xargs :guard
     (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat) (true-listp vars))
...">abstract-pat1</a> k-flg pat (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> pat))
    (declare (ignore vars))
    new-pat))</pre>
  </div>

<div class="form-block function" id="def-alistp-listp" data-defines="ALISTP-LISTP" data-references="CDR,CAR,ALISTP,AND,EQ,ATOM,COND,T,XARGS,DECLARE,X,DEFUN" data-used-by="BUILT-IN-BRR-NEAR-MISSP,ONE-WAY-UNIFY-RESTRICTIONS,ONE-WAY-UNIFY-RESTRICTIONS1" data-part-name="ALISTP-LISTP" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,ALISTP-LISTP,CAR,ALISTP,AND,T,EQ,X,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALISTP-LISTP">alistp-listp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-alistp-listp" data-sym="ALISTP-LISTP" title="(defun alistp-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (eq x nil))
        (t (and (alistp (car x)) (alistp-listp (cdr x))))))">alistp-listp</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (car x)) (<a class="sym-link local-def" href="#def-alistp-listp" data-sym="ALISTP-LISTP" title="(defun alistp-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (eq x nil))
        (t (and (alistp (car x)) (alistp-listp (cdr x))))))">alistp-listp</a> (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-one-way-unify-restrictions1" data-defines="ONE-WAY-UNIFY-RESTRICTIONS1" data-references="CDR,CAR,ONE-WAY-UNIFY1,UNIFY-SUBST,UNIFY-ANS,MV-LET,T,MV,ENDP,COND,ALISTP-LISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,RESTRICTIONS,TERM,PAT,DEFUN" data-used-by="ONE-WAY-UNIFY-RESTRICTIONS" data-part-name="ONE-WAY-UNIFY-RESTRICTIONS1" data-part-args="RESTRICTIONS,TERM,PAT" data-part-declare="RESTRICTIONS,ALISTP-LISTP,TERM,PAT,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="CDR,ONE-WAY-UNIFY-RESTRICTIONS1,CAR,TERM,PAT,ONE-WAY-UNIFY1,UNIFY-SUBST,UNIFY-ANS,MV-LET,T,MV,RESTRICTIONS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ONE-WAY-UNIFY-RESTRICTIONS1">one-way-unify-restrictions1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-one-way-unify-restrictions1" data-sym="ONE-WAY-UNIFY-RESTRICTIONS1" title="(defun one-way-unify-restrictions1 (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((endp restrictions) (mv nil nil))
...">one-way-unify-restrictions1</a>
  (pat term restrictions)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat)
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)
        (<a class="sym-link local-def" href="#def-alistp-listp" data-sym="ALISTP-LISTP" title="(defun alistp-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (eq x nil))
        (t (and (alistp (car x)) (alistp-listp (cdr x))))))">alistp-listp</a> restrictions))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> restrictions) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
        (one-way-unify1 pat term (car restrictions))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (unify-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> unify-ans unify-subst))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-one-way-unify-restrictions1" data-sym="ONE-WAY-UNIFY-RESTRICTIONS1" title="(defun one-way-unify-restrictions1 (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((endp restrictions) (mv nil nil))
...">one-way-unify-restrictions1</a> pat term (cdr restrictions))))))))</pre>
  </div>

<div class="form-block function" id="def-one-way-unify-restrictions" data-defines="ONE-WAY-UNIFY-RESTRICTIONS" data-references="ONE-WAY-UNIFY-RESTRICTIONS1,T,ONE-WAY-UNIFY,NULL,COND,ALISTP-LISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,RESTRICTIONS,TERM,PAT,DEFUN" data-used-by="REWRITE,BUILT-IN-BRR-NEAR-MISSP" data-part-name="ONE-WAY-UNIFY-RESTRICTIONS" data-part-args="RESTRICTIONS,TERM,PAT" data-part-declare="RESTRICTIONS,ALISTP-LISTP,TERM,PAT,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="ONE-WAY-UNIFY-RESTRICTIONS1,T,TERM,PAT,ONE-WAY-UNIFY,RESTRICTIONS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ONE-WAY-UNIFY-RESTRICTIONS">one-way-unify-restrictions</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a>
  (pat term restrictions)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat)
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term)
        (<a class="sym-link local-def" href="#def-alistp-listp" data-sym="ALISTP-LISTP" title="(defun alistp-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (eq x nil))
        (t (and (alistp (car x)) (alistp-listp (cdr x))))))">alistp-listp</a> restrictions))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> restrictions) (one-way-unify pat term))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-one-way-unify-restrictions1" data-sym="ONE-WAY-UNIFY-RESTRICTIONS1" title="(defun one-way-unify-restrictions1 (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((endp restrictions) (mv nil nil))
...">one-way-unify-restrictions1</a> pat term restrictions))))</pre>
  </div>

<div class="form-block function" id="def-symbol-alist-to-keyword-value-list" data-defines="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST" data-references="CDR,CAR,CONS,T,ENDP,COND,ALISTP,XARGS,DECLARE,ALIST,DEFUN" data-used-by="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" data-part-name="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST" data-part-args="ALIST" data-part-declare="ALIST,ALISTP,XARGS,DECLARE" data-part-body="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST,CDR,CAR,CONS,T,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST">symbol-alist-to-keyword-value-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-symbol-alist-to-keyword-value-list" data-sym="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST" title="(defun symbol-alist-to-keyword-value-list (alist)
  (declare (xargs :guard (alistp alist)))
  (cond ((endp alist) nil)
        (t
         (cons (car (car alist))
...">symbol-alist-to-keyword-value-list</a>
  (alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car (car alist))
        (cons (cdr (car alist))
          (<a class="sym-link local-def" href="#def-symbol-alist-to-keyword-value-list" data-sym="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST" title="(defun symbol-alist-to-keyword-value-list (alist)
  (declare (xargs :guard (alistp alist)))
  (cond ((endp alist) nil)
        (t
         (cons (car (car alist))
...">symbol-alist-to-keyword-value-list</a> (cdr alist)))))))</pre>
  </div>

<div class="form-block function" id="def-brr-criteria-alistp" data-defines="BRR-CRITERIA-ALISTP" data-references="BOOLEANP,PSEUDO-TERMP,CDR,NATP,AND,EQ,CAR,CONSP,NOT,EQUAL,ATOM,COND,T,XARGS,DECLARE,ALIST,DEFUN" data-used-by="BUILT-IN-BRR-NEAR-MISSP,MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" data-part-name="BRR-CRITERIA-ALISTP" data-part-args="ALIST" data-part-declare="T,XARGS,DECLARE" data-part-body="T,BOOLEANP,PSEUDO-TERMP,BRR-CRITERIA-ALISTP,CDR,NATP,AND,EQ,CAR,CONSP,NOT,EQUAL,ALIST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-CRITERIA-ALISTP">brr-criteria-alistp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a>
  (alist)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> alist) (equal alist nil))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (consp (car alist))) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (car alist)) <span class="keyword">:depth</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (cdr (car alist)))
        (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> (cdr alist))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (car alist)) <span class="keyword">:abstraction</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> (cdr (car alist)))
        (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> (cdr alist))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (car alist)) <span class="keyword">:lambda</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-booleanp" data-sym="BOOLEANP">booleanp</a> (cdr (car alist)))
        (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> (cdr alist))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-make-built-in-brr-near-miss-msg" data-defines="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" data-references="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST,APPEND,REASONS,LAMBDA-MSG,ABSTRACTION-MSG,ABSTRACT-PAT,MSG,LIST,IF,DEPTH-MSG,LET*,ASSOC-EQ,CDR,NATP,IMPLIES,BRR-CRITERIA-ALISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,LAMBDA-CRITERION-SATISFIEDP,ABSTRACTION-CRITERION-SATISFIEDP,DEPTH-CRITERION-SATISFIEDP,ALIST,PAT,BRR-CMD-NAME,DEFUN" data-used-by="BUILT-IN-BRR-NEAR-MISSP" data-part-name="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" data-part-args="LAMBDA-CRITERION-SATISFIEDP,ABSTRACTION-CRITERION-SATISFIEDP,DEPTH-CRITERION-SATISFIEDP,ALIST,PAT,BRR-CMD-NAME" data-part-declare="ASSOC-EQ,CDR,NATP,DEPTH-CRITERION-SATISFIEDP,IMPLIES,ALIST,BRR-CRITERIA-ALISTP,PAT,PSEUDO-TERMP,AND,XARGS,DECLARE" data-part-body="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST,APPEND,REASONS,LAMBDA-CRITERION-SATISFIEDP,LAMBDA-MSG,ABSTRACTION-CRITERION-SATISFIEDP,ABSTRACTION-MSG,PAT,ABSTRACT-PAT,ALIST,ASSOC-EQ,CDR,BRR-CMD-NAME,MSG,LIST,DEPTH-CRITERION-SATISFIEDP,IF,DEPTH-MSG,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG">make-built-in-brr-near-miss-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-built-in-brr-near-miss-msg" data-sym="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" title="(defun make-built-in-brr-near-miss-msg
       (brr-cmd-name pat alist depth-criterion-satisfiedp
        abstraction-criterion-satisfiedp lambda-criterion-satisfiedp)
  (declare
   (xargs :guard
...">make-built-in-brr-near-miss-msg</a>
  (brr-cmd-name pat
    alist
    depth-criterion-satisfiedp
    abstraction-criterion-satisfiedp
    lambda-criterion-satisfiedp)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pat)
        (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> alist)
        (<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a> depth-criterion-satisfiedp
          (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:depth</span> alist)))))))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((depth-msg (if depth-criterion-satisfiedp
         (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"* The abstraction of ~x0 to depth ~x1, namely the ~
                          pattern ~X23, matches :TARGET."</span>
             brr-cmd-name
             (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:depth</span> alist))
             (<a class="sym-link local-def" href="#def-abstract-pat" data-sym="ABSTRACT-PAT" title="(defun abstract-pat (k-flg pat)
  (declare
   (xargs :guard (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat))))
  (mv-let (new-pat vars) (abstract-pat1 k-flg pat (all-vars pat))
          (declare (ignore vars)) new-pat))">abstract-pat</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:depth</span> alist)) pat)
             nil))
         nil)) (abstraction-msg (if abstraction-criterion-satisfiedp
          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"* The :ABSTRACTION pattern provided in your ~
                          monitor, ~x0, matches :TARGET."</span>
              (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:abstraction</span> alist))))
          nil))
      (lambda-msg (if lambda-criterion-satisfiedp
          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"* ~x0 matches :TARGET except at one or more quoted ~
                          LAMBDA constants."</span>
              brr-cmd-name))
          nil))
      (reasons (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> depth-msg abstraction-msg lambda-msg)))
    (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"However, this is considered a NEAR MISS under the break criteria, ~
          ~X01, specified when this rule was monitored.  The following ~
          ~#2~[criterion is~/criteria are~] satisfied.~%~%~*3"</span>
      (<a class="sym-link local-def" href="#def-symbol-alist-to-keyword-value-list" data-sym="SYMBOL-ALIST-TO-KEYWORD-VALUE-LIST" title="(defun symbol-alist-to-keyword-value-list (alist)
  (declare (xargs :guard (alistp alist)))
  (cond ((endp alist) nil)
        (t
         (cons (car (car alist))
...">symbol-alist-to-keyword-value-list</a> alist)
      nil
      (if (cdr reasons)
        <span class="number">1</span>
        <span class="number">0</span>)
      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="string">""</span> <span class="string">"~@*~%~%"</span> <span class="string">"~@*~%~%"</span> <span class="string">"~@*~%~%"</span> reasons))))</pre>
  </div>

<div class="form-block function" id="def-built-in-brr-near-missp" data-defines="BUILT-IN-BRR-NEAR-MISSP" data-references="T,MAKE-BUILT-IN-BRR-NEAR-MISS-MSG,LAMBDA-CRITERION-SATISFIEDP,LAMBDA-ARG,ABSTRACTION-CRITERION-SATISFIEDP,NOT,ABSTRACTION-ARG,ABSTRACT-PAT,ONE-WAY-UNIFY-RESTRICTIONS,UNIFY-SUBST,FLG,CDR,IF,DEPTH-CRITERION-SATISFIEDP,ASSOC-EQ,DEPTH-ARG,LET*,ALISTP-LISTP,COND,IGNORE,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET,BRR-CRITERIA-ALISTP,WEAK-REWRITE-CONSTANT-P,PSEUDO-TERMP,WEAK-LINEAR-LEMMA-P,WEAK-REWRITE-RULE-P,OR,AND,XARGS,DECLARE,CRITERIA-ALIST,RCNST,TARGET,LEMMA,MSGP,DEFUN" data-part-name="BUILT-IN-BRR-NEAR-MISSP" data-part-args="CRITERIA-ALIST,RCNST,TARGET,LEMMA,MSGP" data-part-declare="CRITERIA-ALIST,BRR-CRITERIA-ALISTP,RCNST,WEAK-REWRITE-CONSTANT-P,TARGET,PSEUDO-TERMP,WEAK-LINEAR-LEMMA-P,LEMMA,WEAK-REWRITE-RULE-P,OR,AND,XARGS,DECLARE" data-part-body="T,MAKE-BUILT-IN-BRR-NEAR-MISS-MSG,LAMBDA-CRITERION-SATISFIEDP,OR,LAMBDA-ARG,ABSTRACTION-CRITERION-SATISFIEDP,MSGP,NOT,ABSTRACTION-ARG,TARGET,ABSTRACT-PAT,ONE-WAY-UNIFY-RESTRICTIONS,UNIFY-SUBST,FLG,CDR,IF,DEPTH-CRITERION-SATISFIEDP,CRITERIA-ALIST,ASSOC-EQ,DEPTH-ARG,LET*,ALISTP-LISTP,PSEUDO-TERMP,AND,COND,IGNORE,DECLARE,RCNST,LEMMA,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BUILT-IN-BRR-NEAR-MISSP">built-in-brr-near-missp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-built-in-brr-near-missp" data-sym="BUILT-IN-BRR-NEAR-MISSP" title="(defun built-in-brr-near-missp (msgp lemma target rcnst criteria-alist)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (pseudo-termp target) (weak-rewrite-constant-p rcnst)
...">built-in-brr-near-missp</a>
  (<a class="sym-link system" href="axioms.html#def-msgp" data-sym="MSGP">msgp</a> lemma target rcnst criteria-alist)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
        (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> target)
        (weak-rewrite-constant-p rcnst)
        (<a class="sym-link local-def" href="#def-brr-criteria-alistp" data-sym="BRR-CRITERIA-ALISTP" title="(defun brr-criteria-alistp (alist)
  (declare (xargs :guard t))
  (cond ((atom alist) (equal alist nil)) ((not (consp (car alist))) nil)
        ((eq (car (car alist)) :depth)
         (and (natp (cdr (car alist))) (brr-criteria-alistp (cdr alist))))
...">brr-criteria-alistp</a> criteria-alist))))
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rune brr-cmd-name pattern restrictions)
    (<a class="sym-link local-def" href="#def-get-brr-one-way-unify-info" data-sym="GET-BRR-ONE-WAY-UNIFY-INFO" title="(defun get-brr-one-way-unify-info (lemma rcnst)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (weak-rewrite-constant-p rcnst))))
...">get-brr-one-way-unify-info</a> lemma rcnst)
    (declare (ignore rune))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> pattern) (<a class="sym-link local-def" href="#def-alistp-listp" data-sym="ALISTP-LISTP" title="(defun alistp-listp (x)
  (declare (xargs :guard t))
  (cond ((atom x) (eq x nil))
        (t (and (alistp (car x)) (alistp-listp (cdr x))))))">alistp-listp</a> restrictions)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((depth-arg (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:depth</span> criteria-alist)) (depth-criterion-satisfiedp (if (cdr depth-arg)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                  (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> (<a class="sym-link local-def" href="#def-abstract-pat" data-sym="ABSTRACT-PAT" title="(defun abstract-pat (k-flg pat)
  (declare
   (xargs :guard (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat))))
  (mv-let (new-pat vars) (abstract-pat1 k-flg pat (all-vars pat))
          (declare (ignore vars)) new-pat))">abstract-pat</a> (cdr depth-arg) pattern)
                    target
                    restrictions)
                  (declare (ignore unify-subst))
                  flg)
                nil))
            (abstraction-arg (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link system" href="axioms.html#def-msgp" data-sym="MSGP">msgp</a>) depth-criterion-satisfiedp)
                nil
                (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:abstraction</span> criteria-alist)))
            (abstraction-criterion-satisfiedp (if (cdr abstraction-arg)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                  (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> (cdr abstraction-arg)
                    target
                    restrictions)
                  (declare (ignore unify-subst))
                  flg)
                nil))
            (lambda-arg (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link system" href="axioms.html#def-msgp" data-sym="MSGP">msgp</a>)
                  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> depth-criterion-satisfiedp
                    abstraction-criterion-satisfiedp))
                nil
                (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:lambda</span> criteria-alist)))
            (lambda-criterion-satisfiedp (if (cdr lambda-arg)
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                  (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> (<a class="sym-link local-def" href="#def-abstract-pat" data-sym="ABSTRACT-PAT" title="(defun abstract-pat (k-flg pat)
  (declare
   (xargs :guard (and (or (eq k-flg t) (natp k-flg)) (pseudo-termp pat))))
  (mv-let (new-pat vars) (abstract-pat1 k-flg pat (all-vars pat))
          (declare (ignore vars)) new-pat))">abstract-pat</a> (cdr lambda-arg) pattern)
                    target
                    restrictions)
                  (declare (ignore unify-subst))
                  flg)
                nil)))
          (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> depth-criterion-satisfiedp
              abstraction-criterion-satisfiedp
              lambda-criterion-satisfiedp)
            (if <a class="sym-link system" href="axioms.html#def-msgp" data-sym="MSGP">msgp</a>
              (<a class="sym-link local-def" href="#def-make-built-in-brr-near-miss-msg" data-sym="MAKE-BUILT-IN-BRR-NEAR-MISS-MSG" title="(defun make-built-in-brr-near-miss-msg
       (brr-cmd-name pat alist depth-criterion-satisfiedp
        abstraction-criterion-satisfiedp lambda-criterion-satisfiedp)
  (declare
   (xargs :guard
...">make-built-in-brr-near-miss-msg</a> brr-cmd-name
                pattern
                criteria-alist
                depth-criterion-satisfiedp
                abstraction-criterion-satisfiedp
                lambda-criterion-satisfiedp)
              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
            nil)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))</pre>
  </div>

<div class="form-block other" id="form-281" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> brr-near-missp (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block other" id="form-282" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (brr-near-missp <a class="sym-link local-def" href="#def-built-in-brr-near-missp" data-sym="BUILT-IN-BRR-NEAR-MISSP" title="(defun built-in-brr-near-missp (msgp lemma target rcnst criteria-alist)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (pseudo-termp target) (weak-rewrite-constant-p rcnst)
...">built-in-brr-near-missp</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block mutual-recursion" id="def-tilde-_40-failure-reason-free-phrase" data-defines="TILDE-@-FAILURE-REASON-FREE-PHRASE" data-references="NORMALIZER-RETURNED-SAME-CONSTANT,NORMALIZER-FAILED-TO-EVALUATE,HARD,ER,CADDDR,SYNP-FN,BIND-FREE-EXTENDED,SYNTAXP-EXTENDED,SYNTAXP,*NIL*,EQUAL,REWROTE-TO,TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT,BACKCHAIN-LIMIT,*DEFAULT-FREE-VARS-DISPLAY-LIMIT*,BIND-FREE,UNQUOTE,FARGN,QUOTEP,SYNP,FFN-SYMB-P,EVG,LEMMA,GET-BRR-LOCAL,GET-RULE-FIELD,NTH,HYP,LET*,EQL,STRIP-CARS,CDDDR,SET-DIFFERENCE-EQUAL,IGNORE,DECLARE,MV,LIMIT-FAILURE-REASON,ELIDED-P,FAILURES-REMAINING,MV-LET,OTHERWISE,KNOWN-NIL,ANCESTORS,CASE,N,LINEAR-POSSIBLE-LOOP,UNREWRITTEN,REWRITTEN,LINEARIZE-REWRITTEN-PRODUCED-DISJUNCTION,LINEARIZE-UNREWRITTEN-PRODUCED-DISJUNCTION,REWRITE-FNCALLP,TOO-MANY-IFS-POST-REWRITE,TOO-MANY-IFS-PRE-REWRITE,LOOP-STOPPER,NEAR-MISS,REFINEMENT-FAILURE,TIME-OUT,FREE-VARS-DISPLAY-LIMIT,FAILURE-REASON,1+,TILDE-@-FAILURE-REASON-PHRASE1,ELIDED,HYP-VARS,CADDR,MEMBER-EQ,CDDR,FREE-VARS,CADR,NOT,OR,INTEGERP,CDR,CACHED,QUOTE,CAR,EQ,CONSP,AND,FR,+,ALIST-DIFFERENCE-EQ,TILDE-*-ALIST-PHRASE,1-,*,<,IF,MSG,CDAR,NEW-FAILURE-REASON,CAAR,NEW-UNIFY-SUBST,LET,T,NULL,COND,STATE,EVISC-TUPLE,UNIFY-SUBST,LEVEL,ALIST,HYP-NUMBER,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-@-FAILURE-REASON-FREE-PHRASE">tilde-@-failure-reason-free-phrase</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_40-failure-reason-free-phrase" data-sym="TILDE-@-FAILURE-REASON-FREE-PHRASE" title="(mutual-recursion
 (defun tilde-@-failure-reason-free-phrase
        (hyp-number alist level unify-subst evisc-tuple state)
   (cond ((null alist) &quot;&quot;)
         (t
...">tilde-@-failure-reason-free-phrase</a>
    (hyp-number alist level unify-subst <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> state)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist) <span class="string">""</span>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-unify-subst (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)) (new-failure-reason (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)))
          (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~t0[~x1]~*2~|~@3~@4~@5"</span>
            (if (&lt; hyp-number <span class="number">10</span>)
              (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">4</span> level)
              (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">4</span> level)))
            hyp-number
            (tilde-*-alist-phrase (<a class="sym-link system" href="axioms.html#def-alist-difference-eq" data-sym="ALIST-DIFFERENCE-EQ">alist-difference-eq</a> new-unify-subst unify-subst)
              <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
              (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">4</span> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <span class="number">4</span> level)))
            (if (let ((fr (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp new-failure-reason)
                       (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car new-failure-reason) 'cached))
                     (cdr new-failure-reason)
                     new-failure-reason)))
                (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp fr)
                  (integerp (car fr))
                  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr fr)) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> fr) 'free-vars)))
                    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr fr))
                      (consp (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> fr))
                      (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> fr) '(hyp-vars elided))))))
              <span class="string">"Failed because "</span>
              <span class="string">""</span>)
            (tilde-@-failure-reason-phrase1 new-failure-reason
              (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> level)
              new-unify-subst
              <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
              nil
              state)
            (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-free-phrase" data-sym="TILDE-@-FAILURE-REASON-FREE-PHRASE" title="(mutual-recursion
 (defun tilde-@-failure-reason-free-phrase
        (hyp-number alist level unify-subst evisc-tuple state)
   (cond ((null alist) &quot;&quot;)
         (t
...">tilde-@-failure-reason-free-phrase</a> hyp-number
              (cdr alist)
              level
              unify-subst
              <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
              state))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> tilde-@-failure-reason-phrase1
    (failure-reason level
      unify-subst
      <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
      <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
      state)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'time-out) <span class="string">"we ran out of time."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'refinement-failure) <span class="string">"the rule&#39;s equivalence relation is not a refinement of the geneqv."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'near-miss) <span class="string">"the pattern (:LHS or :MAX-TERM) did not match the :TARGET."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason '<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>) <span class="string">"it permutes a big term forward."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'too-many-ifs-pre-rewrite) <span class="string">"the unrewritten :RHS contains too many IFs for the given args."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'too-many-ifs-post-rewrite) <span class="string">"the rewritten :RHS contains too many IFs for the given args."</span>)
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason '<a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a>) <span class="string">"the :REWRITTEN-RHS is judged heuristically unattractive."</span>)
      ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> failure-reason
         '(linearize-unrewritten-produced-disjunction linearize-rewritten-produced-disjunction)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the ~@0 term generated a disjunction of two conjunctions of ~
               polynomials."</span>
          (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason
              'linearize-rewritten-produced-disjunction)
            'rewritten
            'unrewritten)))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'linear-possible-loop) <span class="string">"the rewritten term was judged to have the potential to cause a loop ~
          related to linear arithmetic."</span>)
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason) (integerp (car failure-reason))) (let ((n (car failure-reason)))
          (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (cdr failure-reason)
            (time-out (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"we ran out of time while processing :HYP ~x0."</span> n))
            (ancestors (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 is judged more complicated than its ~
                              ancestors (type :ANCESTORS to see the ancestors ~
                              and :PATH to see how we got to this point)."</span>
                n))
            (known-nil (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 is known nil by type-set."</span> n))
            (otherwise (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason) 'free-vars) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (failures-remaining failure-reason elided-p)
                    (if <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
                      (<a class="sym-link local-def" href="#def-limit-failure-reason" data-sym="LIMIT-FAILURE-REASON" title="(mutual-recursion
 (defun limit-failure-reason (failures-remaining failure-reason elided-p)
   (declare (xargs :guard (natp failures-remaining)))
   (case-match failure-reason
               ((hyp &#39;free-vars . alist)
...">limit-failure-reason</a> <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
                        failure-reason
                        nil)
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil failure-reason nil))
                    (declare (ignore failures-remaining))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> failure-reason) 'hyp-vars) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 contains free variable~#1~[~/s~] ~&amp;1, for ~
                         which no suitable ~#1~[binding was~/bindings were~] ~
                         found."</span>
                          n
                          (<a class="sym-link system" href="axioms.html#def-set-difference-equal" data-sym="SET-DIFFERENCE-EQUAL">set-difference-equal</a> (<a class="sym-link system" href="axioms.html#def-cdddr" data-sym="CDDDR">cdddr</a> failure-reason)
                            (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> unify-subst))))
                      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> failure-reason) 'elided) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 contains free variables (further reasons ~
                         elided, as noted above)."</span>
                          n))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~@0~@1"</span>
                          (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> level <span class="number">1</span>)
                            (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 ~@1.  The following display summarizes ~
                              the attempts to relieve hypotheses by binding ~
                              free variables; see :DOC free-variables.~|~@2~%"</span>
                              n
                              (if (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((hyp (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n)
                                       (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>))) (evg (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> hyp '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>)
                                        (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>))
                                        (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>)))))
                                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> evg (consp evg) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car evg) '<a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>)))
                                (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"uses ~x0 to produce unsuccessful free ~
                                       variable bindings"</span>
                                  '<a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>)
                                <span class="string">"contains free variables"</span>)
                              (if elided-p
                                (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"     Also, if you want to avoid ~
                                     ``reasons elided&#39;&#39; notes below, then ~
                                     evaluate (assign free-vars-display-limit ~
                                     k) for larger k (currently ~x0, default ~
                                     ~x1); then :failure-reason will show the ~
                                     first k or so failure sub-reasons before ~
                                     eliding.  Note that you may want to do ~
                                     this evaluation outside break-rewrite, ~
                                     so that it persists.~|"</span>
                                  <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
                                  <a class="sym-link local-def" href="#def-_2Adefault-free-vars-display-limit_2A" data-sym="*DEFAULT-FREE-VARS-DISPLAY-LIMIT*" title="(defconst *default-free-vars-display-limit* 30)">*default-free-vars-display-limit*</a>)
                                <span class="string">""</span>))
                            <span class="string">""</span>)
                          (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-free-phrase" data-sym="TILDE-@-FAILURE-REASON-FREE-PHRASE" title="(mutual-recursion
 (defun tilde-@-failure-reason-free-phrase
        (hyp-number alist level unify-subst evisc-tuple state)
   (cond ((null alist) &quot;&quot;)
         (t
...">tilde-@-failure-reason-free-phrase</a> n
                            (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> failure-reason)
                            level
                            unify-subst
                            <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
                            state))))))
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason) '<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>) (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase1-backchain-limit" data-sym="TILDE-@-FAILURE-REASON-PHRASE1-BACKCHAIN-LIMIT" title="(defun tilde-@-failure-reason-phrase1-backchain-limit
       (hyp-number ancestors state evisc-tuple)
  (msg &quot;a backchain limit was reached while processing :HYP ~x0.  ~@1&quot;
       hyp-number
       (let ((pairs (backchain-limit-enforcers 0 ancestors (w state))))
...">tilde-@-failure-reason-phrase1-backchain-limit</a> n
                    (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> failure-reason)
                    state
                    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
                ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason) 'rewrote-to) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">":HYP ~x0 rewrote to ~X12.~@3"</span>
                    n
                    (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> failure-reason)
                    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
                    (if (equal (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> failure-reason) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                      <span class="string">"  (See :DOC tail-biting if this surprises you.)"</span>
                      <span class="string">""</span>)))
                ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)
                   '(<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> syntaxp-extended <a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a> bind-free-extended)) (let ((synp-fn (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)
                         (syntaxp-extended '<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a>)
                         (bind-free-extended '<a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>)
                         (otherwise (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)))))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> failure-reason) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the evaluation of the ~x0 test in :HYP ~x1 ~
                               produced the error ``~@2&#39;&#39;"</span>
                          synp-fn
                          n
                          (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> failure-reason)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the ~x0 test in :HYP ~x1 evaluated to NIL."</span> synp-fn n)))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                    'tilde-@-failure-reason-phrase1
                    <span class="string">"Unrecognized failure reason, ~x0."</span>
                    failure-reason)))))))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason)
         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car failure-reason) 'normalizer-failed-to-evaluate)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the normalizer, ~x0, simplified to a non-constant, ~x1."</span>
          (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)
          (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> failure-reason)))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason)
         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car failure-reason) 'normalizer-returned-same-constant)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the normalizer, ~x0, simplified to the same constant, ~x1."</span>
          (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)
          (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> failure-reason)))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason)
         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car failure-reason) 'cached)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~@0~|*NOTE*: This failure was cached earlier.  Use the hint ~
               :RW-CACHE-STATE ~x1 to disable failure caching."</span>
          (tilde-@-failure-reason-phrase1 (cdr failure-reason)
            level
            unify-subst
            <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
            <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
            state)
          nil))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          'tilde-@-failure-reason-phrase1
          <span class="string">"Unrecognized failure reason, ~x0."</span>
          failure-reason)))))</pre>
  </div>

<div class="form-block function" id="def-tilde-_40-failure-reason-phrase" data-defines="TILDE-@-FAILURE-REASON-PHRASE" data-references="FIX-FREE-FAILURE-REASON,TILDE-@-FAILURE-REASON-PHRASE1,STATE,FREE-VARS-DISPLAY-LIMIT,EVISC-TUPLE,UNIFY-SUBST,LEVEL,FAILURE-REASON,DEFUN" data-used-by="BRKPT2,*BRKPT2-ALIASES*" data-part-name="TILDE-@-FAILURE-REASON-PHRASE" data-part-args="STATE,FREE-VARS-DISPLAY-LIMIT,EVISC-TUPLE,UNIFY-SUBST,LEVEL,FAILURE-REASON" data-part-body="STATE,FREE-VARS-DISPLAY-LIMIT,EVISC-TUPLE,UNIFY-SUBST,LEVEL,FAILURE-REASON,FIX-FREE-FAILURE-REASON,TILDE-@-FAILURE-REASON-PHRASE1" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TILDE-@-FAILURE-REASON-PHRASE">tilde-@-failure-reason-phrase</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase" data-sym="TILDE-@-FAILURE-REASON-PHRASE" title="(defun tilde-@-failure-reason-phrase
       (failure-reason level unify-subst evisc-tuple free-vars-display-limit
        state)
  (tilde-@-failure-reason-phrase1 (fix-free-failure-reason failure-reason)
                                  level unify-subst evisc-tuple">tilde-@-failure-reason-phrase</a>
  (failure-reason level
    unify-subst
    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
    <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
    state)
  (tilde-@-failure-reason-phrase1 (<a class="sym-link local-def" href="#def-fix-free-failure-reason" data-sym="FIX-FREE-FAILURE-REASON" title="(mutual-recursion
 (defun fix-free-failure-reason (failure-reason)
   (case-match failure-reason ((&amp; &#39;free-vars &#39;hyp-vars . &amp;) failure-reason)
               ((bkptr &#39;free-vars . failure-reason-lst)
                (list* bkptr &#39;free-vars
...">fix-free-failure-reason</a> failure-reason)
    level
    unify-subst
    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
    <a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a>
    state))</pre>
  </div>

<div class="form-block function" id="def-brr-result" data-defines="BRR-RESULT" data-references="T,SHOW-POLY-LST,LINEAR-LEMMA,LEMMA,RECORD-TYPE,EQ,COND,QUOTE,GET-BRR-LOCAL,RESULT,LET,STATE,DEFUN" data-used-by="REWRITE,CW-GSTACK-FOR-TERM-FN,CW-GSTACK-FOR-TERM-FN1-1,BRR-DATA-2-FOR-TERM-1,BRKPT2,UPDATE-BRR-DATA-2-BUILTIN,*BRKPT2-ALIASES*" data-part-name="BRR-RESULT" data-part-args="STATE" data-part-body="T,SHOW-POLY-LST,LINEAR-LEMMA,LEMMA,RECORD-TYPE,EQ,COND,STATE,BRR-RESULT,QUOTE,GET-BRR-LOCAL,RESULT,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-RESULT">brr-result</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
  (state)
  (let ((result (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> '<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state))
         'linear-lemma) (show-poly-lst result))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> result))))</pre>
  </div>

<div class="form-block constant" id="def-_2Abrkpt1-aliases_2A" data-defines="*BRKPT1-ALIASES*" data-references="HELP,SILENT,1-,BRR-COMMANDS,DOC,PRINT,EVISC-TUPLE,EXPLAIN-NEAR-MISS1,RUNES,BREAK,PROCEED-FROM-BRKPT1,UNIFY-SUBST,TILDE-*-ALIST-PHRASE,UNIFY-SUBST-FN,NON-PRIMS,GENEQV,SHOW-GENEQV,GENEQV-FN,W,TYPE-ALIST,TYPE-ALIST-SEGMENTS,PRINT-TYPE-ALIST-SEGMENTS,TYPE-ALIST-FN,TOP-FN,TARGET,TARGET-FN,PRINT-POT-LST,POT-LIST,POT-LIST-FN,CW-GSTACK,PATH-FN,INITIAL-TTREE,LINEAR-LEMMA,RECORD-TYPE,INITIAL-TTREE-FN,-,NTH,GFRAME,=,IF,<=,>=,INTEGERP,AND,REVERSE,RGSTACK,N,FRAME-FN,CAR,LENGTH,CW-GFRAME,BRR-STATUS,ACCESS,GSTACK,WORMHOLE-STATUS,F-GET-GLOBAL,WHS,LET*,BTM-FN,SHOW-ANCESTORS-STACK-MSG,ANCESTORS-FN,MAX-TERM-FN,T,SOFT,ER,EQ,COND,VAL,LET,PLUSP,LHS-FN,VALUE,STATE,LEMMA,QUOTE,GET-BRR-LOCAL,GET-RULE-FIELD,CW,PROG2$,LAMBDA,QUASIQUOTE,NOT-YET-EVALED-FN,FLET,DEFCONST" data-used-by="BRKPT1,NEAR-MISS-BRKPT1,REFINEMENT-FAILURE-BRKPT1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*BRKPT1-ALIASES*">*brkpt1-aliases*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Abrkpt1-aliases_2A" data-sym="*BRKPT1-ALIASES*" title="(defconst *brkpt1-aliases*
          (flet ((not-yet-evaled-fn ()
                   `(lambda ()
                      (prog2$
                       (cw &quot;~F0 has not yet been :EVALed.~%&quot;
...">*brkpt1-aliases*</a>
  (flet ((not-yet-evaled-fn nil
       `(lambda nil
         (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~F0 has not yet been :EVALed.~%"</span>
             (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>))
           (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))) (lhs-fn (plusp)
        `(lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:lhs</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft <span class="keyword">:lhs</span> <span class="string">":LHS is only legal for a :REWRITE rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    val
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (max-term-fn (plusp)
        `(lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:max-term</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:max-term</span> <span class="string">":MAX-TERM is only legal for a :LINEAR rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    val
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (ancestors-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~@0"</span>
              (<a class="sym-link local-def" href="#def-show-ancestors-stack-msg" data-sym="SHOW-ANCESTORS-STACK-MSG" title="(defun show-ancestors-stack-msg (state evisc-tuple)
  (msg &quot;Ancestors stack (most recent entry on top):~%~*0~%Use ~x1 to see ~
        actual ancestors stack.~%&quot;
       (tilde-*-ancestors-stack-msg (get-brr-local &#39;ancestors state) (w state)
                                    evisc-tuple)">show-ancestors-stack-msg</a> state
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (btm-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (gstack (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-gstack</span>)))
              (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> gstack)
                nil
                (car gstack)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (frame-fn (plusp)
        `(lambda (n)
          (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (rgstack (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-gstack</span>))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp n) (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> n <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> n (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> rgstack))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> n
                    (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">1</span>)
                      nil
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">2</span>) rgstack) <span class="keyword">:sys-fn</span>))
                    (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) rgstack)
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:frame</span> <span class="string">":FRAME must be given an integer argument ~
                                 between 1 and ~x0."</span>
                  (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> rgstack)))))))
      (initial-ttree-fn (plusp)
        `(lambda nil
          (let ((lemma (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'linear-lemma) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:initial-ttree</span> <span class="string">":INITIAL-TTREE is not legal for a ~
                                       :LINEAR rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'initial-ttree state)
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (path-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a> <span class="keyword">:evisc-tuple</span> ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (pot-list-fn (plusp)
        `(lambda nil
          (let ((pot-list (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'pot-list state)))
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if pot-list
                (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Display of linear pot-list:~|"</span>)
                  (<a class="sym-link local-def" href="#def-print-pot-lst" data-sym="PRINT-POT-LST" title="(defun print-pot-lst (pot-lst evisc-tuple)
  (cond ((null pot-lst) (cw &quot;~%&quot;))
        (t
         (prog2$
          (cw
...">print-pot-lst</a> pot-list
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
                (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%The linear pot-list is empty.~|"</span>))
              (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
      (target-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
              (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (top-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> <span class="number">1</span>
              nil
              (car (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                    (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                    <span class="keyword">:brr-gstack</span>)))
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (type-alist-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Decoded type-alist:~%"</span>)
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-print-type-alist-segments" data-sym="PRINT-TYPE-ALIST-SEGMENTS" title="(defun print-type-alist-segments (segs wrld evisc-tuple)
  (if (endp segs)
      segs
      (prog2$
       (cw &quot;-----~%Terms with type ~x0:~%&quot; (decode-type-set (caar segs)))
...">print-type-alist-segments</a> (<a class="sym-link local-def" href="#def-type-alist-segments" data-sym="TYPE-ALIST-SEGMENTS" title="(defun type-alist-segments (type-alist acc)
  (if (endp type-alist)
      (sort-type-alist-segments acc)
      (type-alist-segments (cdr type-alist)
                           (add-to-type-alist-segments (cadar type-alist)">type-alist-segments</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'type-alist state) nil)
                (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
              (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%==========~%Use ~x0 to see actual ~
                                   type-alist.~%"</span>
                  '(<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'type-alist state))
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))))
      (geneqv-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Geneqv:~%~Y01"</span>
              (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'geneqv state) 'non-prims)
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%==========~%Use ~x0 to see actual geneqv ~
                               data structure.~%"</span>
                '(<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'geneqv state))
              (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
      (unify-subst-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~*0"</span>
              (tilde-*-alist-phrase (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'unify-subst state)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))
                <span class="number">5</span>))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
    `((<span class="keyword">:ancestors</span> <span class="number">0</span> ,(ANCESTORS-FN NIL)) (<span class="keyword">:ancestors+</span> <span class="number">0</span> ,(ANCESTORS-FN T))
      (<span class="keyword">:btm</span> <span class="number">0</span> ,(BTM-FN NIL))
      (<span class="keyword">:btm+</span> <span class="number">0</span> ,(BTM-FN T))
      (<span class="keyword">:eval</span> <span class="number">0</span>
        (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'break <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:eval</span> state)))
      (<span class="keyword">:eval!</span> <span class="number">0</span>
        (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'break <span class="keyword">:none</span> <span class="keyword">:eval!</span> state)))
      (<span class="keyword">:eval$</span> <span class="number">1</span>
        (lambda (runes)
          (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'break runes <span class="keyword">:eval$</span> state)))
      (<span class="keyword">:explain-near-miss</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link local-def" href="#def-explain-near-miss1" data-sym="EXPLAIN-NEAR-MISS1" title="(defun explain-near-miss1 (target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (let* ((pat-cmd (get-brr-local &#39;brr-cmd-name-for-pattern state))
         (pat-term (get-brr-local &#39;pattern state)))
    (explain-near-miss2 pat-cmd pat-term target-term large-cons-count">explain-near-miss1</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
            <span class="number">30</span>
            (<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <span class="number">10</span> <span class="number">20</span> nil nil)
            state)))
      (<span class="keyword">:explain-near-miss+</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link local-def" href="#def-explain-near-miss1" data-sym="EXPLAIN-NEAR-MISS1" title="(defun explain-near-miss1 (target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (let* ((pat-cmd (get-brr-local &#39;brr-cmd-name-for-pattern state))
         (pat-term (get-brr-local &#39;pattern state)))
    (explain-near-miss2 pat-cmd pat-term target-term large-cons-count">explain-near-miss1</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
            nil
            nil
            state)))
      (<span class="keyword">:failure-reason</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:failure-reason+</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:final-ttree</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:final-ttree+</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:frame</span> <span class="number">1</span> ,(FRAME-FN NIL))
      (<span class="keyword">:frame+</span> <span class="number">1</span> ,(FRAME-FN T))
      (<span class="keyword">:go</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'print <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:go</span> state)))
      (<span class="keyword">:go!</span> <span class="number">0</span>
        (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'print <span class="keyword">:none</span> <span class="keyword">:go!</span> state)))
      (<span class="keyword">:go$</span> <span class="number">1</span>
        (lambda (runes)
          (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'print runes <span class="keyword">:go$</span> state)))
      (<span class="keyword">:help</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="history-management.html#def-doc" data-sym="DOC">doc</a> 'brr-commands)))
      (<span class="keyword">:hyp</span> <span class="number">1</span>
        (lambda (n)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp n)
               (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> n <span class="number">1</span>)
               (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> n
                 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>)))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                  (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n)
                    (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>))
                  nil)
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                <span class="keyword">:hyp</span> <span class="string">":HYP must be given an integer argument between 1 and ~x0."</span>
                (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>)))))))
      (<span class="keyword">:hyps</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0~|"</span>
              (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (<span class="keyword">:initial-ttree</span> <span class="number">0</span> ,(INITIAL-TTREE-FN NIL))
      (<span class="keyword">:initial-ttree+</span> <span class="number">0</span> ,(INITIAL-TTREE-FN T))
      (<span class="keyword">:lhs</span> <span class="number">0</span> ,(LHS-FN NIL))
      (<span class="keyword">:lhs+</span> <span class="number">0</span> ,(LHS-FN T))
      (<span class="keyword">:max-term</span> <span class="number">0</span> ,(MAX-TERM-FN NIL))
      (<span class="keyword">:max-term+</span> <span class="number">0</span> ,(MAX-TERM-FN T))
      (<span class="keyword">:ok</span> <span class="number">0</span>
        (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'silent <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:ok</span> state)))
      (<span class="keyword">:ok!</span> <span class="number">0</span>
        (lambda nil (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'silent <span class="keyword">:none</span> <span class="keyword">:ok!</span> state)))
      (<span class="keyword">:ok$</span> <span class="number">1</span>
        (lambda (runes)
          (<a class="sym-link system" href="defthm.html#def-proceed-from-brkpt1" data-sym="PROCEED-FROM-BRKPT1">proceed-from-brkpt1</a> 'silent runes <span class="keyword">:ok$</span> state)))
      (<span class="keyword">:path</span> <span class="number">0</span> ,(PATH-FN NIL))
      (<span class="keyword">:path+</span> <span class="number">0</span> ,(PATH-FN T))
      (<span class="keyword">:poly-list</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:poly-list+</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:pot-list</span> <span class="number">0</span> ,(POT-LIST-FN NIL))
      (<span class="keyword">:pot-list+</span> <span class="number">0</span> ,(POT-LIST-FN T))
      (<span class="keyword">:q</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"Proceed with some flavor of :ok, :go, or :eval, or ~
                        use :a! to abort.~%"</span>)
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (<span class="keyword">:rewritten-rhs</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:rewritten-rhs+</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN))
      (<span class="keyword">:rhs</span> <span class="number">0</span>
        (lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rhs</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft <span class="keyword">:rhs</span> <span class="string">":RHS is only legal for a :REWRITE rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0~|"</span> val) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (<span class="keyword">:standard-help</span> <span class="number">0</span> <a class="sym-link system" href="history-management.html#def-help" data-sym="HELP">help</a>)
      (<span class="keyword">:target</span> <span class="number">0</span> ,(TARGET-FN NIL))
      (<span class="keyword">:target+</span> <span class="number">0</span> ,(TARGET-FN T))
      (<span class="keyword">:top</span> <span class="number">0</span> ,(TOP-FN NIL))
      (<span class="keyword">:top+</span> <span class="number">0</span> ,(TOP-FN T))
      (<span class="keyword">:type-alist</span> <span class="number">0</span> ,(TYPE-ALIST-FN NIL))
      (<span class="keyword">:type-alist+</span> <span class="number">0</span> ,(TYPE-ALIST-FN T))
      (<span class="keyword">:geneqv</span> <span class="number">0</span> ,(GENEQV-FN NIL))
      (<span class="keyword">:geneqv+</span> <span class="number">0</span> ,(GENEQV-FN T))
      (<span class="keyword">:unify-subst</span> <span class="number">0</span> ,(UNIFY-SUBST-FN NIL))
      (<span class="keyword">:unify-subst+</span> <span class="number">0</span> ,(UNIFY-SUBST-FN T))
      (<span class="keyword">:wonp</span> <span class="number">0</span> ,(NOT-YET-EVALED-FN)))))</pre>
  </div>

<div class="form-block constant" id="def-_2Abrkpt2-aliases_2A" data-defines="*BRKPT2-ALIASES*" data-references="HELP,1-,BRR-COMMANDS,DOC,EXIT-BRR,EVISC-TUPLE,EXPLAIN-NEAR-MISS1,RUNES,TILDE-*-ALIST-PHRASE,UNIFY-SUBST-FN,NON-PRIMS,GENEQV,SHOW-GENEQV,GENEQV-FN,W,TYPE-ALIST,TYPE-ALIST-SEGMENTS,PRINT-TYPE-ALIST-SEGMENTS,TYPE-ALIST-FN,TOP-FN,TARGET,TARGET-FN,REWRITE-FNCALLP,TOO-MANY-IFS,MEMBER-EQ,OR,REWRITE-RULE,REWRITTEN-RHS-FN,PRINT-POT-LST,POT-LIST,POT-LIST-FN,BRR-RESULT,POLY-LIST-FN,CW-GSTACK,PATH-FN,INITIAL-TTREE,INITIAL-TTREE-FN,-,NTH,GFRAME,=,<=,>=,INTEGERP,AND,REVERSE,RGSTACK,N,FRAME-FN,FINAL-TTREE,LINEAR-LEMMA,RECORD-TYPE,FINAL-TTREE-FN,FREE-VARS-DISPLAY-LIMIT,UNIFY-SUBST,FAILURE-REASON,TILDE-@-FAILURE-REASON-PHRASE,WONP,IF,FAILURE-REASON-FN,CAR,LENGTH,CW-GFRAME,BRR-STATUS,ACCESS,GSTACK,WORMHOLE-STATUS,F-GET-GLOBAL,WHS,LET*,BTM-FN,SHOW-ANCESTORS-STACK-MSG,ANCESTORS-FN,MAX-TERM-FN,T,SOFT,ER,EQ,COND,STATE,LEMMA,GET-BRR-LOCAL,GET-RULE-FIELD,VAL,LET,QUASIQUOTE,PLUSP,LHS-FN,VALUE,CW,PROG2$,LAMBDA,QUOTE,ALREADY-EVALED-FN,FLET,DEFCONST" data-used-by="BRKPT2" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*BRKPT2-ALIASES*">*brkpt2-aliases*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Abrkpt2-aliases_2A" data-sym="*BRKPT2-ALIASES*" title="(defconst *brkpt2-aliases*
          (flet ((already-evaled-fn ()
                   &#39;(lambda ()
                      (prog2$
                       (cw &quot;You already have run some flavor ~
...">*brkpt2-aliases*</a>
  (flet ((already-evaled-fn nil
       '(lambda nil
         (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"You already have run some flavor ~
                                            of :eval.~%"</span>)
           (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))) (lhs-fn (plusp)
        `(lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:lhs</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft <span class="keyword">:lhs</span> <span class="string">":LHS is only legal for a :REWRITE rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    val
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (max-term-fn (plusp)
        `(lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:max-term</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:max-term</span> <span class="string">":MAX-TERM is only legal for a :LINEAR rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    val
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (ancestors-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~@0"</span>
              (<a class="sym-link local-def" href="#def-show-ancestors-stack-msg" data-sym="SHOW-ANCESTORS-STACK-MSG" title="(defun show-ancestors-stack-msg (state evisc-tuple)
  (msg &quot;Ancestors stack (most recent entry on top):~%~*0~%Use ~x1 to see ~
        actual ancestors stack.~%&quot;
       (tilde-*-ancestors-stack-msg (get-brr-local &#39;ancestors state) (w state)
                                    evisc-tuple)">show-ancestors-stack-msg</a> state
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (btm-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (gstack (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-gstack</span>)))
              (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> gstack)
                nil
                (car gstack)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (failure-reason-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state)
              (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"? ~F0 succeeded.~%"</span>
                (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>))
              (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~@0~|"</span>
                (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase" data-sym="TILDE-@-FAILURE-REASON-PHRASE" title="(defun tilde-@-failure-reason-phrase
       (failure-reason level unify-subst evisc-tuple free-vars-display-limit
        state)
  (tilde-@-failure-reason-phrase1 (fix-free-failure-reason failure-reason)
                                  level unify-subst evisc-tuple">tilde-@-failure-reason-phrase</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'failure-reason state)
                  <span class="number">1</span>
                  (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'unify-subst state)
                  ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))
                  (<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> state)
                  state)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (final-ttree-fn (plusp)
        `(lambda nil
          (let ((lemma (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'linear-lemma) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:final-ttree</span> <span class="string">":FINAL-TTREE is not legal for a :LINEAR ~
                                     rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'final-ttree state)
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (frame-fn (plusp)
        `(lambda (n)
          (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((whs (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)) (rgstack (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-gstack</span>))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp n) (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> n <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> n (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> rgstack))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> n
                    (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">1</span>)
                      nil
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> gframe (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">2</span>) rgstack) <span class="keyword">:sys-fn</span>))
                    (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) rgstack)
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:frame</span> <span class="string">":FRAME must be given an integer argument ~
                                 between 1 and ~x0."</span>
                  (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> rgstack)))))))
      (initial-ttree-fn (plusp)
        `(lambda nil
          (let ((lemma (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'linear-lemma) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:initial-ttree</span> <span class="string">":INITIAL-TTREE is not legal for a ~
                                       :LINEAR rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                    (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'initial-ttree state)
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (path-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gstack" data-sym="CW-GSTACK" title="(defmacro cw-gstack (&amp;key (evisc-tuple &#39;nil evisc-tuplep) (frames &#39;nil))
  (declare (xargs :guard t))
  `(cw-gstack-fn
    ,(if evisc-tuplep
         evisc-tuple
...">cw-gstack</a> <span class="keyword">:evisc-tuple</span> ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (poly-list-fn (plusp)
        `(lambda nil
          (let ((lemma (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'linear-lemma) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                        (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> state)
                        ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"? ~F0 failed.~%"</span> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>))))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:poly-list</span> <span class="string">":POLY-LIST is only legal for a :LINEAR ~
                                   rule."</span>))))))
      (pot-list-fn (plusp)
        `(lambda nil
          (let ((pot-list (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'pot-list state)))
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if pot-list
                (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Display of linear pot-list:~|"</span>)
                  (<a class="sym-link local-def" href="#def-print-pot-lst" data-sym="PRINT-POT-LST" title="(defun print-pot-lst (pot-lst evisc-tuple)
  (cond ((null pot-lst) (cw &quot;~%&quot;))
        (t
         (prog2$
          (cw
...">print-pot-lst</a> pot-list
                    ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
                (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%The linear pot-list is empty.~|"</span>))
              (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
      (rewritten-rhs-fn (plusp)
        `(lambda nil
          (let ((lemma (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-record-type" data-sym="RECORD-TYPE">record-type</a> lemma) 'rewrite-rule) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state)
                       (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'failure-reason state)
                         '(too-many-ifs <a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a>))) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                        (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> '<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> state)
                        ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"? ~F0 failed.~%"</span> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>))))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                  <span class="keyword">:rewritten-rhs</span> <span class="string">":REWRITTEN-RHS is only legal for a ~
                                       :REWRITE rule."</span>))))))
      (target-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
              (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (top-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-cw-gframe" data-sym="CW-GFRAME" title="(defun cw-gframe (i calling-sys-fn frame evisc-tuple)
  (case (access gframe frame :sys-fn)
    (simplify-clause
     (cw &quot;~x0. Simplifying the clause~%     ~Y12&quot; i (access gframe frame :args)
         evisc-tuple))
...">cw-gframe</a> <span class="number">1</span>
              nil
              (car (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                    (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                    <span class="keyword">:brr-gstack</span>)))
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (type-alist-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Decoded type-alist:~%"</span>)
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-print-type-alist-segments" data-sym="PRINT-TYPE-ALIST-SEGMENTS" title="(defun print-type-alist-segments (segs wrld evisc-tuple)
  (if (endp segs)
      segs
      (prog2$
       (cw &quot;-----~%Terms with type ~x0:~%&quot; (decode-type-set (caar segs)))
...">print-type-alist-segments</a> (<a class="sym-link local-def" href="#def-type-alist-segments" data-sym="TYPE-ALIST-SEGMENTS" title="(defun type-alist-segments (type-alist acc)
  (if (endp type-alist)
      (sort-type-alist-segments acc)
      (type-alist-segments (cdr type-alist)
                           (add-to-type-alist-segments (cadar type-alist)">type-alist-segments</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'type-alist state) nil)
                (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
              (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%==========~%Use ~x0 to see actual ~
                                   type-alist.~%"</span>
                  '(<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'type-alist state))
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))))
      (geneqv-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%Geneqv:~%~Y01"</span>
              (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'geneqv state) 'non-prims)
              ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE)))
            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%==========~%Use ~x0 to see actual geneqv ~
                               data structure.~%"</span>
                '(<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'geneqv state))
              (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
      (unify-subst-fn (plusp)
        `(lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~*0"</span>
              (tilde-*-alist-phrase (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'unify-subst state)
                ,(IF PLUSP
     NIL
     &#39;(BRR-EVISC-TUPLE STATE))
                <span class="number">5</span>))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))
    `((<span class="keyword">:ancestors</span> <span class="number">0</span> ,(ANCESTORS-FN NIL)) (<span class="keyword">:ancestors+</span> <span class="number">0</span> ,(ANCESTORS-FN T))
      (<span class="keyword">:btm</span> <span class="number">0</span> ,(BTM-FN NIL))
      (<span class="keyword">:btm+</span> <span class="number">0</span> ,(BTM-FN T))
      (<span class="keyword">:eval</span> <span class="number">0</span> ,(ALREADY-EVALED-FN))
      (<span class="keyword">:eval!</span> <span class="number">0</span> ,(ALREADY-EVALED-FN))
      (<span class="keyword">:eval$</span> <span class="number">1</span>
        (lambda (runes) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> runes ,(ALREADY-EVALED-FN))))
      (<span class="keyword">:explain-near-miss</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link local-def" href="#def-explain-near-miss1" data-sym="EXPLAIN-NEAR-MISS1" title="(defun explain-near-miss1 (target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (let* ((pat-cmd (get-brr-local &#39;brr-cmd-name-for-pattern state))
         (pat-term (get-brr-local &#39;pattern state)))
    (explain-near-miss2 pat-cmd pat-term target-term large-cons-count">explain-near-miss1</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
            <span class="number">30</span>
            (<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <span class="number">10</span> <span class="number">20</span> nil nil)
            state)))
      (<span class="keyword">:explain-near-miss+</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link local-def" href="#def-explain-near-miss1" data-sym="EXPLAIN-NEAR-MISS1" title="(defun explain-near-miss1 (target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (let* ((pat-cmd (get-brr-local &#39;brr-cmd-name-for-pattern state))
         (pat-term (get-brr-local &#39;pattern state)))
    (explain-near-miss2 pat-cmd pat-term target-term large-cons-count">explain-near-miss1</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
            nil
            nil
            state)))
      (<span class="keyword">:failure-reason</span> <span class="number">0</span> ,(FAILURE-REASON-FN NIL))
      (<span class="keyword">:failure-reason+</span> <span class="number">0</span> ,(FAILURE-REASON-FN T))
      (<span class="keyword">:final-ttree</span> <span class="number">0</span> ,(FINAL-TTREE-FN NIL))
      (<span class="keyword">:final-ttree+</span> <span class="number">0</span> ,(FINAL-TTREE-FN T))
      (<span class="keyword">:frame</span> <span class="number">1</span> ,(FRAME-FN NIL))
      (<span class="keyword">:frame+</span> <span class="number">1</span> ,(FRAME-FN T))
      (<span class="keyword">:go</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state)))
      (<span class="keyword">:go!</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state)))
      (<span class="keyword">:go$</span> <span class="number">1</span> (lambda (runes) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> runes (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state))))
      (<span class="keyword">:help</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="history-management.html#def-doc" data-sym="DOC">doc</a> 'brr-commands)))
      (<span class="keyword">:hyp</span> <span class="number">1</span>
        (lambda (n)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (integerp n)
               (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> n <span class="number">1</span>)
               (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> n
                 (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>)))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~X01~|"</span>
                  (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> n)
                    (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>))
                  nil)
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                <span class="keyword">:hyp</span> <span class="string">":HYP must be given an integer argument between 1 and ~x0."</span>
                (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>)))))))
      (<span class="keyword">:hyps</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0~|"</span>
              (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:hyps</span>))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (<span class="keyword">:initial-ttree</span> <span class="number">0</span> ,(INITIAL-TTREE-FN NIL))
      (<span class="keyword">:initial-ttree+</span> <span class="number">0</span> ,(INITIAL-TTREE-FN T))
      (<span class="keyword">:lhs</span> <span class="number">0</span> ,(LHS-FN NIL))
      (<span class="keyword">:lhs+</span> <span class="number">0</span> ,(LHS-FN T))
      (<span class="keyword">:max-term</span> <span class="number">0</span> ,(MAX-TERM-FN NIL))
      (<span class="keyword">:max-term+</span> <span class="number">0</span> ,(MAX-TERM-FN T))
      (<span class="keyword">:ok</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state)))
      (<span class="keyword">:ok!</span> <span class="number">0</span> (lambda nil (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state)))
      (<span class="keyword">:ok$</span> <span class="number">1</span> (lambda (runes) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> runes (<a class="sym-link system" href="defthm.html#def-exit-brr" data-sym="EXIT-BRR">exit-brr</a> state))))
      (<span class="keyword">:path</span> <span class="number">0</span> ,(PATH-FN NIL))
      (<span class="keyword">:path+</span> <span class="number">0</span> ,(PATH-FN T))
      (<span class="keyword">:poly-list</span> <span class="number">0</span> ,(POLY-LIST-FN NIL))
      (<span class="keyword">:poly-list+</span> <span class="number">0</span> ,(POLY-LIST-FN T))
      (<span class="keyword">:pot-list</span> <span class="number">0</span> ,(POT-LIST-FN NIL))
      (<span class="keyword">:pot-list+</span> <span class="number">0</span> ,(POT-LIST-FN T))
      (<span class="keyword">:q</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"Proceed with some flavor of :ok, :go, or :eval, ~
                       or use :a! to abort.~%"</span>)
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))
      (<span class="keyword">:rewritten-rhs</span> <span class="number">0</span> ,(REWRITTEN-RHS-FN NIL))
      (<span class="keyword">:rewritten-rhs+</span> <span class="number">0</span> ,(REWRITTEN-RHS-FN T))
      (<span class="keyword">:rhs</span> <span class="number">0</span>
        (lambda nil
          (let ((val (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rhs</span>)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <span class="keyword">:get-rule-field-none</span>) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft <span class="keyword">:rhs</span> <span class="string">":RHS is only legal for a :REWRITE rule."</span>))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~x0~|"</span> val) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))
      (<span class="keyword">:standard-help</span> <span class="number">0</span> <a class="sym-link system" href="history-management.html#def-help" data-sym="HELP">help</a>)
      (<span class="keyword">:target</span> <span class="number">0</span> ,(TARGET-FN NIL))
      (<span class="keyword">:target+</span> <span class="number">0</span> ,(TARGET-FN T))
      (<span class="keyword">:top</span> <span class="number">0</span> ,(TOP-FN NIL))
      (<span class="keyword">:top+</span> <span class="number">0</span> ,(TOP-FN T))
      (<span class="keyword">:type-alist</span> <span class="number">0</span> ,(TYPE-ALIST-FN NIL))
      (<span class="keyword">:type-alist+</span> <span class="number">0</span> ,(TYPE-ALIST-FN T))
      (<span class="keyword">:geneqv</span> <span class="number">0</span> ,(GENEQV-FN NIL))
      (<span class="keyword">:geneqv+</span> <span class="number">0</span> ,(GENEQV-FN T))
      (<span class="keyword">:unify-subst</span> <span class="number">0</span> ,(UNIFY-SUBST-FN NIL))
      (<span class="keyword">:unify-subst+</span> <span class="number">0</span> ,(UNIFY-SUBST-FN T))
      (<span class="keyword">:wonp</span> <span class="number">0</span>
        (lambda nil
          (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state)
              (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"? ~F0 succeeded.~%"</span>
                (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>))
              (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"? ~F0 failed.~%"</span>
                (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)))
            (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))))</pre>
  </div>

<div class="form-block other" id="form-288" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> brr-data-1
  (((lemma . target) unify-subst type-alist . geneqv) (pot-list . ancestors)
    rcnst
    initial-ttree . gstack)
  nil)</pre>
  </div>

<div class="form-block other" id="form-289" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> brr-data-2
  ((failure-reason unify-subst . <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>) rcnst
    final-ttree . gstack)
  nil)</pre>
  </div>

<div class="form-block other" id="form-290" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> brr-data (pre post . completed) nil)</pre>
  </div>

<div class="form-block mutual-recursion" id="def-brr-data-p" data-defines="BRR-DATA-P" data-references="CDR,CAR,ATOM,COND,LST,BRR-DATA-LISTP,NULL,WEAK-BRR-DATA-2-P,IF,BRR-DATA,ACCESS,WEAK-BRR-DATA-1-P,WEAK-BRR-DATA-P,AND,ACL2-COUNT,T,XARGS,DECLARE,X,COMPLETED-P,DEFUN,MUTUAL-RECURSION" data-used-by="SHOW-BRR-DATA" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DATA-P">brr-data-p</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-data-p" data-sym="BRR-DATA-P" title="(mutual-recursion
 (defun brr-data-p (completed-p x)
   (declare (xargs :guard t :measure (acl2-count x)))
   (and (weak-brr-data-p x) (weak-brr-data-1-p (access brr-data x :pre))
        (if completed-p
...">brr-data-p</a>
    (completed-p x)
    (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> x)))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (weak-brr-data-p x)
      (weak-brr-data-1-p (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:pre</span>))
      (if completed-p
        (weak-brr-data-2-p (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:post</span>))
        (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:post</span>)))
      (brr-data-listp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:completed</span>))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> brr-data-listp
    (completed-p lst)
    (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> lst)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> lst) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst))
      ((<a class="sym-link local-def" href="#def-brr-data-p" data-sym="BRR-DATA-P" title="(mutual-recursion
 (defun brr-data-p (completed-p x)
   (declare (xargs :guard t :measure (acl2-count x)))
   (and (weak-brr-data-p x) (weak-brr-data-1-p (access brr-data x :pre))
        (if completed-p
...">brr-data-p</a> completed-p (car lst)) (brr-data-listp completed-p (cdr lst)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))</pre>
  </div>

<div class="form-block other" id="form-292" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> brkpt1-brr-data-entry (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> state) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block other" id="form-293" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defproxy" data-sym="DEFPROXY">defproxy</a> brkpt2-brr-data-entry (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> state) =&gt; <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>)</pre>
  </div>

<div class="form-block other" id="form-294" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> update-brr-data-1
  (lemma target
    unify-subst
    type-alist
    geneqv
    ancestors
    initial-ttree
    gstack
    rcnst
    pot-lst
    whs-data)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-295" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> update-brr-data-2
  (wonp failure-reason
    unify-subst
    gstack
    <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
    final-ttree
    rcnst
    ancestors
    whs-data)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-brkpt1-brr-data-entry-builtin" data-defines="BRKPT1-BRR-DATA-ENTRY-BUILTIN" data-references="NULL,IGNORE,XARGS,DECLARE,STATE,RCNST,GSTACK,ANCESTORS,DEFUN" data-part-name="BRKPT1-BRR-DATA-ENTRY-BUILTIN" data-part-args="STATE,RCNST,GSTACK,ANCESTORS" data-part-declare="RCNST,GSTACK,IGNORE,STATE,XARGS,DECLARE" data-part-body="ANCESTORS,NULL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRKPT1-BRR-DATA-ENTRY-BUILTIN">brkpt1-brr-data-entry-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brkpt1-brr-data-entry-builtin" data-sym="BRKPT1-BRR-DATA-ENTRY-BUILTIN" title="(defun brkpt1-brr-data-entry-builtin (ancestors gstack rcnst state)
  (declare (xargs :stobjs state)
           (ignore gstack rcnst state))
  (null ancestors))">brkpt1-brr-data-entry-builtin</a>
  (ancestors gstack rcnst state)
  (declare (xargs <span class="keyword">:stobjs</span> state)
    (ignore gstack rcnst state))
  (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ancestors))</pre>
  </div>

<div class="form-block function" id="def-brkpt2-brr-data-entry-builtin" data-defines="BRKPT2-BRR-DATA-ENTRY-BUILTIN" data-references="NULL,IGNORE,XARGS,DECLARE,STATE,RCNST,GSTACK,ANCESTORS,DEFUN" data-part-name="BRKPT2-BRR-DATA-ENTRY-BUILTIN" data-part-args="STATE,RCNST,GSTACK,ANCESTORS" data-part-declare="RCNST,GSTACK,IGNORE,STATE,XARGS,DECLARE" data-part-body="ANCESTORS,NULL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRKPT2-BRR-DATA-ENTRY-BUILTIN">brkpt2-brr-data-entry-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brkpt2-brr-data-entry-builtin" data-sym="BRKPT2-BRR-DATA-ENTRY-BUILTIN" title="(defun brkpt2-brr-data-entry-builtin (ancestors gstack rcnst state)
  (declare (xargs :stobjs state)
           (ignore gstack rcnst state))
  (null ancestors))">brkpt2-brr-data-entry-builtin</a>
  (ancestors gstack rcnst state)
  (declare (xargs <span class="keyword">:stobjs</span> state)
    (ignore gstack rcnst state))
  (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ancestors))</pre>
  </div>

<div class="form-block function" id="def-update-brr-data-1-builtin" data-defines="UPDATE-BRR-DATA-1-BUILTIN" data-references="HARD?,ER,BRR-DATA-1,BRR-DATA,MAKE,CONS,CDR,COMPLETED,CAR,PENDING,LET*,LISTP,COND,QUOTE,CTX,LET,T,XARGS,DECLARE,WHS-DATA,POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA,DEFUN" data-part-name="UPDATE-BRR-DATA-1-BUILTIN" data-part-args="WHS-DATA,POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA" data-part-declare="T,XARGS,DECLARE" data-part-body="HARD?,ER,T,POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA,BRR-DATA-1,BRR-DATA,MAKE,CONS,CDR,COMPLETED,CAR,PENDING,LET*,WHS-DATA,LISTP,COND,UPDATE-BRR-DATA-1-BUILTIN,QUOTE,CTX,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-BRR-DATA-1-BUILTIN">update-brr-data-1-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-brr-data-1-builtin" data-sym="UPDATE-BRR-DATA-1-BUILTIN" title="(defun update-brr-data-1-builtin
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst pot-lst whs-data)
  (declare (xargs :guard t))
  (let ((ctx &#39;update-brr-data-1-builtin))
...">update-brr-data-1-builtin</a>
  (lemma target
    unify-subst
    type-alist
    geneqv
    ancestors
    initial-ttree
    gstack
    rcnst
    pot-lst
    whs-data)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (let ((ctx '<a class="sym-link local-def" href="#def-update-brr-data-1-builtin" data-sym="UPDATE-BRR-DATA-1-BUILTIN" title="(defun update-brr-data-1-builtin
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst pot-lst whs-data)
  (declare (xargs :guard t))
  (let ((ctx &#39;update-brr-data-1-builtin))
...">update-brr-data-1-builtin</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-listp" data-sym="LISTP">listp</a> whs-data) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pending (car whs-data)) (completed (cdr whs-data)))
          (cons (cons (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> brr-data
                <span class="keyword">:pre</span> (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> brr-data-1
                  <span class="keyword">:lemma</span> lemma
                  <span class="keyword">:target</span> target
                  <span class="keyword">:unify-subst</span> unify-subst
                  <span class="keyword">:type-alist</span> type-alist
                  <span class="keyword">:geneqv</span> geneqv
                  <span class="keyword">:ancestors</span> ancestors
                  <span class="keyword">:initial-ttree</span> initial-ttree
                  <span class="keyword">:gstack</span> gstack
                  <span class="keyword">:rcnst</span> rcnst
                  <span class="keyword">:pot-list</span> pot-lst)
                <span class="keyword">:post</span> nil
                <span class="keyword">:completed</span> nil)
              pending)
            completed)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
          ctx
          <span class="string">"Implementation error: Found whs-data not a listp:~|~y0"</span>
          whs-data)))))</pre>
  </div>

<div class="form-block function" id="def-update-brr-data-2-builtin" data-defines="UPDATE-BRR-DATA-2-BUILTIN" data-references="CDDR,ACCESS,BRR-DATA,CHANGE,CADR,BRR-DATA-2,MAKE,X,WEAK-BRR-DATA-P,CONS,NULL,HARD?,ER,CONSP,NOT,CDR,COMPLETED,CAR,PENDING,LET*,LISTP,COND,QUOTE,CTX,LET,IGNORE,T,XARGS,DECLARE,WHS-DATA,ANCESTORS,RCNST,FINAL-TTREE,BRR-RESULT,GSTACK,UNIFY-SUBST,FAILURE-REASON,WONP,DEFUN" data-part-name="UPDATE-BRR-DATA-2-BUILTIN" data-part-args="WHS-DATA,ANCESTORS,RCNST,FINAL-TTREE,BRR-RESULT,GSTACK,UNIFY-SUBST,FAILURE-REASON,WONP" data-part-declare="ANCESTORS,IGNORE,T,XARGS,DECLARE" data-part-body="CDDR,ACCESS,BRR-DATA,CHANGE,CADR,RCNST,FINAL-TTREE,BRR-RESULT,GSTACK,UNIFY-SUBST,FAILURE-REASON,BRR-DATA-2,MAKE,X,T,WEAK-BRR-DATA-P,CONS,WONP,NULL,HARD?,ER,CONSP,NOT,CDR,COMPLETED,CAR,PENDING,LET*,WHS-DATA,LISTP,COND,UPDATE-BRR-DATA-2-BUILTIN,QUOTE,CTX,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-BRR-DATA-2-BUILTIN">update-brr-data-2-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-brr-data-2-builtin" data-sym="UPDATE-BRR-DATA-2-BUILTIN" title="(defun update-brr-data-2-builtin
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors whs-data)
  (declare (xargs :guard t)
           (ignore ancestors))
...">update-brr-data-2-builtin</a>
  (wonp failure-reason
    unify-subst
    gstack
    <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
    final-ttree
    rcnst
    ancestors
    whs-data)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (ignore ancestors))
  (let ((ctx '<a class="sym-link local-def" href="#def-update-brr-data-2-builtin" data-sym="UPDATE-BRR-DATA-2-BUILTIN" title="(defun update-brr-data-2-builtin
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors whs-data)
  (declare (xargs :guard t)
           (ignore ancestors))
...">update-brr-data-2-builtin</a>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-listp" data-sym="LISTP">listp</a> whs-data) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pending (car whs-data)) (completed (cdr whs-data)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (consp pending)) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
                ctx
                <span class="string">"Implementation error: Found bad whs-data ((car pending) not a ~
               cons):~|~y0"</span>
                whs-data))
            ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> wonp) (cons (cdr pending) completed))
            ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (weak-brr-data-p (car pending))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
                ctx
                <span class="string">"Implementation error: Found bad whs-data ((car pending) not a ~
               brr-data record)):~|~y0"</span>
                whs-data))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((x (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> brr-data-2
                     <span class="keyword">:failure-reason</span> failure-reason
                     <span class="keyword">:unify-subst</span> unify-subst
                     <span class="keyword">:gstack</span> gstack
                     <span class="keyword">:brr-result</span> <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                     <span class="keyword">:final-ttree</span> final-ttree
                     <span class="keyword">:rcnst</span> rcnst)))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((consp (cdr pending)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (weak-brr-data-p (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> pending))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
                          ctx
                          <span class="string">"Implementation error: Found whs-data (bad (cadr ~
                     pending)):~|~y0"</span>
                          whs-data))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-data
                              (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> pending)
                              <span class="keyword">:completed</span> (cons (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-data (car pending) <span class="keyword">:post</span> x)
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> pending) <span class="keyword">:completed</span>)))
                            (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> pending))
                          completed))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons nil
                      (cons (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-data (car pending) <span class="keyword">:post</span> x) completed)))))))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard?
          ctx
          <span class="string">"Implementation error: Found whs-data not a listp:~|~y0"</span>
          whs-data)))))</pre>
  </div>

<div class="form-block macro" id="def-set-brr-data-attachments" data-defines="SET-BRR-DATA-ATTACHMENTS" data-references="DEFATTACH,PROGN,WITH-OUTPUT,QUASIQUOTE,BRKPT2-BRR-DATA-ENTRY,BRKPT2-BDE-SUFFIX,BRKPT1-BRR-DATA-ENTRY,BRKPT1-BDE-SUFFIX,UPDATE-BRR-DATA-2,UPDATE-BRR-DATA-2-SUFFIX,UPDATE-BRR-DATA-1,ADD-SUFFIX,UPDATE-BRR-DATA-1-SUFFIX,STRING,CONCATENATE,T,SYMBOL-NAME,COND,LET*,STRINGP,SYMBOLP,OR,XARGS,DECLARE,BUILTIN,QUOTE,SUFFIX,&OPTIONAL,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-BRR-DATA-ATTACHMENTS">set-brr-data-attachments</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-brr-data-attachments" data-sym="SET-BRR-DATA-ATTACHMENTS" title="(defmacro set-brr-data-attachments (&amp;optional (suffix &#39;builtin))
  (declare (xargs :guard (or (symbolp suffix) (stringp suffix))))
  (let* ((suffix (cond ((symbolp suffix) (symbol-name suffix)) (t suffix)))
         (suffix (concatenate &#39;string &quot;-&quot; suffix))
         (update-brr-data-1-suffix (add-suffix &#39;update-brr-data-1 suffix))
...">set-brr-data-attachments</a>
  (&amp;optional (suffix 'builtin))
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (symbolp suffix) (stringp suffix))))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((suffix (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((symbolp suffix) (symbol-name suffix)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> suffix))) (suffix (<a class="sym-link system" href="axioms.html#def-concatenate" data-sym="CONCATENATE">concatenate</a> '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a> <span class="string">"-"</span> suffix))
      (update-brr-data-1-suffix (<a class="sym-link system" href="axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> 'update-brr-data-1 suffix))
      (update-brr-data-2-suffix (<a class="sym-link system" href="axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> 'update-brr-data-2 suffix))
      (brkpt1-bde-suffix (<a class="sym-link system" href="axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> 'brkpt1-brr-data-entry suffix))
      (brkpt2-bde-suffix (<a class="sym-link system" href="axioms.html#def-add-suffix" data-sym="ADD-SUFFIX">add-suffix</a> 'brkpt2-brr-data-entry suffix)))
    `(<a class="sym-link system" href="axioms.html#def-with-output" data-sym="WITH-OUTPUT">with-output</a> <span class="keyword">:off</span> <span class="keyword">:all</span> (<a class="sym-link system" href="axioms.html#def-progn" data-sym="PROGN">progn</a> (<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (update-brr-data-1 ,UPDATE-BRR-DATA-1-SUFFIX)
          <span class="keyword">:system-ok</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (update-brr-data-2 ,UPDATE-BRR-DATA-2-SUFFIX)
          <span class="keyword">:system-ok</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (brkpt1-brr-data-entry ,BRKPT1-BDE-SUFFIX)
          <span class="keyword">:system-ok</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (brkpt2-brr-data-entry ,BRKPT2-BDE-SUFFIX)
          <span class="keyword">:system-ok</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))))</pre>
  </div>

<div class="form-block function" id="def-set-wormhole-data-fast" data-defines="SET-WORMHOLE-DATA-FAST" data-references="CAR,CONS,CONSP,IF,T,XARGS,DECLARE,DATA,WHS,DEFUN" data-used-by="BRKPT2,BRKPT1,CLEAR-BRR-DATA-LST" data-part-name="SET-WORMHOLE-DATA-FAST" data-part-args="DATA,WHS" data-part-declare="T,XARGS,DECLARE" data-part-body="DATA,CAR,CONS,WHS,CONSP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-WORMHOLE-DATA-FAST">set-wormhole-data-fast</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-set-wormhole-data-fast" data-sym="SET-WORMHOLE-DATA-FAST" title="(defun set-wormhole-data-fast (whs data)
  (declare (xargs :guard t))
  (if (consp whs)
      (cons (car whs) data)
      (cons :enter data)))">set-wormhole-data-fast</a>
  (whs data)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (if (consp whs)
    (cons (car whs) data)
    (cons <span class="keyword">:enter</span> data)))</pre>
  </div>

<div class="form-block function" id="def-brr-data-mirror" data-defines="BRR-DATA-MIRROR" data-references="CONS,CDR,CHANGE,NULL,IF,X2,BRR-DATA,ACCESS,C,CAR,X1,LET*,ENDP,COND,TRUE-LISTP,T,BRR-DATA-LISTP,AND,XARGS,DECLARE,ACC,LST,DEFUN" data-used-by="BRR-DATA-LST" data-part-name="BRR-DATA-MIRROR" data-part-args="ACC,LST" data-part-declare="ACC,TRUE-LISTP,LST,T,BRR-DATA-LISTP,AND,XARGS,DECLARE" data-part-body="CONS,CDR,BRR-DATA-MIRROR,CHANGE,NULL,IF,X2,BRR-DATA,ACCESS,C,CAR,X1,LET*,T,ACC,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DATA-MIRROR">brr-data-mirror</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-data-mirror" data-sym="BRR-DATA-MIRROR" title="(defun brr-data-mirror (lst acc)
  (declare (xargs :guard (and (brr-data-listp t lst) (true-listp acc))))
  (cond ((endp lst) acc)
        (t
         (let* ((x1 (car lst))
...">brr-data-mirror</a>
  (lst acc)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (brr-data-listp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> lst) (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> acc))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((x1 (car lst)) (c (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x1 <span class="keyword">:completed</span>))
          (x2 (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> c)
              x1
              (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> brr-data x1 <span class="keyword">:completed</span> (<a class="sym-link local-def" href="#def-brr-data-mirror" data-sym="BRR-DATA-MIRROR" title="(defun brr-data-mirror (lst acc)
  (declare (xargs :guard (and (brr-data-listp t lst) (true-listp acc))))
  (cond ((endp lst) acc)
        (t
         (let* ((x1 (car lst))
...">brr-data-mirror</a> c nil)))))
        (<a class="sym-link local-def" href="#def-brr-data-mirror" data-sym="BRR-DATA-MIRROR" title="(defun brr-data-mirror (lst acc)
  (declare (xargs :guard (and (brr-data-listp t lst) (true-listp acc))))
  (cond ((endp lst) acc)
        (t
         (let* ((x1 (car lst))
...">brr-data-mirror</a> (cdr lst) (cons x2 acc))))))</pre>
  </div>

<div class="form-block function" id="def-brr-data-lst" data-defines="BRR-DATA-LST" data-references="T,CDR,BRR-DATA-MIRROR,EC-CALL,CONSP,COND,WORMHOLE-DATA,DATA,LET,VALUE,BRR-DATA,QUOTE,GET-PERSISTENT-WHS,STATUS,ER-LET*,XARGS,DECLARE,STATE,DEFUN" data-used-by="SET-BRR-DATA-LST,CW-GSTACK-FOR-SUBTERM,CW-GSTACK-FOR-TERM,CW-GSTACK-FOR-SUBTERM*,CW-GSTACK-FOR-TERM*,CW-GSTACK-FOR-TERM*-FN,CW-GSTACK-FOR-TERM-FN,CW-GSTACK-FOR-TERM-FN1-1,BRR-DATA-2-FOR-TERM-1,WITH-BRR-DATA" data-part-name="BRR-DATA-LST" data-part-args="STATE" data-part-declare="STATE,XARGS,DECLARE" data-part-body="T,CDR,BRR-DATA-MIRROR,EC-CALL,CONSP,COND,WORMHOLE-DATA,DATA,LET,VALUE,STATE,BRR-DATA,QUOTE,GET-PERSISTENT-WHS,STATUS,ER-LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DATA-LST">brr-data-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>
  (state)
  (declare (xargs <span class="keyword">:stobjs</span> state))
  (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((status (<a class="sym-link system" href="axioms.html#def-get-persistent-whs" data-sym="GET-PERSISTENT-WHS">get-persistent-whs</a> 'brr-data state)))
    (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (let ((data (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> status)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((consp data) (<a class="sym-link system" href="axioms.html#def-ec-call" data-sym="EC-CALL">ec-call</a> (<a class="sym-link local-def" href="#def-brr-data-mirror" data-sym="BRR-DATA-MIRROR" title="(defun brr-data-mirror (lst acc)
  (declare (xargs :guard (and (brr-data-listp t lst) (true-listp acc))))
  (cond ((endp lst) acc)
        (t
         (let* ((x1 (car lst))
...">brr-data-mirror</a> (cdr data) nil)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))))</pre>
  </div>

<div class="form-block function" id="def-clear-brr-data-lst" data-defines="CLEAR-BRR-DATA-LST" data-references="SET-WORMHOLE-DATA-FAST,WHS,LAMBDA,BRR-DATA,QUOTE,WORMHOLE-EVAL,T,XARGS,DECLARE,DEFUN" data-used-by="WITH-BRR-DATA" data-part-name="CLEAR-BRR-DATA-LST" data-part-declare="T,XARGS,DECLARE" data-part-body="SET-WORMHOLE-DATA-FAST,WHS,LAMBDA,BRR-DATA,QUOTE,WORMHOLE-EVAL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CLEAR-BRR-DATA-LST">clear-brr-data-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-clear-brr-data-lst" data-sym="CLEAR-BRR-DATA-LST" title="(defun clear-brr-data-lst ()
  (declare (xargs :guard t))
  (wormhole-eval &#39;brr-data &#39;(lambda (whs) (set-wormhole-data-fast whs nil))
                 nil))">clear-brr-data-lst</a>
  nil
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> 'brr-data
    '(lambda (whs) (<a class="sym-link local-def" href="#def-set-wormhole-data-fast" data-sym="SET-WORMHOLE-DATA-FAST" title="(defun set-wormhole-data-fast (whs data)
  (declare (xargs :guard t))
  (if (consp whs)
      (cons (car whs) data)
      (cons :enter data)))">set-wormhole-data-fast</a> whs nil))
    nil))</pre>
  </div>

<div class="form-block macro" id="def-with-brr-data" data-defines="WITH-BRR-DATA" data-references="CLEAR-BRR-DATA-LST,PROG2$,T,COND,FORM4,IGNORE,DECLARE,FORM3,MV,SET-BRR-DATA-LST,ER-PROGN,STATE,VAL,ERP,MV-LET,IF,FORM2,GSTACKP,STATE-GLOBAL-LET*,QUASIQUOTE,FORM1,LET*,BRR-DATA-RETURNED,BRR-DATA-LST,QUOTE,GLOBAL-VAR,&KEY,FORM,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="WITH-BRR-DATA">with-brr-data</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-with-brr-data" data-sym="WITH-BRR-DATA" title="(defmacro with-brr-data
          (form &amp;key (global-var &#39;brr-data-lst) (brr-data-returned &#39;nil))
  (let* ((form1 `(state-global-let* ((gstackp :brr-data)) ,form))
         (form2
          (if global-var
...">with-brr-data</a>
  (form &amp;key
    (global-var '<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>)
    (brr-data-returned 'nil))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((form1 `(<a class="sym-link system" href="axioms.html#def-state-global-let_2A" data-sym="STATE-GLOBAL-LET*">state-global-let*</a> ((gstackp <span class="keyword">:brr-data</span>)) ,FORM)) (form2 (if global-var
          `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val state)
            ,FORM1
            (<a class="sym-link system" href="axioms.html#def-er-progn" data-sym="ER-PROGN">er-progn</a> (<a class="sym-link local-def" href="#def-set-brr-data-lst" data-sym="SET-BRR-DATA-LST" title="(defmacro set-brr-data-lst (global-var &amp;optional (action &#39;:observation))
  (declare
   (xargs :guard
    (and (member-eq action (quote (:observation :error :silent))) global-var
         (symbolp global-var))))
...">set-brr-data-lst</a> ,GLOBAL-VAR) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp val state)))
          form1))
      (form3 (if brr-data-returned
          `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val state)
            ,FORM2
            (declare (ignore val))
            ,(IF GLOBAL-VAR
     `(MV ERP (@ ,GLOBAL-VAR) STATE)
     `(ER-LET* ((X (BRR-DATA-LST STATE))) (MV ERP (REVERSE X) STATE))))
          form2))
      (form4 `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ,FORM3))))
    `(<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-clear-brr-data-lst" data-sym="CLEAR-BRR-DATA-LST" title="(defun clear-brr-data-lst ()
  (declare (xargs :guard t))
  (wormhole-eval &#39;brr-data &#39;(lambda (whs) (set-wormhole-data-fast whs nil))
                 nil))">clear-brr-data-lst</a>) ,FORM4)))</pre>
  </div>

<div class="form-block function" id="def-addr_5Ep" data-defines="ADDR^P" data-references="CDDR,CADR,CDR,CONSP,AND,IF,POSP,^,QUOTE,CAR,EQ,ATOM,COND,T,XARGS,DECLARE,ADDR,DEFUN" data-used-by="GET-ADDR^" data-part-name="ADDR^P" data-part-args="ADDR" data-part-declare="T,XARGS,DECLARE" data-part-body="T,ADDR^P,CDDR,CADR,CDR,CONSP,AND,IF,POSP,^,QUOTE,CAR,EQ,ADDR,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADDR^P">addr^p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-addr_5Ep" data-sym="ADDR^P" title="(defun addr^p (addr)
  (declare (xargs :guard t))
  (cond ((atom addr) (eq addr nil)) ((eq (car addr) &#39;^) nil)
        ((posp (car addr))
         (if (and (consp (cdr addr)) (eq (cadr addr) &#39;^))
...">addr^p</a>
  (addr)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> addr) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> addr nil))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car addr) '^) nil)
    ((<a class="sym-link system" href="axioms.html#def-posp" data-sym="POSP">posp</a> (car addr)) (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr addr)) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> addr) '^))
        (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> addr) nil)
        (<a class="sym-link local-def" href="#def-addr_5Ep" data-sym="ADDR^P" title="(defun addr^p (addr)
  (declare (xargs :guard t))
  (cond ((atom addr) (eq addr nil)) ((eq (car addr) &#39;^) nil)
        ((posp (car addr))
         (if (and (consp (cdr addr)) (eq (cadr addr) &#39;^))
...">addr^p</a> (cdr addr))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))</pre>
  </div>

<div class="form-block function" id="def-safe-nth" data-defines="SAFE-NTH" data-references="CDR,-,CAR,=,CONSP,NATP,IF,T,XARGS,DECLARE,X,N,DEFUN" data-used-by="GET-ADDR^" data-part-name="SAFE-NTH" data-part-args="X,N" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,-,SAFE-NTH,CAR,=,X,CONSP,N,NATP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SAFE-NTH">safe-nth</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-safe-nth" data-sym="SAFE-NTH" title="(defun safe-nth (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nth</a>
  (n x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> n)
    (if (consp x)
      (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>)
        (car x)
        (<a class="sym-link local-def" href="#def-safe-nth" data-sym="SAFE-NTH" title="(defun safe-nth (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nth</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) (cdr x)))
      nil)
    (if (consp x)
      (car x)
      nil)))</pre>
  </div>

<div class="form-block function" id="def-safe-nthcdr" data-defines="SAFE-NTHCDR" data-references="CDR,-,=,CONSP,NATP,IF,T,XARGS,DECLARE,X,N,DEFUN" data-used-by="GET-ADDR^" data-part-name="SAFE-NTHCDR" data-part-args="X,N" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,-,SAFE-NTHCDR,=,X,CONSP,N,NATP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SAFE-NTHCDR">safe-nthcdr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-safe-nthcdr" data-sym="SAFE-NTHCDR" title="(defun safe-nthcdr (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nthcdr</a>
  (n x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (if (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> n)
    (if (consp x)
      (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>)
        x
        (<a class="sym-link local-def" href="#def-safe-nthcdr" data-sym="SAFE-NTHCDR" title="(defun safe-nthcdr (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nthcdr</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) (cdr x)))
      (if (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n <span class="number">0</span>)
        x
        nil))
    x))</pre>
  </div>

<div class="form-block function" id="def-terminal-marker" data-defines="TERMINAL-MARKER" data-references="CDR,CONSP,IF,T,XARGS,DECLARE,X,DEFUN" data-used-by="GET-ADDR^" data-part-name="TERMINAL-MARKER" data-part-args="X" data-part-declare="T,XARGS,DECLARE" data-part-body="CDR,TERMINAL-MARKER,X,CONSP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="TERMINAL-MARKER">terminal-marker</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-terminal-marker" data-sym="TERMINAL-MARKER" title="(defun terminal-marker (x)
  (declare (xargs :guard t))
  (if (consp x)
      (terminal-marker (cdr x))
      x))">terminal-marker</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (if (consp x)
    (<a class="sym-link local-def" href="#def-terminal-marker" data-sym="TERMINAL-MARKER" title="(defun terminal-marker (x)
  (declare (xargs :guard t))
  (if (consp x)
      (terminal-marker (cdr x))
      x))">terminal-marker</a> (cdr x))
    x))</pre>
  </div>

<div class="form-block function" id="def-get-addr_5E" data-defines="GET-ADDR^" data-references="+,TERMINAL-MARKER,.,LIST,=,SAFE-NTH,SAFE-NTHCDR,<,IF,ADDR1,^,QUOTE,CADR,EQ,CDR,AND,UP-FLG,LEN,K,CAR,-,N,LET*,T,ENDP,COND,ACL2-COUNT,ADDR^P,XARGS,DECLARE,X,ADDR,DEFUN" data-part-name="GET-ADDR^" data-part-args="X,ADDR" data-part-declare="ACL2-COUNT,ADDR,ADDR^P,XARGS,DECLARE" data-part-body="+,TERMINAL-MARKER,.,LIST,=,SAFE-NTH,SAFE-NTHCDR,GET-ADDR^,<,IF,ADDR1,^,QUOTE,CADR,EQ,CDR,AND,UP-FLG,LEN,K,CAR,-,N,LET*,T,X,ADDR,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-ADDR^">get-addr^</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-addr_5E" data-sym="GET-ADDR^" title="(defun get-addr^ (addr x)
  (declare (xargs :guard (addr^p addr) :measure (acl2-count addr)))
  (cond ((endp addr) x)
        (t
         (let* ((n (- (car addr) 1))
...">get-addr^</a>
  (addr x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-addr_5Ep" data-sym="ADDR^P" title="(defun addr^p (addr)
  (declare (xargs :guard t))
  (cond ((atom addr) (eq addr nil)) ((eq (car addr) &#39;^) nil)
        ((posp (car addr))
         (if (and (consp (cdr addr)) (eq (cadr addr) &#39;^))
...">addr^p</a> addr) <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-acl2-count" data-sym="ACL2-COUNT">acl2-count</a> addr)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> addr) x)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (car addr) <span class="number">1</span>)) (k (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> x))
          (up-flg (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (cdr addr) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> addr) '^)))
          (addr1 (if up-flg
              nil
              (cdr addr))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((&lt; n k) (<a class="sym-link local-def" href="#def-get-addr_5E" data-sym="GET-ADDR^" title="(defun get-addr^ (addr x)
  (declare (xargs :guard (addr^p addr) :measure (acl2-count addr)))
  (cond ((endp addr) x)
        (t
         (let* ((n (- (car addr) 1))
...">get-addr^</a> addr1
              (if up-flg
                (<a class="sym-link local-def" href="#def-safe-nthcdr" data-sym="SAFE-NTHCDR" title="(defun safe-nthcdr (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nthcdr</a> n x)
                (<a class="sym-link local-def" href="#def-safe-nth" data-sym="SAFE-NTH" title="(defun safe-nth (n x)
  (declare (xargs :guard t))
  (if (natp n)
      (if (consp x)
          (if (= n 0)
...">safe-nth</a> n x))))
          ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n k) (<a class="sym-link local-def" href="#def-get-addr_5E" data-sym="GET-ADDR^" title="(defun get-addr^ (addr x)
  (declare (xargs :guard (addr^p addr) :measure (acl2-count addr)))
  (cond ((endp addr) x)
        (t
         (let* ((n (- (car addr) 1))
...">get-addr^</a> addr1
              (if up-flg
                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '. (<a class="sym-link local-def" href="#def-terminal-marker" data-sym="TERMINAL-MARKER" title="(defun terminal-marker (x)
  (declare (xargs :guard t))
  (if (consp x)
      (terminal-marker (cdr x))
      x))">terminal-marker</a> x))
                '.)))
          ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> k)) (<a class="sym-link local-def" href="#def-get-addr_5E" data-sym="GET-ADDR^" title="(defun get-addr^ (addr x)
  (declare (xargs :guard (addr^p addr) :measure (acl2-count addr)))
  (cond ((endp addr) x)
        (t
         (let* ((n (- (car addr) 1))
...">get-addr^</a> addr1
              (if up-flg
                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link local-def" href="#def-terminal-marker" data-sym="TERMINAL-MARKER" title="(defun terminal-marker (x)
  (declare (xargs :guard t))
  (if (consp x)
      (terminal-marker (cdr x))
      x))">terminal-marker</a> x))
                (<a class="sym-link local-def" href="#def-terminal-marker" data-sym="TERMINAL-MARKER" title="(defun terminal-marker (x)
  (declare (xargs :guard t))
  (if (consp x)
      (terminal-marker (cdr x))
      x))">terminal-marker</a> x))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))))</pre>
  </div>

<div class="form-block function" id="def-update-nthcdr" data-defines="UPDATE-NTHCDR" data-references="CDR,-,CAR,CONS,T,ZP,COND,LEN,<=,NATP,AND,XARGS,DECLARE,X,VAL,N,DEFUN" data-used-by="PUT-ADDR^" data-part-name="UPDATE-NTHCDR" data-part-args="X,VAL,N" data-part-declare="X,LEN,<=,N,NATP,AND,XARGS,DECLARE" data-part-body="CDR,-,UPDATE-NTHCDR,X,CAR,CONS,T,VAL,N,ZP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UPDATE-NTHCDR">update-nthcdr</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-update-nthcdr" data-sym="UPDATE-NTHCDR" title="(defun update-nthcdr (n val x)
  (declare (xargs :guard (and (natp n) (&lt;= n (len x)))))
  (cond ((zp n) val) (t (cons (car x) (update-nthcdr (- n 1) val (cdr x))))))">update-nthcdr</a>
  (n val x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> n) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> n (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> x)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> n) val)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car x) (<a class="sym-link local-def" href="#def-update-nthcdr" data-sym="UPDATE-NTHCDR" title="(defun update-nthcdr (n val x)
  (declare (xargs :guard (and (natp n) (&lt;= n (len x)))))
  (cond ((zp n) val) (t (cons (car x) (update-nthcdr (- n 1) val (cdr x))))))">update-nthcdr</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> n <span class="number">1</span>) val (cdr x))))))</pre>
  </div>

<div class="form-block function" id="def-put-addr_5E" data-defines="PUT-ADDR^" data-references="NTH,UPDATE-NTH,CDDR,NULL,.,IF,+,OR,UPDATE-NTHCDR,<,LEN,K,-,N,LET*,T,CAR,=,^,QUOTE,CADR,EQ,CDR,CONSP,AND,ENDP,COND,X,VAL,ADDR,DEFUN" data-used-by="EXPLAIN-NEAR-MISS2,COMPARE-OBJECTS-LOOP$5,COMPARE-OBJECTS-LOOP$2" data-part-name="PUT-ADDR^" data-part-args="X,VAL,ADDR" data-part-body="NTH,PUT-ADDR^,UPDATE-NTH,CDDR,NULL,.,IF,+,OR,UPDATE-NTHCDR,<,X,LEN,K,-,N,LET*,T,CAR,=,^,QUOTE,CADR,EQ,CDR,CONSP,AND,VAL,ADDR,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-ADDR^">put-addr^</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-addr_5E" data-sym="PUT-ADDR^" title="(defun put-addr^ (addr val x)
  (cond ((endp addr) val)
        ((and (consp (cdr addr)) (eq (cadr addr) &#39;^))
         (cond ((= (car addr) 1) val)
               (t
...">put-addr^</a>
  (addr val x)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> addr) val)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr addr)) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> addr) '^)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> (car addr) <span class="number">1</span>) val)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (car addr) <span class="number">1</span>)) (k (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> x)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((&lt; n k) (<a class="sym-link local-def" href="#def-update-nthcdr" data-sym="UPDATE-NTHCDR" title="(defun update-nthcdr (n val x)
  (declare (xargs :guard (and (natp n) (&lt;= n (len x)))))
  (cond ((zp n) val) (t (cons (car x) (update-nthcdr (- n 1) val (cdr x))))))">update-nthcdr</a> n val x))
              ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n k) (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> k))) (<a class="sym-link local-def" href="#def-update-nthcdr" data-sym="UPDATE-NTHCDR" title="(defun update-nthcdr (n val x)
  (declare (xargs :guard (and (natp n) (&lt;= n (len x)))))
  (cond ((zp n) val) (t (cons (car x) (update-nthcdr (- n 1) val (cdr x))))))">update-nthcdr</a> k
                  (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp val)
                      (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car val) '.)
                      (consp (cdr val))
                      (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> val)))
                    (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> val)
                    val)
                  x))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (car addr) <span class="number">1</span>)) (k (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> x)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((&lt; n k) (<a class="sym-link system" href="axioms.html#def-update-nth" data-sym="UPDATE-NTH">update-nth</a> n (<a class="sym-link local-def" href="#def-put-addr_5E" data-sym="PUT-ADDR^" title="(defun put-addr^ (addr val x)
  (cond ((endp addr) val)
        ((and (consp (cdr addr)) (eq (cadr addr) &#39;^))
         (cond ((= (car addr) 1) val)
               (t
...">put-addr^</a> (cdr addr) val (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> n x)) x))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n k) (<a class="sym-link system" href="axioms.html#def-_3D" data-sym="=">=</a> n (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> k <span class="number">1</span>))) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr addr))) (<a class="sym-link local-def" href="#def-update-nthcdr" data-sym="UPDATE-NTHCDR" title="(defun update-nthcdr (n val x)
  (declare (xargs :guard (and (natp n) (&lt;= n (len x)))))
  (cond ((zp n) val) (t (cons (car x) (update-nthcdr (- n 1) val (cdr x))))))">update-nthcdr</a> k
              (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp val)
                  (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car val) '.)
                  (consp (cdr val))
                  (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> val)))
                (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> val)
                val)
              x))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-compare-objects1" data-defines="COMPARE-OBJECTS1" data-references=".,^,QUOTE,+,CDR,CAR,ANS1,LET,CONSP,N,COMPARE-OBJECTS1-LST,T,REVERSE,LIST,CONS,ATOM,OR,EQUAL,COND,XARGS,DECLARE,ANS,RADDR,Y,X,DEFUN,MUTUAL-RECURSION" data-used-by="COMPARE-OBJECTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS1">compare-objects1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects1" data-sym="COMPARE-OBJECTS1" title="(mutual-recursion
 (defun compare-objects1 (x y raddr ans)
   (declare (xargs :mode :program))
   (cond ((equal x y) ans)
         ((or (atom x) (atom y)) (cons (list (reverse raddr) x y) ans))
...">compare-objects1</a>
    (x y raddr ans)
    (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal x y) ans)
      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> x) (<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> y)) (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> raddr) x y) ans))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (compare-objects1-lst x y <span class="number">1</span> raddr ans))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> compare-objects1-lst
    (x y n raddr ans)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal x y) ans)
      ((consp x) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((consp y) (let ((ans1 (<a class="sym-link local-def" href="#def-compare-objects1" data-sym="COMPARE-OBJECTS1" title="(mutual-recursion
 (defun compare-objects1 (x y raddr ans)
   (declare (xargs :mode :program))
   (cond ((equal x y) ans)
         ((or (atom x) (atom y)) (cons (list (reverse raddr) x y) ans))
...">compare-objects1</a> (car x) (car y) (cons n raddr) ans)))
              (compare-objects1-lst (cdr x) (cdr y) (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> n) raddr ans1)))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (cons '^ (cons n raddr))) x (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '. y))
              ans))))
      ((consp y) (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (cons '^ (cons n raddr))) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '. x) y)
          ans))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (cons (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> <span class="number">1</span> n) raddr)) x y) ans)))))</pre>
  </div>

<div class="form-block function" id="def-make-compare-objects-placeholder" data-defines="MAKE-COMPARE-OBJECTS-PLACEHOLDER" data-references="STRING-DOWNCASE,STRING-APPEND,INTERN-IN-PACKAGE-OF-SYMBOL,>,PACKN,IF,LIST,QUOTE,SYMBOL-NAME,COERCE,STANDARD-CHAR-LISTP,SYMBOLP,AND,INTEGERP,OR,XARGS,DECLARE,X,DEFUN" data-used-by="EXPLAIN-NEAR-MISS2,COMPARE-OBJECTS-LOOP$1" data-part-name="MAKE-COMPARE-OBJECTS-PLACEHOLDER" data-part-args="X" data-part-declare="LIST,QUOTE,SYMBOL-NAME,COERCE,STANDARD-CHAR-LISTP,SYMBOLP,AND,X,INTEGERP,OR,XARGS,DECLARE" data-part-body="SYMBOL-NAME,STRING-DOWNCASE,STRING-APPEND,INTERN-IN-PACKAGE-OF-SYMBOL,>,QUOTE,LIST,PACKN,X,INTEGERP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-COMPARE-OBJECTS-PLACEHOLDER">make-compare-objects-placeholder</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-compare-objects-placeholder" data-sym="MAKE-COMPARE-OBJECTS-PLACEHOLDER" title="(defun make-compare-objects-placeholder (x)
  (declare
   (xargs :guard
    (or (integerp x)
        (and (symbolp x)
...">make-compare-objects-placeholder</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (integerp x)
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp x)
          (<a class="sym-link system" href="axioms.html#def-standard-char-listp" data-sym="STANDARD-CHAR-LISTP">standard-char-listp</a> (coerce (symbol-name x) '<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>))))))
  (if (integerp x)
    (<a class="sym-link system" href="basis-a.html#def-packn" data-sym="PACKN">packn</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> '<span class="keyword">:|&lt;s|</span> x '<a class="sym-link system" href="axioms.html#def-_3E" data-sym="&gt;">&gt;</a>))
    (intern-in-package-of-symbol (<a class="sym-link system" href="axioms.html#def-string-append" data-sym="STRING-APPEND">string-append</a> <span class="string">"&lt;"</span>
        (<a class="sym-link system" href="axioms.html#def-string-append" data-sym="STRING-APPEND">string-append</a> (<a class="sym-link system" href="axioms.html#def-string-downcase" data-sym="STRING-DOWNCASE">string-downcase</a> (symbol-name x)) <span class="string">"&gt;"</span>))
      <span class="keyword">:keyword</span>)))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_241" data-defines="COMPARE-OBJECTS-LOOP$1" data-references="CAR,CONS,-,CDR,MAKE-COMPARE-OBJECTS-PLACEHOLDER,NAME,LET,T,ENDP,COND,XARGS,DECLARE,ANS,I,LST,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$1" data-part-args="ANS,I,LST" data-part-declare="XARGS,DECLARE" data-part-body="CAR,CONS,-,CDR,COMPARE-OBJECTS-LOOP$1,I,MAKE-COMPARE-OBJECTS-PLACEHOLDER,NAME,LET,T,ANS,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$1">compare-objects-loop$1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_241" data-sym="COMPARE-OBJECTS-LOOP$1" title="(defun compare-objects-loop$1 (lst i ans)
  (declare (xargs :mode :program))
  (cond ((endp lst) ans)
        (t
         (let ((name (make-compare-objects-placeholder i)))
...">compare-objects-loop$1</a>
  (lst i ans)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) ans)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((name (<a class="sym-link local-def" href="#def-make-compare-objects-placeholder" data-sym="MAKE-COMPARE-OBJECTS-PLACEHOLDER" title="(defun make-compare-objects-placeholder (x)
  (declare
   (xargs :guard
    (or (integerp x)
        (and (symbolp x)
...">make-compare-objects-placeholder</a> i)))
        (<a class="sym-link local-def" href="#def-compare-objects-loop_241" data-sym="COMPARE-OBJECTS-LOOP$1" title="(defun compare-objects-loop$1 (lst i ans)
  (declare (xargs :mode :program))
  (cond ((endp lst) ans)
        (t
         (let ((name (make-compare-objects-placeholder i)))
...">compare-objects-loop$1</a> (cdr lst)
          (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> i <span class="number">1</span>)
          (cons (cons name (car lst)) ans))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_242" data-defines="COMPARE-OBJECTS-LOOP$2" data-references="PUT-ADDR^,CDR,CADR,ADDR,NAME,CAR,NAMED-TRIPLET,LET*,T,ENDP,COND,XARGS,DECLARE,OBJ,LST,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$2" data-part-args="OBJ,LST" data-part-declare="XARGS,DECLARE" data-part-body="PUT-ADDR^,CDR,COMPARE-OBJECTS-LOOP$2,CADR,ADDR,NAME,CAR,NAMED-TRIPLET,LET*,T,OBJ,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$2">compare-objects-loop$2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_242" data-sym="COMPARE-OBJECTS-LOOP$2" title="(defun compare-objects-loop$2 (lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$2</a>
  (lst obj)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) obj)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((named-triplet (car lst)) (name (car named-triplet))
          (addr (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> named-triplet)))
        (<a class="sym-link local-def" href="#def-compare-objects-loop_242" data-sym="COMPARE-OBJECTS-LOOP$2" title="(defun compare-objects-loop$2 (lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$2</a> (cdr lst) (<a class="sym-link local-def" href="#def-put-addr_5E" data-sym="PUT-ADDR^" title="(defun put-addr^ (addr val x)
  (cond ((endp addr) val)
        ((and (consp (cdr addr)) (eq (cadr addr) &#39;^))
         (cond ((= (car addr) 1) val)
               (t
...">put-addr^</a> addr name obj))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_243" data-defines="COMPARE-OBJECTS-LOOP$3" data-references="^,LAST,OR,CDDR,NULL,CDR,.,QUOTE,EQ,CONSP,IF,AND,CADDDR,YI,CADDR,XI,CAR,CADR,ADDRI,LET,T,ENDP,COND,XARGS,DECLARE,LST,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$3" data-part-args="LST" data-part-declare="XARGS,DECLARE" data-part-body="COMPARE-OBJECTS-LOOP$3,^,LAST,OR,CDDR,NULL,CDR,.,QUOTE,EQ,CONSP,IF,AND,CADDDR,YI,CADDR,XI,CAR,CADR,ADDRI,LET,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$3">compare-objects-loop$3</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_243" data-sym="COMPARE-OBJECTS-LOOP$3" title="(defun compare-objects-loop$3 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) t)
        (t
         (let ((addri (cadr (car lst)))
...">compare-objects-loop$3</a>
  (lst)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((addri (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car lst))) (xi (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst)))
          (yi (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst))))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp xi) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xi) '.))
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr xi)) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> xi)))
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp yi) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car yi) '.))
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr yi)) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> yi)))
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp xi) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car xi) '.))
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp yi) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car yi) '.)))
            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp addri) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-last" data-sym="LAST">last</a> addri)) '^))
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          (<a class="sym-link local-def" href="#def-compare-objects-loop_243" data-sym="COMPARE-OBJECTS-LOOP$3" title="(defun compare-objects-loop$3 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) t)
        (t
         (let ((addri (cadr (car lst)))
...">compare-objects-loop$3</a> (cdr lst)))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_244" data-defines="COMPARE-OBJECTS-LOOP$4" data-references="CDR,CADDDR,.,QUOTE,EQ,CADDR,CONSP,AND,IF,CADR,CAR,LIST,CONS,T,ENDP,COND,XARGS,DECLARE,LST,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$4" data-part-args="LST" data-part-declare="XARGS,DECLARE" data-part-body="CDR,COMPARE-OBJECTS-LOOP$4,CADDDR,.,QUOTE,EQ,CADDR,CONSP,AND,IF,CADR,CAR,LIST,CONS,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$4">compare-objects-loop$4</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_244" data-sym="COMPARE-OBJECTS-LOOP$4" title="(defun compare-objects-loop$4 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons
...">compare-objects-loop$4</a>
  (lst)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (car (car lst))
          (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car lst))
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst)))
              (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst))) '.))
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst)))
            (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst)))
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst)))
              (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst))) '.))
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst)))
            (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst))))
        (<a class="sym-link local-def" href="#def-compare-objects-loop_244" data-sym="COMPARE-OBJECTS-LOOP$4" title="(defun compare-objects-loop$4 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons
...">compare-objects-loop$4</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_245" data-defines="COMPARE-OBJECTS-LOOP$5" data-references="PUT-ADDR^,CDR,CADDDR,CADDR,IF,XI-OR-YI,CADR,ADDRI,CAR,NAMED-TRIPLET,LET*,T,ENDP,COND,XARGS,DECLARE,OBJ,LST,FLG,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$5" data-part-args="OBJ,LST,FLG" data-part-declare="XARGS,DECLARE" data-part-body="PUT-ADDR^,CDR,COMPARE-OBJECTS-LOOP$5,CADDDR,CADDR,FLG,IF,XI-OR-YI,CADR,ADDRI,CAR,NAMED-TRIPLET,LET*,T,OBJ,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$5">compare-objects-loop$5</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_245" data-sym="COMPARE-OBJECTS-LOOP$5" title="(defun compare-objects-loop$5 (flg lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$5</a>
  (flg lst obj)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) obj)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((named-triplet (car lst)) (addri (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> named-triplet))
          (xi-or-yi (if flg
              (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> named-triplet)
              (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> named-triplet))))
        (<a class="sym-link local-def" href="#def-compare-objects-loop_245" data-sym="COMPARE-OBJECTS-LOOP$5" title="(defun compare-objects-loop$5 (flg lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$5</a> flg
          (cdr lst)
          (<a class="sym-link local-def" href="#def-put-addr_5E" data-sym="PUT-ADDR^" title="(defun put-addr^ (addr val x)
  (cond ((endp addr) val)
        ((and (consp (cdr addr)) (eq (cadr addr) &#39;^))
         (cond ((= (car addr) 1) val)
               (t
...">put-addr^</a> addri xi-or-yi obj))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects-loop_246" data-defines="COMPARE-OBJECTS-LOOP$6" data-references="CDR,CADDDR,CADDR,CAR,LIST,CONS,T,ENDP,COND,XARGS,DECLARE,LST,DEFUN" data-used-by="COMPARE-OBJECTS" data-part-name="COMPARE-OBJECTS-LOOP$6" data-part-args="LST" data-part-declare="XARGS,DECLARE" data-part-body="CDR,COMPARE-OBJECTS-LOOP$6,CADDDR,CADDR,CAR,LIST,CONS,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS-LOOP$6">compare-objects-loop$6</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects-loop_246" data-sym="COMPARE-OBJECTS-LOOP$6" title="(defun compare-objects-loop$6 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons (list (car (car lst)) (caddr (car lst)) (cadddr (car lst)))">compare-objects-loop$6</a>
  (lst)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (car (car lst)) (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> (car lst)) (<a class="sym-link system" href="axioms.html#def-cadddr" data-sym="CADDDR">cadddr</a> (car lst)))
        (<a class="sym-link local-def" href="#def-compare-objects-loop_246" data-sym="COMPARE-OBJECTS-LOOP$6" title="(defun compare-objects-loop$6 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons (list (car (car lst)) (caddr (car lst)) (cadddr (car lst)))">compare-objects-loop$6</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-compare-objects" data-defines="COMPARE-OBJECTS" data-references="LIST,QUOTE,HARD,ER,QUASIQUOTE,COMPARE-OBJECTS-LOOP$6,NAMED-DOUBLETS,LET,EQUAL,AND,Y-PRIME,T,COMPARE-OBJECTS-LOOP$5,X-PRIME,COMPARE-OBJECTS-LOOP$4,NAMED-TRIPLETS-WITHOUT-BOGUS-DOTS,COMPARE-OBJECTS-LOOP$3,COND,COMPARE-OBJECTS-LOOP$2,COMMON-OBJ,LENGTH,COMPARE-OBJECTS-LOOP$1,NAMED-TRIPLETS,COMPARE-OBJECTS1,TRIPLETS,LET*,XARGS,DECLARE,Y,X,DEFUN" data-used-by="EXPLAIN-NEAR-MISS2" data-part-name="COMPARE-OBJECTS" data-part-args="Y,X" data-part-declare="XARGS,DECLARE" data-part-body="LIST,COMPARE-OBJECTS,QUOTE,HARD,ER,QUASIQUOTE,COMPARE-OBJECTS-LOOP$6,NAMED-DOUBLETS,LET,EQUAL,AND,Y-PRIME,T,COMPARE-OBJECTS-LOOP$5,X-PRIME,COMPARE-OBJECTS-LOOP$4,NAMED-TRIPLETS-WITHOUT-BOGUS-DOTS,COMPARE-OBJECTS-LOOP$3,COND,COMPARE-OBJECTS-LOOP$2,COMMON-OBJ,LENGTH,COMPARE-OBJECTS-LOOP$1,NAMED-TRIPLETS,Y,X,COMPARE-OBJECTS1,TRIPLETS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMPARE-OBJECTS">compare-objects</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-compare-objects" data-sym="COMPARE-OBJECTS" title="(defun compare-objects (x y)
  (declare (xargs :mode :program))
  (let* ((triplets (compare-objects1 x y nil nil))
         (named-triplets
          (compare-objects-loop$1 triplets (length triplets) nil))
...">compare-objects</a>
  (x y)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((triplets (<a class="sym-link local-def" href="#def-compare-objects1" data-sym="COMPARE-OBJECTS1" title="(mutual-recursion
 (defun compare-objects1 (x y raddr ans)
   (declare (xargs :mode :program))
   (cond ((equal x y) ans)
         ((or (atom x) (atom y)) (cons (list (reverse raddr) x y) ans))
...">compare-objects1</a> x y nil nil)) (named-triplets (<a class="sym-link local-def" href="#def-compare-objects-loop_241" data-sym="COMPARE-OBJECTS-LOOP$1" title="(defun compare-objects-loop$1 (lst i ans)
  (declare (xargs :mode :program))
  (cond ((endp lst) ans)
        (t
         (let ((name (make-compare-objects-placeholder i)))
...">compare-objects-loop$1</a> triplets (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> triplets) nil))
      (common-obj (<a class="sym-link local-def" href="#def-compare-objects-loop_242" data-sym="COMPARE-OBJECTS-LOOP$2" title="(defun compare-objects-loop$2 (lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$2</a> named-triplets x)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-compare-objects-loop_243" data-sym="COMPARE-OBJECTS-LOOP$3" title="(defun compare-objects-loop$3 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) t)
        (t
         (let ((addri (cadr (car lst)))
...">compare-objects-loop$3</a> named-triplets) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((named-triplets-without-bogus-dots (<a class="sym-link local-def" href="#def-compare-objects-loop_244" data-sym="COMPARE-OBJECTS-LOOP$4" title="(defun compare-objects-loop$4 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons
...">compare-objects-loop$4</a> named-triplets)) (x-prime (<a class="sym-link local-def" href="#def-compare-objects-loop_245" data-sym="COMPARE-OBJECTS-LOOP$5" title="(defun compare-objects-loop$5 (flg lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$5</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                named-triplets-without-bogus-dots
                common-obj))
            (y-prime (<a class="sym-link local-def" href="#def-compare-objects-loop_245" data-sym="COMPARE-OBJECTS-LOOP$5" title="(defun compare-objects-loop$5 (flg lst obj)
  (declare (xargs :mode :program))
  (cond ((endp lst) obj)
        (t
         (let* ((named-triplet (car lst))
...">compare-objects-loop$5</a> nil
                named-triplets-without-bogus-dots
                common-obj)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal x-prime x) (equal y-prime y)) (let ((named-doublets (<a class="sym-link local-def" href="#def-compare-objects-loop_246" data-sym="COMPARE-OBJECTS-LOOP$6" title="(defun compare-objects-loop$6 (lst)
  (declare (xargs :mode :program))
  (cond ((endp lst) nil)
        (t
         (cons (list (car (car lst)) (caddr (car lst)) (cadddr (car lst)))">compare-objects-loop$6</a> named-triplets-without-bogus-dots)))
                `((<span class="keyword">:obj</span> ,COMMON-OBJ) (<span class="keyword">:legend</span> ,NAMED-DOUBLETS))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                '<a class="sym-link local-def" href="#def-compare-objects" data-sym="COMPARE-OBJECTS" title="(defun compare-objects (x y)
  (declare (xargs :mode :program))
  (let* ((triplets (compare-objects1 x y nil nil))
         (named-triplets
          (compare-objects-loop$1 triplets (length triplets) nil))
...">compare-objects</a>
                <span class="string">"Compare-objects does not satisfy its intended spec that ~
                    the original x and y can be obtained from the common ~
                    object by hitting, with put-addr^, the addr of each name ~
                    &lt;si&gt; with the simplified replacements, xi and yi, stripped ~
                    of any bogus dots.  Please send this error message ~
                    (complete with the display below) to the ~
                    implementors.~%~Y01~%Thanks."</span>
                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:x</span> x)
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:y</span> y)
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:named-triplets</span> named-triplets)
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:named-triplets-without-bogus-dots</span> named-triplets-without-bogus-dots)
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:x-prime</span> x-prime)
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:y-prime</span> y-prime))
                nil)))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
          '<a class="sym-link local-def" href="#def-compare-objects" data-sym="COMPARE-OBJECTS" title="(defun compare-objects (x y)
  (declare (xargs :mode :program))
  (let* ((triplets (compare-objects1 x y nil nil))
         (named-triplets
          (compare-objects-loop$1 triplets (length triplets) nil))
...">compare-objects</a>
          <span class="string">"We thought compare-objects1 never reported a replacement ~
             containing a bogus dot unless the replacement was of the form ~
             (|.| z) and the associated address ended in ^.  Please send this ~
             error message (complete with the display below) to the ~
             implementors.~%~Y01~%~Y21.~%Thanks."</span>
          x
          nil
          y)))))</pre>
  </div>

<div class="form-block function" id="def-get-actual-brr-evisc-tuple" data-defines="GET-ACTUAL-BRR-EVISC-TUPLE" data-references="T,EVISC-TUPLE,TERM-EVISC-TUPLE,EQ,COND,BRR-EVISC-TUPLE,QUOTE,F-GET-GLOBAL,TUPLE,LET,STATE,DEFUN" data-used-by="EXPLAIN-NEAR-MISS2" data-part-name="GET-ACTUAL-BRR-EVISC-TUPLE" data-part-args="STATE" data-part-body="T,EVISC-TUPLE,TERM-EVISC-TUPLE,EQ,COND,STATE,BRR-EVISC-TUPLE,QUOTE,F-GET-GLOBAL,TUPLE,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="GET-ACTUAL-BRR-EVISC-TUPLE">get-actual-brr-evisc-tuple</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-get-actual-brr-evisc-tuple" data-sym="GET-ACTUAL-BRR-EVISC-TUPLE" title="(defun get-actual-brr-evisc-tuple (state)
  (let ((tuple (f-get-global &#39;brr-evisc-tuple state)))
    (cond
     ((eq tuple :default)
      (let ((tuple (f-get-global &#39;term-evisc-tuple state)))
...">get-actual-brr-evisc-tuple</a>
  (state)
  (let ((tuple (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> tuple <span class="keyword">:default</span>) (let ((tuple (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-a.html#def-term-evisc-tuple" data-sym="TERM-EVISC-TUPLE">term-evisc-tuple</a> state)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> tuple <span class="keyword">:default</span>) (<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <span class="number">5</span> <span class="number">7</span> nil nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> tuple))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> tuple))))</pre>
  </div>

<div class="form-block function" id="def-keyword-to-lc-string-alist" data-defines="KEYWORD-TO-LC-STRING-ALIST" data-references="T,CDR,SYMBOL-NAME,STRING-DOWNCASE,CONS,CAR,KEYWORDP,ENDP,COND,KEYWORDS,DEFUN" data-part-name="KEYWORD-TO-LC-STRING-ALIST" data-part-args="KEYWORDS" data-part-body="T,CDR,KEYWORD-TO-LC-STRING-ALIST,SYMBOL-NAME,STRING-DOWNCASE,CONS,CAR,KEYWORDP,KEYWORDS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="KEYWORD-TO-LC-STRING-ALIST">keyword-to-lc-string-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-keyword-to-lc-string-alist" data-sym="KEYWORD-TO-LC-STRING-ALIST" title="(defun keyword-to-lc-string-alist (keywords)
  (cond ((endp keywords) nil)
        ((keywordp (car keywords))
         (cons
          (cons (car keywords) (string-downcase (symbol-name (car keywords))))
...">keyword-to-lc-string-alist</a>
  (keywords)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> keywords) nil)
    ((<a class="sym-link system" href="axioms.html#def-keywordp" data-sym="KEYWORDP">keywordp</a> (car keywords)) (cons (cons (car keywords)
          (<a class="sym-link system" href="axioms.html#def-string-downcase" data-sym="STRING-DOWNCASE">string-downcase</a> (symbol-name (car keywords))))
        (<a class="sym-link local-def" href="#def-keyword-to-lc-string-alist" data-sym="KEYWORD-TO-LC-STRING-ALIST" title="(defun keyword-to-lc-string-alist (keywords)
  (cond ((endp keywords) nil)
        ((keywordp (car keywords))
         (cons
          (cons (car keywords) (string-downcase (symbol-name (car keywords))))
...">keyword-to-lc-string-alist</a> (cdr keywords))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-keyword-to-lc-string-alist" data-sym="KEYWORD-TO-LC-STRING-ALIST" title="(defun keyword-to-lc-string-alist (keywords)
  (cond ((endp keywords) nil)
        ((keywordp (car keywords))
         (cons
          (cons (car keywords) (string-downcase (symbol-name (car keywords))))
...">keyword-to-lc-string-alist</a> (cdr keywords)))))</pre>
  </div>

<div class="form-block function" id="def-explain-near-miss2" data-defines="EXPLAIN-NEAR-MISS2" data-references="COMPARE-OBJECTS,OBJ-AND-LEGEND,CONS-COUNT-BOUNDED-AC,>=,LARGEP,OBJ2,IF,OBJ1,EQUAL,FFN-SYMB,FLAMBDAP,FQUOTEP,NVARIABLEP,COMPARE-OBJECTSP,QUOTEP,AND,TWO-QUOTESP,STRIP-CDRS,PAIRLIS-X2,STRIP-CARS,PAIRLIS$,DOUBLET-ALIST,PAT,MAKE-COMPARE-OBJECTS-PLACEHOLDER,PUT-ADDR^,MARKED-PAT,SUBLIS-VAR,INSTANTIATED-SUBPAT,FETCH-ADDR,SUBPAT,LET*,HARD,PROG2$,VALUE,*STANDARD-CO*,QUASIQUOTE,FMT-ABBREV,ONE-WAY-UNIFY,ALIST2,ANS2,GET-ACTUAL-BRR-EVISC-TUPLE,LET,STANDARD-EVISC-TUPLEP,T,NATP,EXPLAIN-NEAR-MISS,QUOTE,SOFT,ER,EQ,NOT,NULL,OR,COND,ONE-WAY-UNIFY-FR,SUBTARGET,ALIST,ADDR,ALIST1,ANS1,MV-LET,XARGS,DECLARE,STATE,EVISC-TUPLE,LARGE-CONS-COUNT,TARGET-TERM,PAT-TERM,PAT-CMD,DEFUN" data-used-by="EXPLAIN-NEAR-MISS1" data-part-name="EXPLAIN-NEAR-MISS2" data-part-args="STATE,EVISC-TUPLE,LARGE-CONS-COUNT,TARGET-TERM,PAT-TERM,PAT-CMD" data-part-declare="XARGS,DECLARE" data-part-body="COMPARE-OBJECTS,OBJ-AND-LEGEND,CONS-COUNT-BOUNDED-AC,>=,LARGEP,OBJ2,IF,OBJ1,EQUAL,FFN-SYMB,FLAMBDAP,FQUOTEP,NVARIABLEP,COMPARE-OBJECTSP,QUOTEP,AND,TWO-QUOTESP,STRIP-CDRS,PAIRLIS-X2,STRIP-CARS,PAIRLIS$,DOUBLET-ALIST,PAT,MAKE-COMPARE-OBJECTS-PLACEHOLDER,PUT-ADDR^,MARKED-PAT,SUBLIS-VAR,INSTANTIATED-SUBPAT,FETCH-ADDR,SUBPAT,LET*,HARD,PROG2$,VALUE,*STANDARD-CO*,QUASIQUOTE,FMT-ABBREV,ONE-WAY-UNIFY,ALIST2,ANS2,STATE,GET-ACTUAL-BRR-EVISC-TUPLE,LET,STANDARD-EVISC-TUPLEP,T,EVISC-TUPLE,NATP,LARGE-CONS-COUNT,EXPLAIN-NEAR-MISS,QUOTE,SOFT,ER,PAT-CMD,EQ,NOT,NULL,OR,COND,TARGET-TERM,PAT-TERM,ONE-WAY-UNIFY-FR,SUBTARGET,ALIST,ADDR,ALIST1,ANS1,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPLAIN-NEAR-MISS2">explain-near-miss2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-explain-near-miss2" data-sym="EXPLAIN-NEAR-MISS2" title="(defun explain-near-miss2
       (pat-cmd pat-term target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (mv-let (ans1 alist1 addr alist subtarget)
          (one-way-unify-fr pat-term target-term)
...">explain-near-miss2</a>
  (pat-cmd pat-term
    target-term
    large-cons-count
    <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
    state)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans1 alist1 addr alist subtarget)
    (one-way-unify-fr pat-term target-term)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pat-term)
         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat-cmd <span class="keyword">:lhs</span>) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pat-cmd <span class="keyword">:max-term</span>)))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
          'explain-near-miss
          <span class="string">"Explain-near-miss is meant to be invoked when (brr@ :lemma) is a ~
           lemma of rule-class :rewrite, :linear, or :rewrite-quoted-constant ~
           and the current value of (brr@ :lemma) is none of these."</span>))
      ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> large-cons-count) (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> large-cons-count))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
          'explain-near-miss
          <span class="string">"The large-cons-count argument must be nil or a natural, but you ~
           supplied ~x0."</span>
          large-cons-count))
      ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-standard-evisc-tuplep" data-sym="STANDARD-EVISC-TUPLEP">standard-evisc-tuplep</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
          'explain-near-miss
          <span class="string">"The evisc-tuple argument must be nil (meaning no evisceration), ~
           t (meaning use the brr evisc-tuple), or a standard evisceration ~
           4-tuple.  You supplied ~x0."</span>
          <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((<a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> nil) nil)
               ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-get-actual-brr-evisc-tuple" data-sym="GET-ACTUAL-BRR-EVISC-TUPLE" title="(defun get-actual-brr-evisc-tuple (state)
  (let ((tuple (f-get-global &#39;brr-evisc-tuple state)))
    (cond
     ((eq tuple :default)
      (let ((tuple (f-get-global &#39;term-evisc-tuple state)))
...">get-actual-brr-evisc-tuple</a> state))
               (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>))))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans1 (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans2 alist2)
                (one-way-unify pat-term target-term)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans2 (let ((state (<a class="sym-link system" href="basis-a.html#def-fmt-abbrev" data-sym="FMT-ABBREV">fmt-abbrev</a> <span class="string">"Explain-near-miss is meant to be invoked only ~
                            after the rule&#39;s triggering pattern, ~X01, fails ~
                            to match the target term, ~X21.  But these two ~
                            terms do match, under the substitution ~X31 (here ~
                            printed as a list of doublets, (var term), rather ~
                            than a list of pairs (var . term)).  The ~
                            triggering-pattern and target term may be ~
                            obtained from within a near miss break with the ~
                            commands ~x4 and :TARGET."</span>
                           `((#\0 . ,PAT-TERM) (#\1 . ,EVISC-TUPLE)
                             (#\2 . ,TARGET-TERM)
                             (#\3 . ,(PAIRLIS$ (STRIP-CARS ALIST2) (PAIRLIS-X2 (STRIP-CDRS ALIST2) NIL)))
                             (#\4 . ,PAT-CMD))
                           <span class="number">0</span>
                           <a class="sym-link system" href="axioms.html#def-_2Astandard-co_2A" data-sym="*STANDARD-CO*">*standard-co*</a>
                           state
                           <span class="string">"~%~%"</span>)))
                      (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                        'explain-near-miss
                        <span class="string">"There is a bug in ONE-WAY-UNIFY-FR.  It reports ~
                           that the pattern ~X01 matches the term ~X21 under ~
                           substitution ~X31, even though ONE-WAY-UNIFY ~
                           reports that the pattern and term do not match!  ~
                           Please provide the implementors with this ~
                           information."</span>
                        pat-term
                        nil
                        target-term
                        alist1)
                      (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((subpat (fetch-addr addr pat-term)) (instantiated-subpat (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> alist subpat))
                  (marked-pat (<a class="sym-link local-def" href="#def-put-addr_5E" data-sym="PUT-ADDR^" title="(defun put-addr^ (addr val x)
  (cond ((endp addr) val)
        ((and (consp (cdr addr)) (eq (cadr addr) &#39;^))
         (cond ((= (car addr) 1) val)
               (t
...">put-addr^</a> addr
                      (<a class="sym-link local-def" href="#def-make-compare-objects-placeholder" data-sym="MAKE-COMPARE-OBJECTS-PLACEHOLDER" title="(defun make-compare-objects-placeholder (x)
  (declare
   (xargs :guard
    (or (integerp x)
        (and (symbolp x)
...">make-compare-objects-placeholder</a> 'pat)
                      pat-term))
                  (doublet-alist (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> alist)
                      (<a class="sym-link system" href="axioms.html#def-pairlis-x2" data-sym="PAIRLIS-X2">pairlis-x2</a> (<a class="sym-link system" href="axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> alist) nil)))
                  (two-quotesp (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> instantiated-subpat) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> subtarget)))
                  (compare-objectsp (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> two-quotesp
                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> instantiated-subpat)
                        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> instantiated-subpat))
                        (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> instantiated-subpat))
                        (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> subtarget)
                        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> subtarget))
                        (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> subtarget))
                        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> instantiated-subpat) (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> subtarget))))))
                  (obj1 (if compare-objectsp
                      (if two-quotesp
                        instantiated-subpat
                        (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> instantiated-subpat))
                      nil))
                  (obj2 (if compare-objectsp
                      (if two-quotesp
                        subtarget
                        (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> subtarget))
                      nil))
                  (largep (if compare-objectsp
                      (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> large-cons-count)
                        (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (cons-count-bounded-ac obj1 <span class="number">0</span> large-cons-count)
                          large-cons-count)
                        (<a class="sym-link system" href="axioms.html#def-_3E_3D" data-sym="&gt;=">&gt;=</a> (cons-count-bounded-ac obj2 <span class="number">0</span> large-cons-count)
                          large-cons-count))
                      nil))
                  (obj-and-legend (<a class="sym-link local-def" href="#def-compare-objects" data-sym="COMPARE-OBJECTS" title="(defun compare-objects (x y)
  (declare (xargs :mode :program))
  (let* ((triplets (compare-objects1 x y nil nil))
         (named-triplets
          (compare-objects-loop$1 triplets (length triplets) nil))
...">compare-objects</a> obj1 obj2)))
                (let ((state (<a class="sym-link system" href="basis-a.html#def-fmt-abbrev" data-sym="FMT-ABBREV">fmt-abbrev</a> <span class="string">"~%The ACL2 match algorithm attempted to match ~xe with ~
                       :TARGET by finding a substitution, s, such that ~xe/s ~
                       = :TARGET.  That attempt failed when trying to match ~
                       the subterm of ~xe marked &lt;pat&gt; in ~xe&#39; below.~%~%~
                       ~xe:~_f ~Y01~
                       ~xe&#39;:~_f~Y21~
                       :TARGET:   ~Y31~%~
                       Below we show the substitution, s, computed prior to ~
                       the failure; the subterm of ~xe we&#39;re calling &lt;pat&gt;; ~
                       the instantiated subterm, &lt;pat&gt;/s; and the ~
                       corresponding subterm, &lt;tar&gt;, of :TARGET.~%~%~
                       s:       ~Y61~
                       &lt;pat&gt;:   ~Y51~
                       &lt;pat&gt;/s: ~Y81~
                       &lt;tar&gt;:   ~Y71~%~
                       For the rewriter to get past this failure the match ~
                       algorithm must be able to extend substitution s to s&#39; ~
                       so that &lt;pat&gt;/s&#39; is equal to &lt;tar&gt; and our match ~
                       algorithm could not find such an extension.~%~%In case ~
                       you want to manually explore &lt;pat&gt; and &lt;tar&gt; they may ~
                       be obtained by executing the following forms in the ~
                       break caused by this near miss~%~%&lt;pat&gt;: ~Yc1&lt;tar&gt;: ~
                       ~Yd1~%(Note: The substitution, s, is displayed above ~
                       as a list of ``doublets&#39;&#39; rather than pairs.  I.e., ~
                       ((var1 term1) ...) instead of ((var1 . term1) ...).  ~
                       If you wish to instantiate &lt;pat&gt; using sublis-var you ~
                       must convert the doublets to pairs.  Finally, be ~
                       advised that instantiating a term can produce a quoted ~
                       object, e.g., (sublis-var &#39;((x . &#39;13)) &#39;(cons x x)) is ~
                       &#39;(13 . 13), not (cons &#39;13 &#39;13).)~%~
                       ~#9~[~/~%Since &lt;pat&gt;/s and &lt;tar&gt; are ~#a~[quoted ~
                       objects, those objects~/applications of lambda ~
                       expressions, those lambda expressions~] must be ~
                       identical for the match algorithm to succeed.  ~
                       Because they are ``large&#39;&#39; it might be difficult to ~
                       see where they differ.  So we show you below.~%~%Let ~
                       x be ~#a~[&lt;pat&gt;/s~/the lambda expression being ~
                       applied in &lt;pat&gt;/s, i.e., (fn-symb &lt;pat/s&gt;)~] and let ~
                       y be ~#a~[&lt;tar&gt;~/(fn-symb &lt;tar&gt;)~].  Below is the ~
                       output of (compare-objects x y).  The object labeled ~
                       :OBJ shows the basic structure of x and y with ~
                       certain substructures replaced by tokens, &lt;si&gt;, ~
                       i=1,2,....  These &lt;si&gt; mark where x and y differ. The ~
                       :LEGEND is a list of elements, each of the form (&lt;si&gt; ~
                       xi yi) meaning ``at &lt;si&gt;, x contains xi but y ~
                       contains yi.&#39;&#39;~%~%~Yb1~]~%See :DOC ~
                       explain-near-miss~#9~[~/ and :DOC compare-objects~] ~
                       for details."</span>
                       `((#\0 . ,PAT-TERM) (#\1 . ,(EVISC-TUPLE (CADR EVISC-TUPLE) (CADDR EVISC-TUPLE)
              (KEYWORD-TO-LC-STRING-ALIST
               (CONS &#39;:|&lt;pat&gt;|
                     (STRIP-CARS (CADR (ASSOC-EQ :LEGEND OBJ-AND-LEGEND)))))
              NIL))
                         (#\2 . ,MARKED-PAT)
                         (#\3 . ,TARGET-TERM)
                         (#\5 . ,SUBPAT)
                         (#\6 . ,DOUBLET-ALIST)
                         (#\7 . ,SUBTARGET)
                         (#\8 . ,INSTANTIATED-SUBPAT)
                         (#\9 . ,(IF (AND COMPARE-OBJECTSP LARGEP)
     1
     0))
                         (#\a . ,(IF TWO-QUOTESP
     0
     1))
                         (#\b . ,OBJ-AND-LEGEND)
                         (#\c . ,`(FETCH-ADDR &#39;,ADDR (BRR@ ,PAT-CMD)))
                         (#\d . ,`(FETCH-ADDR &#39;,ADDR (BRR@ :TARGET)))
                         (#\e . ,PAT-CMD)
                         (#\f . ,(IF (EQ PAT-CMD :MAX-TERM)
     0
     5)))
                       <span class="number">0</span>
                       <a class="sym-link system" href="axioms.html#def-_2Astandard-co_2A" data-sym="*STANDARD-CO*">*standard-co*</a>
                       state
                       <span class="string">"~%~%"</span>)))
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))))))))</pre>
  </div>

<div class="form-block function" id="def-explain-near-miss1" data-defines="EXPLAIN-NEAR-MISS1" data-references="EXPLAIN-NEAR-MISS2,PATTERN,PAT-TERM,BRR-CMD-NAME-FOR-PATTERN,QUOTE,GET-BRR-LOCAL,PAT-CMD,LET*,XARGS,DECLARE,STATE,EVISC-TUPLE,LARGE-CONS-COUNT,TARGET-TERM,DEFUN" data-used-by="*BRKPT2-ALIASES*,*BRKPT1-ALIASES*" data-part-name="EXPLAIN-NEAR-MISS1" data-part-args="STATE,EVISC-TUPLE,LARGE-CONS-COUNT,TARGET-TERM" data-part-declare="XARGS,DECLARE" data-part-body="EVISC-TUPLE,LARGE-CONS-COUNT,TARGET-TERM,EXPLAIN-NEAR-MISS2,PATTERN,PAT-TERM,STATE,BRR-CMD-NAME-FOR-PATTERN,QUOTE,GET-BRR-LOCAL,PAT-CMD,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPLAIN-NEAR-MISS1">explain-near-miss1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-explain-near-miss1" data-sym="EXPLAIN-NEAR-MISS1" title="(defun explain-near-miss1 (target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (let* ((pat-cmd (get-brr-local &#39;brr-cmd-name-for-pattern state))
         (pat-term (get-brr-local &#39;pattern state)))
    (explain-near-miss2 pat-cmd pat-term target-term large-cons-count">explain-near-miss1</a>
  (target-term large-cons-count <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a> state)
  (declare (xargs <span class="keyword">:mode</span> <span class="keyword">:program</span>))
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pat-cmd (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'brr-cmd-name-for-pattern state)) (pat-term (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'pattern state)))
    (<a class="sym-link local-def" href="#def-explain-near-miss2" data-sym="EXPLAIN-NEAR-MISS2" title="(defun explain-near-miss2
       (pat-cmd pat-term target-term large-cons-count evisc-tuple state)
  (declare (xargs :mode :program))
  (mv-let (ans1 alist1 addr alist subtarget)
          (one-way-unify-fr pat-term target-term)
...">explain-near-miss2</a> pat-cmd
      pat-term
      target-term
      large-cons-count
      <a class="sym-link system" href="basis-a.html#def-evisc-tuple" data-sym="EVISC-TUPLE">evisc-tuple</a>
      state)))</pre>
  </div>

<div class="form-block function" id="def-refinement-failure-brkpt1" data-defines="REFINEMENT-FAILURE-BRKPT1" data-references="*BRKPT1-ALIASES*,POP-BRR-STATUS,NON-PRIM,SHOW-GENEQV,REWRITE-RULE,BRR-EVISC-TUPLE,BRR-DEPTH,CW,PROG2$,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,CAR,EVAL-BREAK-CONDITION,OKP,ERP,WORMHOLE-STATUS,GET-BRR-LOCAL,PAIR,PUSH-BRR-STATUS,PPROGN,POT-LIST,BRR-CMD-NAME-FOR-PATTERN,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,ASSOC-EQ,CDR,AND,IF,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,TEMP,LET,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET,T,GSTACKP,QUOTE,F-GET-GLOBAL,NOT,COND,STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,TARGET,LEMMA,DEFUN" data-used-by="REWRITE" data-part-name="REFINEMENT-FAILURE-BRKPT1" data-part-args="STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,TARGET,LEMMA" data-part-body="*BRKPT1-ALIASES*,POP-BRR-STATUS,NON-PRIM,SHOW-GENEQV,REWRITE-RULE,BRR-EVISC-TUPLE,BRR-DEPTH,CW,PROG2$,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,CAR,EVAL-BREAK-CONDITION,OKP,ERP,WORMHOLE-STATUS,GET-BRR-LOCAL,PAIR,PUSH-BRR-STATUS,PPROGN,INITIAL-TTREE,ANCESTORS,POT-LIST,GENEQV,TYPE-ALIST,TARGET,BRR-CMD-NAME-FOR-PATTERN,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,ASSOC-EQ,CDR,AND,IF,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,TEMP,LET,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,RCNST,LEMMA,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET,T,STATE,GSTACKP,QUOTE,F-GET-GLOBAL,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REFINEMENT-FAILURE-BRKPT1">refinement-failure-brkpt1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-refinement-failure-brkpt1" data-sym="REFINEMENT-FAILURE-BRKPT1" title="(defun refinement-failure-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">refinement-failure-brkpt1</a>
  (lemma target
    type-alist
    geneqv
    ancestors
    initial-ttree
    gstack
    rcnst
    simplify-clause-pot-lst
    state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rune brr-cmd-name pattern restrictions)
        (<a class="sym-link local-def" href="#def-get-brr-one-way-unify-info" data-sym="GET-BRR-ONE-WAY-UNIFY-INFO" title="(defun get-brr-one-way-unify-info (lemma rcnst)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (weak-rewrite-constant-p rcnst))))
...">get-brr-one-way-unify-info</a> lemma rcnst)
        (<a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a> '(lambda (whs)
            (<a class="sym-link system" href="basis-a.html#def-set-wormhole-entry-code" data-sym="SET-WORMHOLE-ENTRY-CODE">set-wormhole-entry-code</a> whs
              (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>)
                     (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-monitored-runes</span>))))
                (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:rf</span> (cdr temp))))
                  <span class="keyword">:enter</span> <span class="keyword">:skip</span>))))
          `((brr-gstack . ,GSTACK) (brr-local-alist (rune . ,RUNE)
              (brr-cmd-name-for-pattern . ,BRR-CMD-NAME)
              (pattern . ,PATTERN)
              (restrictions . ,RESTRICTIONS)
              (lemma . ,LEMMA)
              (target . ,TARGET)
              (type-alist . ,TYPE-ALIST)
              (geneqv . ,GENEQV)
              (pot-list . ,SIMPLIFY-CLAUSE-POT-LST)
              (ancestors . ,ANCESTORS)
              (rcnst . ,RCNST)
              (initial-ttree . ,INITIAL-TTREE)))
          '(<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-push-brr-status" data-sym="PUSH-BRR-STATUS" title="(defun push-brr-status (state)
  (let* ((input (f-get-global &#39;wormhole-input state))
         (gstack (cdr (assoc-eq &#39;brr-gstack input)))
         (alist (cdr (assoc-eq &#39;brr-local-alist input)))
         (whs (f-get-global &#39;wormhole-status state))
...">push-brr-status</a> state)
            (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                     (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                     <span class="keyword">:brr-monitored-runes</span>))))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp okp state)
                (<a class="sym-link local-def" href="#def-eval-break-condition" data-sym="EVAL-BREAK-CONDITION" title="(defun eval-break-condition (rune term ctx state)
  (cond ((equal term *t*) (value t))
        ((not (termp term (w state)))
         (er soft ctx
             &quot;The monitored rune ~x0 has a non-trivial break :condition, ~X12, ~
...">eval-break-condition</a> (car pair)
                  (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:condition</span> (cdr pair)))
                  '<a class="sym-link system" href="basis-a.html#def-wormhole" data-sym="WORMHOLE">wormhole</a>
                  state)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> '(<span class="keyword">:a!</span>) state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
                  (okp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> okp) (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> okp state))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state))
                      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%(~F0 Breaking ~F1 on ~X23:~|~%The ~
                                equivalence relation, ~x4, of this rule is ~
                                not a refinement of the current geneqv, ~x5.  ~
                                Use :path or :path+ to see how the geneqv ~
                                evolved.  See :DOC refinement-failure for ~
                                advice about how to deal with this kind of ~
                                problem.~%~%"</span>
                          (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                          (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                          (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
                          (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state)
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:equiv</span>)
                          (<a class="sym-link local-def" href="#def-show-geneqv" data-sym="SHOW-GENEQV" title="(defun show-geneqv (x with-runes-p)
  (cond ((endp x) nil)
        (t
         (cons
          (cond
...">show-geneqv</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'geneqv state) 'non-prim))
                        (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a> state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))))))
          <a class="sym-link local-def" href="#def-_2Abrkpt1-aliases_2A" data-sym="*BRKPT1-ALIASES*" title="(defconst *brkpt1-aliases*
          (flet ((not-yet-evaled-fn ()
                   `(lambda ()
                      (prog2$
                       (cw &quot;~F0 has not yet been :EVALed.~%&quot;
...">*brkpt1-aliases*</a>)))))</pre>
  </div>

<div class="form-block function" id="def-near-miss-brkpt1" data-defines="NEAR-MISS-BRKPT1" data-references="*BRKPT1-ALIASES*,POP-BRR-STATUS,IF,BRR-EVISC-TUPLE,BRR-DEPTH,CW,PROG2$,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,ASSOC-EQ,CAR,EVAL-BREAK-CONDITION,OKP,ERP,WORMHOLE-STATUS,GET-BRR-LOCAL,PUSH-BRR-STATUS,PPROGN,POT-LIST,BRR-CMD-NAME-FOR-PATTERN,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,CDR,BRR-NEAR-MISSP,NULL,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,PAIR,LET,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET,T,GSTACKP,QUOTE,F-GET-GLOBAL,NOT,COND,STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,TARGET,LEMMA,DEFUN" data-used-by="REWRITE" data-part-name="NEAR-MISS-BRKPT1" data-part-args="STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,TARGET,LEMMA" data-part-body="*BRKPT1-ALIASES*,POP-BRR-STATUS,IF,BRR-EVISC-TUPLE,BRR-DEPTH,CW,PROG2$,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,ASSOC-EQ,CAR,EVAL-BREAK-CONDITION,OKP,ERP,WORMHOLE-STATUS,GET-BRR-LOCAL,PUSH-BRR-STATUS,PPROGN,INITIAL-TTREE,ANCESTORS,POT-LIST,GENEQV,TYPE-ALIST,BRR-CMD-NAME-FOR-PATTERN,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,CDR,TARGET,BRR-NEAR-MISSP,NULL,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,PAIR,LET,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,RCNST,LEMMA,GET-BRR-ONE-WAY-UNIFY-INFO,RESTRICTIONS,PATTERN,BRR-CMD-NAME,RUNE,MV-LET,T,STATE,GSTACKP,QUOTE,F-GET-GLOBAL,NOT,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NEAR-MISS-BRKPT1">near-miss-brkpt1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-near-miss-brkpt1" data-sym="NEAR-MISS-BRKPT1" title="(defun near-miss-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">near-miss-brkpt1</a>
  (lemma target
    type-alist
    geneqv
    ancestors
    initial-ttree
    gstack
    rcnst
    simplify-clause-pot-lst
    state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rune brr-cmd-name pattern restrictions)
        (<a class="sym-link local-def" href="#def-get-brr-one-way-unify-info" data-sym="GET-BRR-ONE-WAY-UNIFY-INFO" title="(defun get-brr-one-way-unify-info (lemma rcnst)
  (declare
   (xargs :guard
    (and (or (weak-rewrite-rule-p lemma) (weak-linear-lemma-p lemma))
         (weak-rewrite-constant-p rcnst))))
...">get-brr-one-way-unify-info</a> lemma rcnst)
        (<a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a> '(lambda (whs)
            (<a class="sym-link system" href="basis-a.html#def-set-wormhole-entry-code" data-sym="SET-WORMHOLE-ENTRY-CODE">set-wormhole-entry-code</a> whs
              (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>)
                     (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-monitored-runes</span>))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pair) <span class="keyword">:skip</span>)
                  ((brr-near-missp nil lemma target rcnst (cdr pair)) <span class="keyword">:enter</span>)
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:skip</span>)))))
          `((brr-gstack . ,GSTACK) (brr-local-alist (rune . ,RUNE)
              (brr-cmd-name-for-pattern . ,BRR-CMD-NAME)
              (pattern . ,PATTERN)
              (restrictions . ,RESTRICTIONS)
              (lemma . ,LEMMA)
              (target . ,TARGET)
              (type-alist . ,TYPE-ALIST)
              (geneqv . ,GENEQV)
              (pot-list . ,SIMPLIFY-CLAUSE-POT-LST)
              (ancestors . ,ANCESTORS)
              (rcnst . ,RCNST)
              (initial-ttree . ,INITIAL-TTREE)))
          '(<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-push-brr-status" data-sym="PUSH-BRR-STATUS" title="(defun push-brr-status (state)
  (let* ((input (f-get-global &#39;wormhole-input state))
         (gstack (cdr (assoc-eq &#39;brr-gstack input)))
         (alist (cdr (assoc-eq &#39;brr-local-alist input)))
         (whs (f-get-global &#39;wormhole-status state))
...">push-brr-status</a> state)
            (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                     (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                     <span class="keyword">:brr-monitored-runes</span>))))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp okp state)
                (<a class="sym-link local-def" href="#def-eval-break-condition" data-sym="EVAL-BREAK-CONDITION" title="(defun eval-break-condition (rune term ctx state)
  (cond ((equal term *t*) (value t))
        ((not (termp term (w state)))
         (er soft ctx
             &quot;The monitored rune ~x0 has a non-trivial break :condition, ~X12, ~
...">eval-break-condition</a> (car pair)
                  (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:condition</span> (cdr pair)))
                  '<a class="sym-link system" href="basis-a.html#def-wormhole" data-sym="WORMHOLE">wormhole</a>
                  state)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> '(<span class="keyword">:a!</span>) state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
                  (okp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> okp) (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> okp state))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state))
                      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%(~F0 Breaking ~F1 on ~X23:~|~%The pattern in ~
                             this rule failed to match the target~#4~[~/ ~
                             under the restrictions ~x5~].  ~@6"</span>
                          (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                          (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                          (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
                          (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state)
                          (if (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'restrictions state)
                            <span class="number">1</span>
                            <span class="number">0</span>)
                          (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'restrictions state)
                          (brr-near-missp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state)
                            (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
                            (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'restrictions state)
                            (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'rune state)
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                                  (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                                  <span class="keyword">:brr-monitored-runes</span>)))))
                        (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a> state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))))))
          <a class="sym-link local-def" href="#def-_2Abrkpt1-aliases_2A" data-sym="*BRKPT1-ALIASES*" title="(defconst *brkpt1-aliases*
          (flet ((not-yet-evaled-fn ()
                   `(lambda ()
                      (prog2$
                       (cw &quot;~F0 has not yet been :EVALed.~%&quot;
...">*brkpt1-aliases*</a>)))))</pre>
  </div>

<div class="form-block function" id="def-brkpt1" data-defines="BRKPT1" data-references="*BRKPT1-ALIASES*,POP-BRR-STATUS,BRR-EVISC-TUPLE,BRR-DEPTH,CW,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,ASSOC-EQ,CDR,CAR,EVAL-BREAK-CONDITION,OKP,ERP,MV-LET,WORMHOLE-STATUS,GET-BRR-LOCAL,PAIR,PUSH-BRR-STATUS,PPROGN,POT-LIST,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,IF,SET-WORMHOLE-ENTRY-CODE,BRR-WORMHOLE,LIST,WORMHOLE-DATA,UPDATE-BRR-DATA-1,SET-WORMHOLE-DATA-FAST,WHS,LAMBDA,BRR-DATA,WORMHOLE-EVAL,BRKPT1-BRR-DATA-ENTRY,EQ,AND,PROG2$,NOT,QUOTE,F-GET-GLOBAL,GSTACKP,LET,T,COND,STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA,DEFUN" data-used-by="REWRITE" data-part-name="BRKPT1" data-part-args="STATE,SIMPLIFY-CLAUSE-POT-LST,RCNST,GSTACK,INITIAL-TTREE,ANCESTORS,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA" data-part-body="*BRKPT1-ALIASES*,POP-BRR-STATUS,BRR-EVISC-TUPLE,BRR-DEPTH,CW,TRUE-LISTP,VALUE,STUFF-STANDARD-OI,WORMHOLE,ASSOC-EQ,CDR,CAR,EVAL-BREAK-CONDITION,OKP,ERP,MV-LET,WORMHOLE-STATUS,GET-BRR-LOCAL,PAIR,PUSH-BRR-STATUS,PPROGN,POT-LIST,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,BRR-STATUS,ACCESS,GET-RULE-FIELD,ASSOC-EQUAL,IF,SET-WORMHOLE-ENTRY-CODE,BRR-WORMHOLE,LIST,WORMHOLE-DATA,SIMPLIFY-CLAUSE-POT-LST,INITIAL-TTREE,GENEQV,TYPE-ALIST,UNIFY-SUBST,TARGET,LEMMA,UPDATE-BRR-DATA-1,SET-WORMHOLE-DATA-FAST,WHS,LAMBDA,BRR-DATA,WORMHOLE-EVAL,RCNST,GSTACK,ANCESTORS,BRKPT1-BRR-DATA-ENTRY,EQ,AND,PROG2$,NOT,STATE,QUOTE,F-GET-GLOBAL,GSTACKP,LET,T,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRKPT1">brkpt1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brkpt1" data-sym="BRKPT1" title="(defun brkpt1
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst simplify-clause-pot-lst state)
  (cond
   (t
...">brkpt1</a>
  (lemma target
    unify-subst
    type-alist
    geneqv
    ancestors
    initial-ttree
    gstack
    rcnst
    simplify-clause-pot-lst
    state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((gstackp (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> gstackp) nil)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> gstackp <span class="keyword">:brr-data</span>)
                (brkpt1-brr-data-entry ancestors gstack rcnst state)
                (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> 'brr-data
                  '(lambda (whs)
                    (<a class="sym-link local-def" href="#def-set-wormhole-data-fast" data-sym="SET-WORMHOLE-DATA-FAST" title="(defun set-wormhole-data-fast (whs data)
  (declare (xargs :guard t))
  (if (consp whs)
      (cons (car whs) data)
      (cons :enter data)))">set-wormhole-data-fast</a> whs
                      (update-brr-data-1 lemma
                        target
                        unify-subst
                        type-alist
                        geneqv
                        ancestors
                        initial-ttree
                        gstack
                        rcnst
                        simplify-clause-pot-lst
                        (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs))))
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:no-wormhole-lock</span> lemma
                    target
                    unify-subst
                    type-alist
                    geneqv
                    simplify-clause-pot-lst
                    ancestors
                    rcnst
                    initial-ttree
                    gstack)))
              (<a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a> '(lambda (whs)
                  (<a class="sym-link system" href="basis-a.html#def-set-wormhole-entry-code" data-sym="SET-WORMHOLE-ENTRY-CODE">set-wormhole-entry-code</a> whs
                    (if (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> lemma <span class="keyword">:rune</span>)
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-monitored-runes</span>))
                      <span class="keyword">:enter</span> <span class="keyword">:skip</span>)))
                `((brr-gstack . ,GSTACK) (brr-local-alist (lemma . ,LEMMA)
                    (target . ,TARGET)
                    (unify-subst . ,UNIFY-SUBST)
                    (type-alist . ,TYPE-ALIST)
                    (geneqv . ,GENEQV)
                    (pot-list . ,SIMPLIFY-CLAUSE-POT-LST)
                    (ancestors . ,ANCESTORS)
                    (rcnst . ,RCNST)
                    (initial-ttree . ,INITIAL-TTREE)))
                '(<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-push-brr-status" data-sym="PUSH-BRR-STATUS" title="(defun push-brr-status (state)
  (let* ((input (f-get-global &#39;wormhole-input state))
         (gstack (cdr (assoc-eq &#39;brr-gstack input)))
         (alist (cdr (assoc-eq &#39;brr-local-alist input)))
         (whs (f-get-global &#39;wormhole-status state))
...">push-brr-status</a> state)
                  (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status
                           (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-status state)
                           <span class="keyword">:brr-monitored-runes</span>))))
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp okp state)
                      (<a class="sym-link local-def" href="#def-eval-break-condition" data-sym="EVAL-BREAK-CONDITION" title="(defun eval-break-condition (rune term ctx state)
  (cond ((equal term *t*) (value t))
        ((not (termp term (w state)))
         (er soft ctx
             &quot;The monitored rune ~x0 has a non-trivial break :condition, ~X12, ~
...">eval-break-condition</a> (car pair)
                        (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <span class="keyword">:condition</span> (cdr pair)))
                        '<a class="sym-link system" href="basis-a.html#def-wormhole" data-sym="WORMHOLE">wormhole</a>
                        state)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> '(<span class="keyword">:a!</span>) state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
                        (okp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> okp) (<a class="sym-link local-def" href="#def-stuff-standard-oi" data-sym="STUFF-STANDARD-OI" title="(defun stuff-standard-oi (cmds state)
  (declare (xargs :guard (true-listp cmds)))
  (cond ((null cmds) state)
        (t
         (pprogn (f-put-global &#39;ld-pre-eval-print t state)
...">stuff-standard-oi</a> okp state))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state))
                            (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%(~F0 Breaking ~F1 on ~X23:~|"</span>
                                (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                                (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                                (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'target state)
                                (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state))
                              (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a> state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))))))
                <a class="sym-link local-def" href="#def-_2Abrkpt1-aliases_2A" data-sym="*BRKPT1-ALIASES*" title="(defconst *brkpt1-aliases*
          (flet ((not-yet-evaled-fn ()
                   `(lambda ()
                      (prog2$
                       (cw &quot;~F0 has not yet been :EVALed.~%&quot;
...">*brkpt1-aliases*</a>))))))))</pre>
  </div>

<div class="form-block function" id="def-brkpt2" data-defines="BRKPT2" data-references="LIST,WORMHOLE-DATA,UPDATE-BRR-DATA-2,SET-WORMHOLE-DATA-FAST,BRR-DATA,WORMHOLE-EVAL,BRKPT2-BRR-DATA-ENTRY,REFINEMENT-FAILURE,NEAR-MISS,AND,*BRKPT2-ALIASES*,SET-LD-PRE-EVAL-PRINT,STANDARD-OI,CONSP,SAVED-STANDARD-OI,SET-STANDARD-OI,ER-PROGN,FREE-VARS-DISPLAY-LIMIT,TILDE-@-FAILURE-REASON-PHRASE,BRR-EVISC-TUPLE,LEMMA,GET-RULE-FIELD,WORMHOLE-INPUT,ASSOC-EQ,CDR,PUT-BRR-LOCALS,PRINT,VALUE,POP-BRR-STATUS,PPROGN,BRR-DEPTH,CW,SILENT,ACTION,GET-BRR-LOCAL,EQ,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,BRR-STATUS,ACCESS,EQUAL,IF,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,PROG2$,NOT,QUOTE,F-GET-GLOBAL,GSTACKP,LET,T,COND,STATE,ANCESTORS,RCNST,FINAL-TTREE,BRR-RESULT,GSTACK,UNIFY-SUBST,FAILURE-REASON,WONP,DEFUN" data-used-by="REWRITE" data-part-name="BRKPT2" data-part-args="STATE,ANCESTORS,RCNST,FINAL-TTREE,BRR-RESULT,GSTACK,UNIFY-SUBST,FAILURE-REASON,WONP" data-part-body="LIST,WORMHOLE-DATA,UPDATE-BRR-DATA-2,SET-WORMHOLE-DATA-FAST,BRR-DATA,WORMHOLE-EVAL,ANCESTORS,BRKPT2-BRR-DATA-ENTRY,REFINEMENT-FAILURE,NEAR-MISS,AND,*BRKPT2-ALIASES*,SET-LD-PRE-EVAL-PRINT,STANDARD-OI,CONSP,SAVED-STANDARD-OI,SET-STANDARD-OI,ER-PROGN,FREE-VARS-DISPLAY-LIMIT,TILDE-@-FAILURE-REASON-PHRASE,BRR-EVISC-TUPLE,LEMMA,GET-RULE-FIELD,WORMHOLE-INPUT,ASSOC-EQ,CDR,PUT-BRR-LOCALS,PRINT,VALUE,POP-BRR-STATUS,PPROGN,BRR-DEPTH,CW,SILENT,ACTION,GET-BRR-LOCAL,EQ,FINAL-TTREE,RCNST,BRR-RESULT,UNIFY-SUBST,FAILURE-REASON,WONP,BRR-LOCAL-ALIST,BRR-GSTACK,QUASIQUOTE,BRR-STATUS,ACCESS,GSTACK,EQUAL,IF,SET-WORMHOLE-ENTRY-CODE,WHS,LAMBDA,BRR-WORMHOLE,PROG2$,NOT,STATE,QUOTE,F-GET-GLOBAL,GSTACKP,LET,T,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRKPT2">brkpt2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a>
  (wonp failure-reason
    unify-subst
    gstack
    <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
    final-ttree
    rcnst
    ancestors
    state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((gstackp (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> gstackp) nil)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brr-wormhole" data-sym="BRR-WORMHOLE" title="(defmacro brr-wormhole (entry-lambda input-alist test-form aliases)
  (let ((aliases
         `(append ,aliases
                  &#39;((:exit 0
                     (lambda ()
...">brr-wormhole</a> '(lambda (whs)
                  (<a class="sym-link system" href="basis-a.html#def-set-wormhole-entry-code" data-sym="SET-WORMHOLE-ENTRY-CODE">set-wormhole-entry-code</a> whs
                    (if (equal gstack (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-status whs <span class="keyword">:brr-gstack</span>))
                      <span class="keyword">:enter</span> <span class="keyword">:skip</span>)))
                `((brr-gstack . ,GSTACK) (brr-local-alist (wonp . ,WONP)
                    (failure-reason . ,FAILURE-REASON)
                    (unify-subst . ,UNIFY-SUBST)
                    (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> . ,BRR-RESULT)
                    (rcnst . ,RCNST)
                    (final-ttree . ,FINAL-TTREE)))
                '(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'action state) 'silent) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~F0)~%"</span> (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state))
                      (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a> state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil))))
                  ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'action state) 'print) (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-put-brr-locals" data-sym="PUT-BRR-LOCALS" title="(defun put-brr-locals (alist state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist1 (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-locals</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'brr-local-alist
                            (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-input state)))
                        state)
                      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state)
                          (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~F0 ~F1 produced ~X23.~|~F0)~%"</span>
                            (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                            (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                            (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> state)
                            (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state))
                          (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~F0x ~F1 failed because ~@2~|~F0)~%"</span>
                            (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                            (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                            (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase" data-sym="TILDE-@-FAILURE-REASON-PHRASE" title="(defun tilde-@-failure-reason-phrase
       (failure-reason level unify-subst evisc-tuple free-vars-display-limit
        state)
  (tilde-@-failure-reason-phrase1 (fix-free-failure-reason failure-reason)
                                  level unify-subst evisc-tuple">tilde-@-failure-reason-phrase</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'failure-reason state)
                              <span class="number">1</span>
                              (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'unify-subst state)
                              (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state)
                              (<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> state)
                              state)))
                        (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-pop-brr-status" data-sym="POP-BRR-STATUS" title="(defun pop-brr-status (state)
  (let* ((whs (f-get-global &#39;wormhole-status state))
         (prev-whs (access brr-status whs :brr-previous-status)))
    (if (null prev-whs)
        state">pop-brr-status</a> state) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-put-brr-locals" data-sym="PUT-BRR-LOCALS" title="(defun put-brr-locals (alist state)
  (if (eq (f-get-global &#39;wormhole-name state) &#39;brr)
      (let* ((whs (f-get-global &#39;wormhole-status state))
             (alist1 (access brr-status whs :brr-local-alist))
             (new-whs
...">put-brr-locals</a> (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> 'brr-local-alist
                            (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'wormhole-input state)))
                        state)
                      (<a class="sym-link system" href="axioms.html#def-er-progn" data-sym="ER-PROGN">er-progn</a> (<a class="sym-link system" href="basis-b.html#def-set-standard-oi" data-sym="SET-STANDARD-OI">set-standard-oi</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'saved-standard-oi state)
                          state)
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((consp (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> '<a class="sym-link system" href="basis-b.html#def-standard-oi" data-sym="STANDARD-OI">standard-oi</a> state)) (<a class="sym-link system" href="basis-b.html#def-set-ld-pre-eval-print" data-sym="SET-LD-PRE-EVAL-PRINT">set-ld-pre-eval-print</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))
                        (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (if (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'wonp state)
                            (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~F0! ~F1 produced ~X23.~|~%"</span>
                              (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                              (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                              (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> state)
                              (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state))
                            (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"~%~F0x ~F1 failed because ~@2~|~%"</span>
                              (<a class="sym-link local-def" href="#def-brr-depth" data-sym="BRR-DEPTH" title="(defun brr-depth (state) (brr-depth1 (f-get-global &#39;wormhole-status state)))">brr-depth</a> state)
                              (<a class="sym-link local-def" href="#def-get-rule-field" data-sym="GET-RULE-FIELD" title="(defmacro get-rule-field (x field)
  (declare
   (xargs :guard
    (let ((fields (quote (:rune :hyps :lhs :rhs :max-term))))
      (and (not (member-eq x fields)) (member-eq field fields)))))
...">get-rule-field</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'lemma state) <span class="keyword">:rune</span>)
                              (<a class="sym-link local-def" href="#def-tilde-_40-failure-reason-phrase" data-sym="TILDE-@-FAILURE-REASON-PHRASE" title="(defun tilde-@-failure-reason-phrase
       (failure-reason level unify-subst evisc-tuple free-vars-display-limit
        state)
  (tilde-@-failure-reason-phrase1 (fix-free-failure-reason failure-reason)
                                  level unify-subst evisc-tuple">tilde-@-failure-reason-phrase</a> (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'failure-reason state)
                                <span class="number">1</span>
                                (<a class="sym-link local-def" href="#def-get-brr-local" data-sym="GET-BRR-LOCAL" title="(defun get-brr-local (var state)
  (let ((whs (f-get-global &#39;wormhole-status state)))
    (cdr (assoc-eq var (access brr-status whs :brr-local-alist)))))">get-brr-local</a> 'unify-subst state)
                                (<a class="sym-link system" href="basis-a.html#def-brr-evisc-tuple" data-sym="BRR-EVISC-TUPLE">brr-evisc-tuple</a> state)
                                (<a class="sym-link local-def" href="#def-free-vars-display-limit" data-sym="FREE-VARS-DISPLAY-LIMIT" title="(defun free-vars-display-limit (state)
  (if (f-boundp-global &#39;free-vars-display-limit state)
      (let ((val (f-get-global &#39;free-vars-display-limit state)))
        (if (or (natp val) (null val))
            val
...">free-vars-display-limit</a> state)
                                state)))
                          (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))))
                <a class="sym-link local-def" href="#def-_2Abrkpt2-aliases_2A" data-sym="*BRKPT2-ALIASES*" title="(defconst *brkpt2-aliases*
          (flet ((already-evaled-fn ()
                   &#39;(lambda ()
                      (prog2$
                       (cw &quot;You already have run some flavor ~
...">*brkpt2-aliases*</a>)
              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'near-miss))
                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> failure-reason 'refinement-failure))
                (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> gstackp <span class="keyword">:brr-data</span>)
                (brkpt2-brr-data-entry ancestors gstack rcnst state)
                (<a class="sym-link system" href="basis-a.html#def-wormhole-eval" data-sym="WORMHOLE-EVAL">wormhole-eval</a> 'brr-data
                  '(lambda (whs)
                    (<a class="sym-link local-def" href="#def-set-wormhole-data-fast" data-sym="SET-WORMHOLE-DATA-FAST" title="(defun set-wormhole-data-fast (whs data)
  (declare (xargs :guard t))
  (if (consp whs)
      (cons (car whs) data)
      (cons :enter data)))">set-wormhole-data-fast</a> whs
                      (update-brr-data-2 wonp
                        failure-reason
                        unify-subst
                        gstack
                        <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                        final-ttree
                        rcnst
                        ancestors
                        (<a class="sym-link system" href="basis-a.html#def-wormhole-data" data-sym="WORMHOLE-DATA">wormhole-data</a> whs))))
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:no-wormhole-lock</span> wonp
                    failure-reason
                    unify-subst
                    gstack
                    <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                    final-ttree
                    rcnst))))))))))</pre>
  </div>

<div class="form-block function" id="def-show-brr-data-1" data-defines="SHOW-BRR-DATA-1" data-references="CAR,ACCESS-X-RULE-RUNE,CONSP,AND,LEMMA,LET,DECODE-TYPE-ALIST,ALIST-TO-DOUBLETS,BRR-DATA-1,ACCESS,LIST,WEAK-BRR-DATA-1-P,XARGS,DECLARE,X,DEFUN" data-used-by="SHOW-BRR-DATA" data-part-name="SHOW-BRR-DATA-1" data-part-args="X" data-part-declare="X,WEAK-BRR-DATA-1-P,XARGS,DECLARE" data-part-body="CAR,ACCESS-X-RULE-RUNE,CONSP,AND,LEMMA,LET,DECODE-TYPE-ALIST,ALIST-TO-DOUBLETS,X,BRR-DATA-1,ACCESS,LIST" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-BRR-DATA-1">show-brr-data-1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-brr-data-1" data-sym="SHOW-BRR-DATA-1" title="(defun show-brr-data-1 (x)
  (declare (xargs :guard (weak-brr-data-1-p x)))
  (list :target (access brr-data-1 x :target) :unify-subst
        (alist-to-doublets (access brr-data-1 x :unify-subst)) :type-alist
        (alist-to-doublets
...">show-brr-data-1</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (weak-brr-data-1-p x)))
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:target</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 x <span class="keyword">:target</span>)
    <span class="keyword">:unify-subst</span> (alist-to-doublets (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 x <span class="keyword">:unify-subst</span>))
    <span class="keyword">:type-alist</span> (alist-to-doublets (<a class="sym-link local-def" href="#def-decode-type-alist" data-sym="DECODE-TYPE-ALIST" title="(defun decode-type-alist (type-alist)
  (cond ((null type-alist) nil)
        (t
         (cons (cons (caar type-alist) (decode-type-set (cadar type-alist)))
               (decode-type-alist (cdr type-alist))))))">decode-type-alist</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 x <span class="keyword">:type-alist</span>)))
    <span class="keyword">:lemma</span> (let ((lemma (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 x <span class="keyword">:lemma</span>)))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp lemma) (<a class="sym-link local-def" href="#def-access-x-rule-rune" data-sym="ACCESS-X-RULE-RUNE" title="(defun access-x-rule-rune (x rule)
  (case x
    (recognizer-tuple (access recognizer-tuple rule :rune))
    (type-prescription (access type-prescription rule :rune))
    (congruence-rule (access congruence-rule rule :rune))
...">access-x-rule-rune</a> (car lemma) lemma)))
    <span class="keyword">:gstack</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 x <span class="keyword">:gstack</span>)))</pre>
  </div>

<div class="form-block function" id="def-show-brr-data-2" data-defines="SHOW-BRR-DATA-2" data-references="LIST,AND,FAILURE-REASON,LET,BRR-DATA-2,ACCESS,LIST*,WEAK-BRR-DATA-2-P,XARGS,DECLARE,X,DEFUN" data-used-by="SHOW-BRR-DATA" data-part-name="SHOW-BRR-DATA-2" data-part-args="X" data-part-declare="X,WEAK-BRR-DATA-2-P,XARGS,DECLARE" data-part-body="LIST,AND,FAILURE-REASON,LET,X,BRR-DATA-2,ACCESS,LIST*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-BRR-DATA-2">show-brr-data-2</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-brr-data-2" data-sym="SHOW-BRR-DATA-2" title="(defun show-brr-data-2 (x)
  (declare (xargs :guard (weak-brr-data-2-p x)))
  (list* :brr-result (access brr-data-2 x :brr-result)
         (let ((failure-reason (access brr-data-2 x :failure-reason)))
           (and failure-reason (list :failure-reason failure-reason)))))">show-brr-data-2</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (weak-brr-data-2-p x)))
  (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:brr-result</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 x <span class="keyword">:brr-result</span>)
    (let ((failure-reason (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 x <span class="keyword">:failure-reason</span>)))
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> failure-reason (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:failure-reason</span> failure-reason)))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-show-brr-data" data-defines="SHOW-BRR-DATA" data-references="CDR,CAR,CONS,ENDP,COND,BRR-DATA-LISTP,SHOW-BRR-DATA-LST,LIST,SHOW-BRR-DATA-2,BRR-DATA,ACCESS,SHOW-BRR-DATA-1,APPEND,MBT,AND,T,BRR-DATA-P,XARGS,DECLARE,X,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SHOW-BRR-DATA">show-brr-data</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-show-brr-data" data-sym="SHOW-BRR-DATA" title="(mutual-recursion
 (defun show-brr-data (x)
   (declare (xargs :guard (brr-data-p t x)))
   (and (mbt (brr-data-p t x))
        (append (show-brr-data-1 (access brr-data x :pre))
...">show-brr-data</a>
    (x)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link local-def" href="#def-brr-data-p" data-sym="BRR-DATA-P" title="(mutual-recursion
 (defun brr-data-p (completed-p x)
   (declare (xargs :guard t :measure (acl2-count x)))
   (and (weak-brr-data-p x) (weak-brr-data-1-p (access brr-data x :pre))
        (if completed-p
...">brr-data-p</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x)))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-mbt" data-sym="MBT">mbt</a> (<a class="sym-link local-def" href="#def-brr-data-p" data-sym="BRR-DATA-P" title="(mutual-recursion
 (defun brr-data-p (completed-p x)
   (declare (xargs :guard t :measure (acl2-count x)))
   (and (weak-brr-data-p x) (weak-brr-data-1-p (access brr-data x :pre))
        (if completed-p
...">brr-data-p</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x))
      (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link local-def" href="#def-show-brr-data-1" data-sym="SHOW-BRR-DATA-1" title="(defun show-brr-data-1 (x)
  (declare (xargs :guard (weak-brr-data-1-p x)))
  (list :target (access brr-data-1 x :target) :unify-subst
        (alist-to-doublets (access brr-data-1 x :unify-subst)) :type-alist
        (alist-to-doublets
...">show-brr-data-1</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:pre</span>))
        (<a class="sym-link local-def" href="#def-show-brr-data-2" data-sym="SHOW-BRR-DATA-2" title="(defun show-brr-data-2 (x)
  (declare (xargs :guard (weak-brr-data-2-p x)))
  (list* :brr-result (access brr-data-2 x :brr-result)
         (let ((failure-reason (access brr-data-2 x :failure-reason)))
           (and failure-reason (list :failure-reason failure-reason)))))">show-brr-data-2</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:post</span>))
        (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:completed</span> (show-brr-data-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data x <span class="keyword">:completed</span>))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> show-brr-data-lst
    (x)
    (declare (xargs <span class="keyword">:guard</span> (brr-data-listp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link local-def" href="#def-show-brr-data" data-sym="SHOW-BRR-DATA" title="(mutual-recursion
 (defun show-brr-data (x)
   (declare (xargs :guard (brr-data-p t x)))
   (and (mbt (brr-data-p t x))
        (append (show-brr-data-1 (access brr-data x :pre))
...">show-brr-data</a> (car x)) (show-brr-data-lst (cdr x)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-brr-data-2-for-term-1" data-defines="BRR-DATA-2-FOR-TERM-1" data-references="CDR,CAR,T,ENDP,COND,BRR-DATA-LST,EQUAL,DUMB-OCCUR,IF,AND,BRR-DATA-2,BRR-RESULT,POST,LET*,ACCESS,BRR-DATA-2-FOR-TERM,OR,BRR-DATA,TERM,SUBTERM-P,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DATA-2-FOR-TERM-1">brr-data-2-for-term-1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-data-2-for-term-1" data-sym="BRR-DATA-2-FOR-TERM-1" title="(mutual-recursion
 (defun brr-data-2-for-term-1 (subterm-p term brr-data)
   (or
    (brr-data-2-for-term subterm-p term (access brr-data brr-data :completed))
    (let* ((post (access brr-data brr-data :post))
...">brr-data-2-for-term-1</a>
    (subterm-p term brr-data)
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (brr-data-2-for-term subterm-p
        term
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:completed</span>))
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((post (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:post</span>)) (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 post <span class="keyword">:brr-result</span>)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (if subterm-p
            (dumb-occur term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>)
            (equal term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>))
          post))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> brr-data-2-for-term
    (subterm-p term <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-brr-data-2-for-term-1" data-sym="BRR-DATA-2-FOR-TERM-1" title="(mutual-recursion
 (defun brr-data-2-for-term-1 (subterm-p term brr-data)
   (or
    (brr-data-2-for-term subterm-p term (access brr-data brr-data :completed))
    (let* ((post (access brr-data brr-data :post))
...">brr-data-2-for-term-1</a> subterm-p term (car <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))
          (brr-data-2-for-term subterm-p term (cdr <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-matching-subterm" data-defines="MATCHING-SUBTERM" data-references="CDR,CAR,ENDP,LST,FARGS,MATCHING-SUBTERM-LST,T,FQUOTEP,VARIABLEP,OR,DUMB-OCCUR,NOT,AND,COND,IGNORE,DECLARE,ONE-WAY-UNIFY1,ALIST2,FLG,MV-LET,TARGET,ALIST,TERM,PAT,DEFUN,MUTUAL-RECURSION" data-used-by="CW-GSTACK-FOR-TERM-FN1-1" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MATCHING-SUBTERM">matching-subterm</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-matching-subterm" data-sym="MATCHING-SUBTERM" title="(mutual-recursion
 (defun matching-subterm (pat term alist target)
   (mv-let (flg alist2) (one-way-unify1 pat term alist)
           (declare (ignore alist2))
           (cond ((and flg (not (dumb-occur term target))) term)
...">matching-subterm</a>
    (pat term alist target)
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist2)
      (one-way-unify1 pat term alist)
      (declare (ignore alist2))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (dumb-occur term target))) term)
        ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)) nil)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (matching-subterm-lst pat (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) alist target)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> matching-subterm-lst
    (pat lst alist target)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-matching-subterm" data-sym="MATCHING-SUBTERM" title="(mutual-recursion
 (defun matching-subterm (pat term alist target)
   (mv-let (flg alist2) (one-way-unify1 pat term alist)
           (declare (ignore alist2))
           (cond ((and flg (not (dumb-occur term target))) term)
...">matching-subterm</a> pat (car lst) alist target)
          (matching-subterm-lst pat (cdr lst) alist target))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-cw-gstack-for-term-fn1-1" data-defines="CW-GSTACK-FOR-TERM-FN1-1" data-references="CDR,APPEND,CAR,REST,EARLIER-D-2,ENDP,BRR-DATA-LST,CW-GSTACK-FOR-TERM-FN1,MV,NULL,BRR-DATA-2-FOR-TERM,D-2,LET,IGNORE,DECLARE,ONE-WAY-UNIFY1,ALIST2,FLG,MV-LET,T,MATCHING-SUBTERM,EQUAL,IF,DUMB-OCCUR,NOT,AND,EQ,COND,SUBTERM,BRR-DATA-2,BRR-RESULT,POST,BRR-DATA-1,TARGET,ACCESS,PRE,LET*,ALIST,BRR-DATA,TERM,SUBTERM-P,DEFUN,MUTUAL-RECURSION" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-TERM-FN1-1">cw-gstack-for-term-fn1-1</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gstack-for-term-fn1-1" data-sym="CW-GSTACK-FOR-TERM-FN1-1" title="(mutual-recursion
 (defun cw-gstack-for-term-fn1-1 (subterm-p term brr-data alist)
   (let* ((pre (access brr-data brr-data :pre))
          (target (access brr-data-1 pre :target))
          (post (access brr-data brr-data :post))
...">cw-gstack-for-term-fn1-1</a>
    (subterm-p term brr-data alist)
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((pre (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:pre</span>)) (target (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-1 pre <span class="keyword">:target</span>))
        (post (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:post</span>))
        (<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 post <span class="keyword">:brr-result</span>))
        (subterm (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> alist <span class="keyword">:none</span>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (dumb-occur term target))
                (if subterm-p
                  (dumb-occur term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>)
                  (equal term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>))
                term))
            (subterm-p (<a class="sym-link local-def" href="#def-matching-subterm" data-sym="MATCHING-SUBTERM" title="(mutual-recursion
 (defun matching-subterm (pat term alist target)
   (mv-let (flg alist2) (one-way-unify1 pat term alist)
           (declare (ignore alist2))
           (cond ((and flg (not (dumb-occur term target))) term)
...">matching-subterm</a> term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> alist target))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist2)
                (one-way-unify1 term <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> alist)
                (declare (ignore alist2))
                (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (dumb-occur <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> target)) <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>))))))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (subterm (let ((d-2 (brr-data-2-for-term subterm-p
                 subterm
                 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:completed</span>))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> d-2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil post nil)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> post d-2 nil)))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cw-gstack-for-term-fn1 subterm-p
            term
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data brr-data <span class="keyword">:completed</span>)
            alist)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> cw-gstack-for-term-fn1
    (subterm-p term <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a> alist)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (earlier-d-2 d-2 <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
          (<a class="sym-link local-def" href="#def-cw-gstack-for-term-fn1-1" data-sym="CW-GSTACK-FOR-TERM-FN1-1" title="(mutual-recursion
 (defun cw-gstack-for-term-fn1-1 (subterm-p term brr-data alist)
   (let* ((pre (access brr-data brr-data :pre))
          (target (access brr-data-1 pre :target))
          (post (access brr-data brr-data :post))
...">cw-gstack-for-term-fn1-1</a> subterm-p
            term
            (car <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>)
            alist)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (d-2 (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> earlier-d-2 d-2 (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a> (cdr <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cw-gstack-for-term-fn1 subterm-p
                term
                (cdr <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>)
                alist))))))))</pre>
  </div>

<div class="form-block function" id="def-symbol-name-lst" data-defines="SYMBOL-NAME-LST" data-references="CDR,CAR,SYMBOL-NAME,CONS,T,ENDP,COND,SYMBOL-LISTP,XARGS,DECLARE,LST,DEFUN" data-used-by="ACL2-QUERY1" data-part-name="SYMBOL-NAME-LST" data-part-args="LST" data-part-declare="LST,SYMBOL-LISTP,XARGS,DECLARE" data-part-body="CDR,SYMBOL-NAME-LST,CAR,SYMBOL-NAME,CONS,T,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SYMBOL-NAME-LST">symbol-name-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-symbol-name-lst" data-sym="SYMBOL-NAME-LST" title="(defun symbol-name-lst (lst)
  (declare (xargs :guard (symbol-listp lst)))
  (cond ((endp lst) nil)
        (t (cons (symbol-name (car lst)) (symbol-name-lst (cdr lst))))))">symbol-name-lst</a>
  (lst)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> lst)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (symbol-name (car lst)) (<a class="sym-link local-def" href="#def-symbol-name-lst" data-sym="SYMBOL-NAME-LST" title="(defun symbol-name-lst (lst)
  (declare (xargs :guard (symbol-listp lst)))
  (cond ((endp lst) nil)
        (t (cons (symbol-name (car lst)) (symbol-name-lst (cdr lst))))))">symbol-name-lst</a> (cdr lst))))))</pre>
  </div>

<div class="form-block function" id="def-acl2-query-simulate-interaction" data-defines="ACL2-QUERY-SIMULATE-INTERACTION" data-references="T,NEWLINE,PRINC$,LD-EVISC-TUPLE,FMS,PPROGN,*STANDARD-CO*,STANDARD-CO,EQ,WINDOW-INTERFACEP,QUOTE,F-GET-GLOBAL,NOT,OR,ATOM,AND,COND,STATE,ANS,CONTROLLEDP,ALIST,MSG,DEFUN" data-used-by="ACL2-QUERY1" data-part-name="ACL2-QUERY-SIMULATE-INTERACTION" data-part-args="STATE,ANS,CONTROLLEDP,ALIST,MSG" data-part-body="T,NEWLINE,PRINC$,LD-EVISC-TUPLE,ALIST,MSG,FMS,PPROGN,*STANDARD-CO*,STANDARD-CO,EQ,STATE,WINDOW-INTERFACEP,QUOTE,F-GET-GLOBAL,NOT,CONTROLLEDP,OR,ANS,ATOM,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACL2-QUERY-SIMULATE-INTERACTION">acl2-query-simulate-interaction</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-acl2-query-simulate-interaction" data-sym="ACL2-QUERY-SIMULATE-INTERACTION" title="(defun acl2-query-simulate-interaction (msg alist controlledp ans state)
  (cond
   ((and (atom ans)
         (or controlledp
             (and (not (f-get-global &#39;window-interfacep state))
...">acl2-query-simulate-interaction</a>
  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> alist controlledp ans state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> ans)
       (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> controlledp
         (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'window-interfacep state))
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-standard-co" data-sym="STANDARD-CO">standard-co</a> state) <a class="sym-link system" href="axioms.html#def-_2Astandard-co_2A" data-sym="*STANDARD-CO*">*standard-co*</a>))))) (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="basis-a.html#def-fms" data-sym="FMS">fms</a> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>
          alist
          (<a class="sym-link system" href="basis-a.html#def-standard-co" data-sym="STANDARD-CO">standard-co</a> state)
          state
          (<a class="sym-link system" href="basis-a.html#def-ld-evisc-tuple" data-sym="LD-EVISC-TUPLE">ld-evisc-tuple</a> state))
        (<a class="sym-link system" href="axioms.html#def-princ_24" data-sym="PRINC$">princ$</a> ans (<a class="sym-link system" href="basis-a.html#def-standard-co" data-sym="STANDARD-CO">standard-co</a> state) state)
        (<a class="sym-link system" href="basis-a.html#def-newline" data-sym="NEWLINE">newline</a> (<a class="sym-link system" href="basis-a.html#def-standard-co" data-sym="STANDARD-CO">standard-co</a> state) state)
        state))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> state)))</pre>
  </div>

<div class="form-block function" id="def-acl2-query1" data-defines="ACL2-QUERY1" data-references="ACL2-QUERY,QUOTE,SOFT,ER,CONSP,IF,CADDR,EQ,T,CADR,VALUE,ACL2-QUERY-SIMULATE-INTERACTION,SYMBOL-NAME,INTERN,ASSOC-KEYWORD,SYMBOLP,AND,TEMP,*STANDARD-OI*,READ-OBJECT,ANS,ER-LET*,LD-EVISC-TUPLE,*STANDARD-CO*,FMS,QUERY,IO?,PPROGN,NULL,COND,CDR,EVENS,SYMBOL-NAME-LST,CAR,CONS,LIST,ALIST1,MSG,LD-QUERY-CONTROL-ALIST,CDR-ASSOC-QUERY-ID,DV,LET,STATE,ALIST,QT,ID,DEFUN" data-used-by="ACL2-QUERY" data-part-name="ACL2-QUERY1" data-part-args="STATE,ALIST,QT,ID" data-part-body="ACL2-QUERY,QUOTE,SOFT,ER,CONSP,IF,CADDR,EQ,ACL2-QUERY1,T,CADR,VALUE,ACL2-QUERY-SIMULATE-INTERACTION,SYMBOL-NAME,INTERN,ASSOC-KEYWORD,SYMBOLP,AND,TEMP,*STANDARD-OI*,READ-OBJECT,ANS,ER-LET*,LD-EVISC-TUPLE,*STANDARD-CO*,FMS,QUERY,IO?,PPROGN,NULL,COND,CDR,EVENS,SYMBOL-NAME-LST,ALIST,QT,CAR,CONS,LIST,ALIST1,MSG,STATE,LD-QUERY-CONTROL-ALIST,ID,CDR-ASSOC-QUERY-ID,DV,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACL2-QUERY1">acl2-query1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-acl2-query1" data-sym="ACL2-QUERY1" title="(defun acl2-query1 (id qt alist state)
  (let ((dv (cdr-assoc-query-id id (ld-query-control-alist state)))
        (msg &quot;ACL2 Query (~x0):  ~@1  (~*2):  &quot;)
        (alist1
         (list (cons #\0 id) (cons #\1 (cons (car qt) alist))
...">acl2-query1</a>
  (id qt alist state)
  (let ((dv (<a class="sym-link system" href="basis-b.html#def-cdr-assoc-query-id" data-sym="CDR-ASSOC-QUERY-ID">cdr-assoc-query-id</a> id (<a class="sym-link system" href="basis-b.html#def-ld-query-control-alist" data-sym="LD-QUERY-CONTROL-ALIST">ld-query-control-alist</a> state))) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"ACL2 Query (~x0):  ~@1  (~*2):  "</span>)
      (alist1 (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 id)
          (cons #\1 (cons (car qt) alist))
          (cons #\2
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="string">""</span>
              <span class="string">"~s*"</span>
              <span class="string">"~s* or "</span>
              <span class="string">"~s*, "</span>
              (<a class="sym-link local-def" href="#def-symbol-name-lst" data-sym="SYMBOL-NAME-LST" title="(defun symbol-name-lst (lst)
  (declare (xargs :guard (symbol-listp lst)))
  (cond ((endp lst) nil)
        (t (cons (symbol-name (car lst)) (symbol-name-lst (cdr lst))))))">symbol-name-lst</a> (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> (cdr qt))))))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> dv) (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="basis-a.html#def-io_3F" data-sym="IO?">io?</a> query
            nil
            state
            (alist1 <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>)
            (<a class="sym-link system" href="basis-a.html#def-fms" data-sym="FMS">fms</a> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> alist1 <a class="sym-link system" href="axioms.html#def-_2Astandard-co_2A" data-sym="*STANDARD-CO*">*standard-co*</a> state (<a class="sym-link system" href="basis-a.html#def-ld-evisc-tuple" data-sym="LD-EVISC-TUPLE">ld-evisc-tuple</a> state)))
          (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((ans (<a class="sym-link system" href="axioms.html#def-read-object" data-sym="READ-OBJECT">read-object</a> <a class="sym-link system" href="axioms.html#def-_2Astandard-oi_2A" data-sym="*STANDARD-OI*">*standard-oi*</a> state)))
            (let ((temp (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp ans)
                   (<a class="sym-link system" href="axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> (<a class="sym-link system" href="axioms.html#def-intern" data-sym="INTERN">intern</a> (symbol-name ans) <span class="string">"KEYWORD"</span>)
                     (cdr qt)))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-acl2-query-simulate-interaction" data-sym="ACL2-QUERY-SIMULATE-INTERACTION" title="(defun acl2-query-simulate-interaction (msg alist controlledp ans state)
  (cond
   ((and (atom ans)
         (or controlledp
             (and (not (f-get-global &#39;window-interfacep state))
...">acl2-query-simulate-interaction</a> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> alist1 nil ans state)
                    (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-acl2-query1" data-sym="ACL2-QUERY1" title="(defun acl2-query1 (id qt alist state)
  (let ((dv (cdr-assoc-query-id id (ld-query-control-alist state)))
        (msg &quot;ACL2 Query (~x0):  ~@1  (~*2):  &quot;)
        (alist1
         (list (cons #\0 id) (cons #\1 (cons (car qt) alist))
...">acl2-query1</a> id qt alist state)))))))
      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> dv <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-acl2-query-simulate-interaction" data-sym="ACL2-QUERY-SIMULATE-INTERACTION" title="(defun acl2-query-simulate-interaction (msg alist controlledp ans state)
  (cond
   ((and (atom ans)
         (or controlledp
             (and (not (f-get-global &#39;window-interfacep state))
...">acl2-query-simulate-interaction</a> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a>
            alist1
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> qt)
            state)
          (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-caddr" data-sym="CADDR">caddr</a> qt))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-keyword" data-sym="ASSOC-KEYWORD">assoc-keyword</a> (if (consp dv)
                 (car dv)
                 dv)
               (cdr qt))))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> temp) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                '<a class="sym-link local-def" href="#def-acl2-query" data-sym="ACL2-QUERY" title="(defun acl2-query (id qt alist state)
  (cond ((atom qt) (value qt))
        ((not
          (and
           (or (stringp (car qt)) (and (consp (car qt)) (stringp (caar qt))))
...">acl2-query</a>
                <span class="string">"The default response, ~x0, supplied in ~
                 ld-query-control-alist for the ~x1 query, is not one ~
                 of the expected responses.  The ~x1 query ~
                 is~%~%~@2~%~%Note the expected responses above.  See ~
                 :DOC ld-query-control-alist."</span>
                (if (consp dv)
                  (car dv)
                  dv)
                id
                (cons <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> alist1)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link local-def" href="#def-acl2-query-simulate-interaction" data-sym="ACL2-QUERY-SIMULATE-INTERACTION" title="(defun acl2-query-simulate-interaction (msg alist controlledp ans state)
  (cond
   ((and (atom ans)
         (or controlledp
             (and (not (f-get-global &#39;window-interfacep state))
...">acl2-query-simulate-interaction</a> <a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> alist1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> dv state)
                (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> temp))))))))))</pre>
  </div>

<div class="form-block function" id="def-acl2-query" data-defines="ACL2-QUERY" data-references="ACL2-QUERY1,QT1,ER-LET*,T,QUOTE,SOFT,ER,KEYWORD-VALUE-LISTP,CDR,CAAR,CONSP,CAR,STRINGP,OR,AND,NOT,VALUE,ATOM,COND,STATE,ALIST,QT,ID,DEFUN" data-used-by="BRR-DATA-QUERY,ACL2-QUERY1" data-part-name="ACL2-QUERY" data-part-args="STATE,ALIST,QT,ID" data-part-body="STATE,ALIST,ID,ACL2-QUERY1,QT1,ER-LET*,T,ACL2-QUERY,QUOTE,SOFT,ER,KEYWORD-VALUE-LISTP,CDR,CAAR,CONSP,CAR,STRINGP,OR,AND,NOT,VALUE,QT,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACL2-QUERY">acl2-query</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-acl2-query" data-sym="ACL2-QUERY" title="(defun acl2-query (id qt alist state)
  (cond ((atom qt) (value qt))
        ((not
          (and
           (or (stringp (car qt)) (and (consp (car qt)) (stringp (caar qt))))
...">acl2-query</a>
  (id qt alist state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> qt) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> qt))
    ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (stringp (car qt))
           (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (car qt)) (stringp (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> qt))))
         (consp (cdr qt))
         (<a class="sym-link system" href="axioms.html#def-keyword-value-listp" data-sym="KEYWORD-VALUE-LISTP">keyword-value-listp</a> (cdr qt)))) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
        '<a class="sym-link local-def" href="#def-acl2-query" data-sym="ACL2-QUERY" title="(defun acl2-query (id qt alist state)
  (cond ((atom qt) (value qt))
        ((not
          (and
           (or (stringp (car qt)) (and (consp (car qt)) (stringp (caar qt))))
...">acl2-query</a>
        <span class="string">"The object ~x0 is not a query tree!  See the comment in ~
              acl2-query."</span>
        qt))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((qt1 (<a class="sym-link local-def" href="#def-acl2-query1" data-sym="ACL2-QUERY1" title="(defun acl2-query1 (id qt alist state)
  (let ((dv (cdr-assoc-query-id id (ld-query-control-alist state)))
        (msg &quot;ACL2 Query (~x0):  ~@1  (~*2):  &quot;)
        (alist1
         (list (cons #\0 id) (cons #\1 (cons (car qt) alist))
...">acl2-query1</a> id qt alist state)))
        (<a class="sym-link local-def" href="#def-acl2-query" data-sym="ACL2-QUERY" title="(defun acl2-query (id qt alist state)
  (cond ((atom qt) (value qt))
        ((not
          (and
           (or (stringp (car qt)) (and (consp (car qt)) (stringp (caar qt))))
...">acl2-query</a> id qt1 alist state)))))</pre>
  </div>

<div class="form-block function" id="def-brr-data-query" data-defines="BRR-DATA-QUERY" data-references="T,QUOTE,ACL2-QUERY,STATE,ID,DEFUN" data-used-by="CW-GSTACK-FOR-TERM-FN" data-part-name="BRR-DATA-QUERY" data-part-args="STATE,ID" data-part-body="STATE,T,QUOTE,ID,ACL2-QUERY" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BRR-DATA-QUERY">brr-data-query</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-brr-data-query" data-sym="BRR-DATA-QUERY" title="(defun brr-data-query (id state)
  (acl2-query id
              &#39;(&quot;Attempt to present another result?&quot; :y t :n nil :?
                (&quot;reply with y to continue, or with n to quit&quot; :y t :n nil))
              nil state))">brr-data-query</a>
  (id state)
  (<a class="sym-link local-def" href="#def-acl2-query" data-sym="ACL2-QUERY" title="(defun acl2-query (id qt alist state)
  (cond ((atom qt) (value qt))
        ((not
          (and
           (or (stringp (car qt)) (and (consp (car qt)) (stringp (caar qt))))
...">acl2-query</a> id
    '(<span class="string">"Attempt to present another result?"</span> <span class="keyword">:y</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
      <span class="keyword">:n</span> nil
      <span class="keyword">:?</span> (<span class="string">"reply with y to continue, or with n to quit"</span> <span class="keyword">:y</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:n</span> nil))
    nil
    state))</pre>
  </div>

<div class="form-block function" id="def-cw-gstack-for-term-fn" data-defines="CW-GSTACK-FOR-TERM-FN" data-references="ASSERT$,BRR-DATA-QUERY,ACTION,ER-LET*,NOT,EQUAL,LENGTH,IF,CW,AND,EARLIER-BRR-RESULT,BRR-RESULT,LET,BRR-DATA-2,ACCESS,REVERSE,CW-GSTACK1,PROGN$,CW-GSTACK-FOR-TERM-FN1,REST,D-2,EARLIER-D2,MV-LET,T,EQ,VALUE,NULL,COND,STATE,ALIST,BRR-DATA-LST,TTERM,MULTIPLE,SUBTERM-P,ID,DEFUN" data-used-by="CW-GSTACK-FOR-TERM*-FN" data-part-name="CW-GSTACK-FOR-TERM-FN" data-part-args="STATE,ALIST,BRR-DATA-LST,TTERM,MULTIPLE,SUBTERM-P,ID" data-part-body="ASSERT$,CW-GSTACK-FOR-TERM-FN,STATE,ID,BRR-DATA-QUERY,ACTION,ER-LET*,NOT,EQUAL,LENGTH,IF,CW,AND,EARLIER-BRR-RESULT,BRR-RESULT,LET,BRR-DATA-2,ACCESS,REVERSE,CW-GSTACK1,PROGN$,ALIST,TTERM,SUBTERM-P,CW-GSTACK-FOR-TERM-FN1,REST,D-2,EARLIER-D2,MV-LET,T,MULTIPLE,EQ,VALUE,BRR-DATA-LST,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-TERM-FN">cw-gstack-for-term-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gstack-for-term-fn" data-sym="CW-GSTACK-FOR-TERM-FN" title="(defun cw-gstack-for-term-fn
       (id subterm-p multiple tterm brr-data-lst alist state)
  (cond ((null brr-data-lst) (value (eq multiple :more)))
        (t
         (mv-let (earlier-d2 d-2 rest)
...">cw-gstack-for-term-fn</a>
  (id subterm-p multiple tterm <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a> alist state)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> multiple <span class="keyword">:more</span>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (earlier-d2 d-2 <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (cw-gstack-for-term-fn1 subterm-p tterm <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a> alist)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (d-2 (<a class="sym-link system" href="axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> (<a class="sym-link local-def" href="#def-cw-gstack1" data-sym="CW-GSTACK1" title="(defun cw-gstack1 (i calling-sys-fn lst evisc-tuple)
  (cond ((null lst) nil)
        (t
         (prog2$ (cw-gframe i calling-sys-fn (car lst) evisc-tuple)
                 (cw-gstack1 (1+ i) (access gframe (car lst) :sys-fn) (cdr lst)">cw-gstack1</a> <span class="number">1</span>
                nil
                (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 d-2 <span class="keyword">:gstack</span>))
                nil)
              (let ((<a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 d-2 <span class="keyword">:brr-result</span>)) (earlier-brr-result (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> earlier-d2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 earlier-d2 <span class="keyword">:brr-result</span>))))
                (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"The resulting (translated) term is~|  ~
                         ~y0.~|~#1~[~/Note: The first lemma application above ~
                         that provides a suitable result is at frame ~x2, and ~
                         ~#3~[it&#39;s the same result as above.~/that result ~
                         is~|  ~y4.~]~]~|"</span>
                  <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                  (if earlier-d2
                    <span class="number">1</span>
                    <span class="number">0</span>)
                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> earlier-d2
                    (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> brr-data-2 earlier-d2 <span class="keyword">:gstack</span>)))
                  (if (equal <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a> earlier-brr-result)
                    <span class="number">0</span>
                    <span class="number">1</span>)
                  earlier-brr-result))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> multiple) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:quit</span>))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((action (if multiple
                         (<a class="sym-link local-def" href="#def-brr-data-query" data-sym="BRR-DATA-QUERY" title="(defun brr-data-query (id state)
  (acl2-query id
              &#39;(&quot;Attempt to present another result?&quot; :y t :n nil :?
                (&quot;reply with y to continue, or with n to quit&quot; :y t :n nil))
              nil state))">brr-data-query</a> id state)
                         (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil))))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> action <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-cw-gstack-for-term-fn" data-sym="CW-GSTACK-FOR-TERM-FN" title="(defun cw-gstack-for-term-fn
       (id subterm-p multiple tterm brr-data-lst alist state)
  (cond ((null brr-data-lst) (value (eq multiple :more)))
        (t
         (mv-let (earlier-d2 d-2 rest)
...">cw-gstack-for-term-fn</a> id
                          subterm-p
                          <span class="keyword">:more</span> tterm
                          <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>
                          alist
                          state))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:quit</span>))))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> multiple <span class="keyword">:more</span>)))))))))</pre>
  </div>

<div class="form-block function" id="def-cw-gstack-for-term_2A-fn" data-defines="CW-GSTACK-FOR-TERM*-FN" data-references="CW,PROG2$,CW-GSTACK-FOR-TERM-FN,ANS,PAIRLIS$,SET-DIFFERENCE-EQ,BOUND-VARS,SUBSETP-EQ,ALL-VARS,LET,VALUE,ARGLISTP,NOT,ALIST,W,TRANSLATE,SOFT,ER,CAR,EQ,CONSP,AND,COND,TTERM,ER-LET*,&,T,MV,QUOTE,CASE-MATCH,FREEP,UTERM,VARS,MV-LET,STATE,BRR-DATA-LST,UTERM+,MULTIPLE,SUBTERM-P,ID,DEFUN" data-used-by="CW-GSTACK-FOR-SUBTERM,CW-GSTACK-FOR-TERM,CW-GSTACK-FOR-SUBTERM*,CW-GSTACK-FOR-TERM*" data-part-name="CW-GSTACK-FOR-TERM*-FN" data-part-args="STATE,BRR-DATA-LST,UTERM+,MULTIPLE,SUBTERM-P,ID" data-part-body="CW,PROG2$,BRR-DATA-LST,MULTIPLE,SUBTERM-P,CW-GSTACK-FOR-TERM-FN,ANS,PAIRLIS$,SET-DIFFERENCE-EQ,BOUND-VARS,SUBSETP-EQ,ALL-VARS,LET,VALUE,ARGLISTP,NOT,ALIST,STATE,W,TRANSLATE,ID,SOFT,ER,CAR,EQ,CONSP,AND,COND,TTERM,ER-LET*,&,T,MV,QUOTE,UTERM+,CASE-MATCH,FREEP,UTERM,VARS,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-TERM*-FN">cw-gstack-for-term*-fn</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cw-gstack-for-term_2A-fn" data-sym="CW-GSTACK-FOR-TERM*-FN" title="(defun cw-gstack-for-term*-fn (id subterm-p multiple uterm+ brr-data-lst state)
  (mv-let (vars uterm freep)
          (case-match uterm+ ((&#39;:free vars uterm) (mv vars uterm t))
                      (&amp; (mv nil uterm+ nil)))
          (er-let*
...">cw-gstack-for-term*-fn</a>
  (id subterm-p multiple uterm+ <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a> state)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (vars uterm freep)
    (<a class="sym-link system" href="basis-a.html#def-case-match" data-sym="CASE-MATCH">case-match</a> uterm+
      (('<span class="keyword">:free</span> vars uterm) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> vars uterm <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
      (&amp; (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil uterm+ nil)))
    (<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((tterm (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp uterm) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car uterm) <span class="keyword">:free</span>)) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
               id
               <span class="string">"An input of the form (:FREE ..) must be of the ~
                            form (:FREE vars x).  The input ~x0 is thus ~
                            illegal.  See :DOC cw-gstack-for-term."</span>
               uterm))
           (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (translate uterm <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil nil id (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state) state)))) (alist (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-a.html#def-arglistp" data-sym="ARGLISTP">arglistp</a> vars)) (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                id
                <span class="string">"The first argument of :FREE must be a list of ~
                            distinct variables, but ~f0 is not.  See :DOC ~
                            cw-gstack-for-term."</span>
                vars))
            ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> freep) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:none</span>))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> tterm)))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-subsetp-eq" data-sym="SUBSETP-EQ">subsetp-eq</a> vars <a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a>) (let ((<a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a> (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> <a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> vars)))
                      (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft
                      id
                      <span class="string">"For a :FREE expression, each specified ~
                                    variable must occur in the specified ~
                                    term.  But ~&amp;0 ~#0~[does~/do~] not occur ~
                                    in the term, ~x1.  See :DOC ~
                                    cw-gstack-for-term."</span>
                      (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> vars <a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a>)
                      tterm)))))))
        (ans (<a class="sym-link local-def" href="#def-cw-gstack-for-term-fn" data-sym="CW-GSTACK-FOR-TERM-FN" title="(defun cw-gstack-for-term-fn
       (id subterm-p multiple tterm brr-data-lst alist state)
  (cond ((null brr-data-lst) (value (eq multiple :more)))
        (t
         (mv-let (earlier-d2 d-2 rest)
...">cw-gstack-for-term-fn</a> id
            subterm-p
            multiple
            tterm
            <a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>
            alist
            state)))
      (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ans <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"There are no more results.~|"</span>))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> ans nil) (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"There are no results.~|"</span>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))
        (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>)))))</pre>
  </div>

<div class="form-block macro" id="def-cw-gstack-for-term_2A" data-defines="CW-GSTACK-FOR-TERM*" data-references="STATE,@,T,CW-GSTACK-FOR-TERM*-FN,QUASIQUOTE,BRR-DATA-LST,QUOTE,GLOBAL-VAR,&KEY,UTERM+,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-TERM*">cw-gstack-for-term*</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-cw-gstack-for-term_2A" data-sym="CW-GSTACK-FOR-TERM*" title="(defmacro cw-gstack-for-term* (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-term* nil t &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-term*</a>
  (uterm+ &amp;key (global-var '<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))
  `(<a class="sym-link local-def" href="#def-cw-gstack-for-term_2A-fn" data-sym="CW-GSTACK-FOR-TERM*-FN" title="(defun cw-gstack-for-term*-fn (id subterm-p multiple uterm+ brr-data-lst state)
  (mv-let (vars uterm freep)
          (case-match uterm+ ((&#39;:free vars uterm) (mv vars uterm t))
                      (&amp; (mv nil uterm+ nil)))
          (er-let*
...">cw-gstack-for-term*-fn</a> '<a class="sym-link local-def" href="#def-cw-gstack-for-term_2A" data-sym="CW-GSTACK-FOR-TERM*" title="(defmacro cw-gstack-for-term* (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-term* nil t &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-term*</a>
    nil
    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    ',UTERM+
    (<a class="sym-link system" href="axioms.html#def-_40" data-sym="@">@</a> ,GLOBAL-VAR)
    state))</pre>
  </div>

<div class="form-block macro" id="def-cw-gstack-for-subterm_2A" data-defines="CW-GSTACK-FOR-SUBTERM*" data-references="STATE,@,T,CW-GSTACK-FOR-TERM*-FN,QUASIQUOTE,BRR-DATA-LST,QUOTE,GLOBAL-VAR,&KEY,UTERM+,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-SUBTERM*">cw-gstack-for-subterm*</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-cw-gstack-for-subterm_2A" data-sym="CW-GSTACK-FOR-SUBTERM*" title="(defmacro cw-gstack-for-subterm* (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-subterm* t t &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-subterm*</a>
  (uterm+ &amp;key (global-var '<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))
  `(<a class="sym-link local-def" href="#def-cw-gstack-for-term_2A-fn" data-sym="CW-GSTACK-FOR-TERM*-FN" title="(defun cw-gstack-for-term*-fn (id subterm-p multiple uterm+ brr-data-lst state)
  (mv-let (vars uterm freep)
          (case-match uterm+ ((&#39;:free vars uterm) (mv vars uterm t))
                      (&amp; (mv nil uterm+ nil)))
          (er-let*
...">cw-gstack-for-term*-fn</a> '<a class="sym-link local-def" href="#def-cw-gstack-for-subterm_2A" data-sym="CW-GSTACK-FOR-SUBTERM*" title="(defmacro cw-gstack-for-subterm* (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-subterm* t t &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-subterm*</a>
    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    ',UTERM+
    (<a class="sym-link system" href="axioms.html#def-_40" data-sym="@">@</a> ,GLOBAL-VAR)
    state))</pre>
  </div>

<div class="form-block macro" id="def-cw-gstack-for-term" data-defines="CW-GSTACK-FOR-TERM" data-references="STATE,@,CW-GSTACK-FOR-TERM*-FN,QUASIQUOTE,BRR-DATA-LST,QUOTE,GLOBAL-VAR,&KEY,UTERM+,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-TERM">cw-gstack-for-term</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-cw-gstack-for-term" data-sym="CW-GSTACK-FOR-TERM" title="(defmacro cw-gstack-for-term (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-term nil nil &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-term</a>
  (uterm+ &amp;key (global-var '<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))
  `(<a class="sym-link local-def" href="#def-cw-gstack-for-term_2A-fn" data-sym="CW-GSTACK-FOR-TERM*-FN" title="(defun cw-gstack-for-term*-fn (id subterm-p multiple uterm+ brr-data-lst state)
  (mv-let (vars uterm freep)
          (case-match uterm+ ((&#39;:free vars uterm) (mv vars uterm t))
                      (&amp; (mv nil uterm+ nil)))
          (er-let*
...">cw-gstack-for-term*-fn</a> '<a class="sym-link local-def" href="#def-cw-gstack-for-term" data-sym="CW-GSTACK-FOR-TERM" title="(defmacro cw-gstack-for-term (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-term nil nil &#39;,uterm+ (@ ,global-var)
                           state))">cw-gstack-for-term</a>
    nil
    nil
    ',UTERM+
    (<a class="sym-link system" href="axioms.html#def-_40" data-sym="@">@</a> ,GLOBAL-VAR)
    state))</pre>
  </div>

<div class="form-block macro" id="def-cw-gstack-for-subterm" data-defines="CW-GSTACK-FOR-SUBTERM" data-references="STATE,@,T,CW-GSTACK-FOR-TERM*-FN,QUASIQUOTE,BRR-DATA-LST,QUOTE,GLOBAL-VAR,&KEY,UTERM+,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="CW-GSTACK-FOR-SUBTERM">cw-gstack-for-subterm</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-cw-gstack-for-subterm" data-sym="CW-GSTACK-FOR-SUBTERM" title="(defmacro cw-gstack-for-subterm (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-subterm t nil &#39;,uterm+
                           (@ ,global-var) state))">cw-gstack-for-subterm</a>
  (uterm+ &amp;key (global-var '<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a>))
  `(<a class="sym-link local-def" href="#def-cw-gstack-for-term_2A-fn" data-sym="CW-GSTACK-FOR-TERM*-FN" title="(defun cw-gstack-for-term*-fn (id subterm-p multiple uterm+ brr-data-lst state)
  (mv-let (vars uterm freep)
          (case-match uterm+ ((&#39;:free vars uterm) (mv vars uterm t))
                      (&amp; (mv nil uterm+ nil)))
          (er-let*
...">cw-gstack-for-term*-fn</a> '<a class="sym-link local-def" href="#def-cw-gstack-for-subterm" data-sym="CW-GSTACK-FOR-SUBTERM" title="(defmacro cw-gstack-for-subterm (uterm+ &amp;key (global-var &#39;brr-data-lst))
  `(cw-gstack-for-term*-fn &#39;cw-gstack-for-subterm t nil &#39;,uterm+
                           (@ ,global-var) state))">cw-gstack-for-subterm</a>
    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
    nil
    ',UTERM+
    (<a class="sym-link system" href="axioms.html#def-_40" data-sym="@">@</a> ,GLOBAL-VAR)
    state))</pre>
  </div>

<div class="form-block macro" id="def-set-brr-data-lst" data-defines="SET-BRR-DATA-LST" data-references="LEN,@,LENGTH,F-PUT-GLOBAL,T,OTHERWISE,SOFT,ER,VALUE,OBSERVATION,PPROGN,CASE,NULL,COND,Y,STATE,BRR-DATA-LST,X,ER-LET*,QUASIQUOTE,SYMBOLP,MEMBER-EQ,AND,XARGS,DECLARE,QUOTE,ACTION,&OPTIONAL,GLOBAL-VAR,DEFMACRO" data-used-by="WITH-BRR-DATA" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-BRR-DATA-LST">set-brr-data-lst</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-brr-data-lst" data-sym="SET-BRR-DATA-LST" title="(defmacro set-brr-data-lst (global-var &amp;optional (action &#39;:observation))
  (declare
   (xargs :guard
    (and (member-eq action (quote (:observation :error :silent))) global-var
         (symbolp global-var))))
...">set-brr-data-lst</a>
  (global-var &amp;optional (action '<span class="keyword">:observation</span>))
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> action '(<span class="keyword">:observation</span> <span class="keyword">:error</span> <span class="keyword">:silent</span>))
        global-var
        (symbolp global-var))))
  `(<a class="sym-link system" href="basis-b.html#def-er-let_2A" data-sym="ER-LET*">er-let*</a> ((x (<a class="sym-link local-def" href="#def-brr-data-lst" data-sym="BRR-DATA-LST" title="(defun brr-data-lst (state)
  (declare (xargs :stobjs state))
  (er-let* ((status (get-persistent-whs &#39;brr-data state)))
           (value
            (let ((data (wormhole-data status)))
...">brr-data-lst</a> state)) (y (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> x) (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> ,ACTION
              (<span class="keyword">:observation</span> (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="basis-a.html#def-observation" data-sym="OBSERVATION">observation</a> nil <span class="string">"There is no brr-data available."</span>)
                  (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil)))
              (<span class="keyword">:error</span> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> soft nil <span class="string">"There is no brr-data available."</span>))
              (otherwise (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> nil))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> x)))))
    (<a class="sym-link system" href="axioms.html#def-pprogn" data-sym="PPROGN">pprogn</a> (<a class="sym-link system" href="axioms.html#def-f-put-global" data-sym="F-PUT-GLOBAL">f-put-global</a> ',GLOBAL-VAR y state)
      (<a class="sym-link system" href="axioms.html#def-case" data-sym="CASE">case</a> ,ACTION
        (<span class="keyword">:observation</span> (<a class="sym-link system" href="basis-a.html#def-observation" data-sym="OBSERVATION">observation</a> nil
            <span class="string">"~x0 = ~x1"</span>
            '(<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> (<a class="sym-link system" href="axioms.html#def-_40" data-sym="@">@</a> ,GLOBAL-VAR))
            (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> y)))
        (otherwise state))
      (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> <span class="keyword">:invisible</span>))))</pre>
  </div>

<div class="form-block other" id="form-348" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> expand-hint
  ((equiv . alist) pattern (rune . hyp) lhs . rhs)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-binds-to-constants-p" data-defines="BINDS-TO-CONSTANTS-P" data-references="QUOTEP,CDR,EQ,OR,AND,CAR,PAIR,LET,T,ENDP,COND,UNIFY-SUBST,DEFUN" data-used-by="EXPAND-PERMISSION-RESULT1" data-part-name="BINDS-TO-CONSTANTS-P" data-part-args="UNIFY-SUBST" data-part-body="BINDS-TO-CONSTANTS-P,QUOTEP,CDR,EQ,OR,AND,CAR,PAIR,LET,T,UNIFY-SUBST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BINDS-TO-CONSTANTS-P">binds-to-constants-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-binds-to-constants-p" data-sym="BINDS-TO-CONSTANTS-P" title="(defun binds-to-constants-p (unify-subst)
  (cond ((endp unify-subst) t)
        (t
         (let ((pair (car unify-subst)))
           (and (or (eq (car pair) (cdr pair)) (quotep (cdr pair)))">binds-to-constants-p</a>
  (unify-subst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> unify-subst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((pair (car unify-subst)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car pair) (cdr pair)) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (cdr pair)))
          (<a class="sym-link local-def" href="#def-binds-to-constants-p" data-sym="BINDS-TO-CONSTANTS-P" title="(defun binds-to-constants-p (unify-subst)
  (cond ((endp unify-subst) t)
        (t
         (let ((pair (car unify-subst)))
           (and (or (eq (car pair) (cdr pair)) (quotep (cdr pair)))">binds-to-constants-p</a> (cdr unify-subst)))))))</pre>
  </div>

<div class="form-block function" id="def-expand-permission-result1" data-defines="EXPAND-PERMISSION-RESULT1" data-references="LENGTH,OR,ONE-WAY-UNIFY,UNIFY-SUBST,BINDS-TO-CONSTANTS-P,ONE-WAY-UNIFY1,EQUAL,UNIFY-SUBST0,FLG,MV-LET,AND,ALIST-CONSTANTS-P,ALIST-NONE-P,ALIST,LET*,EXPAND-HINT,ACCESS,GENEQV-REFINEMENTP,NOT,CDR,T,FARGS,LAMBDA-FORMALS,PAIRLIS$,FFN-SYMB,LAMBDA-BODY,MV,FLAMBDA-APPLICATIONP,EQ,COND,CAR,X,LET,IF,WRLD,GENEQV,EXPAND-LST,TERM,DEFUN" data-used-by="EXPAND-PERMISSION-RESULT" data-part-name="EXPAND-PERMISSION-RESULT1" data-part-args="WRLD,GENEQV,EXPAND-LST,TERM" data-part-body="LENGTH,OR,ONE-WAY-UNIFY,UNIFY-SUBST,BINDS-TO-CONSTANTS-P,ONE-WAY-UNIFY1,EQUAL,UNIFY-SUBST0,FLG,MV-LET,AND,ALIST-CONSTANTS-P,ALIST-NONE-P,ALIST,LET*,EXPAND-HINT,ACCESS,GENEQV-REFINEMENTP,NOT,WRLD,GENEQV,CDR,EXPAND-PERMISSION-RESULT1,T,FARGS,LAMBDA-FORMALS,PAIRLIS$,FFN-SYMB,LAMBDA-BODY,MV,TERM,FLAMBDA-APPLICATIONP,EQ,COND,CAR,X,LET,EXPAND-LST,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPAND-PERMISSION-RESULT1">expand-permission-result1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a>
  (term expand-lst geneqv wrld)
  (if expand-lst
    (let ((x (car expand-lst)))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> x <span class="keyword">:lambdas</span>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
                nil
                (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term))
                nil
                nil))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a> term
                (cdr expand-lst)
                geneqv
                wrld))))
        ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:equiv</span>)
             geneqv
             wrld)) (<a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a> term
            (cdr expand-lst)
            geneqv
            wrld))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((alist (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:alist</span>)) (alist-none-p (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> alist <span class="keyword">:none</span>))
              (alist-constants-p (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> alist-none-p) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car alist) <span class="keyword">:constants</span>)))
              (alist (if alist-constants-p
                  (cdr alist)
                  alist)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst0)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (alist-none-p (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:pattern</span>) term) nil))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (one-way-unify1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:pattern</span>) term alist)))
              (let ((flg (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg
                     (if alist-constants-p
                       (<a class="sym-link local-def" href="#def-binds-to-constants-p" data-sym="BINDS-TO-CONSTANTS-P" title="(defun binds-to-constants-p (unify-subst)
  (cond ((endp unify-subst) t)
        (t
         (let ((pair (car unify-subst)))
           (and (or (eq (car pair) (cdr pair)) (quotep (cdr pair)))">binds-to-constants-p</a> unify-subst0)
                       <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg unify-subst)
                      (one-way-unify (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:lhs</span>) term)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:rhs</span>)
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:hyp</span>)
                            unify-subst
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> expand-hint x <span class="keyword">:rune</span>)
                            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> alist-none-p alist-constants-p)
                              (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> expand-lst))))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a> term
                            (cdr expand-lst)
                            geneqv
                            wrld)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a> term
                      (cdr expand-lst)
                      geneqv
                      wrld)))))))))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil nil nil)))</pre>
  </div>

<div class="form-block function" id="def-remove1-by-position" data-defines="REMOVE1-BY-POSITION" data-references="CAR,CONS,1-,T,CDR,REVAPPEND,ZP,COND,LEN,<,NATP,TRUE-LISTP,AND,XARGS,DECLARE,ACC,LST,TARGET-INDEX,DEFUN" data-used-by="EXPAND-PERMISSION-RESULT" data-part-name="REMOVE1-BY-POSITION" data-part-args="ACC,LST,TARGET-INDEX" data-part-declare="LEN,<,TARGET-INDEX,NATP,ACC,LST,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CAR,CONS,1-,REMOVE1-BY-POSITION,T,LST,CDR,ACC,REVAPPEND,TARGET-INDEX,ZP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REMOVE1-BY-POSITION">remove1-by-position</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-remove1-by-position" data-sym="REMOVE1-BY-POSITION" title="(defun remove1-by-position (target-index lst acc)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp acc) (natp target-index)
         (&lt; target-index (len lst)))))
...">remove1-by-position</a>
  (target-index lst acc)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> lst)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> acc)
        (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> target-index)
        (&lt; target-index (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> lst)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-zp" data-sym="ZP">zp</a> target-index) (<a class="sym-link system" href="axioms.html#def-revappend" data-sym="REVAPPEND">revappend</a> acc (cdr lst)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-remove1-by-position" data-sym="REMOVE1-BY-POSITION" title="(defun remove1-by-position (target-index lst acc)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp acc) (natp target-index)
         (&lt; target-index (len lst)))))
...">remove1-by-position</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> target-index)
        (cdr lst)
        (cons (car lst) acc)))))</pre>
  </div>

<div class="form-block function" id="def-expand-permission-result" data-defines="EXPAND-PERMISSION-RESULT" data-references="T,LENGTH,-,REMOVE1-BY-POSITION,CHANGE,MV,ASSERT$,COND,EXPAND-PERMISSION-RESULT1,POSN-FROM-END,RUNE,UNIFY-SUBST,HYP,NEW-TERM,MV-LET,REWRITE-CONSTANT,ACCESS,EXPAND-LST,LET,WRLD,GENEQV,RCNST,TERM,DEFUN" data-used-by="REWRITE,EXPAND-PERMISSION-P" data-part-name="EXPAND-PERMISSION-RESULT" data-part-args="WRLD,GENEQV,RCNST,TERM" data-part-body="T,LENGTH,-,REMOVE1-BY-POSITION,CHANGE,MV,ASSERT$,COND,WRLD,GENEQV,TERM,EXPAND-PERMISSION-RESULT1,POSN-FROM-END,RUNE,UNIFY-SUBST,HYP,NEW-TERM,MV-LET,RCNST,REWRITE-CONSTANT,ACCESS,EXPAND-LST,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPAND-PERMISSION-RESULT">expand-permission-result</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-expand-permission-result" data-sym="EXPAND-PERMISSION-RESULT" title="(defun expand-permission-result (term rcnst geneqv wrld)
  (let ((expand-lst (access rewrite-constant rcnst :expand-lst)))
    (mv-let (new-term hyp unify-subst rune posn-from-end)
            (expand-permission-result1 term expand-lst geneqv wrld)
            (cond
...">expand-permission-result</a>
  (term rcnst geneqv wrld)
  (let ((expand-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:expand-lst</span>)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-term hyp unify-subst rune posn-from-end)
      (<a class="sym-link local-def" href="#def-expand-permission-result1" data-sym="EXPAND-PERMISSION-RESULT1" title="(defun expand-permission-result1 (term expand-lst geneqv wrld)
  (if expand-lst
      (let ((x (car expand-lst)))
        (cond
         ((eq x :lambdas)
...">expand-permission-result1</a> term expand-lst geneqv wrld)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (posn-from-end (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> new-term
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-term
              hyp
              unify-subst
              rune
              (let ((expand-lst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:expand-lst</span>)))
                (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rewrite-constant
                  rcnst
                  <span class="keyword">:expand-lst</span> (<a class="sym-link local-def" href="#def-remove1-by-position" data-sym="REMOVE1-BY-POSITION" title="(defun remove1-by-position (target-index lst acc)
  (declare
   (xargs :guard
    (and (true-listp lst) (true-listp acc) (natp target-index)
         (&lt; target-index (len lst)))))
...">remove1-by-position</a> (<a class="sym-link system" href="axioms.html#def--" data-sym="-">-</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> expand-lst) posn-from-end)
                    expand-lst
                    nil))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> new-term hyp unify-subst rune rcnst))))))</pre>
  </div>

<div class="form-block function" id="def-expand-permission-p" data-defines="EXPAND-PERMISSION-P" data-references="AND,IGNORE,DECLARE,EXPAND-PERMISSION-RESULT,NEW-RCNST,RUNE,UNIFY-SUBST,HYP,NEW-TERM,MV-LET,WRLD,GENEQV,RCNST,TERM,DEFUN" data-used-by="REWRITE" data-part-name="EXPAND-PERMISSION-P" data-part-args="WRLD,GENEQV,RCNST,TERM" data-part-body="AND,IGNORE,DECLARE,WRLD,GENEQV,RCNST,TERM,EXPAND-PERMISSION-RESULT,NEW-RCNST,RUNE,UNIFY-SUBST,HYP,NEW-TERM,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXPAND-PERMISSION-P">expand-permission-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-expand-permission-p" data-sym="EXPAND-PERMISSION-P" title="(defun expand-permission-p (term rcnst geneqv wrld)
  (mv-let (new-term hyp unify-subst rune new-rcnst)
          (expand-permission-result term rcnst geneqv wrld)
          (declare (ignore hyp unify-subst rune)) (and new-term new-rcnst)))">expand-permission-p</a>
  (term rcnst geneqv wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-term hyp unify-subst rune new-rcnst)
    (<a class="sym-link local-def" href="#def-expand-permission-result" data-sym="EXPAND-PERMISSION-RESULT" title="(defun expand-permission-result (term rcnst geneqv wrld)
  (let ((expand-lst (access rewrite-constant rcnst :expand-lst)))
    (mv-let (new-term hyp unify-subst rune posn-from-end)
            (expand-permission-result1 term expand-lst geneqv wrld)
            (cond
...">expand-permission-result</a> term rcnst geneqv wrld)
    (declare (ignore hyp unify-subst rune))
    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> new-term new-rcnst)))</pre>
  </div>

<div class="form-block function" id="def-ev-fncall_21" data-defines="EV-FNCALL!" data-references="EV-FNCALL,NULL,ASSERT$,T,FORMALS,PAIRLIS$,GUARD,EV,LATCHES,VAL,ERP,MV-LET,SYMBOL-CLASS,STOBJS-OUT,EQUAL,STOBJS-IN,ALL-NILS,FUNCTION-SYMBOLP,RETURN-LAST,QUOTE,EQ,NOT,SYMBOLP,AND,W,WRLD,LET,XARGS,DECLARE,AOK,STATE,ARGS,FN,DEFUN" data-used-by="EV-FNCALL-META" data-part-name="EV-FNCALL!" data-part-args="AOK,STATE,ARGS,FN" data-part-declare="NULL,ASSERT$,AOK,T,ARGS,FORMALS,PAIRLIS$,GUARD,EV,LATCHES,VAL,ERP,MV-LET,SYMBOL-CLASS,STOBJS-OUT,EQUAL,STOBJS-IN,ALL-NILS,FUNCTION-SYMBOLP,RETURN-LAST,QUOTE,EQ,NOT,FN,SYMBOLP,AND,STATE,W,WRLD,LET,XARGS,DECLARE" data-part-body="AOK,STATE,ARGS,FN,EV-FNCALL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EV-FNCALL!">ev-fncall!</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ev-fncall_21" data-sym="EV-FNCALL!" title="(defun ev-fncall! (fn args state aok)
  (declare
   (xargs :guard
    (let ((wrld (w state)))
      (and (symbolp fn) (not (eq fn (quote return-last)))
...">ev-fncall!</a>
  (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> state aok)
  (declare (xargs <span class="keyword">:guard</span> (let ((wrld (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)))
        (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp fn)
          (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-return-last" data-sym="RETURN-LAST">return-last</a>))
          (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> fn wrld)
          (<a class="sym-link system" href="axioms.html#def-all-nils" data-sym="ALL-NILS">all-nils</a> (<a class="sym-link system" href="axioms.html#def-stobjs-in" data-sym="STOBJS-IN">stobjs-in</a> fn wrld))
          (equal (<a class="sym-link system" href="axioms.html#def-stobjs-out" data-sym="STOBJS-OUT">stobjs-out</a> fn wrld) '(nil))
          (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-b.html#def-symbol-class" data-sym="SYMBOL-CLASS">symbol-class</a> fn wrld) <span class="keyword">:common-lisp-compliant</span>)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val latches)
            (ev (<a class="sym-link system" href="basis-b.html#def-guard" data-sym="GUARD">guard</a> fn nil wrld)
              (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> fn wrld) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
              state
              nil
              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
              aok)
            (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> latches) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> erp) val)))))))
  (ev-fncall fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> nil state nil nil aok))</pre>
  </div>

<div class="form-block function" id="def-ev-fncall-meta" data-defines="EV-FNCALL-META" data-references="EV-FNCALL,T,EV-FNCALL!,SYMBOL-CLASS,EQ,COND,LET,W,FUNCTION-SYMBOLP,SYMBOLP,AND,XARGS,DECLARE,STATE,ARGS,FN,DEFUN" data-used-by="REWRITE" data-part-name="EV-FNCALL-META" data-part-args="STATE,ARGS,FN" data-part-declare="STATE,W,FUNCTION-SYMBOLP,FN,SYMBOLP,AND,XARGS,DECLARE" data-part-body="EV-FNCALL,T,ARGS,EV-FNCALL!,STATE,W,FN,SYMBOL-CLASS,EQ,COND,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EV-FNCALL-META">ev-fncall-meta</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ev-fncall-meta" data-sym="EV-FNCALL-META" title="(defun ev-fncall-meta (fn args state)
  (declare (xargs :guard (and (symbolp fn) (function-symbolp fn (w state)))))
  (let ()
    (cond
     ((eq (symbol-class fn (w state)) :common-lisp-compliant)
...">ev-fncall-meta</a>
  (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> state)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (symbolp fn) (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> fn (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)))))
  (let nil
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-b.html#def-symbol-class" data-sym="SYMBOL-CLASS">symbol-class</a> fn (<a class="sym-link system" href="axioms.html#def-w" data-sym="W">w</a> state)) <span class="keyword">:common-lisp-compliant</span>) (<a class="sym-link local-def" href="#def-ev-fncall_21" data-sym="EV-FNCALL!" title="(defun ev-fncall! (fn args state aok)
  (declare
   (xargs :guard
    (let ((wrld (w state)))
      (and (symbolp fn) (not (eq fn (quote return-last)))
...">ev-fncall!</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> state <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (ev-fncall fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> nil state nil nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))))</pre>
  </div>

<div class="form-block function" id="def-ev-synp" data-defines="EV-SYNP" data-references="T,GET-EVG,EV,COERCE-STATE-TO-OBJECT,UNIFY-SUBST2,QUOTE,CONS,IF,UNIFY-SUBST1,LET*,STATE,MFC,UNIFY-SUBST,SYNP-TERM,DEFUN" data-used-by="RELIEVE-HYP-SYNP" data-part-name="EV-SYNP" data-part-args="STATE,MFC,UNIFY-SUBST,SYNP-TERM" data-part-body="T,EV-SYNP,SYNP-TERM,GET-EVG,EV,COERCE-STATE-TO-OBJECT,STATE,UNIFY-SUBST2,UNIFY-SUBST,QUOTE,CONS,MFC,IF,UNIFY-SUBST1,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EV-SYNP">ev-synp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-ev-synp" data-sym="EV-SYNP" title="(defun ev-synp (synp-term unify-subst mfc state)
  (let* ((unify-subst1
          (if mfc
              (cons (cons &#39;mfc mfc) unify-subst)
              unify-subst))
...">ev-synp</a>
  (synp-term unify-subst mfc state)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((unify-subst1 (if mfc
         (cons (cons 'mfc mfc) unify-subst)
         unify-subst)) (unify-subst2 (if mfc
          (cons (cons 'state (<a class="sym-link system" href="axioms.html#def-coerce-state-to-object" data-sym="COERCE-STATE-TO-OBJECT">coerce-state-to-object</a> state))
            unify-subst1)
          unify-subst)))
    (ev (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> synp-term '<a class="sym-link local-def" href="#def-ev-synp" data-sym="EV-SYNP" title="(defun ev-synp (synp-term unify-subst mfc state)
  (let* ((unify-subst1
          (if mfc
              (cons (cons &#39;mfc mfc) unify-subst)
              unify-subst))
...">ev-synp</a>) unify-subst2 state nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))</pre>
  </div>

<div class="form-block function" id="def-bad-synp-alist1" data-defines="BAD-SYNP-ALIST1" data-references="CDR,MEMBER-EQ,T,EQ,AND,TERMP,ASSOC-EQ,MSG,LEGAL-VARIABLEP,NOT,COND,CDAR,VALUE,CAAR,KEY,LET,OR,NULL,IF,ALISTP,XARGS,DECLARE,WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,ALIST,DEFUN" data-used-by="BIND-FREE-INFO,BAD-SYNP-ALIST1-LST" data-part-name="BAD-SYNP-ALIST1" data-part-args="WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,ALIST" data-part-declare="ALIST,ALISTP,XARGS,DECLARE" data-part-body="CDR,BAD-SYNP-ALIST1,MEMBER-EQ,T,VARS-TO-BE-BOUND,EQ,AND,WRLD,TERMP,UNIFY-SUBST,ASSOC-EQ,MSG,LEGAL-VARIABLEP,NOT,COND,CDAR,VALUE,CAAR,KEY,LET,OR,ALIST,NULL,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BAD-SYNP-ALIST1">bad-synp-alist1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bad-synp-alist1" data-sym="BAD-SYNP-ALIST1" title="(defun bad-synp-alist1 (alist unify-subst vars-to-be-bound wrld)
  (declare (xargs :guard (alistp alist)))
  (if (null alist)
      nil
      (or
...">bad-synp-alist1</a>
  (alist unify-subst vars-to-be-bound wrld)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> alist)))
  (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist)
    nil
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (let ((key (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)) (<a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-a.html#def-legal-variablep" data-sym="LEGAL-VARIABLEP">legal-variablep</a> key)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the key ~x0 is not a legal variable"</span> key))
          ((<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> key unify-subst) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the key ~x0 is already bound in the unifying ~
                       substitution, ~x1"</span>
              key
              unify-subst))
          ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (termp <a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a> wrld)) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the value ~x0 bound to key ~x1 is not a legal term ~
                       (translated into ACL2 internal form) in the current ~
                       ACL2 world"</span>
              <a class="sym-link system" href="axioms.html#def-value" data-sym="VALUE">value</a>
              key))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> key vars-to-be-bound))) (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"the key ~x0 is not a member of the specified list of ~
                       variables to be bound, ~x1"</span>
              key
              vars-to-be-bound))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil)))
      (<a class="sym-link local-def" href="#def-bad-synp-alist1" data-sym="BAD-SYNP-ALIST1" title="(defun bad-synp-alist1 (alist unify-subst vars-to-be-bound wrld)
  (declare (xargs :guard (alistp alist)))
  (if (null alist)
      nil
      (or
...">bad-synp-alist1</a> (cdr alist)
        unify-subst
        vars-to-be-bound
        wrld))))</pre>
  </div>

<div class="form-block function" id="def-bad-synp-alist1-lst" data-defines="BAD-SYNP-ALIST1-LST" data-references="CDR,CAR,BAD-SYNP-ALIST1,OR,T,ENDP,COND,WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,ALIST-LST,DEFUN" data-used-by="BIND-FREE-INFO" data-part-name="BAD-SYNP-ALIST1-LST" data-part-args="WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,ALIST-LST" data-part-body="CDR,BAD-SYNP-ALIST1-LST,WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,CAR,BAD-SYNP-ALIST1,OR,T,ALIST-LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BAD-SYNP-ALIST1-LST">bad-synp-alist1-lst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bad-synp-alist1-lst" data-sym="BAD-SYNP-ALIST1-LST" title="(defun bad-synp-alist1-lst (alist-lst unify-subst vars-to-be-bound wrld)
  (cond ((endp alist-lst) nil)
        (t
         (or
          (bad-synp-alist1 (car alist-lst) unify-subst vars-to-be-bound wrld)
...">bad-synp-alist1-lst</a>
  (alist-lst unify-subst vars-to-be-bound wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist-lst) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-bad-synp-alist1" data-sym="BAD-SYNP-ALIST1" title="(defun bad-synp-alist1 (alist unify-subst vars-to-be-bound wrld)
  (declare (xargs :guard (alistp alist)))
  (if (null alist)
      nil
      (or
...">bad-synp-alist1</a> (car alist-lst)
          unify-subst
          vars-to-be-bound
          wrld)
        (<a class="sym-link local-def" href="#def-bad-synp-alist1-lst" data-sym="BAD-SYNP-ALIST1-LST" title="(defun bad-synp-alist1-lst (alist-lst unify-subst vars-to-be-bound wrld)
  (cond ((endp alist-lst) nil)
        (t
         (or
          (bad-synp-alist1 (car alist-lst) unify-subst vars-to-be-bound wrld)
...">bad-synp-alist1-lst</a> (cdr alist-lst)
          unify-subst
          vars-to-be-bound
          wrld)))))</pre>
  </div>

<div class="form-block function" id="def-bind-free-info" data-defines="BIND-FREE-INFO" data-references="BAD-SYNP-ALIST1,T,BAD-SYNP-ALIST,QUOTE,GET-EVG,BAD-SYNP-ALIST1-LST,OR,CAR,ALISTP,TRUE-LISTP,AND,COND,WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,X,DEFUN" data-used-by="RELIEVE-HYP-SYNP" data-part-name="BIND-FREE-INFO" data-part-args="WRLD,VARS-TO-BE-BOUND,UNIFY-SUBST,X" data-part-body="BAD-SYNP-ALIST1,T,WRLD,BAD-SYNP-ALIST,QUOTE,VARS-TO-BE-BOUND,GET-EVG,UNIFY-SUBST,BAD-SYNP-ALIST1-LST,OR,CAR,ALISTP,X,TRUE-LISTP,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BIND-FREE-INFO">bind-free-info</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bind-free-info" data-sym="BIND-FREE-INFO" title="(defun bind-free-info (x unify-subst vars-to-be-bound wrld)
  (cond
   ((and (true-listp x) (alistp (car x)))
    (or
     (bad-synp-alist1-lst x unify-subst
...">bind-free-info</a>
  (x unify-subst vars-to-be-bound wrld)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x) (<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> (car x))) (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-bad-synp-alist1-lst" data-sym="BAD-SYNP-ALIST1-LST" title="(defun bad-synp-alist1-lst (alist-lst unify-subst vars-to-be-bound wrld)
  (cond ((endp alist-lst) nil)
        (t
         (or
          (bad-synp-alist1 (car alist-lst) unify-subst vars-to-be-bound wrld)
...">bad-synp-alist1-lst</a> x
          unify-subst
          (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> vars-to-be-bound 'bad-synp-alist)
          wrld)
        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
    ((<a class="sym-link system" href="axioms.html#def-alistp" data-sym="ALISTP">alistp</a> x) (<a class="sym-link local-def" href="#def-bad-synp-alist1" data-sym="BAD-SYNP-ALIST1" title="(defun bad-synp-alist1 (alist unify-subst vars-to-be-bound wrld)
  (declare (xargs :guard (alistp alist)))
  (if (null alist)
      nil
      (or
...">bad-synp-alist1</a> x
        unify-subst
        (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> vars-to-be-bound 'bad-synp-alist)
        wrld))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="string">"it is not an alist"</span>)))</pre>
  </div>

<div class="form-block function" id="def-evgs-or-t" data-defines="EVGS-OR-T" data-references="FQUOTEP,CADR,CONS,T,EQ,REST,CDR,QUOTEP,AND,IF,ASSOC-EQ,TEMP,LET,CAR,VARIABLEP,ENDP,COND,ALIST,LST,DEFUN" data-part-name="EVGS-OR-T" data-part-args="ALIST,LST" data-part-body="FQUOTEP,CADR,CONS,T,EQ,EVGS-OR-T,REST,CDR,QUOTEP,AND,IF,ALIST,ASSOC-EQ,TEMP,LET,CAR,VARIABLEP,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EVGS-OR-T">evgs-or-t</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-evgs-or-t" data-sym="EVGS-OR-T" title="(defun evgs-or-t (lst alist)
  (cond ((endp lst) nil)
        ((variablep (car lst))
         (let ((temp (assoc-eq (car lst) alist)))
           (if (and temp (quotep (cdr temp)))
...">evgs-or-t</a>
  (lst alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) nil)
    ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> (car lst)) (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car lst) alist)))
        (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> temp (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (cdr temp)))
          (let ((<a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a> (<a class="sym-link local-def" href="#def-evgs-or-t" data-sym="EVGS-OR-T" title="(defun evgs-or-t (lst alist)
  (cond ((endp lst) nil)
        ((variablep (car lst))
         (let ((temp (assoc-eq (car lst) alist)))
           (if (and temp (quotep (cdr temp)))
...">evgs-or-t</a> (cdr lst) alist)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (cdr temp)) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>))))
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> (car lst)) (let ((<a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a> (<a class="sym-link local-def" href="#def-evgs-or-t" data-sym="EVGS-OR-T" title="(defun evgs-or-t (lst alist)
  (cond ((endp lst) nil)
        ((variablep (car lst))
         (let ((temp (assoc-eq (car lst) alist)))
           (if (and temp (quotep (cdr temp)))
...">evgs-or-t</a> (cdr lst) alist)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car lst)) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))</pre>
  </div>

<div class="form-block function" id="def-search-type-alist_2B" data-defines="SEARCH-TYPE-ALIST+" data-references="SEARCH-TYPE-ALIST-REC,FARGN,FCONS-TERM*,T,MV,FFN-SYMB,EQUIVALENCE-RELATIONP,NOT,FQUOTEP,VARIABLEP,OR,COND,ALT-TERM,MV-LET,WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM,DEFUN" data-used-by="REWRITE" data-part-name="SEARCH-TYPE-ALIST+" data-part-args="WRLD,TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,TERM" data-part-body="TTREE,UNIFY-SUBST,TYPE-ALIST,TYP,SEARCH-TYPE-ALIST-REC,FARGN,FCONS-TERM*,T,MV,WRLD,FFN-SYMB,EQUIVALENCE-RELATIONP,NOT,FQUOTEP,VARIABLEP,OR,COND,ALT-TERM,TERM,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SEARCH-TYPE-ALIST+">search-type-alist+</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-search-type-alist_2B" data-sym="SEARCH-TYPE-ALIST+" title="(defun search-type-alist+ (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist+</a>
  (term typ type-alist unify-subst ttree wrld)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term alt-term)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term)
         (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term)
         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-equivalence-relationp" data-sym="EQUIVALENCE-RELATIONP">equivalence-relationp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term nil))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term
          (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))))
    (search-type-alist-rec term
      alt-term
      typ
      type-alist
      unify-subst
      ttree)))</pre>
  </div>

<div class="form-block function" id="def-oncep" data-defines="ONCEP" data-references="CDR,MEMBER-EQUAL,CAR,<=,EQ,OR,IF,NUME,RUNE,MATCH-FREE,NUME-RUNES,DEFUN" data-used-by="REWRITE" data-part-name="ONCEP" data-part-args="NUME,RUNE,MATCH-FREE,NUME-RUNES" data-part-body="CDR,RUNE,MEMBER-EQUAL,MATCH-FREE,NUME,CAR,<=,NUME-RUNES,EQ,OR,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ONCEP">oncep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-oncep" data-sym="ONCEP" title="(defun oncep (nume-runes match-free rune nume)
  (if (or (eq nume-runes :clear) (&lt;= (car nume-runes) nume))
      (eq match-free :once)
      (member-equal rune (cdr nume-runes))))">oncep</a>
  (nume-runes match-free rune nume)
  (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> nume-runes <span class="keyword">:clear</span>) (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> (car nume-runes) nume))
    (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> match-free <span class="keyword">:once</span>)
    (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> rune (cdr nume-runes))))</pre>
  </div>

<div class="form-block macro" id="def-zero-depthp" data-defines="ZERO-DEPTHP" data-references="THE-FIXNUM,EQL,QUASIQUOTE,DEPTH,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ZERO-DEPTHP">zero-depthp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-zero-depthp" data-sym="ZERO-DEPTHP" title="(defmacro zero-depthp (depth) `(eql (the-fixnum ,depth) 0))">zero-depthp</a> (depth) `(<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> (<a class="sym-link system" href="axioms.html#def-the-fixnum" data-sym="THE-FIXNUM">the-fixnum</a> ,DEPTH) <span class="number">0</span>))</pre>
  </div>

<div class="form-block macro" id="def-rdepth-error" data-defines="RDEPTH-ERROR" data-references="REWRITE,STATE,GSTACKP,F-GET-GLOBAL,WRLD,REWRITE-STACK-LIMIT,ER-HARD,PROG2$,QUASIQUOTE,PREPROCESS,QUOTE,CTX,LET,IF,PREPROCESS-P,&OPTIONAL,FORM,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="RDEPTH-ERROR">rdepth-error</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rdepth-error" data-sym="RDEPTH-ERROR" title="(defmacro rdepth-error (form &amp;optional preprocess-p)
  (if preprocess-p
      (let ((ctx &#39;&#39;preprocess))
        `(prog2$
          (er-hard ,ctx &quot;Call depth&quot;
...">rdepth-error</a>
  (form &amp;optional preprocess-p)
  (if preprocess-p
    (let ((ctx ''preprocess))
      `(<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="basis-a.html#def-er-hard" data-sym="ER-HARD">er-hard</a> ,CTX
          <span class="string">"Call depth"</span>
          <span class="string">"The call depth limit of ~x0 has been exceeded in the ACL2 ~
                   preprocessor (a sort of rewriter).  There might be a loop ~
                   caused by some set of enabled simple rules.  To see why ~
                   the limit was exceeded, ~@1retry the proof with :hints~%  ~
                   :do-not &#39;(preprocess)~%and then follow the directions in ~
                   the resulting error message.  See :DOC rewrite-stack-limit ~
                   for a possible solution when there is not a loop."</span>
          (<a class="sym-link system" href="axioms.html#def-rewrite-stack-limit" data-sym="REWRITE-STACK-LIMIT">rewrite-stack-limit</a> wrld)
          (if (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
            <span class="string">""</span>
            <span class="string">"execute~%  :brr t~%and next "</span>))
        ,FORM))
    (let ((ctx ''<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a>))
      `(<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="basis-a.html#def-er-hard" data-sym="ER-HARD">er-hard</a> ,CTX
          <span class="string">"Call depth"</span>
          <span class="string">"The call depth limit of ~x0 has been exceeded in the ACL2 ~
                 rewriter.  To see why the limit was exceeded, ~@1execute the ~
                 form (cw-gstack) or, for less verbose output, instead try ~
                 (cw-gstack :frames 30).  You may then notice a loop caused ~
                 by some set of enabled rules, some of which you can then ~
                 disable; see :DOC disable.  For a possible solution when ~
                 there is not a loop, see :DOC rewrite-stack-limit."</span>
          (<a class="sym-link system" href="axioms.html#def-rewrite-stack-limit" data-sym="REWRITE-STACK-LIMIT">rewrite-stack-limit</a> wrld)
          (if (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
            <span class="string">""</span>
            <span class="string">"first execute~%  :brr t~%and then try the proof again, and ~
                   then "</span>))
        ,FORM))))</pre>
  </div>

<div class="form-block function" id="def-bad-synp-hyp-msg1" data-defines="BAD-SYNP-HYP-MSG1" data-references="UNION-EQ,CDDR,CADR,CDR,CAR,MFC,STATE,SET-DIFFERENCE-EQ,SUBSETP-EQ,REVERSE,<ALL_VARIABLES>,INTERSECTP-EQ,COLLECT-NON-LEGAL-VARIABLEPS,EQUAL,AND,BIND-FREE,SYNTAXP,MEMBER-EQ,FQUOTEP,VARIABLEP,OR,TERMP,VARS-TO-BE-BOUND,SAVED-TERM,ALL-VARS,VARS,FARGN,UNQUOTE,TERM-TO-BE-EVALUATED,LET*,FARGS,ALL-QUOTEPS,T,UNTRANSLATE,LIST,CONS,MV,FFN-SYMB,EQ,NOT,COND,SYNP,QUOTE,FFNNAMEP,IF,WRLD,ALL-VARS-BOUND-P,BOUND-VARS,HYP,DEFUN" data-used-by="BAD-SYNP-HYP-MSG" data-part-name="BAD-SYNP-HYP-MSG1" data-part-args="WRLD,ALL-VARS-BOUND-P,BOUND-VARS,HYP" data-part-body="UNION-EQ,CDDR,CADR,CDR,CAR,MFC,STATE,SET-DIFFERENCE-EQ,SUBSETP-EQ,REVERSE,<ALL_VARIABLES>,INTERSECTP-EQ,COLLECT-NON-LEGAL-VARIABLEPS,EQUAL,AND,BIND-FREE,SYNTAXP,MEMBER-EQ,FQUOTEP,VARIABLEP,OR,TERMP,VARS-TO-BE-BOUND,SAVED-TERM,ALL-VARS,VARS,FARGN,UNQUOTE,TERM-TO-BE-EVALUATED,LET*,FARGS,ALL-QUOTEPS,ALL-VARS-BOUND-P,BOUND-VARS,WRLD,T,UNTRANSLATE,LIST,CONS,MV,FFN-SYMB,EQ,NOT,COND,HYP,SYNP,QUOTE,FFNNAMEP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BAD-SYNP-HYP-MSG1">bad-synp-hyp-msg1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bad-synp-hyp-msg1" data-sym="BAD-SYNP-HYP-MSG1" title="(defun bad-synp-hyp-msg1 (hyp bound-vars all-vars-bound-p wrld)
  (if (ffnnamep &#39;synp hyp)
      (cond
       ((not (eq (ffn-symb hyp) &#39;synp))
        (mv
...">bad-synp-hyp-msg1</a>
  (hyp <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a> all-vars-bound-p wrld)
  (if (ffnnamep '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a> hyp)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"a call of syntaxp or bind-free should occur only ~
                   at the top level of a hypothesis, but in ~x0 it ~
                   appears elsewhere but not at the top level."</span>
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld))))
          <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
          all-vars-bound-p))
      ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (all-quoteps (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> hyp))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"a call of ~x0 in a hypothesis should be made on quoted ~
                   arguments, but that is not true for the hypothesis, ~x1."</span>
            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>)
              (cons #\1 (untranslate hyp nil wrld))))
          <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
          all-vars-bound-p))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((term-to-be-evaluated (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">3</span>))) (vars (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> term-to-be-evaluated))
            (saved-term (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>)))
            (vars-to-be-bound (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>))))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (termp term-to-be-evaluated wrld)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"the term to be evaluated by the syntaxp or ~
                            bind-free hypothesis must be an ACL2 term, but ~
                            this is not the case in ~x0.  The term&#39;s internal ~
                            (translated) form is ~x1."</span>
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp nil wrld))
                    (cons #\1 term-to-be-evaluated)))
                <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                all-vars-bound-p))
            ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> saved-term)
               (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> saved-term)
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> saved-term) '(<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> <a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"a synp hyp has been found which does not appear to ~
                            have come from a syntaxp or bind-free hypothesis: ~
                            ~x0. This is not, at present, allowed.  If we are ~
                            in error or you believe we have been otherwise too ~
                            restrictive, please contact the maintainers of ~
                            ACL2."</span>
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp nil wrld))))
                <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                all-vars-bound-p))
            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal vars-to-be-bound nil))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
               (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (collect-non-legal-variableps vars-to-be-bound)
                 all-vars-bound-p
                 (<a class="sym-link system" href="axioms.html#def-intersectp-eq" data-sym="INTERSECTP-EQ">intersectp-eq</a> vars-to-be-bound <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"the vars to be bound by a bind-free hypothesis ~
                            must be either t or a list of variables which ~
                            are not already bound.  This is not the case in ~
                            ~x0.  The vars to be bound are ~x1 and the vars ~
                            already bound are ~x2."</span>
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld))
                    (cons #\1 vars-to-be-bound)
                    (cons #\2
                      (if all-vars-bound-p
                        '&lt;all_variables&gt;
                        (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))))
                <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                all-vars-bound-p))
            ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> all-vars-bound-p)
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-subsetp-eq" data-sym="SUBSETP-EQ">subsetp-eq</a> (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> vars '(state mfc))
                   <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"any vars, other than ~x2 and ~x3, used in ~
                            the term to be evaluated by a ~
                            syntaxp or bind-free hypothesis must already be ~
                            bound.  This does not appear to be the case ~
                            in ~x0.  The vars already bound are ~x1."</span>
                  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld))
                    (cons #\1 (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>))
                    (cons #\2 'mfc)
                    (cons #\3 'state)))
                <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                all-vars-bound-p))
            ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'state vars) (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'mfc vars)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'state <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                   (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'mfc <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                   all-vars-bound-p) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"we do not allow the use of state or mfc ~
                                   in a syntaxp or bind-free hypothesis ~
                                   in a context where either state or ~
                                   mfc is already bound.  This restriction ~
                                   is violated in ~x0.  The vars already ~
                                   bound are ~x1."</span>
                      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp nil wrld))
                        (cons #\1
                          (if all-vars-bound-p
                            '&lt;all_variables&gt;
                            (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))))
                    <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                    all-vars-bound-p))
                ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> 'state (car vars)))
                   (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'state (cdr vars))
                   (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> 'mfc (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> vars)))
                   (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'mfc (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> vars))
                   (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> all-vars-bound-p)
                     (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-subsetp-eq" data-sym="SUBSETP-EQ">subsetp-eq</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> vars) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (cons <span class="string">"if either state or mfc is a member of the ~
                                   vars of the term to be evaluated, we ~
                                   require that both mfc and state be present ~
                                   and that they be the last two args of the ~
                                   term, in that order.  We also require that ~
                                   the remaining vars be already bound.  This ~
                                   does not appear to be the case in ~x0.  The ~
                                   vars already bound are ~x1."</span>
                      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons #\0 (untranslate hyp nil wrld))
                        (cons #\1
                          (if all-vars-bound-p
                            '&lt;all_variables&gt;
                            (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))))
                    <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
                    all-vars-bound-p))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> vars-to-be-bound nil) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                      ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-union-eq" data-sym="UNION-EQ">union-eq</a> vars-to-be-bound <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))
                    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> all-vars-bound-p (equal vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal vars-to-be-bound nil) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                  ((equal vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-union-eq" data-sym="UNION-EQ">union-eq</a> vars-to-be-bound <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)))
                (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> all-vars-bound-p (equal vars-to-be-bound <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))))))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
      (<a class="sym-link system" href="axioms.html#def-union-eq" data-sym="UNION-EQ">union-eq</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> hyp) <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>)
      all-vars-bound-p)))</pre>
  </div>

<div class="form-block function" id="def-bad-synp-hyp-msg" data-defines="BAD-SYNP-HYP-MSG" data-references="CDR,OR,CAR,BAD-SYNP-HYP-MSG1,MV-LET,NULL,IF,WRLD,ALL-VARS-BOUND-P,BOUND-VARS,HYPS,DEFUN" data-used-by="REWRITE" data-part-name="BAD-SYNP-HYP-MSG" data-part-args="WRLD,ALL-VARS-BOUND-P,BOUND-VARS,HYPS" data-part-body="CDR,OR,WRLD,CAR,BAD-SYNP-HYP-MSG1,ALL-VARS-BOUND-P,BOUND-VARS,BAD-SYNP-HYP-MSG,MV-LET,HYPS,NULL,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BAD-SYNP-HYP-MSG">bad-synp-hyp-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a>
  (hyps <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a> all-vars-bound-p wrld)
  (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyps)
    nil
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a> all-vars-bound-p)
      (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg1" data-sym="BAD-SYNP-HYP-MSG1" title="(defun bad-synp-hyp-msg1 (hyp bound-vars all-vars-bound-p wrld)
  (if (ffnnamep &#39;synp hyp)
      (cond
       ((not (eq (ffn-symb hyp) &#39;synp))
        (mv
...">bad-synp-hyp-msg1</a> (car hyps)
        <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
        all-vars-bound-p
        wrld)
      (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> <a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a>
        (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> (cdr hyps)
          <a class="sym-link system" href="history-management.html#def-bound-vars" data-sym="BOUND-VARS">bound-vars</a>
          all-vars-bound-p
          wrld)))))</pre>
  </div>

<div class="form-block macro" id="def-sl-let" data-defines="SL-LET" data-references="SIGNED-BYTE,TYPE,DECLARE,MV-LET,QUASIQUOTE,STEP-LIMIT,QUOTE,CONS,NEW-VARS,LET,REST,&REST,FORM,VARS,DEFMACRO" data-used-by="REWRITE,REWRITE-STANDARD-EXIT" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SL-LET">sl-let</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a>
  (vars form &amp;rest <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
  (let ((new-vars (cons 'step-limit vars)))
    `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> ,NEW-VARS
      ,FORM
      (declare (type (signed-byte <span class="number">61</span>) step-limit))
      ,@REST)))</pre>
  </div>

<div class="form-block macro" id="def-rewrite-entry-extending-failure" data-defines="REWRITE-ENTRY-EXTENDING-FAILURE" data-references="CHECK-VARS-NOT-FREE,CONS,NULL,AND,MV,REWRITE-ENTRY,RW-CACHE-ALIST-NEWXX,ALLPXX,TTREEXX,UNIFY-SUBSTXX,FAILURE-REASON-LSTXX,RELIEVE-HYPS-ANSXX,STEP-LIMITXX,MV-LET,QUASIQUOTE,ARGS,&REST,FORM,FAILURE-REASON,UNIFY-SUBST,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-ENTRY-EXTENDING-FAILURE">rewrite-entry-extending-failure</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rewrite-entry-extending-failure" data-sym="REWRITE-ENTRY-EXTENDING-FAILURE" title="(defmacro rewrite-entry-extending-failure
          (unify-subst failure-reason form &amp;rest args)
  `(mv-let
    (step-limitxx relieve-hyps-ansxx failure-reason-lstxx unify-substxx ttreexx
     allpxx rw-cache-alist-newxx)
...">rewrite-entry-extending-failure</a>
  (unify-subst failure-reason form &amp;rest <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
  `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (step-limitxx relieve-hyps-ansxx
      failure-reason-lstxx
      unify-substxx
      ttreexx
      allpxx
      rw-cache-alist-newxx)
    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> ,FORM ,@ARGS)
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limitxx
      relieve-hyps-ansxx
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> relieve-hyps-ansxx)
        (cons (<a class="sym-link system" href="axioms.html#def-check-vars-not-free" data-sym="CHECK-VARS-NOT-FREE">check-vars-not-free</a> (step-limitxx relieve-hyps-ansxx
              failure-reason-lstxx
              unify-substxx
              ttreexx
              allpxx
              rw-cache-alist-newxx)
            (cons ,UNIFY-SUBST ,FAILURE-REASON))
          failure-reason-lstxx))
      unify-substxx
      ttreexx
      allpxx
      rw-cache-alist-newxx)))</pre>
  </div>

<div class="form-block function" id="def-extend-unify-subst" data-defines="EXTEND-UNIFY-SUBST" data-references="STRIP-CDRS,QUOTE-NORMAL-FORM,STRIP-CARS,PAIRLIS$,APPEND,UNIFY-SUBST,ALIST,DEFUN" data-used-by="REWRITE,RELIEVE-HYP-SYNP" data-part-name="EXTEND-UNIFY-SUBST" data-part-args="UNIFY-SUBST,ALIST" data-part-body="UNIFY-SUBST,STRIP-CDRS,QUOTE-NORMAL-FORM,ALIST,STRIP-CARS,PAIRLIS$,APPEND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-UNIFY-SUBST">extend-unify-subst</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-unify-subst" data-sym="EXTEND-UNIFY-SUBST" title="(defun extend-unify-subst (alist unify-subst)
  (append (pairlis$ (strip-cars alist) (quote-normal-form (strip-cdrs alist)))
          unify-subst))">extend-unify-subst</a>
  (alist unify-subst)
  (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> alist)
      (quote-normal-form (<a class="sym-link system" href="axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> alist)))
    unify-subst))</pre>
  </div>

<div class="form-block function" id="def-relieve-hyp-synp" data-defines="RELIEVE-HYP-SYNP" data-references="UNTRANSLATE,EXTEND-UNIFY-SUBST,BIND-FREE-INFO,INFO,HARD,ER,FN-RUNE-NUME,PUSH-LEMMA,LIST,MV,T,BIND-FREE-EXTENDED,SYNTAXP-EXTENDED,SYM,LET,NULL,OR,COND,IGNORE,DECLARE,EV-SYNP,LATCHES,VAL,ERP,MV-LET,BIND-FREE,SYNTAXP,EQ,SYNP,PUSH-GFRAME,?,METAFUNCTION-CONTEXT,MAKE,ALL-VARS,MEMBER-EQ,IF,MFC,RELIEVE-HYP,QUOTE,FARGN,GET-EVG,CAR,SYNP-FN,LET*,BKPTR,TTREE,GSTACK,RCNST,SIMPLIFY-CLAUSE-POT-LST,BACKCHAIN-LIMIT,ANCESTORS,FNSTACK,STATE,WRLD,TYPE-ALIST,RDEPTH,UNIFY-SUBST,HYP0,RUNE,DEFUN" data-used-by="REWRITE" data-part-name="RELIEVE-HYP-SYNP" data-part-args="BKPTR,TTREE,GSTACK,RCNST,SIMPLIFY-CLAUSE-POT-LST,BACKCHAIN-LIMIT,ANCESTORS,FNSTACK,STATE,WRLD,TYPE-ALIST,RDEPTH,UNIFY-SUBST,HYP0,RUNE" data-part-body="UNTRANSLATE,EXTEND-UNIFY-SUBST,BIND-FREE-INFO,INFO,RUNE,HARD,ER,FN-RUNE-NUME,PUSH-LEMMA,LIST,MV,T,BIND-FREE-EXTENDED,SYNTAXP-EXTENDED,SYM,LET,NULL,OR,COND,IGNORE,DECLARE,EV-SYNP,LATCHES,VAL,ERP,MV-LET,UNIFY-SUBST,TTREE,GSTACK,BIND-FREE,SYNTAXP,EQ,SYNP,PUSH-GFRAME,BKPTR,RCNST,SIMPLIFY-CLAUSE-POT-LST,BACKCHAIN-LIMIT,ANCESTORS,FNSTACK,WRLD,?,TYPE-ALIST,RDEPTH,METAFUNCTION-CONTEXT,MAKE,ALL-VARS,STATE,MEMBER-EQ,IF,MFC,RELIEVE-HYP,QUOTE,HYP0,FARGN,GET-EVG,CAR,SYNP-FN,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RELIEVE-HYP-SYNP">relieve-hyp-synp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-relieve-hyp-synp" data-sym="RELIEVE-HYP-SYNP" title="(defun relieve-hyp-synp
       (rune hyp0 unify-subst rdepth type-alist wrld state fnstack ancestors
        backchain-limit simplify-clause-pot-lst rcnst gstack ttree bkptr)
  (let* ((synp-fn (car (get-evg (fargn hyp0 2) &#39;relieve-hyp)))
         (mfc
...">relieve-hyp-synp</a>
  (rune hyp0
    unify-subst
    rdepth
    type-alist
    wrld
    state
    fnstack
    ancestors
    <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
    simplify-clause-pot-lst
    rcnst
    gstack
    ttree
    bkptr)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((synp-fn (car (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">2</span>) 'relieve-hyp))) (mfc (if (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> 'state
            (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">3</span>) 'relieve-hyp)))
          (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> metafunction-context
            <span class="keyword">:rdepth</span> rdepth
            <span class="keyword">:type-alist</span> type-alist
            <span class="keyword">:obj</span> '?
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:wrld</span> wrld
            <span class="keyword">:fnstack</span> fnstack
            <span class="keyword">:ancestors</span> ancestors
            <span class="keyword">:backchain-limit</span> <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
            <span class="keyword">:simplify-clause-pot-lst</span> simplify-clause-pot-lst
            <span class="keyword">:rcnst</span> rcnst
            <span class="keyword">:gstack</span> (if bkptr
              (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>
                bkptr
                (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> synp-fn '<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a>)
                  synp-fn
                  '<a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>))
              gstack)
            <span class="keyword">:ttree</span> ttree
            <span class="keyword">:unify-subst</span> unify-subst)
          nil)))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val latches)
      (<a class="sym-link local-def" href="#def-ev-synp" data-sym="EV-SYNP" title="(defun ev-synp (synp-term unify-subst mfc state)
  (let* ((unify-subst1
          (if mfc
              (cons (cons &#39;mfc mfc) unify-subst)
              unify-subst))
...">ev-synp</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">3</span>) unify-subst mfc state)
      (declare (ignore latches))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> erp (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> val)) (let ((sym (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> mfc) synp-fn)
                 ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> synp-fn '<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a>) 'syntaxp-extended)
                 ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> synp-fn '<a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>) 'bind-free-extended)
                 (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> synp-fn))))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> sym erp val) unify-subst ttree)))
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> synp-fn '<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                nil
                unify-subst
                (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a> nil nil wrld) ttree)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                  'relieve-hyp
                  <span class="string">"The evaluation of the SYNTAXP test in :HYP ~x0 of ~
                         rule ~x1 produced something other than t or nil, ~
                         ~x2. This was unexpected and is illegal.  Please ~
                         contact the maintainers of ACL2 with a description ~
                         of the situation that led to this message."</span>
                  (<a class="sym-link local-def" href="#def-get-evg" data-sym="GET-EVG" title="(defun get-evg (q ctx)
  (if (quotep q)
      (cadr q)
      (er hard ctx
          &quot;We expected a quotep in this context, variables, but ~x0 is not a ~
...">get-evg</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">1</span>) 'relieve-hyp)
                  rune
                  val)
                nil
                unify-subst
                ttree))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((info (<a class="sym-link local-def" href="#def-bind-free-info" data-sym="BIND-FREE-INFO" title="(defun bind-free-info (x unify-subst vars-to-be-bound wrld)
  (cond
   ((and (true-listp x) (alistp (car x)))
    (or
     (bad-synp-alist1-lst x unify-subst
...">bind-free-info</a> val unify-subst (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">1</span>) wrld)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> info nil) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                  nil
                  (<a class="sym-link local-def" href="#def-extend-unify-subst" data-sym="EXTEND-UNIFY-SUBST" title="(defun extend-unify-subst (alist unify-subst)
  (append (pairlis$ (strip-cars alist) (quote-normal-form (strip-cdrs alist)))
          unify-subst))">extend-unify-subst</a> val unify-subst)
                  (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a> nil nil wrld) ttree)))
              ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> info <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <span class="keyword">:unify-subst-list</span> nil
                  val
                  (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a> nil nil wrld) ttree)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                    'relieve-hyp
                    <span class="string">"The evaluation of the BIND-FREE form in ~
                             hypothesis ~p0 of rule ~x1 produced the result ~
                             ~x2, which is illegal because ~@3."</span>
                    (untranslate hyp0 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld)
                    rune
                    val
                    info)
                  nil
                  unify-subst
                  ttree)))))))))</pre>
  </div>

<div class="form-block macro" id="def-push-lemma_2B" data-defines="PUSH-LEMMA+" data-references="PUSH-LEMMA,SPLITTER-IF-INTRO,ADD-TO-TAG-TREE,LET,T,IF,QUOTE,FFNNAMEP-HIDE,REWRITE-CONSTANT,ACCESS,NULL,AND,COND,QUASIQUOTE,REWRITTEN-RHS,RHS,ANCESTORS,RCNST,TTREE,RUNE,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-LEMMA+">push-lemma+</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a>
  (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ,ANCESTORS)
       (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant ,RCNST <span class="keyword">:splitter-output</span>)
       (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> 'if ,RHS <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
       (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> 'if ,REWRITTEN-RHS <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)) (let ((rune ,RUNE) (ttree ,TTREE))
        (add-to-tag-tree 'splitter-if-intro
          rune
          (push-lemma rune ttree))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (push-lemma ,RUNE ,TTREE))))</pre>
  </div>

<div class="form-block macro" id="def-push-splitter_3F" data-defines="PUSH-SPLITTER?" data-references="SPLITTER-IF-INTRO,ADD-TO-TAG-TREE,T,IF,QUOTE,FFNNAMEP-HIDE,REWRITE-CONSTANT,ACCESS,NULL,AND,COND,QUASIQUOTE,SYMBOLP,XARGS,DECLARE,REWRITTEN-RHS,RHS,ANCESTORS,RCNST,TTREE,RUNE,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-SPLITTER?">push-splitter?</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-push-splitter_3F" data-sym="PUSH-SPLITTER?" title="(defmacro push-splitter? (rune ttree rcnst ancestors rhs rewritten-rhs)
  (declare (xargs :guard (symbolp rune)))
  `(cond
    ((and ,rune (null ,ancestors)
          (access rewrite-constant ,rcnst :splitter-output)
...">push-splitter?</a>
  (rune ttree rcnst ancestors rhs rewritten-rhs)
  (declare (xargs <span class="keyword">:guard</span> (symbolp rune)))
  `(<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ,RUNE
       (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ,ANCESTORS)
       (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant ,RCNST <span class="keyword">:splitter-output</span>)
       (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> 'if ,RHS <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
       (<a class="sym-link local-def" href="#def-ffnnamep-hide" data-sym="FFNNAMEP-HIDE" title="(mutual-recursion
 (defun ffnnamep-hide (fn term lambda-exp)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
          (or (equal fn (ffn-symb term))
...">ffnnamep-hide</a> 'if ,REWRITTEN-RHS <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)) (add-to-tag-tree 'splitter-if-intro ,RUNE ,TTREE))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ,TTREE)))</pre>
  </div>

<div class="form-block macro" id="def-prepend-step-limit" data-defines="PREPEND-STEP-LIMIT" data-references="STEP-LIMIT,MV,MV-LET,QUASIQUOTE,X,QUOTE,MAKE-VAR-LST,CONSP,IF,VARS,LET,FORM,N,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="PREPEND-STEP-LIMIT">prepend-step-limit</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a>
  (n form)
  (let ((vars (if (consp n)
         n
         (<a class="sym-link system" href="axioms.html#def-make-var-lst" data-sym="MAKE-VAR-LST">make-var-lst</a> 'x n))))
    `(<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> ,VARS ,FORM (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit ,@VARS))))</pre>
  </div>

<div class="form-block other" id="form-374" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defrec" data-sym="DEFREC">defrec</a> rw-cache-entry
  ((step-limit . failure-reason) unify-subst . hyp-info)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block macro" id="def-free-failure-p" data-defines="FREE-FAILURE-P" data-references="CAR,EQ,QUASIQUOTE,R,DEFMACRO" data-used-by="REWRITE,RW-CACHED-FAILURE-PAIR,NOTE-RW-CACHE-FREE-NIL-TAG,MERGE-FREE-FAILURE-ALISTS-NIL-TAG,RW-CACHE-ALIST-NIL-TAG-P,REPLACE-FREE-RW-CACHE-ENTRY1,RW-CACHE-LIST-LOOKUP,COMBINE-SORTED-RW-CACHE-LISTS1,COMBINE-FREE-FAILURE-ALISTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="FREE-FAILURE-P">free-failure-p</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> (r) `(<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car ,R) <span class="keyword">:rw-cache-alist</span>))</pre>
  </div>

<div class="form-block other" id="def-combine-free-failure-reasons" data-defines="COMBINE-FREE-FAILURE-REASONS" data-references="CONS,T,MV,COND,CDR,COMBINE-FREE-FAILURE-ALISTS,ALIST,FLG,MV-LET,R2,R1,DEFABBREV" data-used-by="COMBINE-SORTED-RW-CACHE-LISTS1,COMBINE-FREE-FAILURE-ALISTS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-FREE-FAILURE-REASONS">combine-free-failure-reasons</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-combine-free-failure-reasons" data-sym="COMBINE-FREE-FAILURE-REASONS" title="(defabbrev combine-free-failure-reasons (r1 r2)
           (mv-let (flg alist) (combine-free-failure-alists (cdr r1) (cdr r2))
                   (cond (flg (mv t r2))
                         (t (mv nil (cons :rw-cache-alist alist))))))">combine-free-failure-reasons</a>
  (r1 r2)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
    (<a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a> (cdr r1) (cdr r2))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> r2))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons <span class="keyword">:rw-cache-alist</span> alist))))))</pre>
  </div>

<div class="form-block function" id="def-combine-free-failure-alists" data-defines="COMBINE-FREE-FAILURE-ALISTS" data-references="CAR,CONS,IGNORE,DECLARE,ALIST,COMBINE-FREE-FAILURE-REASONS,NEW-REASON,FLG2,PUT-ASSOC-EQUAL,FREE-FAILURE-P,NOT,FLG,MV-LET,CDR,FAILURE-REASON-2,CDAR,FAILURE-REASON-1,CAAR,ASSOC-EQUAL,PAIR,LET,T,MV,ENDP,COND,A2,A1,DEFUN" data-used-by="NOTE-RELIEVE-HYPS-FAILURE-FREE,COMBINE-FREE-FAILURE-REASONS" data-part-name="COMBINE-FREE-FAILURE-ALISTS" data-part-args="A2,A1" data-part-body="CAR,CONS,IGNORE,DECLARE,ALIST,COMBINE-FREE-FAILURE-ALISTS,COMBINE-FREE-FAILURE-REASONS,NEW-REASON,FLG2,PUT-ASSOC-EQUAL,FREE-FAILURE-P,NOT,FLG,MV-LET,CDR,FAILURE-REASON-2,CDAR,FAILURE-REASON-1,CAAR,ASSOC-EQUAL,PAIR,LET,A2,T,MV,A1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-FREE-FAILURE-ALISTS">combine-free-failure-alists</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a>
  (a1 a2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> a1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) a2)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair (let ((failure-reason-1 (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> a1)) (failure-reason-2 (cdr pair)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg a2)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason-2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
                  ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason-1)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) failure-reason-1 a2)))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg2 new-reason)
                      (<a class="sym-link local-def" href="#def-combine-free-failure-reasons" data-sym="COMBINE-FREE-FAILURE-REASONS" title="(defabbrev combine-free-failure-reasons (r1 r2)
           (mv-let (flg alist) (combine-free-failure-alists (cdr r1) (cdr r2))
                   (cond (flg (mv t r2))
                         (t (mv nil (cons :rw-cache-alist alist))))))">combine-free-failure-reasons</a> failure-reason-1
                        failure-reason-2)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg2 (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) new-reason a2)))))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a> (cdr a1) a2))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
                      (<a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a> (cdr a1) a2)
                      (declare (ignore flg))
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
              (<a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a> (cdr a1) a2)
              (declare (ignore flg))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car a1) alist)))))))))</pre>
  </div>

<div class="form-block function" id="def-combine-sorted-rw-cache-lists1" data-defines="COMBINE-SORTED-RW-CACHE-LISTS1" data-references="IGNORE,DECLARE,LEXORDER,CHANGE,CONS,COMBINE-FREE-FAILURE-REASONS,FAILURE-REASON,FLG2,FREE-FAILURE-P,R2,R1,LET,CDR,LST,FLG,MV-LET,CAR,RW-CACHE-ENTRY,ACCESS,EQUAL,AND,T,MV,ENDP,COND,L2,L1,DEFUN" data-used-by="COMBINE-RW-CACHE-LISTS,SORT-RW-CACHE-LIST" data-part-name="COMBINE-SORTED-RW-CACHE-LISTS1" data-part-args="L2,L1" data-part-body="IGNORE,DECLARE,LEXORDER,CHANGE,CONS,COMBINE-FREE-FAILURE-REASONS,FAILURE-REASON,FLG2,FREE-FAILURE-P,R2,R1,LET,CDR,COMBINE-SORTED-RW-CACHE-LISTS1,LST,FLG,MV-LET,CAR,RW-CACHE-ENTRY,ACCESS,EQUAL,AND,L2,T,MV,L1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1">combine-sorted-rw-cache-lists1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a>
  (l1 l2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> l2))
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil l1))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l1) <span class="keyword">:unify-subst</span>)
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l2) <span class="keyword">:unify-subst</span>))
       (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l1) <span class="keyword">:hyp-info</span>)
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l2) <span class="keyword">:hyp-info</span>))) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg lst)
        (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> (cdr l1) (cdr l2))
        (let ((r1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l1) <span class="keyword">:failure-reason</span>)) (r2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car l2) <span class="keyword">:failure-reason</span>)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> r1) (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> r2)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg2 failure-reason)
                (<a class="sym-link local-def" href="#def-combine-free-failure-reasons" data-sym="COMBINE-FREE-FAILURE-REASONS" title="(defabbrev combine-free-failure-reasons (r1 r2)
           (mv-let (flg alist) (combine-free-failure-alists (cdr r1) (cdr r2))
                   (cond (flg (mv t r2))
                         (t (mv nil (cons :rw-cache-alist alist))))))">combine-free-failure-reasons</a> r1 r2)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg flg2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> l2))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                      (cons (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rw-cache-entry
                          (car l2)
                          <span class="keyword">:failure-reason</span> failure-reason)
                        lst))))))
            (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> flg l2))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car l2) lst)))))))
    ((<a class="sym-link system" href="axioms.html#def-lexorder" data-sym="LEXORDER">lexorder</a> (car l1) (car l2)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg lst)
        (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> (cdr l1) l2)
        (declare (ignore flg))
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car l1) lst))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg lst)
        (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> l1 (cdr l2))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> l2)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car l2) lst))))))))</pre>
  </div>

<div class="form-block function" id="def-split-psorted-list1" data-defines="SPLIT-PSORTED-LIST1" data-references="CONS,CDR,MEMBER-EQ,NOT,ASSERT$,T,CAR,EQ,MV,ENDP,COND,ACC,LST,DEFUN" data-used-by="SPLIT-PSORTED-LIST" data-part-name="SPLIT-PSORTED-LIST1" data-part-args="ACC,LST" data-part-body="CONS,SPLIT-PSORTED-LIST1,CDR,MEMBER-EQ,NOT,ASSERT$,T,CAR,EQ,ACC,MV,LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLIT-PSORTED-LIST1">split-psorted-list1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-split-psorted-list1" data-sym="SPLIT-PSORTED-LIST1" title="(defun split-psorted-list1 (lst acc)
  (cond ((endp lst) (mv acc nil))
        ((eq (car lst) t)
         (assert$ (not (member-eq t (cdr lst))) (mv acc (cdr lst))))
        (t (split-psorted-list1 (cdr lst) (cons (car lst) acc)))))">split-psorted-list1</a>
  (lst acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> acc nil))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cdr lst))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> acc (cdr lst))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-split-psorted-list1" data-sym="SPLIT-PSORTED-LIST1" title="(defun split-psorted-list1 (lst acc)
  (cond ((endp lst) (mv acc nil))
        ((eq (car lst) t)
         (assert$ (not (member-eq t (cdr lst))) (mv acc (cdr lst))))
        (t (split-psorted-list1 (cdr lst) (cons (car lst) acc)))))">split-psorted-list1</a> (cdr lst) (cons (car lst) acc)))))</pre>
  </div>

<div class="form-block function" id="def-split-psorted-list" data-defines="SPLIT-PSORTED-LIST" data-references="MV,CAR,LIST,SPLIT-PSORTED-LIST1,CDR,T,MEMBER-EQ,COND,LST,DEFUN" data-used-by="CDR-SORT-RW-CACHE,SORT-RW-CACHE-LIST" data-part-name="SPLIT-PSORTED-LIST" data-part-args="LST" data-part-body="MV,CAR,LIST,SPLIT-PSORTED-LIST1,LST,CDR,T,MEMBER-EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SPLIT-PSORTED-LIST">split-psorted-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-split-psorted-list" data-sym="SPLIT-PSORTED-LIST" title="(defun split-psorted-list (lst)
  (cond
   ((member-eq t (cdr lst)) (split-psorted-list1 (cdr lst) (list (car lst))))
   (t (mv lst nil))))">split-psorted-list</a>
  (lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cdr lst)) (<a class="sym-link local-def" href="#def-split-psorted-list1" data-sym="SPLIT-PSORTED-LIST1" title="(defun split-psorted-list1 (lst acc)
  (cond ((endp lst) (mv acc nil))
        ((eq (car lst) t)
         (assert$ (not (member-eq t (cdr lst))) (mv acc (cdr lst))))
        (t (split-psorted-list1 (cdr lst) (cons (car lst) acc)))))">split-psorted-list1</a> (cdr lst) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (car lst))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> lst nil))))</pre>
  </div>

<div class="form-block function" id="def-merge-lexorder-fast" data-defines="MERGE-LEXORDER-FAST" data-references="CONS,IGNORE,CDR,X,FLG,MV-LET,CAR,LEXORDER,T,MV,ENDP,COND,LEN,+,TRUE-LISTP,AND,XARGS,DECLARE,L2,L1,DEFUN" data-used-by="MERGE-SORT-LEXORDER-FAST" data-part-name="MERGE-LEXORDER-FAST" data-part-args="L2,L1" data-part-declare="LEN,+,L2,L1,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CONS,IGNORE,DECLARE,CDR,MERGE-LEXORDER-FAST,X,FLG,MV-LET,CAR,LEXORDER,L2,T,MV,L1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-LEXORDER-FAST">merge-lexorder-fast</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-lexorder-fast" data-sym="MERGE-LEXORDER-FAST" title="(defun merge-lexorder-fast (l1 l2)
  (declare
   (xargs :guard (and (true-listp l1) (true-listp l2)) :measure
    (+ (len l1) (len l2))))
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
...">merge-lexorder-fast</a>
  (l1 l2)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> l1) (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> l2))
      <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-_2B" data-sym="+">+</a> (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> l1) (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> l2))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> l2))
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> l2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil l1))
    ((<a class="sym-link system" href="axioms.html#def-lexorder" data-sym="LEXORDER">lexorder</a> (car l1) (car l2)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg x)
        (<a class="sym-link local-def" href="#def-merge-lexorder-fast" data-sym="MERGE-LEXORDER-FAST" title="(defun merge-lexorder-fast (l1 l2)
  (declare
   (xargs :guard (and (true-listp l1) (true-listp l2)) :measure
    (+ (len l1) (len l2))))
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
...">merge-lexorder-fast</a> (cdr l1) l2)
        (declare (ignore flg))
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car l1) x))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg x)
        (<a class="sym-link local-def" href="#def-merge-lexorder-fast" data-sym="MERGE-LEXORDER-FAST" title="(defun merge-lexorder-fast (l1 l2)
  (declare
   (xargs :guard (and (true-listp l1) (true-listp l2)) :measure
    (+ (len l1) (len l2))))
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
...">merge-lexorder-fast</a> l1 (cdr l2))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> l2)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car l2) x))))))))</pre>
  </div>

<div class="form-block function" id="def-merge-sort-lexorder-fast" data-defines="MERGE-SORT-LEXORDER-FAST" data-references="IGNORE,NTHCDR,TAKE,MERGE-LEXORDER-FAST,X,FLG,MV-LET,ASH,A,LENGTH,N,LET*,LIST,T,CADR,CAR,LEXORDER,CDDR,CDR,ENDP,COND,LEN,TRUE-LISTP,XARGS,DECLARE,L,DEFUN" data-used-by="SORT-RW-CACHE-LIST" data-part-name="MERGE-SORT-LEXORDER-FAST" data-part-args="L" data-part-declare="LEN,L,TRUE-LISTP,XARGS,DECLARE" data-part-body="IGNORE,DECLARE,NTHCDR,TAKE,MERGE-SORT-LEXORDER-FAST,MERGE-LEXORDER-FAST,X,FLG,MV-LET,ASH,A,LENGTH,N,LET*,LIST,T,CADR,CAR,LEXORDER,CDDR,L,CDR,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-SORT-LEXORDER-FAST">merge-sort-lexorder-fast</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-sort-lexorder-fast" data-sym="MERGE-SORT-LEXORDER-FAST" title="(defun merge-sort-lexorder-fast (l)
  (declare (xargs :guard (true-listp l) :measure (len l)))
  (cond ((endp (cdr l)) l)
        ((endp (cddr l))
         (cond ((lexorder (car l) (cadr l)) l) (t (list (cadr l) (car l)))))
...">merge-sort-lexorder-fast</a>
  (l)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> l) <span class="keyword">:measure</span> (<a class="sym-link system" href="axioms.html#def-len" data-sym="LEN">len</a> l)))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> (cdr l)) l)
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> l)) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-lexorder" data-sym="LEXORDER">lexorder</a> (car l) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> l)) l)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> l) (car l)))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((n (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> l)) (a (ash n <span class="number">-1</span>)))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg x)
          (<a class="sym-link local-def" href="#def-merge-lexorder-fast" data-sym="MERGE-LEXORDER-FAST" title="(defun merge-lexorder-fast (l1 l2)
  (declare
   (xargs :guard (and (true-listp l1) (true-listp l2)) :measure
    (+ (len l1) (len l2))))
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
...">merge-lexorder-fast</a> (<a class="sym-link local-def" href="#def-merge-sort-lexorder-fast" data-sym="MERGE-SORT-LEXORDER-FAST" title="(defun merge-sort-lexorder-fast (l)
  (declare (xargs :guard (true-listp l) :measure (len l)))
  (cond ((endp (cdr l)) l)
        ((endp (cddr l))
         (cond ((lexorder (car l) (cadr l)) l) (t (list (cadr l) (car l)))))
...">merge-sort-lexorder-fast</a> (<a class="sym-link system" href="axioms.html#def-take" data-sym="TAKE">take</a> a l))
            (<a class="sym-link local-def" href="#def-merge-sort-lexorder-fast" data-sym="MERGE-SORT-LEXORDER-FAST" title="(defun merge-sort-lexorder-fast (l)
  (declare (xargs :guard (true-listp l) :measure (len l)))
  (cond ((endp (cdr l)) l)
        ((endp (cddr l))
         (cond ((lexorder (car l) (cadr l)) l) (t (list (cadr l) (car l)))))
...">merge-sort-lexorder-fast</a> (<a class="sym-link system" href="axioms.html#def-nthcdr" data-sym="NTHCDR">nthcdr</a> a l)))
          (declare (ignore flg))
          x)))))</pre>
  </div>

<div class="form-block function" id="def-sort-rw-cache-list" data-defines="SORT-RW-CACHE-LIST" data-references="IGNORE,DECLARE,MERGE-SORT-LEXORDER-FAST,COMBINE-SORTED-RW-CACHE-LISTS1,ANS,FLG,SPLIT-PSORTED-LIST,BACK,FRONT,MV-LET,NULL,CDR,T,CAR,EQ,COND,LST,DEFUN" data-used-by="COMBINE-RW-CACHE-LISTS" data-part-name="SORT-RW-CACHE-LIST" data-part-args="LST" data-part-body="IGNORE,DECLARE,MERGE-SORT-LEXORDER-FAST,COMBINE-SORTED-RW-CACHE-LISTS1,ANS,FLG,SPLIT-PSORTED-LIST,BACK,FRONT,MV-LET,NULL,CDR,T,LST,CAR,EQ,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORT-RW-CACHE-LIST">sort-rw-cache-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-sort-rw-cache-list" data-sym="SORT-RW-CACHE-LIST" title="(defun sort-rw-cache-list (lst)
  (cond ((eq (car lst) t) (cdr lst)) ((null (cdr lst)) lst)
        (t
         (mv-let (front back) (split-psorted-list lst)
                 (mv-let (flg ans)
...">sort-rw-cache-list</a>
  (lst)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (cdr lst))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr lst)) lst)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (front back)
        (<a class="sym-link local-def" href="#def-split-psorted-list" data-sym="SPLIT-PSORTED-LIST" title="(defun split-psorted-list (lst)
  (cond
   ((member-eq t (cdr lst)) (split-psorted-list1 (cdr lst) (list (car lst))))
   (t (mv lst nil))))">split-psorted-list</a> lst)
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg ans)
          (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> (<a class="sym-link local-def" href="#def-merge-sort-lexorder-fast" data-sym="MERGE-SORT-LEXORDER-FAST" title="(defun merge-sort-lexorder-fast (l)
  (declare (xargs :guard (true-listp l) :measure (len l)))
  (cond ((endp (cdr l)) l)
        ((endp (cddr l))
         (cond ((lexorder (car l) (cadr l)) l) (t (list (cadr l) (car l)))))
...">merge-sort-lexorder-fast</a> front)
            back)
          (declare (ignore flg))
          ans)))))</pre>
  </div>

<div class="form-block function" id="def-combine-rw-cache-lists" data-defines="COMBINE-RW-CACHE-LISTS" data-references="IGNORE,DECLARE,CONS,CDR,SORT-RW-CACHE-LIST,COMBINE-SORTED-RW-CACHE-LISTS1,ANS,FLG,MV-LET,CAR,EQ,T,MV,NULL,COND,LST2,LST1,DEFUN" data-used-by="MERGE-RW-CACHES" data-part-name="COMBINE-RW-CACHE-LISTS" data-part-args="LST2,LST1" data-part-body="IGNORE,DECLARE,CONS,CDR,SORT-RW-CACHE-LIST,COMBINE-SORTED-RW-CACHE-LISTS1,ANS,FLG,MV-LET,CAR,EQ,LST2,T,MV,LST1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-RW-CACHE-LISTS">combine-rw-cache-lists</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-combine-rw-cache-lists" data-sym="COMBINE-RW-CACHE-LISTS" title="(defun combine-rw-cache-lists (lst1 lst2)
  (cond ((null lst1) (mv t lst2)) ((null lst2) (mv nil lst1))
        ((eq (car lst2) t)
         (mv-let (flg ans)
                 (combine-sorted-rw-cache-lists1 (sort-rw-cache-list lst1)
...">combine-rw-cache-lists</a>
  (lst1 lst2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> lst2))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil lst1))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car lst2) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg ans)
        (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> (<a class="sym-link local-def" href="#def-sort-rw-cache-list" data-sym="SORT-RW-CACHE-LIST" title="(defun sort-rw-cache-list (lst)
  (cond ((eq (car lst) t) (cdr lst)) ((null (cdr lst)) lst)
        (t
         (mv-let (front back) (split-psorted-list lst)
                 (mv-let (flg ans)
...">sort-rw-cache-list</a> lst1)
          (cdr lst2))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> lst2)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ans))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
        (cons <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg ans)
            (<a class="sym-link local-def" href="#def-combine-sorted-rw-cache-lists1" data-sym="COMBINE-SORTED-RW-CACHE-LISTS1" title="(defun combine-sorted-rw-cache-lists1 (l1 l2)
  (cond ((endp l1) (mv t l2)) ((endp l2) (mv nil l1))
        ((and
          (equal (access rw-cache-entry (car l1) :unify-subst)
                 (access rw-cache-entry (car l2) :unify-subst))
...">combine-sorted-rw-cache-lists1</a> (<a class="sym-link local-def" href="#def-sort-rw-cache-list" data-sym="SORT-RW-CACHE-LIST" title="(defun sort-rw-cache-list (lst)
  (cond ((eq (car lst) t) (cdr lst)) ((null (cdr lst)) lst)
        (t
         (mv-let (front back) (split-psorted-list lst)
                 (mv-let (flg ans)
...">sort-rw-cache-list</a> lst1)
              (<a class="sym-link local-def" href="#def-sort-rw-cache-list" data-sym="SORT-RW-CACHE-LIST" title="(defun sort-rw-cache-list (lst)
  (cond ((eq (car lst) t) (cdr lst)) ((null (cdr lst)) lst)
        (t
         (mv-let (front back) (split-psorted-list lst)
                 (mv-let (flg ans)
...">sort-rw-cache-list</a> lst2))
            (declare (ignore flg))
            ans))))))</pre>
  </div>

<div class="form-block function" id="def-merge-rw-caches" data-defines="MERGE-RW-CACHES" data-references="IGNORE,DECLARE,SYMBOL<,ACONS,CAR,CONS,AND,CDAR,COMBINE-RW-CACHE-LISTS,OBJS,FLG2,CDR,REST,FLG,MV-LET,CAAR,EQ,T,MV,ENDP,COND,ALIST2,ALIST1,DEFUN" data-used-by="COMBINE-RW-CACHES,CDR-SORT-RW-CACHE" data-part-name="MERGE-RW-CACHES" data-part-args="ALIST2,ALIST1" data-part-body="IGNORE,DECLARE,SYMBOL<,ACONS,CAR,CONS,AND,CDAR,COMBINE-RW-CACHE-LISTS,OBJS,FLG2,CDR,MERGE-RW-CACHES,REST,FLG,MV-LET,CAAR,EQ,ALIST2,T,MV,ALIST1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-RW-CACHES">merge-rw-caches</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a>
  (alist1 alist2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist2))
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist1))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist1) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist2)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a> (cdr alist1) (cdr alist2))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg2 objs)
          (<a class="sym-link local-def" href="#def-combine-rw-cache-lists" data-sym="COMBINE-RW-CACHE-LISTS" title="(defun combine-rw-cache-lists (lst1 lst2)
  (cond ((null lst1) (mv t lst2)) ((null lst2) (mv nil lst1))
        ((eq (car lst2) t)
         (mv-let (flg ans)
                 (combine-sorted-rw-cache-lists1 (sort-rw-cache-list lst1)
...">combine-rw-cache-lists</a> (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist1) (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist2))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg flg2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist2))
            (flg2 (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car alist2) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist2) objs <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))))))
    ((<a class="sym-link system" href="axioms.html#def-symbol_3C" data-sym="SYMBOL&lt;">symbol&lt;</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist1) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist2)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a> (cdr alist1) alist2)
        (declare (ignore flg))
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car alist1) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a> alist1 (cdr alist2))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist2))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons (car alist2) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>))))))))</pre>
  </div>

<div class="form-block macro" id="def-sorted-rw-cache-p" data-defines="SORTED-RW-CACHE-P" data-references="T,CAR,EQ,QUASIQUOTE,CACHE,DEFMACRO" data-used-by="NORMALIZE-RW-ANY-CACHE,COMBINE-RW-CACHES,CDR-SORT-RW-CACHE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SORTED-RW-CACHE-P">sorted-rw-cache-p</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-sorted-rw-cache-p" data-sym="SORTED-RW-CACHE-P" title="(defmacro sorted-rw-cache-p (cache) `(eq (car ,cache) t))">sorted-rw-cache-p</a> (cache) `(<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car ,CACHE) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))</pre>
  </div>

<div class="form-block function" id="def-cdr-sort-rw-cache" data-defines="CDR-SORT-RW-CACHE" data-references="IGNORE,DECLARE,MERGE-SORT-SYMBOL-ALISTP,MERGE-RW-CACHES,ANS,FLG,SPLIT-PSORTED-LIST,BACK,FRONT,MV-LET,T,CDR,SORTED-RW-CACHE-P,COND,ASSERT$,CACHE,DEFUN" data-used-by="NORMALIZE-RW-ANY-CACHE,COMBINE-RW-CACHES" data-part-name="CDR-SORT-RW-CACHE" data-part-args="CACHE" data-part-body="IGNORE,DECLARE,MERGE-SORT-SYMBOL-ALISTP,MERGE-RW-CACHES,ANS,FLG,SPLIT-PSORTED-LIST,BACK,FRONT,MV-LET,T,CDR,SORTED-RW-CACHE-P,COND,CACHE,ASSERT$" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CDR-SORT-RW-CACHE">cdr-sort-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cdr-sort-rw-cache" data-sym="CDR-SORT-RW-CACHE" title="(defun cdr-sort-rw-cache (cache)
  (assert$ cache
           (cond ((sorted-rw-cache-p cache) (cdr cache))
                 (t
                  (mv-let (front back) (split-psorted-list cache)
...">cdr-sort-rw-cache</a>
  (cache)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> cache
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-sorted-rw-cache-p" data-sym="SORTED-RW-CACHE-P" title="(defmacro sorted-rw-cache-p (cache) `(eq (car ,cache) t))">sorted-rw-cache-p</a> cache) (cdr cache))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (front back)
          (<a class="sym-link local-def" href="#def-split-psorted-list" data-sym="SPLIT-PSORTED-LIST" title="(defun split-psorted-list (lst)
  (cond
   ((member-eq t (cdr lst)) (split-psorted-list1 (cdr lst) (list (car lst))))
   (t (mv lst nil))))">split-psorted-list</a> cache)
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg ans)
            (<a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a> (<a class="sym-link system" href="axioms.html#def-merge-sort-symbol-alistp" data-sym="MERGE-SORT-SYMBOL-ALISTP">merge-sort-symbol-alistp</a> front) back)
            (declare (ignore flg))
            ans))))))</pre>
  </div>

<div class="form-block function" id="def-combine-rw-caches" data-defines="COMBINE-RW-CACHES" data-references="CONS,SORTED-RW-CACHE-P,AND,CDR-SORT-RW-CACHE,MERGE-RW-CACHES,X,FLG,MV-LET,T,MV,NULL,COND,C2,C1,DEFUN" data-used-by="CONS-TAG-TREES-RW-CACHE,RW-CACHE-EXIT-CONTEXT,ACCUMULATE-RW-CACHE1" data-part-name="COMBINE-RW-CACHES" data-part-args="C2,C1" data-part-body="CONS,SORTED-RW-CACHE-P,AND,CDR-SORT-RW-CACHE,MERGE-RW-CACHES,X,FLG,MV-LET,C2,T,MV,C1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COMBINE-RW-CACHES">combine-rw-caches</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a>
  (c1 c2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> c1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> c2))
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> c2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil c1))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg x)
        (<a class="sym-link local-def" href="#def-merge-rw-caches" data-sym="MERGE-RW-CACHES" title="(defun merge-rw-caches (alist1 alist2)
  (cond ((endp alist1) (mv t alist2)) ((endp alist2) (mv nil alist1))
        ((eq (caar alist1) (caar alist2))
         (mv-let (flg rest) (merge-rw-caches (cdr alist1) (cdr alist2))
                 (mv-let (flg2 objs)
...">merge-rw-caches</a> (<a class="sym-link local-def" href="#def-cdr-sort-rw-cache" data-sym="CDR-SORT-RW-CACHE" title="(defun cdr-sort-rw-cache (cache)
  (assert$ cache
           (cond ((sorted-rw-cache-p cache) (cdr cache))
                 (t
                  (mv-let (front back) (split-psorted-list cache)
...">cdr-sort-rw-cache</a> c1)
          (<a class="sym-link local-def" href="#def-cdr-sort-rw-cache" data-sym="CDR-SORT-RW-CACHE" title="(defun cdr-sort-rw-cache (cache)
  (assert$ cache
           (cond ((sorted-rw-cache-p cache) (cdr cache))
                 (t
                  (mv-let (front back) (split-psorted-list cache)
...">cdr-sort-rw-cache</a> c2))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> flg (<a class="sym-link local-def" href="#def-sorted-rw-cache-p" data-sym="SORTED-RW-CACHE-P" title="(defmacro sorted-rw-cache-p (cache) `(eq (car ,cache) t))">sorted-rw-cache-p</a> c2)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> c2))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> x))))))))</pre>
  </div>

<div class="form-block function" id="def-unify-subst-subsetp" data-defines="UNIFY-SUBST-SUBSETP" data-references="CDR,CDAR,EQUAL,AND,CAAR,EQ,T,ENDP,COND,A2,A1,DEFUN" data-used-by="RW-CACHE-LIST-LOOKUP" data-part-name="UNIFY-SUBST-SUBSETP" data-part-args="A2,A1" data-part-body="CDR,UNIFY-SUBST-SUBSETP,CDAR,EQUAL,AND,CAAR,EQ,A2,T,A1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="UNIFY-SUBST-SUBSETP">unify-subst-subsetp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-unify-subst-subsetp" data-sym="UNIFY-SUBST-SUBSETP" title="(defun unify-subst-subsetp (a1 a2)
  (cond ((endp a1) t) ((endp a2) nil)
        ((eq (caar a1) (caar a2))
         (and (equal (cdar a1) (cdar a2))
              (unify-subst-subsetp (cdr a1) (cdr a2))))">unify-subst-subsetp</a>
  (a1 a2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> a1) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> a2) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a2)) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> a1) (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> a2))
        (<a class="sym-link local-def" href="#def-unify-subst-subsetp" data-sym="UNIFY-SUBST-SUBSETP" title="(defun unify-subst-subsetp (a1 a2)
  (cond ((endp a1) t) ((endp a2) nil)
        ((eq (caar a1) (caar a2))
         (and (equal (cdar a1) (cdar a2))
              (unify-subst-subsetp (cdr a1) (cdr a2))))">unify-subst-subsetp</a> (cdr a1) (cdr a2))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-unify-subst-subsetp" data-sym="UNIFY-SUBST-SUBSETP" title="(defun unify-subst-subsetp (a1 a2)
  (cond ((endp a1) t) ((endp a2) nil)
        ((eq (caar a1) (caar a2))
         (and (equal (cdar a1) (cdar a2))
              (unify-subst-subsetp (cdr a1) (cdr a2))))">unify-subst-subsetp</a> a1 (cdr a2)))))</pre>
  </div>

<div class="form-block function" id="def-rw-cache-list-lookup" data-defines="RW-CACHE-LIST-LOOKUP" data-references="UNIFY-SUBST-SUBSETP,1-,NTH,EQUAL,FREE-FAILURE-P,AND,HYP-INFO,RW-CACHE-ENTRY,ACCESS,FAILURE-REASON,REC,LET*,CDR,T,CAR,EQ,ENDP,COND,RECS,HYPS,UNIFY-SUBST,DEFUN" data-used-by="NOTE-RW-CACHE-FREE-NIL-TAG,RELIEVE-HYP-FAILURE-ENTRY" data-part-name="RW-CACHE-LIST-LOOKUP" data-part-args="RECS,HYPS,UNIFY-SUBST" data-part-body="UNIFY-SUBST-SUBSETP,1-,NTH,EQUAL,FREE-FAILURE-P,AND,HYP-INFO,RW-CACHE-ENTRY,ACCESS,FAILURE-REASON,REC,LET*,CDR,HYPS,UNIFY-SUBST,RW-CACHE-LIST-LOOKUP,T,CAR,EQ,RECS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-LIST-LOOKUP">rw-cache-list-lookup</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-list-lookup" data-sym="RW-CACHE-LIST-LOOKUP" title="(defun rw-cache-list-lookup (unify-subst hyps recs)
  (cond ((endp recs) nil)
        ((eq (car recs) t) (rw-cache-list-lookup unify-subst hyps (cdr recs)))
        ((let* ((rec (car recs))
                (failure-reason (access rw-cache-entry rec :failure-reason))
...">rw-cache-list-lookup</a>
  (unify-subst hyps recs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> recs) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car recs) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-rw-cache-list-lookup" data-sym="RW-CACHE-LIST-LOOKUP" title="(defun rw-cache-list-lookup (unify-subst hyps recs)
  (cond ((endp recs) nil)
        ((eq (car recs) t) (rw-cache-list-lookup unify-subst hyps (cdr recs)))
        ((let* ((rec (car recs))
                (failure-reason (access rw-cache-entry rec :failure-reason))
...">rw-cache-list-lookup</a> unify-subst hyps (cdr recs)))
    ((<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((rec (car recs)) (failure-reason (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry rec <span class="keyword">:failure-reason</span>))
         (hyp-info (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry rec <span class="keyword">:hyp-info</span>)))
       (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal hyps hyp-info)
               (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry rec <span class="keyword">:unify-subst</span>) unify-subst)))
           (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (equal hyp-info (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (car failure-reason)) hyps))
               (<a class="sym-link local-def" href="#def-unify-subst-subsetp" data-sym="UNIFY-SUBST-SUBSETP" title="(defun unify-subst-subsetp (a1 a2)
  (cond ((endp a1) t) ((endp a2) nil)
        ((eq (caar a1) (caar a2))
         (and (equal (cdar a1) (cdar a2))
              (unify-subst-subsetp (cdr a1) (cdr a2))))">unify-subst-subsetp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry rec <span class="keyword">:unify-subst</span>)
                 unify-subst))))
         rec)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rw-cache-list-lookup" data-sym="RW-CACHE-LIST-LOOKUP" title="(defun rw-cache-list-lookup (unify-subst hyps recs)
  (cond ((endp recs) nil)
        ((eq (car recs) t) (rw-cache-list-lookup unify-subst hyps (cdr recs)))
        ((let* ((rec (car recs))
                (failure-reason (access rw-cache-entry rec :failure-reason))
...">rw-cache-list-lookup</a> unify-subst hyps (cdr recs)))))</pre>
  </div>

<div class="form-block other" id="form-391" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> relieve-hyp-failure-entry-skip-p
  (rune unify-subst hyps ttree step-limit)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-relieve-hyp-failure-entry-skip-p-builtin" data-defines="RELIEVE-HYP-FAILURE-ENTRY-SKIP-P-BUILTIN" data-references="T,XARGS,IGNORE,DECLARE,STEP-LIMIT,TTREE,HYPS,UNIFY-SUBST,RUNE,DEFUN" data-part-name="RELIEVE-HYP-FAILURE-ENTRY-SKIP-P-BUILTIN" data-part-args="STEP-LIMIT,TTREE,HYPS,UNIFY-SUBST,RUNE" data-part-declare="T,XARGS,STEP-LIMIT,TTREE,HYPS,UNIFY-SUBST,RUNE,IGNORE,DECLARE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RELIEVE-HYP-FAILURE-ENTRY-SKIP-P-BUILTIN">relieve-hyp-failure-entry-skip-p-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-relieve-hyp-failure-entry-skip-p-builtin" data-sym="RELIEVE-HYP-FAILURE-ENTRY-SKIP-P-BUILTIN" title="(defun relieve-hyp-failure-entry-skip-p-builtin
       (rune unify-subst hyps ttree step-limit)
  (declare (ignore rune unify-subst hyps ttree step-limit)
           (xargs :mode :logic :guard t))
  nil)">relieve-hyp-failure-entry-skip-p-builtin</a>
  (rune unify-subst hyps ttree step-limit)
  (declare (ignore rune unify-subst hyps ttree step-limit)
    (xargs <span class="keyword">:mode</span> <span class="keyword">:logic</span> <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  nil)</pre>
  </div>

<div class="form-block other" id="form-393" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (relieve-hyp-failure-entry-skip-p <a class="sym-link local-def" href="#def-relieve-hyp-failure-entry-skip-p-builtin" data-sym="RELIEVE-HYP-FAILURE-ENTRY-SKIP-P-BUILTIN" title="(defun relieve-hyp-failure-entry-skip-p-builtin
       (rune unify-subst hyps ttree step-limit)
  (declare (ignore rune unify-subst hyps ttree step-limit)
           (xargs :mode :logic :guard t))
  nil)">relieve-hyp-failure-entry-skip-p-builtin</a>))</pre>
  </div>

<div class="form-block macro" id="def-rw-cache-active-p" data-defines="RW-CACHE-ACTIVE-P" data-references="T,QUOTE,REWRITE-CONSTANT,ACCESS,MEMBER-EQ,QUASIQUOTE,RCNST,DEFMACRO" data-used-by="REWRITE,RW-CACHE-ADD-FAILURE-REASON,EXTEND-RW-CACHE-ALIST-FREE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-ACTIVE-P">rw-cache-active-p</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a>
  (rcnst)
  `(<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant ,RCNST <span class="keyword">:rw-cache-state</span>)
    '(<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:atom</span>)))</pre>
  </div>

<div class="form-block function" id="def-assoc-rw-cache" data-defines="ASSOC-RW-CACHE" data-references="CAAR,EQL,CDR,ASSOC-EQ,T,CAR,EQ,ENDP,COND,ALIST,KEY,DEFUN" data-used-by="NOTE-RW-CACHE-FREE-NIL-TAG,REPLACE-FREE-RW-CACHE-ENTRY,PUSH-RW-CACHE-ENTRY,RELIEVE-HYP-FAILURE-ENTRY,PUT-ASSOC-RW-CACHE" data-part-name="ASSOC-RW-CACHE" data-part-args="ALIST,KEY" data-part-body="ASSOC-RW-CACHE,CAAR,EQL,CDR,KEY,ASSOC-EQ,T,CAR,EQ,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ASSOC-RW-CACHE">assoc-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a>
  (key alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car alist) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> key (cdr alist)))
    ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> key (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)) (car alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> key (cdr alist)))))</pre>
  </div>

<div class="form-block function" id="def-put-assoc-rw-cache1" data-defines="PUT-ASSOC-RW-CACHE1" data-references="CAAR,CDR,PUT-ASSOC-EQ,T,CAR,EQ,CONS,LIST,ATOM,COND,ALIST,VAL,KEY,DEFUN" data-used-by="PUT-ASSOC-RW-CACHE" data-part-name="PUT-ASSOC-RW-CACHE1" data-part-args="ALIST,VAL,KEY" data-part-body="PUT-ASSOC-RW-CACHE1,CAAR,CDR,PUT-ASSOC-EQ,T,CAR,EQ,VAL,KEY,CONS,LIST,ALIST,ATOM,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-ASSOC-RW-CACHE1">put-assoc-rw-cache1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-assoc-rw-cache1" data-sym="PUT-ASSOC-RW-CACHE1" title="(defun put-assoc-rw-cache1 (key val alist)
  (cond ((atom alist) (list (cons key val)))
        ((eq (car alist) t)
         (cons (car alist) (put-assoc-eq key val (cdr alist))))
        ((eq key (caar alist)) (cons (cons key val) (cdr alist)))">put-assoc-rw-cache1</a>
  (key val alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-atom" data-sym="ATOM">atom</a> alist) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons key val)))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car alist) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (cons (car alist) (<a class="sym-link system" href="axioms.html#def-put-assoc-eq" data-sym="PUT-ASSOC-EQ">put-assoc-eq</a> key val (cdr alist))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> key (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist)) (cons (cons key val) (cdr alist)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car alist) (<a class="sym-link local-def" href="#def-put-assoc-rw-cache1" data-sym="PUT-ASSOC-RW-CACHE1" title="(defun put-assoc-rw-cache1 (key val alist)
  (cond ((atom alist) (list (cons key val)))
        ((eq (car alist) t)
         (cons (car alist) (put-assoc-eq key val (cdr alist))))
        ((eq key (caar alist)) (cons (cons key val) (cdr alist)))">put-assoc-rw-cache1</a> key val (cdr alist))))))</pre>
  </div>

<div class="form-block function" id="def-put-assoc-rw-cache" data-defines="PUT-ASSOC-RW-CACHE" data-references="ACONS,T,PUT-ASSOC-RW-CACHE1,ASSOC-RW-CACHE,COND,ALIST,VAL,KEY,DEFUN" data-used-by="REPLACE-FREE-RW-CACHE-ENTRY,PUSH-RW-CACHE-ENTRY" data-part-name="PUT-ASSOC-RW-CACHE" data-part-args="ALIST,VAL,KEY" data-part-body="ACONS,T,VAL,PUT-ASSOC-RW-CACHE1,ALIST,KEY,ASSOC-RW-CACHE,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUT-ASSOC-RW-CACHE">put-assoc-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-put-assoc-rw-cache" data-sym="PUT-ASSOC-RW-CACHE" title="(defun put-assoc-rw-cache (key val alist)
  (cond ((assoc-rw-cache key alist) (put-assoc-rw-cache1 key val alist))
        (t (acons key val alist))))">put-assoc-rw-cache</a>
  (key val alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> key alist) (<a class="sym-link local-def" href="#def-put-assoc-rw-cache1" data-sym="PUT-ASSOC-RW-CACHE1" title="(defun put-assoc-rw-cache1 (key val alist)
  (cond ((atom alist) (list (cons key val)))
        ((eq (car alist) t)
         (cons (car alist) (put-assoc-eq key val (cdr alist))))
        ((eq key (caar alist)) (cons (cons key val) (cdr alist)))">put-assoc-rw-cache1</a> key val alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> key val alist))))</pre>
  </div>

<div class="form-block function" id="def-relieve-hyp-failure-entry" data-defines="RELIEVE-HYP-FAILURE-ENTRY" data-references="T,RELIEVE-HYP-FAILURE-ENTRY-SKIP-P,NULL,COND,BASE-SYMBOL,ASSOC-RW-CACHE,CDR,RW-CACHE-LIST-LOOKUP,AND,ENTRY,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET*,STEP-LIMIT,TTREE,HYPS,UNIFY-SUBST,RUNE,DEFUN" data-used-by="REWRITE" data-part-name="RELIEVE-HYP-FAILURE-ENTRY" data-part-args="STEP-LIMIT,TTREE,HYPS,UNIFY-SUBST,RUNE" data-part-body="T,STEP-LIMIT,RELIEVE-HYP-FAILURE-ENTRY-SKIP-P,NULL,COND,RUNE,BASE-SYMBOL,ASSOC-RW-CACHE,CDR,HYPS,UNIFY-SUBST,RW-CACHE-LIST-LOOKUP,AND,ENTRY,TTREE,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RELIEVE-HYP-FAILURE-ENTRY">relieve-hyp-failure-entry</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-relieve-hyp-failure-entry" data-sym="RELIEVE-HYP-FAILURE-ENTRY" title="(defun relieve-hyp-failure-entry (rune unify-subst hyps ttree step-limit)
  (let* ((cache (tagged-objects &#39;rw-cache-any-tag ttree))
         (entry
          (and cache
               (rw-cache-list-lookup unify-subst hyps
...">relieve-hyp-failure-entry</a>
  (rune unify-subst hyps ttree step-limit)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((cache (tagged-objects 'rw-cache-any-tag ttree)) (entry (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cache
          (<a class="sym-link local-def" href="#def-rw-cache-list-lookup" data-sym="RW-CACHE-LIST-LOOKUP" title="(defun rw-cache-list-lookup (unify-subst hyps recs)
  (cond ((endp recs) nil)
        ((eq (car recs) t) (rw-cache-list-lookup unify-subst hyps (cdr recs)))
        ((let* ((rec (car recs))
                (failure-reason (access rw-cache-entry rec :failure-reason))
...">rw-cache-list-lookup</a> unify-subst
            hyps
            (cdr (<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> (base-symbol rune) cache))))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> entry) nil)
      ((relieve-hyp-failure-entry-skip-p rune
         unify-subst
         hyps
         ttree
         step-limit) nil)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> entry))))</pre>
  </div>

<div class="form-block function" id="def-maybe-extend-tag-tree" data-defines="MAYBE-EXTEND-TAG-TREE" data-references="EXTEND-TAG-TREE,T,NULL,COND,TTREE,VALS,TAG,DEFUN" data-used-by="RW-CACHE,CONS-TAG-TREES-RW-CACHE-FIRST,RESTORE-RW-CACHE-ANY-TAG,RW-CACHE-EXIT-CONTEXT,RW-CACHE-ENTER-CONTEXT" data-part-name="MAYBE-EXTEND-TAG-TREE" data-part-args="TTREE,VALS,TAG" data-part-body="TAG,EXTEND-TAG-TREE,T,TTREE,VALS,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAYBE-EXTEND-TAG-TREE">maybe-extend-tag-tree</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a>
  (tag vals ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> vals) ttree)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-tag-tree tag vals ttree))))</pre>
  </div>

<div class="form-block function" id="def-accumulate-rw-cache1" data-defines="ACCUMULATE-RW-CACHE1" data-references="COMBINE-RW-CACHES,OBJS,FLG,MV-LET,T,REMOVE-TAG-FROM-TAG-TREE!,EXTEND-TAG-TREE,ASSERT$,EQUAL,AND,COND,OLD-VALS,TAGGED-OBJECTS,NEW-VALS,LET,OLD-TTREE,NEW-TTREE,TAG,REPLACE-P,DEFUN" data-used-by="ACCUMULATE-RW-CACHE?,ACCUMULATE-RW-CACHE" data-part-name="ACCUMULATE-RW-CACHE1" data-part-args="OLD-TTREE,NEW-TTREE,TAG,REPLACE-P" data-part-body="COMBINE-RW-CACHES,OBJS,FLG,MV-LET,T,REMOVE-TAG-FROM-TAG-TREE!,EXTEND-TAG-TREE,ASSERT$,EQUAL,REPLACE-P,AND,COND,OLD-TTREE,OLD-VALS,NEW-TTREE,TAG,TAGGED-OBJECTS,NEW-VALS,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATE-RW-CACHE1">accumulate-rw-cache1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulate-rw-cache1" data-sym="ACCUMULATE-RW-CACHE1" title="(defun accumulate-rw-cache1 (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree))
        (old-vals (tagged-objects tag old-ttree)))
    (cond ((and replace-p (equal new-vals old-vals)) nil)
          (old-vals
...">accumulate-rw-cache1</a>
  (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree)) (old-vals (tagged-objects tag old-ttree)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> replace-p (equal new-vals old-vals)) nil)
      (old-vals (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (replace-p (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> new-vals
              (extend-tag-tree tag
                new-vals
                (remove-tag-from-tag-tree! tag old-ttree))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg objs)
              (<a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a> new-vals old-vals)
              (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> objs
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg old-ttree)
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-tag-tree tag
                      objs
                      (remove-tag-from-tag-tree! tag old-ttree)))))))))
      (new-vals (extend-tag-tree tag new-vals old-ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))))</pre>
  </div>

<div class="form-block function" id="def-accumulate-rw-cache" data-defines="ACCUMULATE-RW-CACHE" data-references="RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,QUOTE,ACCUMULATE-RW-CACHE1,OR,TTREE1,LET,OLD-TTREE,NEW-TTREE,REPLACE-P,DEFUN" data-used-by="REWRITE" data-part-name="ACCUMULATE-RW-CACHE" data-part-args="OLD-TTREE,NEW-TTREE,REPLACE-P" data-part-body="RW-CACHE-ANY-TAG,OLD-TTREE,NEW-TTREE,RW-CACHE-NIL-TAG,QUOTE,REPLACE-P,ACCUMULATE-RW-CACHE1,OR,TTREE1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATE-RW-CACHE">accumulate-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a>
  (replace-p new-ttree old-ttree)
  (let ((ttree1 (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-accumulate-rw-cache1" data-sym="ACCUMULATE-RW-CACHE1" title="(defun accumulate-rw-cache1 (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree))
        (old-vals (tagged-objects tag old-ttree)))
    (cond ((and replace-p (equal new-vals old-vals)) nil)
          (old-vals
...">accumulate-rw-cache1</a> replace-p
           'rw-cache-nil-tag
           new-ttree
           old-ttree)
         old-ttree)))
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-accumulate-rw-cache1" data-sym="ACCUMULATE-RW-CACHE1" title="(defun accumulate-rw-cache1 (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree))
        (old-vals (tagged-objects tag old-ttree)))
    (cond ((and replace-p (equal new-vals old-vals)) nil)
          (old-vals
...">accumulate-rw-cache1</a> replace-p
        'rw-cache-any-tag
        new-ttree
        ttree1)
      ttree1)))</pre>
  </div>

<div class="form-block function" id="def-accumulate-rw-cache_3F" data-defines="ACCUMULATE-RW-CACHE?" data-references="RW-CACHE-ANY-TAG,TTREE2-OR-NIL,OR,TTREE1,RW-CACHE-NIL-TAG,QUOTE,ACCUMULATE-RW-CACHE1,TTREE1-OR-NIL,LET*,OLD-TTREE,NEW-TTREE,REPLACE-P,DEFUN" data-part-name="ACCUMULATE-RW-CACHE?" data-part-args="OLD-TTREE,NEW-TTREE,REPLACE-P" data-part-body="RW-CACHE-ANY-TAG,TTREE2-OR-NIL,OR,TTREE1,OLD-TTREE,NEW-TTREE,RW-CACHE-NIL-TAG,QUOTE,REPLACE-P,ACCUMULATE-RW-CACHE1,TTREE1-OR-NIL,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACCUMULATE-RW-CACHE?">accumulate-rw-cache?</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-accumulate-rw-cache_3F" data-sym="ACCUMULATE-RW-CACHE?" title="(defun accumulate-rw-cache? (replace-p new-ttree old-ttree)
  (let* ((ttree1-or-nil
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree))
         (ttree1 (or ttree1-or-nil old-ttree))
...">accumulate-rw-cache?</a>
  (replace-p new-ttree old-ttree)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ttree1-or-nil (<a class="sym-link local-def" href="#def-accumulate-rw-cache1" data-sym="ACCUMULATE-RW-CACHE1" title="(defun accumulate-rw-cache1 (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree))
        (old-vals (tagged-objects tag old-ttree)))
    (cond ((and replace-p (equal new-vals old-vals)) nil)
          (old-vals
...">accumulate-rw-cache1</a> replace-p
         'rw-cache-nil-tag
         new-ttree
         old-ttree)) (ttree1 (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> ttree1-or-nil old-ttree))
      (ttree2-or-nil (<a class="sym-link local-def" href="#def-accumulate-rw-cache1" data-sym="ACCUMULATE-RW-CACHE1" title="(defun accumulate-rw-cache1 (replace-p tag new-ttree old-ttree)
  (let ((new-vals (tagged-objects tag new-ttree))
        (old-vals (tagged-objects tag old-ttree)))
    (cond ((and replace-p (equal new-vals old-vals)) nil)
          (old-vals
...">accumulate-rw-cache1</a> replace-p
          'rw-cache-any-tag
          new-ttree
          ttree1)))
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> ttree2-or-nil ttree1-or-nil)))</pre>
  </div>

<div class="form-block function" id="def-restrict-alist-to-all-vars1" data-defines="RESTRICT-ALIST-TO-ALL-VARS1" data-references="CAR,CONS,CAAR,DUMB-OCCUR-VAR,CDR,REST,CHANGEDP,MV-LET,T,MV,ENDP,COND,PSEUDO-TERMP,SYMBOL-ALISTP,AND,XARGS,DECLARE,TERM,ALIST,DEFUN" data-used-by="RESTRICT-ALIST-TO-ALL-VARS" data-part-name="RESTRICT-ALIST-TO-ALL-VARS1" data-part-args="TERM,ALIST" data-part-declare="TERM,PSEUDO-TERMP,ALIST,SYMBOL-ALISTP,AND,XARGS,DECLARE" data-part-body="CAR,CONS,CAAR,DUMB-OCCUR-VAR,TERM,CDR,RESTRICT-ALIST-TO-ALL-VARS1,REST,CHANGEDP,MV-LET,T,MV,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RESTRICT-ALIST-TO-ALL-VARS1">restrict-alist-to-all-vars1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-restrict-alist-to-all-vars1" data-sym="RESTRICT-ALIST-TO-ALL-VARS1" title="(defun restrict-alist-to-all-vars1 (alist term)
  (declare (xargs :guard (and (symbol-alistp alist) (pseudo-termp term))))
  (cond ((endp alist) (mv nil nil))
        (t
         (mv-let (changedp rest) (restrict-alist-to-all-vars1 (cdr alist) term)
...">restrict-alist-to-all-vars1</a>
  (alist term)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist) (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-restrict-alist-to-all-vars1" data-sym="RESTRICT-ALIST-TO-ALL-VARS1" title="(defun restrict-alist-to-all-vars1 (alist term)
  (declare (xargs :guard (and (symbol-alistp alist) (pseudo-termp term))))
  (cond ((endp alist) (mv nil nil))
        (t
         (mv-let (changedp rest) (restrict-alist-to-all-vars1 (cdr alist) term)
...">restrict-alist-to-all-vars1</a> (cdr alist) term)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((dumb-occur-var (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> alist) term) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (changedp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car alist) <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)))))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-all-vars-boundp" data-defines="ALL-VARS-BOUNDP" data-references="CDR,CAR,ENDP,PSEUDO-TERM-LISTP,LST,FARGS,ALL-VARS-LST-BOUNDP,T,FQUOTEP,ASSOC-EQ,VARIABLEP,COND,SYMBOL-ALISTP,PSEUDO-TERMP,AND,XARGS,DECLARE,ALIST,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="RESTRICT-ALIST-TO-ALL-VARS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-VARS-BOUNDP">all-vars-boundp</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-vars-boundp" data-sym="ALL-VARS-BOUNDP" title="(mutual-recursion
 (defun all-vars-boundp (term alist)
   (declare (xargs :guard (and (pseudo-termp term) (symbol-alistp alist))))
   (cond ((variablep term) (assoc-eq term alist)) ((fquotep term) t)
         (t (all-vars-lst-boundp (fargs term) alist))))
...">all-vars-boundp</a>
    (term alist)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-pseudo-termp" data-sym="PSEUDO-TERMP">pseudo-termp</a> term) (<a class="sym-link system" href="axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term alist))
      ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (all-vars-lst-boundp (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term) alist))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> all-vars-lst-boundp
    (lst alist)
    (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (pseudo-term-listp lst) (<a class="sym-link system" href="axioms.html#def-symbol-alistp" data-sym="SYMBOL-ALISTP">symbol-alistp</a> alist))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lst) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-all-vars-boundp" data-sym="ALL-VARS-BOUNDP" title="(mutual-recursion
 (defun all-vars-boundp (term alist)
   (declare (xargs :guard (and (pseudo-termp term) (symbol-alistp alist))))
   (cond ((variablep term) (assoc-eq term alist)) ((fquotep term) t)
         (t (all-vars-lst-boundp (fargs term) alist))))
...">all-vars-boundp</a> (car lst) alist)
          (all-vars-lst-boundp (cdr lst) alist))))))</pre>
  </div>

<div class="form-block function" id="def-restrict-alist-to-all-vars" data-defines="RESTRICT-ALIST-TO-ALL-VARS" data-references="T,IGNORE,DECLARE,RESTRICT-ALIST-TO-ALL-VARS1,RESULT,CHANGEDP,MV-LET,ALL-VARS-BOUNDP,COND,TERM,ALIST,DEFUN" data-used-by="NOTE-RELIEVE-HYP-FAILURE" data-part-name="RESTRICT-ALIST-TO-ALL-VARS" data-part-args="TERM,ALIST" data-part-body="T,IGNORE,DECLARE,RESTRICT-ALIST-TO-ALL-VARS1,RESULT,CHANGEDP,MV-LET,ALIST,TERM,ALL-VARS-BOUNDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RESTRICT-ALIST-TO-ALL-VARS">restrict-alist-to-all-vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-restrict-alist-to-all-vars" data-sym="RESTRICT-ALIST-TO-ALL-VARS" title="(defun restrict-alist-to-all-vars (alist term)
  (cond
   ((all-vars-boundp term alist)
    (mv-let (changedp result) (restrict-alist-to-all-vars1 alist term)
            (declare (ignore changedp)) result))">restrict-alist-to-all-vars</a>
  (alist term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-all-vars-boundp" data-sym="ALL-VARS-BOUNDP" title="(mutual-recursion
 (defun all-vars-boundp (term alist)
   (declare (xargs :guard (and (pseudo-termp term) (symbol-alistp alist))))
   (cond ((variablep term) (assoc-eq term alist)) ((fquotep term) t)
         (t (all-vars-lst-boundp (fargs term) alist))))
...">all-vars-boundp</a> term alist) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (changedp result)
        (<a class="sym-link local-def" href="#def-restrict-alist-to-all-vars1" data-sym="RESTRICT-ALIST-TO-ALL-VARS1" title="(defun restrict-alist-to-all-vars1 (alist term)
  (declare (xargs :guard (and (symbol-alistp alist) (pseudo-termp term))))
  (cond ((endp alist) (mv nil nil))
        (t
         (mv-let (changedp rest) (restrict-alist-to-all-vars1 (cdr alist) term)
...">restrict-alist-to-all-vars1</a> alist term)
        (declare (ignore changedp))
        result))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> alist)))</pre>
  </div>

<div class="form-block function" id="def-push-rw-cache-entry" data-defines="PUSH-RW-CACHE-ENTRY" data-references="REMOVE-TAG-FROM-TAG-TREE,PUT-ASSOC-RW-CACHE,T,CONS,LIST,EXTEND-TAG-TREE,NULL,COND,ASSOC-RW-CACHE,CDR,AND,RECS,BASE-SYMBOL,BASE,TAGGED-OBJECTS,CACHE,LET*,TTREE,RUNE,TAG,ENTRY,DEFUN" data-used-by="NOTE-RELIEVE-HYPS-FAILURE-FREE,NOTE-RW-CACHE-FREE-NIL-TAG,NOTE-RELIEVE-HYP-FAILURE" data-part-name="PUSH-RW-CACHE-ENTRY" data-part-args="TTREE,RUNE,TAG,ENTRY" data-part-body="REMOVE-TAG-FROM-TAG-TREE,PUT-ASSOC-RW-CACHE,T,ENTRY,CONS,LIST,EXTEND-TAG-TREE,NULL,COND,ASSOC-RW-CACHE,CDR,AND,RECS,RUNE,BASE-SYMBOL,BASE,TTREE,TAG,TAGGED-OBJECTS,CACHE,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-RW-CACHE-ENTRY">push-rw-cache-entry</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-rw-cache-entry" data-sym="PUSH-RW-CACHE-ENTRY" title="(defun push-rw-cache-entry (entry tag rune ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (and cache (cdr (assoc-rw-cache base cache)))))
    (cond
...">push-rw-cache-entry</a>
  (entry tag rune ttree)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((cache (tagged-objects tag ttree)) (base (base-symbol rune))
      (recs (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cache (cdr (<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> base cache)))))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cache) (extend-tag-tree tag (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons base (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> entry))) ttree))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-tag-tree tag
          (<a class="sym-link local-def" href="#def-put-assoc-rw-cache" data-sym="PUT-ASSOC-RW-CACHE" title="(defun put-assoc-rw-cache (key val alist)
  (cond ((assoc-rw-cache key alist) (put-assoc-rw-cache1 key val alist))
        (t (acons key val alist))))">put-assoc-rw-cache</a> base (cons entry recs) cache)
          (remove-tag-from-tag-tree tag ttree))))))</pre>
  </div>

<div class="form-block other" id="form-407" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> rw-cache-debug
  (rune target
    unify-subst
    relieve-hyp-failure-reason
    step-limit)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block other" id="form-408" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-b.html#def-defstub" data-sym="DEFSTUB">defstub</a> rw-cache-debug-action
  (rune target
    unify-subst
    relieve-hyp-failure-reason
    step-limit)
  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-rw-cache-debug-builtin" data-defines="RW-CACHE-DEBUG-BUILTIN" data-references="T,XARGS,IGNORE,DECLARE,STEP-LIMIT,FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE,DEFUN" data-part-name="RW-CACHE-DEBUG-BUILTIN" data-part-args="STEP-LIMIT,FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE" data-part-declare="T,XARGS,STEP-LIMIT,FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE,IGNORE,DECLARE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-DEBUG-BUILTIN">rw-cache-debug-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-debug-builtin" data-sym="RW-CACHE-DEBUG-BUILTIN" title="(defun rw-cache-debug-builtin
       (rune target unify-subst failure-reason step-limit)
  (declare (ignore rune target unify-subst failure-reason step-limit)
           (xargs :guard t))
  nil)">rw-cache-debug-builtin</a>
  (rune target unify-subst failure-reason step-limit)
  (declare (ignore rune target unify-subst failure-reason step-limit)
    (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  nil)</pre>
  </div>

<div class="form-block function" id="def-rw-cache-debug-action-builtin" data-defines="RW-CACHE-DEBUG-ACTION-BUILTIN" data-references="LIST,CW,T,XARGS,DECLARE,STEP-LIMIT,FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE,DEFUN" data-part-name="RW-CACHE-DEBUG-ACTION-BUILTIN" data-part-args="STEP-LIMIT,FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE" data-part-declare="T,XARGS,DECLARE" data-part-body="FAILURE-REASON,UNIFY-SUBST,TARGET,RUNE,STEP-LIMIT,LIST,CW" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-DEBUG-ACTION-BUILTIN">rw-cache-debug-action-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-debug-action-builtin" data-sym="RW-CACHE-DEBUG-ACTION-BUILTIN" title="(defun rw-cache-debug-action-builtin
       (rune target unify-subst failure-reason step-limit)
  (declare (xargs :guard t))
  (cw &quot;@@ rw-cache-debug:~|~x0~|&quot;
      (list :step-limit step-limit :rune rune :target target :unify-subst">rw-cache-debug-action-builtin</a>
  (rune target unify-subst failure-reason step-limit)
  (declare (xargs <span class="keyword">:guard</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
  (<a class="sym-link system" href="axioms.html#def-cw" data-sym="CW">cw</a> <span class="string">"@@ rw-cache-debug:~|~x0~|"</span>
    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:step-limit</span> step-limit
      <span class="keyword">:rune</span> rune
      <span class="keyword">:target</span> target
      <span class="keyword">:unify-subst</span> unify-subst
      <span class="keyword">:relieve-hyp-failure-reason</span> failure-reason)))</pre>
  </div>

<div class="form-block encapsulate" id="form-411" typeof="Code">
    <div class="form-header"><span class="form-type">encapsulate</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-encapsulate" data-sym="ENCAPSULATE">encapsulate</a> (((rw-cacheable-failure-reason <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>) =&gt;
     <a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a>
     <span class="keyword">:formals</span> (failure-reason)
     <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason) (<a class="sym-link system" href="axioms.html#def-posp" data-sym="POSP">posp</a> (car failure-reason)))))
  (<a class="sym-link system" href="axioms.html#def-logic" data-sym="LOGIC">logic</a>)
  (<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rw-cacheable-failure-reason
      (failure-reason)
      failure-reason)))</pre>
  </div>

<div class="form-block function" id="def-rw-cacheable-failure-reason-builtin" data-defines="RW-CACHEABLE-FAILURE-REASON-BUILTIN" data-references="BIND-FREE,SYNTAXP,REWROTE-TO,QUOTE,CADR,MEMBER-EQ,CDR,CAR,POSP,CONSP,AND,XARGS,DECLARE,FAILURE-REASON,DEFUN" data-part-name="RW-CACHEABLE-FAILURE-REASON-BUILTIN" data-part-args="FAILURE-REASON" data-part-declare="CAR,POSP,FAILURE-REASON,CONSP,AND,XARGS,DECLARE" data-part-body="BIND-FREE,SYNTAXP,REWROTE-TO,QUOTE,CADR,MEMBER-EQ,FAILURE-REASON,CDR,CONSP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHEABLE-FAILURE-REASON-BUILTIN">rw-cacheable-failure-reason-builtin</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cacheable-failure-reason-builtin" data-sym="RW-CACHEABLE-FAILURE-REASON-BUILTIN" title="(defun rw-cacheable-failure-reason-builtin (failure-reason)
  (declare
   (xargs :guard (and (consp failure-reason) (posp (car failure-reason)))))
  (and (consp (cdr failure-reason))
       (member-eq (cadr failure-reason) &#39;(rewrote-to syntaxp bind-free))))">rw-cacheable-failure-reason-builtin</a>
  (failure-reason)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp failure-reason) (<a class="sym-link system" href="axioms.html#def-posp" data-sym="POSP">posp</a> (car failure-reason)))))
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr failure-reason))
    (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason)
      '(rewrote-to <a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> <a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>))))</pre>
  </div>

<div class="form-block other" id="form-413" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defattach" data-sym="DEFATTACH">defattach</a> (rw-cacheable-failure-reason <a class="sym-link local-def" href="#def-rw-cacheable-failure-reason-builtin" data-sym="RW-CACHEABLE-FAILURE-REASON-BUILTIN" title="(defun rw-cacheable-failure-reason-builtin (failure-reason)
  (declare
   (xargs :guard (and (consp failure-reason) (posp (car failure-reason)))))
  (and (consp (cdr failure-reason))
       (member-eq (cadr failure-reason) &#39;(rewrote-to syntaxp bind-free))))">rw-cacheable-failure-reason-builtin</a>)
  <span class="keyword">:skip-checks</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)</pre>
  </div>

<div class="form-block function" id="def-rw-cacheable-nil-tag" data-defines="RW-CACHEABLE-NIL-TAG" data-references="BIND-FREE,SYNTAXP,MEMBER-EQ,ASSERT$,T,*NIL*,CDDR,EQUAL,REWROTE-TO,QUOTE,CADR,EQ,COND,CDR,CONSP,AND,FAILURE-REASON,DEFUN" data-used-by="MERGE-FREE-FAILURE-ALISTS-NIL-TAG,RW-CACHE-ALIST-NIL-TAG-P,NOTE-RELIEVE-HYP-FAILURE" data-part-name="RW-CACHEABLE-NIL-TAG" data-part-args="FAILURE-REASON" data-part-body="BIND-FREE,SYNTAXP,MEMBER-EQ,ASSERT$,T,*NIL*,CDDR,EQUAL,REWROTE-TO,QUOTE,CADR,EQ,COND,FAILURE-REASON,CDR,CONSP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHEABLE-NIL-TAG">rw-cacheable-nil-tag</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cacheable-nil-tag" data-sym="RW-CACHEABLE-NIL-TAG" title="(defun rw-cacheable-nil-tag (failure-reason)
  (and (consp (cdr failure-reason))
       (cond
        ((eq (cadr failure-reason) &#39;rewrote-to)
         (equal (cddr failure-reason) *nil*))
...">rw-cacheable-nil-tag</a>
  (failure-reason)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (cdr failure-reason))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason) 'rewrote-to) (equal (<a class="sym-link system" href="axioms.html#def-cddr" data-sym="CDDR">cddr</a> failure-reason) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> failure-reason) '(<a class="sym-link system" href="axioms.html#def-syntaxp" data-sym="SYNTAXP">syntaxp</a> <a class="sym-link system" href="axioms.html#def-bind-free" data-sym="BIND-FREE">bind-free</a>))
          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))))</pre>
  </div>

<div class="form-block function" id="def-note-relieve-hyp-failure" data-defines="NOTE-RELIEVE-HYP-FAILURE" data-references="RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,PUSH-RW-CACHE-ENTRY,RW-CACHEABLE-NIL-TAG,T,UNQUOTE,QUOTEP,FARGN,QTERM,LET,SYNP,QUOTE,FFN-SYMB-P,RESTRICT-ALIST-TO-ALL-VARS,RW-CACHE-ENTRY,MAKE,ENTRY,CAR,1-,NTH,HYP,LET*,RW-CACHEABLE-FAILURE-REASON,AND,COND,STEP-LIMIT,HYPS,TTREE,FAILURE-REASON,UNIFY-SUBST,RUNE,DEFUN" data-used-by="REWRITE" data-part-name="NOTE-RELIEVE-HYP-FAILURE" data-part-args="STEP-LIMIT,HYPS,TTREE,FAILURE-REASON,UNIFY-SUBST,RUNE" data-part-body="RW-CACHE-ANY-TAG,RUNE,RW-CACHE-NIL-TAG,PUSH-RW-CACHE-ENTRY,RW-CACHEABLE-NIL-TAG,TTREE,STEP-LIMIT,T,UNQUOTE,QUOTEP,FARGN,QTERM,LET,SYNP,QUOTE,FFN-SYMB-P,UNIFY-SUBST,RESTRICT-ALIST-TO-ALL-VARS,RW-CACHE-ENTRY,MAKE,ENTRY,HYPS,CAR,1-,NTH,HYP,LET*,RW-CACHEABLE-FAILURE-REASON,FAILURE-REASON,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOTE-RELIEVE-HYP-FAILURE">note-relieve-hyp-failure</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-note-relieve-hyp-failure" data-sym="NOTE-RELIEVE-HYP-FAILURE" title="(defun note-relieve-hyp-failure
       (rune unify-subst failure-reason ttree hyps step-limit)
  (cond
   ((and failure-reason (rw-cacheable-failure-reason failure-reason))
    (let* ((hyp (nth (1- (car failure-reason)) hyps))
...">note-relieve-hyp-failure</a>
  (rune unify-subst failure-reason ttree hyps step-limit)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> failure-reason
       (rw-cacheable-failure-reason failure-reason)) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((hyp (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> (<a class="sym-link system" href="axioms.html#def-1-" data-sym="1-">1-</a> (car failure-reason)) hyps)) (entry (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> rw-cache-entry
              <span class="keyword">:unify-subst</span> (<a class="sym-link local-def" href="#def-restrict-alist-to-all-vars" data-sym="RESTRICT-ALIST-TO-ALL-VARS" title="(defun restrict-alist-to-all-vars (alist term)
  (cond
   ((all-vars-boundp term alist)
    (mv-let (changedp result) (restrict-alist-to-all-vars1 alist term)
            (declare (ignore changedp)) result))">restrict-alist-to-all-vars</a> unify-subst
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> hyp '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>) (let ((qterm (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">3</span>)))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> qterm) (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> qterm)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> hyp))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> hyp)))
              <span class="keyword">:failure-reason</span> failure-reason
              <span class="keyword">:hyp-info</span> hyp
              <span class="keyword">:step-limit</span> step-limit))
          (ttree (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-rw-cacheable-nil-tag" data-sym="RW-CACHEABLE-NIL-TAG" title="(defun rw-cacheable-nil-tag (failure-reason)
  (and (consp (cdr failure-reason))
       (cond
        ((eq (cadr failure-reason) &#39;rewrote-to)
         (equal (cddr failure-reason) *nil*))
...">rw-cacheable-nil-tag</a> failure-reason) (<a class="sym-link local-def" href="#def-push-rw-cache-entry" data-sym="PUSH-RW-CACHE-ENTRY" title="(defun push-rw-cache-entry (entry tag rune ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (and cache (cdr (assoc-rw-cache base cache)))))
    (cond
...">push-rw-cache-entry</a> entry 'rw-cache-nil-tag rune ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree))))
        (<a class="sym-link local-def" href="#def-push-rw-cache-entry" data-sym="PUSH-RW-CACHE-ENTRY" title="(defun push-rw-cache-entry (entry tag rune ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (and cache (cdr (assoc-rw-cache base cache)))))
    (cond
...">push-rw-cache-entry</a> entry 'rw-cache-any-tag rune ttree)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree)))</pre>
  </div>

<div class="form-block function" id="def-replace-free-rw-cache-entry1" data-defines="REPLACE-FREE-RW-CACHE-ENTRY1" data-references="CDR,CONS,EQUAL,RW-CACHE-ENTRY,ACCESS,FREE-FAILURE-P,T,CAR,EQ,NOT,AND,LIST,ENDP,COND,RECS,ENTRY,HYPS,UNIFY-SUBST,DEFUN" data-used-by="REPLACE-FREE-RW-CACHE-ENTRY" data-part-name="REPLACE-FREE-RW-CACHE-ENTRY1" data-part-args="RECS,ENTRY,HYPS,UNIFY-SUBST" data-part-body="REPLACE-FREE-RW-CACHE-ENTRY1,CDR,CONS,HYPS,UNIFY-SUBST,EQUAL,RW-CACHE-ENTRY,ACCESS,FREE-FAILURE-P,T,CAR,EQ,NOT,AND,ENTRY,LIST,RECS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REPLACE-FREE-RW-CACHE-ENTRY1">replace-free-rw-cache-entry1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-replace-free-rw-cache-entry1" data-sym="REPLACE-FREE-RW-CACHE-ENTRY1" title="(defun replace-free-rw-cache-entry1 (unify-subst hyps entry recs)
  (cond ((endp recs) (list entry))
        ((and (not (eq (car recs) t))
              (free-failure-p
               (access rw-cache-entry (car recs) :failure-reason))
...">replace-free-rw-cache-entry1</a>
  (unify-subst hyps entry recs)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> recs) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> entry))
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car recs) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
       (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car recs) <span class="keyword">:failure-reason</span>))
       (equal unify-subst
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car recs) <span class="keyword">:unify-subst</span>))
       (equal hyps (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry (car recs) <span class="keyword">:hyp-info</span>))) (cons entry (cdr recs)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car recs)
        (<a class="sym-link local-def" href="#def-replace-free-rw-cache-entry1" data-sym="REPLACE-FREE-RW-CACHE-ENTRY1" title="(defun replace-free-rw-cache-entry1 (unify-subst hyps entry recs)
  (cond ((endp recs) (list entry))
        ((and (not (eq (car recs) t))
              (free-failure-p
               (access rw-cache-entry (car recs) :failure-reason))
...">replace-free-rw-cache-entry1</a> unify-subst
          hyps
          entry
          (cdr recs))))))</pre>
  </div>

<div class="form-block function" id="def-replace-free-rw-cache-entry" data-defines="REPLACE-FREE-RW-CACHE-ENTRY" data-references="REMOVE-TAG-FROM-TAG-TREE,REPLACE-FREE-RW-CACHE-ENTRY1,PUT-ASSOC-RW-CACHE,EXTEND-TAG-TREE,ASSOC-RW-CACHE,CDR,RECS,BASE-SYMBOL,BASE,TAGGED-OBJECTS,CACHE,LET*,TTREE,HYPS,UNIFY-SUBST,RUNE,TAG,ENTRY,DEFUN" data-used-by="NOTE-RELIEVE-HYPS-FAILURE-FREE,NOTE-RW-CACHE-FREE-NIL-TAG" data-part-name="REPLACE-FREE-RW-CACHE-ENTRY" data-part-args="TTREE,HYPS,UNIFY-SUBST,RUNE,TAG,ENTRY" data-part-body="REMOVE-TAG-FROM-TAG-TREE,ENTRY,HYPS,UNIFY-SUBST,REPLACE-FREE-RW-CACHE-ENTRY1,PUT-ASSOC-RW-CACHE,EXTEND-TAG-TREE,ASSOC-RW-CACHE,CDR,RECS,RUNE,BASE-SYMBOL,BASE,TTREE,TAG,TAGGED-OBJECTS,CACHE,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REPLACE-FREE-RW-CACHE-ENTRY">replace-free-rw-cache-entry</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-replace-free-rw-cache-entry" data-sym="REPLACE-FREE-RW-CACHE-ENTRY" title="(defun replace-free-rw-cache-entry (entry tag rune unify-subst hyps ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (cdr (assoc-rw-cache base cache))))
    (extend-tag-tree tag
...">replace-free-rw-cache-entry</a>
  (entry tag rune unify-subst hyps ttree)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((cache (tagged-objects tag ttree)) (base (base-symbol rune))
      (recs (cdr (<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> base cache))))
    (extend-tag-tree tag
      (<a class="sym-link local-def" href="#def-put-assoc-rw-cache" data-sym="PUT-ASSOC-RW-CACHE" title="(defun put-assoc-rw-cache (key val alist)
  (cond ((assoc-rw-cache key alist) (put-assoc-rw-cache1 key val alist))
        (t (acons key val alist))))">put-assoc-rw-cache</a> base
        (<a class="sym-link local-def" href="#def-replace-free-rw-cache-entry1" data-sym="REPLACE-FREE-RW-CACHE-ENTRY1" title="(defun replace-free-rw-cache-entry1 (unify-subst hyps entry recs)
  (cond ((endp recs) (list entry))
        ((and (not (eq (car recs) t))
              (free-failure-p
               (access rw-cache-entry (car recs) :failure-reason))
...">replace-free-rw-cache-entry1</a> unify-subst hyps entry recs)
        cache)
      (remove-tag-from-tag-tree tag ttree))))</pre>
  </div>

<div class="form-block function" id="def-rw-cache-alist-nil-tag-p" data-defines="RW-CACHE-ALIST-NIL-TAG-P" data-references="RW-CACHEABLE-NIL-TAG,CDR,FREE-FAILURE-P,CDAR,FAILURE-REASON,LET,OR,T,ENDP,COND,ALIST,DEFUN" data-used-by="NOTE-RW-CACHE-FREE-NIL-TAG" data-part-name="RW-CACHE-ALIST-NIL-TAG-P" data-part-args="ALIST" data-part-body="RW-CACHEABLE-NIL-TAG,CDR,RW-CACHE-ALIST-NIL-TAG-P,FREE-FAILURE-P,CDAR,FAILURE-REASON,LET,OR,T,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-ALIST-NIL-TAG-P">rw-cache-alist-nil-tag-p</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-alist-nil-tag-p" data-sym="RW-CACHE-ALIST-NIL-TAG-P" title="(defun rw-cache-alist-nil-tag-p (alist)
  (cond ((endp alist) nil)
        (t
         (or
          (let ((failure-reason (cdar alist)))
...">rw-cache-alist-nil-tag-p</a>
  (alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) nil)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (let ((failure-reason (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> alist)))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason) (<a class="sym-link local-def" href="#def-rw-cache-alist-nil-tag-p" data-sym="RW-CACHE-ALIST-NIL-TAG-P" title="(defun rw-cache-alist-nil-tag-p (alist)
  (cond ((endp alist) nil)
        (t
         (or
          (let ((failure-reason (cdar alist)))
...">rw-cache-alist-nil-tag-p</a> (cdr failure-reason)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rw-cacheable-nil-tag" data-sym="RW-CACHEABLE-NIL-TAG" title="(defun rw-cacheable-nil-tag (failure-reason)
  (and (consp (cdr failure-reason))
       (cond
        ((eq (cadr failure-reason) &#39;rewrote-to)
         (equal (cddr failure-reason) *nil*))
...">rw-cacheable-nil-tag</a> failure-reason))))
        (<a class="sym-link local-def" href="#def-rw-cache-alist-nil-tag-p" data-sym="RW-CACHE-ALIST-NIL-TAG-P" title="(defun rw-cache-alist-nil-tag-p (alist)
  (cond ((endp alist) nil)
        (t
         (or
          (let ((failure-reason (cdar alist)))
...">rw-cache-alist-nil-tag-p</a> (cdr alist))))))</pre>
  </div>

<div class="form-block other" id="def-merge-free-failure-reasons-nil-tag" data-defines="MERGE-FREE-FAILURE-REASONS-NIL-TAG" data-references="CONS,ASSERT$,T,MV,COND,CDR,MERGE-FREE-FAILURE-ALISTS-NIL-TAG,ALIST,FLG,MV-LET,R2,R1,DEFABBREV" data-used-by="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-FREE-FAILURE-REASONS-NIL-TAG">merge-free-failure-reasons-nil-tag</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-merge-free-failure-reasons-nil-tag" data-sym="MERGE-FREE-FAILURE-REASONS-NIL-TAG" title="(defabbrev merge-free-failure-reasons-nil-tag (r1 r2)
           (mv-let (flg alist)
                   (merge-free-failure-alists-nil-tag (cdr r1) (cdr r2))
                   (cond (flg (mv t r2))
                         (t
...">merge-free-failure-reasons-nil-tag</a>
  (r1 r2)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
    (<a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a> (cdr r1) (cdr r2))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> r2))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> alist (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (cons <span class="keyword">:rw-cache-alist</span> alist)))))))</pre>
  </div>

<div class="form-block function" id="def-merge-free-failure-alists-nil-tag" data-defines="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" data-references="IGNORE,DECLARE,ALIST,MERGE-FREE-FAILURE-REASONS-NIL-TAG,SUB-REASON,FLG2,ACONS,PUT-ASSOC-EQUAL,CAAR,ASSOC-EQUAL,PAIR,LET,FLG,MV-LET,CDR,RW-CACHEABLE-NIL-TAG,NOT,AND,FREE-FAILURE-P,FREE-P,CDAR,FAILURE-REASON,LET*,T,MV,ENDP,COND,A2,A1,DEFUN" data-used-by="NOTE-RW-CACHE-FREE-NIL-TAG,MERGE-FREE-FAILURE-REASONS-NIL-TAG" data-part-name="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" data-part-args="A2,A1" data-part-body="IGNORE,DECLARE,ALIST,MERGE-FREE-FAILURE-REASONS-NIL-TAG,SUB-REASON,FLG2,ACONS,PUT-ASSOC-EQUAL,CAAR,ASSOC-EQUAL,PAIR,LET,FLG,MV-LET,CDR,MERGE-FREE-FAILURE-ALISTS-NIL-TAG,RW-CACHEABLE-NIL-TAG,NOT,AND,FREE-FAILURE-P,FREE-P,CDAR,FAILURE-REASON,LET*,A2,T,MV,A1,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG">merge-free-failure-alists-nil-tag</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a>
  (a1 a2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> a1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((failure-reason (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> a1)) (free-p (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> free-p)
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-rw-cacheable-nil-tag" data-sym="RW-CACHEABLE-NIL-TAG" title="(defun rw-cacheable-nil-tag (failure-reason)
  (and (consp (cdr failure-reason))
       (cond
        ((eq (cadr failure-reason) &#39;rewrote-to)
         (equal (cddr failure-reason) *nil*))
...">rw-cacheable-nil-tag</a> failure-reason))) (<a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a> (cdr a1) a2))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg a2)
              (let ((pair (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) a2)))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> pair (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> (cdr pair)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
                  ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> free-p) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (pair (<a class="sym-link system" href="axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) failure-reason a2))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) failure-reason a2)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg2 sub-reason)
                      (<a class="sym-link local-def" href="#def-merge-free-failure-reasons-nil-tag" data-sym="MERGE-FREE-FAILURE-REASONS-NIL-TAG" title="(defabbrev merge-free-failure-reasons-nil-tag (r1 r2)
           (mv-let (flg alist)
                   (merge-free-failure-alists-nil-tag (cdr r1) (cdr r2))
                   (cond (flg (mv t r2))
                         (t
...">merge-free-failure-reasons-nil-tag</a> failure-reason
                        (cdr pair))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg2 (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> a2))
                        (pair (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) sub-reason a2)))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> a1) sub-reason a2))))))))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg (<a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a> (cdr a1) a2))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
                    (<a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a> (cdr a1) a2)
                    (declare (ignore flg))
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil alist)))))))))))</pre>
  </div>

<div class="form-block function" id="def-note-rw-cache-free-nil-tag" data-defines="NOTE-RW-CACHE-FREE-NIL-TAG" data-references="PUSH-RW-CACHE-ENTRY,REMOVE-TAG-FROM-TAG-TREE,ACONS,LIST,EXTEND-TAG-TREE,NULL,MAKE,NEW-ENTRY,LET,CONS,CHANGE,REPLACE-FREE-RW-CACHE-ENTRY,MERGE-FREE-FAILURE-ALISTS-NIL-TAG,ALIST,FLG,MV-LET,T,FREE-FAILURE-P,NOT,RW-CACHE-ENTRY,ACCESS,FAILURE-REASON,RW-CACHE-LIST-LOOKUP,ENTRY,ASSOC-RW-CACHE,CDR,AND,RECS,BASE-SYMBOL,BASE,RW-CACHE-NIL-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET*,RW-CACHE-ALIST-NIL-TAG-P,COND,STEP-LIMIT,NEW-RW-CACHE-ALIST,TTREE,HYPS,UNIFY-SUBST,RUNE,DEFUN" data-used-by="NOTE-RELIEVE-HYPS-FAILURE-FREE" data-part-name="NOTE-RW-CACHE-FREE-NIL-TAG" data-part-args="STEP-LIMIT,NEW-RW-CACHE-ALIST,TTREE,HYPS,UNIFY-SUBST,RUNE" data-part-body="PUSH-RW-CACHE-ENTRY,REMOVE-TAG-FROM-TAG-TREE,ACONS,LIST,EXTEND-TAG-TREE,NULL,STEP-LIMIT,MAKE,NEW-ENTRY,LET,CONS,CHANGE,REPLACE-FREE-RW-CACHE-ENTRY,MERGE-FREE-FAILURE-ALISTS-NIL-TAG,ALIST,FLG,MV-LET,T,FREE-FAILURE-P,NOT,RW-CACHE-ENTRY,ACCESS,FAILURE-REASON,HYPS,UNIFY-SUBST,RW-CACHE-LIST-LOOKUP,ENTRY,ASSOC-RW-CACHE,CDR,AND,RECS,RUNE,BASE-SYMBOL,BASE,TTREE,RW-CACHE-NIL-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET*,NEW-RW-CACHE-ALIST,RW-CACHE-ALIST-NIL-TAG-P,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOTE-RW-CACHE-FREE-NIL-TAG">note-rw-cache-free-nil-tag</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-note-rw-cache-free-nil-tag" data-sym="NOTE-RW-CACHE-FREE-NIL-TAG" title="(defun note-rw-cache-free-nil-tag
       (rune unify-subst hyps ttree new-rw-cache-alist step-limit)
  (cond
   ((rw-cache-alist-nil-tag-p new-rw-cache-alist)
    (let* ((cache (tagged-objects &#39;rw-cache-nil-tag ttree))
...">note-rw-cache-free-nil-tag</a>
  (rune unify-subst hyps ttree new-rw-cache-alist step-limit)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-rw-cache-alist-nil-tag-p" data-sym="RW-CACHE-ALIST-NIL-TAG-P" title="(defun rw-cache-alist-nil-tag-p (alist)
  (cond ((endp alist) nil)
        (t
         (or
          (let ((failure-reason (cdar alist)))
...">rw-cache-alist-nil-tag-p</a> new-rw-cache-alist) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((cache (tagged-objects 'rw-cache-nil-tag ttree)) (base (base-symbol rune))
          (recs (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cache (cdr (<a class="sym-link local-def" href="#def-assoc-rw-cache" data-sym="ASSOC-RW-CACHE" title="(defun assoc-rw-cache (key alist)
  (cond ((endp alist) nil) ((eq (car alist) t) (assoc-eq key (cdr alist)))
        ((eql key (caar alist)) (car alist))
        (t (assoc-rw-cache key (cdr alist)))))">assoc-rw-cache</a> base cache))))
          (entry (<a class="sym-link local-def" href="#def-rw-cache-list-lookup" data-sym="RW-CACHE-LIST-LOOKUP" title="(defun rw-cache-list-lookup (unify-subst hyps recs)
  (cond ((endp recs) nil)
        ((eq (car recs) t) (rw-cache-list-lookup unify-subst hyps (cdr recs)))
        ((let* ((rec (car recs))
                (failure-reason (access rw-cache-entry rec :failure-reason))
...">rw-cache-list-lookup</a> unify-subst hyps recs))
          (failure-reason (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> entry (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry entry <span class="keyword">:failure-reason</span>))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> entry (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> failure-reason))) ttree)
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
              (<a class="sym-link local-def" href="#def-merge-free-failure-alists-nil-tag" data-sym="MERGE-FREE-FAILURE-ALISTS-NIL-TAG" title="(defun merge-free-failure-alists-nil-tag (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let* ((failure-reason (cdar a1))
                (free-p (free-failure-p failure-reason)))
...">merge-free-failure-alists-nil-tag</a> new-rw-cache-alist
                (cdr failure-reason))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg ttree)
                (entry (<a class="sym-link local-def" href="#def-replace-free-rw-cache-entry" data-sym="REPLACE-FREE-RW-CACHE-ENTRY" title="(defun replace-free-rw-cache-entry (entry tag rune unify-subst hyps ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (cdr (assoc-rw-cache base cache))))
    (extend-tag-tree tag
...">replace-free-rw-cache-entry</a> (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rw-cache-entry
                      entry
                      <span class="keyword">:failure-reason</span> (cons <span class="keyword">:rw-cache-alist</span> alist))
                    'rw-cache-nil-tag
                    rune
                    unify-subst
                    hyps
                    ttree))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-entry (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> rw-cache-entry
                         <span class="keyword">:unify-subst</span> unify-subst
                         <span class="keyword">:failure-reason</span> (cons <span class="keyword">:rw-cache-alist</span> alist)
                         <span class="keyword">:hyp-info</span> hyps
                         <span class="keyword">:step-limit</span> step-limit)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cache) (extend-tag-tree 'rw-cache-nil-tag
                          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons base (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> new-entry)))
                          ttree))
                      ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> recs) (extend-tag-tree 'rw-cache-nil-tag
                          (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> base (cons new-entry nil) cache)
                          (remove-tag-from-tag-tree 'rw-cache-nil-tag ttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-push-rw-cache-entry" data-sym="PUSH-RW-CACHE-ENTRY" title="(defun push-rw-cache-entry (entry tag rune ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (and cache (cdr (assoc-rw-cache base cache)))))
    (cond
...">push-rw-cache-entry</a> new-entry 'rw-cache-nil-tag rune ttree)))))))))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree)))</pre>
  </div>

<div class="form-block function" id="def-note-relieve-hyps-failure-free" data-defines="NOTE-RELIEVE-HYPS-FAILURE-FREE" data-references="MAKE,PUSH-RW-CACHE-ENTRY,RW-CACHE-ANY-TAG,QUOTE,CONS,RW-CACHE-ENTRY,CHANGE,REPLACE-FREE-RW-CACHE-ENTRY,NOTE-RW-CACHE-FREE-NIL-TAG,LET,MV,T,COMBINE-FREE-FAILURE-ALISTS,COND,ALIST,FLG,MV-LET,ASSERT$,STEP-LIMIT,NEW-RW-CACHE-ALIST,OLD-RW-CACHE-ALIST,OLD-ENTRY,TTREE,HYPS,UNIFY-SUBST,RUNE,DEFUN" data-used-by="REWRITE" data-part-name="NOTE-RELIEVE-HYPS-FAILURE-FREE" data-part-args="STEP-LIMIT,NEW-RW-CACHE-ALIST,OLD-RW-CACHE-ALIST,OLD-ENTRY,TTREE,HYPS,UNIFY-SUBST,RUNE" data-part-body="MAKE,PUSH-RW-CACHE-ENTRY,RW-CACHE-ANY-TAG,QUOTE,CONS,RW-CACHE-ENTRY,CHANGE,REPLACE-FREE-RW-CACHE-ENTRY,OLD-ENTRY,STEP-LIMIT,HYPS,UNIFY-SUBST,RUNE,NOTE-RW-CACHE-FREE-NIL-TAG,LET,TTREE,MV,T,COMBINE-FREE-FAILURE-ALISTS,OLD-RW-CACHE-ALIST,COND,ALIST,FLG,MV-LET,NEW-RW-CACHE-ALIST,ASSERT$" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NOTE-RELIEVE-HYPS-FAILURE-FREE">note-relieve-hyps-failure-free</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-note-relieve-hyps-failure-free" data-sym="NOTE-RELIEVE-HYPS-FAILURE-FREE" title="(defun note-relieve-hyps-failure-free
       (rune unify-subst hyps ttree old-entry old-rw-cache-alist
        new-rw-cache-alist step-limit)
  (assert$ new-rw-cache-alist
           (mv-let (flg alist)
...">note-relieve-hyps-failure-free</a>
  (rune unify-subst
    hyps
    ttree
    old-entry
    old-rw-cache-alist
    new-rw-cache-alist
    step-limit)
  (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> new-rw-cache-alist
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg alist)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (old-rw-cache-alist (<a class="sym-link local-def" href="#def-combine-free-failure-alists" data-sym="COMBINE-FREE-FAILURE-ALISTS" title="(defun combine-free-failure-alists (a1 a2)
  (cond ((endp a1) (mv t a2))
        (t
         (let ((pair (assoc-equal (caar a1) a2)))
           (cond
...">combine-free-failure-alists</a> new-rw-cache-alist
            old-rw-cache-alist))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil new-rw-cache-alist)))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (flg ttree)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ttree (<a class="sym-link local-def" href="#def-note-rw-cache-free-nil-tag" data-sym="NOTE-RW-CACHE-FREE-NIL-TAG" title="(defun note-rw-cache-free-nil-tag
       (rune unify-subst hyps ttree new-rw-cache-alist step-limit)
  (cond
   ((rw-cache-alist-nil-tag-p new-rw-cache-alist)
    (let* ((cache (tagged-objects &#39;rw-cache-nil-tag ttree))
...">note-rw-cache-free-nil-tag</a> rune
                 unify-subst
                 hyps
                 ttree
                 new-rw-cache-alist
                 step-limit)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (old-entry (<a class="sym-link local-def" href="#def-replace-free-rw-cache-entry" data-sym="REPLACE-FREE-RW-CACHE-ENTRY" title="(defun replace-free-rw-cache-entry (entry tag rune unify-subst hyps ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (cdr (assoc-rw-cache base cache))))
    (extend-tag-tree tag
...">replace-free-rw-cache-entry</a> (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rw-cache-entry
                    old-entry
                    <span class="keyword">:failure-reason</span> (cons <span class="keyword">:rw-cache-alist</span> alist))
                  'rw-cache-any-tag
                  rune
                  unify-subst
                  hyps
                  ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-push-rw-cache-entry" data-sym="PUSH-RW-CACHE-ENTRY" title="(defun push-rw-cache-entry (entry tag rune ttree)
  (let* ((cache (tagged-objects tag ttree))
         (base (base-symbol rune))
         (recs (and cache (cdr (assoc-rw-cache base cache)))))
    (cond
...">push-rw-cache-entry</a> (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> rw-cache-entry
                    <span class="keyword">:unify-subst</span> unify-subst
                    <span class="keyword">:failure-reason</span> (cons <span class="keyword">:rw-cache-alist</span> alist)
                    <span class="keyword">:hyp-info</span> hyps
                    <span class="keyword">:step-limit</span> step-limit)
                  'rw-cache-any-tag
                  rune
                  ttree)))))))))</pre>
  </div>

<div class="form-block function" id="def-rw-cache-enter-context" data-defines="RW-CACHE-ENTER-CONTEXT" data-references="REMOVE-TAG-FROM-TAG-TREE,RW-CACHE-NIL-TAG,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE,TTREE,DEFUN" data-used-by="REWRITE" data-part-name="RW-CACHE-ENTER-CONTEXT" data-part-args="TTREE" data-part-body="REMOVE-TAG-FROM-TAG-TREE,TTREE,RW-CACHE-NIL-TAG,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-ENTER-CONTEXT">rw-cache-enter-context</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-enter-context" data-sym="RW-CACHE-ENTER-CONTEXT" title="(defun rw-cache-enter-context (ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-nil-tag ttree)
                         (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">rw-cache-enter-context</a>
  (ttree)
  (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-any-tag
    (tagged-objects 'rw-cache-nil-tag ttree)
    (remove-tag-from-tag-tree 'rw-cache-any-tag ttree)))</pre>
  </div>

<div class="form-block function" id="def-erase-rw-cache" data-defines="ERASE-RW-CACHE" data-references="RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,QUOTE,REMOVE-TAG-FROM-TAG-TREE,TTREE,DEFUN" data-used-by="CONS-TAG-TREES-RW-CACHE-FIRST,CONS-TAG-TREES-RW-CACHE,RESTORE-RW-CACHE-ANY-TAG,RW-CACHE-EXIT-CONTEXT" data-part-name="ERASE-RW-CACHE" data-part-args="TTREE" data-part-body="TTREE,RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,QUOTE,REMOVE-TAG-FROM-TAG-TREE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ERASE-RW-CACHE">erase-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a>
  (ttree)
  (remove-tag-from-tag-tree 'rw-cache-nil-tag
    (remove-tag-from-tag-tree 'rw-cache-any-tag ttree)))</pre>
  </div>

<div class="form-block function" id="def-rw-cache-exit-context" data-defines="RW-CACHE-EXIT-CONTEXT" data-references="ERASE-RW-CACHE,RW-CACHE-NIL-TAG,MAYBE-EXTEND-TAG-TREE,IGNORE,DECLARE,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,COMBINE-RW-CACHES,NEW-ANY,FLG,MV-LET,NEW-TTREE,OLD-TTREE,DEFUN" data-used-by="REWRITE" data-part-name="RW-CACHE-EXIT-CONTEXT" data-part-args="NEW-TTREE,OLD-TTREE" data-part-body="ERASE-RW-CACHE,RW-CACHE-NIL-TAG,MAYBE-EXTEND-TAG-TREE,IGNORE,DECLARE,OLD-TTREE,NEW-TTREE,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,COMBINE-RW-CACHES,NEW-ANY,FLG,MV-LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-EXIT-CONTEXT">rw-cache-exit-context</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-exit-context" data-sym="RW-CACHE-EXIT-CONTEXT" title="(defun rw-cache-exit-context (old-ttree new-ttree)
  (mv-let (flg new-any)
          (combine-rw-caches (tagged-objects &#39;rw-cache-any-tag new-ttree)
                             (tagged-objects &#39;rw-cache-any-tag old-ttree))
          (declare (ignore flg))
...">rw-cache-exit-context</a>
  (old-ttree new-ttree)
  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg new-any)
    (<a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a> (tagged-objects 'rw-cache-any-tag new-ttree)
      (tagged-objects 'rw-cache-any-tag old-ttree))
    (declare (ignore flg))
    (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-any-tag
      new-any
      (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-nil-tag
        (tagged-objects 'rw-cache-nil-tag old-ttree)
        (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> new-ttree)))))</pre>
  </div>

<div class="form-block function" id="def-restore-rw-cache-any-tag" data-defines="RESTORE-RW-CACHE-ANY-TAG" data-references="ERASE-RW-CACHE,RW-CACHE-NIL-TAG,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE,OLD-TTREE,NEW-TTREE,DEFUN" data-used-by="REWRITE" data-part-name="RESTORE-RW-CACHE-ANY-TAG" data-part-args="OLD-TTREE,NEW-TTREE" data-part-body="NEW-TTREE,ERASE-RW-CACHE,RW-CACHE-NIL-TAG,OLD-TTREE,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RESTORE-RW-CACHE-ANY-TAG">restore-rw-cache-any-tag</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-restore-rw-cache-any-tag" data-sym="RESTORE-RW-CACHE-ANY-TAG" title="(defun restore-rw-cache-any-tag (new-ttree old-ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-any-tag old-ttree)
                         (maybe-extend-tag-tree &#39;rw-cache-nil-tag
                                                (tagged-objects
...">restore-rw-cache-any-tag</a>
  (new-ttree old-ttree)
  (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-any-tag
    (tagged-objects 'rw-cache-any-tag old-ttree)
    (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-nil-tag
      (tagged-objects 'rw-cache-nil-tag old-ttree)
      (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> new-ttree))))</pre>
  </div>

<div class="form-block function" id="def-cons-tag-trees-rw-cache" data-defines="CONS-TAG-TREES-RW-CACHE" data-references="REMOVE-TAG-FROM-TAG-TREE,T,ERASE-RW-CACHE,CONS-TAG-TREES,EXTEND-TAG-TREE,CACHE-NIL,FLG-NIL,IGNORE,DECLARE,COMBINE-RW-CACHES,CACHE-ANY,FLG-ANY,MV-LET,AND,COND,RW-CACHE-NIL2,RW-CACHE-NIL-TAG,RW-CACHE-NIL1,RW-CACHE-ANY2,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,RW-CACHE-ANY1,LET,TTREE2,TTREE1,DEFUN" data-used-by="REWRITE" data-part-name="CONS-TAG-TREES-RW-CACHE" data-part-args="TTREE2,TTREE1" data-part-body="REMOVE-TAG-FROM-TAG-TREE,T,ERASE-RW-CACHE,CONS-TAG-TREES,EXTEND-TAG-TREE,CACHE-NIL,FLG-NIL,IGNORE,DECLARE,COMBINE-RW-CACHES,CACHE-ANY,FLG-ANY,MV-LET,AND,COND,RW-CACHE-NIL2,RW-CACHE-NIL-TAG,RW-CACHE-NIL1,TTREE2,RW-CACHE-ANY2,TTREE1,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,RW-CACHE-ANY1,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONS-TAG-TREES-RW-CACHE">cons-tag-trees-rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache" data-sym="CONS-TAG-TREES-RW-CACHE" title="(defun cons-tag-trees-rw-cache (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects &#39;rw-cache-any-tag ttree1))
        (rw-cache-any2 (tagged-objects &#39;rw-cache-any-tag ttree2))
        (rw-cache-nil1 (tagged-objects &#39;rw-cache-nil-tag ttree1))
        (rw-cache-nil2 (tagged-objects &#39;rw-cache-nil-tag ttree2)))
...">cons-tag-trees-rw-cache</a>
  (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects 'rw-cache-any-tag ttree1)) (rw-cache-any2 (tagged-objects 'rw-cache-any-tag ttree2))
      (rw-cache-nil1 (tagged-objects 'rw-cache-nil-tag ttree1))
      (rw-cache-nil2 (tagged-objects 'rw-cache-nil-tag ttree2)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rw-cache-any1 rw-cache-any2) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg-any cache-any)
          (<a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a> rw-cache-any1 rw-cache-any2)
          (declare (ignore flg-any))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rw-cache-nil1 rw-cache-nil2) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg-nil cache-nil)
                (<a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a> rw-cache-nil1 rw-cache-nil2)
                (declare (ignore flg-nil))
                (extend-tag-tree 'rw-cache-any-tag
                  cache-any
                  (extend-tag-tree 'rw-cache-nil-tag
                    cache-nil
                    (cons-tag-trees (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> ttree1)
                      (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> ttree2))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-tag-tree 'rw-cache-any-tag
                cache-any
                (cons-tag-trees (remove-tag-from-tag-tree 'rw-cache-any-tag ttree1)
                  (remove-tag-from-tag-tree 'rw-cache-any-tag ttree2)))))))
      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rw-cache-nil1 rw-cache-nil2) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg-nil cache-nil)
          (<a class="sym-link local-def" href="#def-combine-rw-caches" data-sym="COMBINE-RW-CACHES" title="(defun combine-rw-caches (c1 c2)
  (cond ((null c1) (mv t c2)) ((null c2) (mv nil c1))
        (t
         (mv-let (flg x)
                 (merge-rw-caches (cdr-sort-rw-cache c1)
...">combine-rw-caches</a> rw-cache-nil1 rw-cache-nil2)
          (declare (ignore flg-nil))
          (extend-tag-tree 'rw-cache-nil-tag
            cache-nil
            (cons-tag-trees (remove-tag-from-tag-tree 'rw-cache-nil-tag ttree1)
              (remove-tag-from-tag-tree 'rw-cache-nil-tag ttree2)))))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons-tag-trees ttree1 ttree2)))))</pre>
  </div>

<div class="form-block function" id="def-normalize-rw-any-cache" data-defines="NORMALIZE-RW-ANY-CACHE" data-references="REMOVE-TAG-FROM-TAG-TREE,CDR-SORT-RW-CACHE,CONS,EXTEND-TAG-TREE,T,SORTED-RW-CACHE-P,NULL,OR,COND,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET,TTREE,DEFUN" data-used-by="REWRITE" data-part-name="NORMALIZE-RW-ANY-CACHE" data-part-args="TTREE" data-part-body="REMOVE-TAG-FROM-TAG-TREE,CDR-SORT-RW-CACHE,CONS,EXTEND-TAG-TREE,T,SORTED-RW-CACHE-P,NULL,OR,COND,TTREE,RW-CACHE-ANY-TAG,QUOTE,TAGGED-OBJECTS,CACHE,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="NORMALIZE-RW-ANY-CACHE">normalize-rw-any-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-normalize-rw-any-cache" data-sym="NORMALIZE-RW-ANY-CACHE" title="(defun normalize-rw-any-cache (ttree)
  (let ((cache (tagged-objects &#39;rw-cache-any-tag ttree)))
    (cond ((or (null cache) (sorted-rw-cache-p cache)) ttree)
          (t
           (extend-tag-tree &#39;rw-cache-any-tag
...">normalize-rw-any-cache</a>
  (ttree)
  (let ((cache (tagged-objects 'rw-cache-any-tag ttree)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> cache) (<a class="sym-link local-def" href="#def-sorted-rw-cache-p" data-sym="SORTED-RW-CACHE-P" title="(defmacro sorted-rw-cache-p (cache) `(eq (car ,cache) t))">sorted-rw-cache-p</a> cache)) ttree)
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (extend-tag-tree 'rw-cache-any-tag
          (cons <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-cdr-sort-rw-cache" data-sym="CDR-SORT-RW-CACHE" title="(defun cdr-sort-rw-cache (cache)
  (assert$ cache
           (cond ((sorted-rw-cache-p cache) (cdr cache))
                 (t
                  (mv-let (front back) (split-psorted-list cache)
...">cdr-sort-rw-cache</a> cache))
          (remove-tag-from-tag-tree 'rw-cache-any-tag ttree))))))</pre>
  </div>

<div class="form-block function" id="def-cons-tag-trees-rw-cache-first" data-defines="CONS-TAG-TREES-RW-CACHE-FIRST" data-references="ERASE-RW-CACHE,CONS-TAG-TREES,RW-CACHE-NIL-TAG,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE,TTREE2,TTREE1,DEFUN" data-used-by="REWRITE" data-part-name="CONS-TAG-TREES-RW-CACHE-FIRST" data-part-args="TTREE2,TTREE1" data-part-body="TTREE2,ERASE-RW-CACHE,CONS-TAG-TREES,RW-CACHE-NIL-TAG,TTREE1,TAGGED-OBJECTS,RW-CACHE-ANY-TAG,QUOTE,MAYBE-EXTEND-TAG-TREE" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="CONS-TAG-TREES-RW-CACHE-FIRST">cons-tag-trees-rw-cache-first</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache-first" data-sym="CONS-TAG-TREES-RW-CACHE-FIRST" title="(defun cons-tag-trees-rw-cache-first (ttree1 ttree2)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-any-tag ttree1)
                         (maybe-extend-tag-tree &#39;rw-cache-nil-tag
                                                (tagged-objects
...">cons-tag-trees-rw-cache-first</a>
  (ttree1 ttree2)
  (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-any-tag
    (tagged-objects 'rw-cache-any-tag ttree1)
    (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-nil-tag
      (tagged-objects 'rw-cache-nil-tag ttree1)
      (cons-tag-trees (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> ttree1)
        (<a class="sym-link local-def" href="#def-erase-rw-cache" data-sym="ERASE-RW-CACHE" title="(defun erase-rw-cache (ttree)
  (remove-tag-from-tag-tree &#39;rw-cache-nil-tag
                            (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">erase-rw-cache</a> ttree2)))))</pre>
  </div>

<div class="form-block macro" id="def-tag-tree-tags-subsetp" data-defines="TAG-TREE-TAGS-SUBSETP" data-references="ALIST-KEYS-SUBSETP,QUASIQUOTE,TAGS,TTREE,DEFMACRO" data-used-by="RW-CACHE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="TAG-TREE-TAGS-SUBSETP">tag-tree-tags-subsetp</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-tag-tree-tags-subsetp" data-sym="TAG-TREE-TAGS-SUBSETP" title="(defmacro tag-tree-tags-subsetp (ttree tags) `(alist-keys-subsetp ,ttree ,tags))">tag-tree-tags-subsetp</a>
  (ttree tags)
  `(<a class="sym-link system" href="basis-a.html#def-alist-keys-subsetp" data-sym="ALIST-KEYS-SUBSETP">alist-keys-subsetp</a> ,TTREE ,TAGS))</pre>
  </div>

<div class="form-block function" id="def-rw-cache" data-defines="RW-CACHE" data-references="TAGGED-OBJECTS,MAYBE-EXTEND-TAG-TREE,T,RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,QUOTE,TAG-TREE-TAGS-SUBSETP,COND,TTREE,DEFUN" data-used-by="REWRITE" data-part-name="RW-CACHE" data-part-args="TTREE" data-part-body="TAGGED-OBJECTS,MAYBE-EXTEND-TAG-TREE,T,RW-CACHE-ANY-TAG,RW-CACHE-NIL-TAG,QUOTE,TTREE,TAG-TREE-TAGS-SUBSETP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE">rw-cache</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache" data-sym="RW-CACHE" title="(defun rw-cache (ttree)
  (cond
   ((tag-tree-tags-subsetp ttree &#39;(rw-cache-nil-tag rw-cache-any-tag)) ttree)
   (t
    (maybe-extend-tag-tree &#39;rw-cache-any-tag
...">rw-cache</a>
  (ttree)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-tag-tree-tags-subsetp" data-sym="TAG-TREE-TAGS-SUBSETP" title="(defmacro tag-tree-tags-subsetp (ttree tags) `(alist-keys-subsetp ,ttree ,tags))">tag-tree-tags-subsetp</a> ttree
       '(rw-cache-nil-tag rw-cache-any-tag)) ttree)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-any-tag
        (tagged-objects 'rw-cache-any-tag ttree)
        (<a class="sym-link local-def" href="#def-maybe-extend-tag-tree" data-sym="MAYBE-EXTEND-TAG-TREE" title="(defun maybe-extend-tag-tree (tag vals ttree)
  (cond ((null vals) ttree) (t (extend-tag-tree tag vals ttree))))">maybe-extend-tag-tree</a> 'rw-cache-nil-tag
          (tagged-objects 'rw-cache-nil-tag ttree)
          nil)))))</pre>
  </div>

<div class="form-block function" id="def-rw-cached-failure-pair" data-defines="RW-CACHED-FAILURE-PAIR" data-references="NOT,MV,FREE-FAILURE-P,CONSP,CACHED-FAILURE-REASON-FREE-P,ASSOC-EQUAL,CDR,AND,CACHED-FAILURE-REASON-RAW,LET*,RW-CACHE-ALIST,UNIFY-SUBST,DEFUN" data-used-by="REWRITE" data-part-name="RW-CACHED-FAILURE-PAIR" data-part-args="RW-CACHE-ALIST,UNIFY-SUBST" data-part-body="NOT,MV,FREE-FAILURE-P,CONSP,CACHED-FAILURE-REASON-FREE-P,UNIFY-SUBST,ASSOC-EQUAL,CDR,RW-CACHE-ALIST,AND,CACHED-FAILURE-REASON-RAW,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHED-FAILURE-PAIR">rw-cached-failure-pair</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cached-failure-pair" data-sym="RW-CACHED-FAILURE-PAIR" title="(defun rw-cached-failure-pair (unify-subst rw-cache-alist)
  (let* ((cached-failure-reason-raw
          (and rw-cache-alist (cdr (assoc-equal unify-subst rw-cache-alist))))
         (cached-failure-reason-free-p
          (and (consp cached-failure-reason-raw)
...">rw-cached-failure-pair</a>
  (unify-subst rw-cache-alist)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((cached-failure-reason-raw (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rw-cache-alist
         (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> unify-subst rw-cache-alist)))) (cached-failure-reason-free-p (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp cached-failure-reason-raw)
          (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> cached-failure-reason-raw))))
    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cached-failure-reason-free-p cached-failure-reason-raw)
      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> cached-failure-reason-free-p)
        cached-failure-reason-raw))))</pre>
  </div>

<div class="form-block function" id="def-extend-rw-cache-alist-free" data-defines="EXTEND-RW-CACHE-ALIST-FREE" data-references="T,CONS,PUT-ASSOC-EQUAL,RW-CACHE-ACTIVE-P,AND,COND,RW-CACHE-ALIST-NEW,INFERIOR-RW-CACHE-ALIST-NEW,NEW-UNIFY-SUBST,RCNST,DEFUN" data-used-by="REWRITE" data-part-name="EXTEND-RW-CACHE-ALIST-FREE" data-part-args="RW-CACHE-ALIST-NEW,INFERIOR-RW-CACHE-ALIST-NEW,NEW-UNIFY-SUBST,RCNST" data-part-body="T,RW-CACHE-ALIST-NEW,CONS,NEW-UNIFY-SUBST,PUT-ASSOC-EQUAL,RCNST,RW-CACHE-ACTIVE-P,INFERIOR-RW-CACHE-ALIST-NEW,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-RW-CACHE-ALIST-FREE">extend-rw-cache-alist-free</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-rw-cache-alist-free" data-sym="EXTEND-RW-CACHE-ALIST-FREE" title="(defun extend-rw-cache-alist-free
       (rcnst new-unify-subst inferior-rw-cache-alist-new rw-cache-alist-new)
  (cond
   ((and inferior-rw-cache-alist-new (rw-cache-active-p rcnst))
    (put-assoc-equal new-unify-subst
...">extend-rw-cache-alist-free</a>
  (rcnst new-unify-subst
    inferior-rw-cache-alist-new
    rw-cache-alist-new)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> inferior-rw-cache-alist-new (<a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a> rcnst)) (<a class="sym-link system" href="axioms.html#def-put-assoc-equal" data-sym="PUT-ASSOC-EQUAL">put-assoc-equal</a> new-unify-subst
        (cons <span class="keyword">:rw-cache-alist</span> inferior-rw-cache-alist-new)
        rw-cache-alist-new))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> rw-cache-alist-new)))</pre>
  </div>

<div class="form-block function" id="def-rw-cache-add-failure-reason" data-defines="RW-CACHE-ADD-FAILURE-REASON" data-references="T,ACONS,RW-CACHEABLE-FAILURE-REASON,RW-CACHE-ACTIVE-P,AND,COND,RW-CACHE-ALIST-NEW,FAILURE-REASON,NEW-UNIFY-SUBST,RCNST,DEFUN" data-used-by="REWRITE" data-part-name="RW-CACHE-ADD-FAILURE-REASON" data-part-args="RW-CACHE-ALIST-NEW,FAILURE-REASON,NEW-UNIFY-SUBST,RCNST" data-part-body="T,RW-CACHE-ALIST-NEW,NEW-UNIFY-SUBST,ACONS,RW-CACHEABLE-FAILURE-REASON,FAILURE-REASON,RCNST,RW-CACHE-ACTIVE-P,AND,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RW-CACHE-ADD-FAILURE-REASON">rw-cache-add-failure-reason</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rw-cache-add-failure-reason" data-sym="RW-CACHE-ADD-FAILURE-REASON" title="(defun rw-cache-add-failure-reason
       (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (cond
   ((and (rw-cache-active-p rcnst) failure-reason
         (rw-cacheable-failure-reason failure-reason))
...">rw-cache-add-failure-reason</a>
  (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a> rcnst)
       failure-reason
       (rw-cacheable-failure-reason failure-reason)) (<a class="sym-link system" href="axioms.html#def-acons" data-sym="ACONS">acons</a> new-unify-subst failure-reason rw-cache-alist-new))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> rw-cache-alist-new)))</pre>
  </div>

<div class="form-block function" id="def-add-linear-lemma-finish" data-defines="ADD-LINEAR-LEMMA-FINISH" data-references="NEW-VARS-IN-POT-LST,SET-LOOP-STOPPER-VALUES,ADD-POLYS,NEW-POT-LST,CONTRADICTIONP,MV-LET,LINEAR-POSSIBLE-LOOP,LOOP-STOPPER-VALUE-OF-VAR,*MAX-LINEAR-POT-LOOP-STOPPER-VALUE*,<=,CAR,NEW-AND-UGLY-LINEAR-VARSP,LINEARIZE-UNREWRITTEN-PRODUCED-DISJUNCTION,LINEARIZE-REWRITTEN-PRODUCED-DISJUNCTION,IF,CDR,IRRELEVANT,QUOTE,MV,NULL,AND,COND,PUSH-LEMMA,REWRITE-CONSTANT,ACCESS,T,LINEARIZE,LST,LET,TTREE,RCNST,SIMPLIFY-CLAUSE-POT-LST,STATE,WRLD,TYPE-ALIST,TERM,REWRITTEN-P,RUNE,FORCE-FLG,CONCL,DEFUN" data-used-by="REWRITE" data-part-name="ADD-LINEAR-LEMMA-FINISH" data-part-args="TTREE,RCNST,SIMPLIFY-CLAUSE-POT-LST,STATE,WRLD,TYPE-ALIST,TERM,REWRITTEN-P,RUNE,FORCE-FLG,CONCL" data-part-body="NEW-VARS-IN-POT-LST,SET-LOOP-STOPPER-VALUES,ADD-POLYS,NEW-POT-LST,CONTRADICTIONP,MV-LET,LINEAR-POSSIBLE-LOOP,TERM,LOOP-STOPPER-VALUE-OF-VAR,*MAX-LINEAR-POT-LOOP-STOPPER-VALUE*,<=,CAR,NEW-AND-UGLY-LINEAR-VARSP,LINEARIZE-UNREWRITTEN-PRODUCED-DISJUNCTION,LINEARIZE-REWRITTEN-PRODUCED-DISJUNCTION,IF,SIMPLIFY-CLAUSE-POT-LST,CDR,IRRELEVANT,QUOTE,MV,REWRITTEN-P,NULL,AND,COND,STATE,TTREE,RUNE,PUSH-LEMMA,WRLD,FORCE-FLG,RCNST,REWRITE-CONSTANT,ACCESS,TYPE-ALIST,T,CONCL,LINEARIZE,LST,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ADD-LINEAR-LEMMA-FINISH">add-linear-lemma-finish</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-add-linear-lemma-finish" data-sym="ADD-LINEAR-LEMMA-FINISH" title="(defun add-linear-lemma-finish
       (concl force-flg rune rewritten-p term type-alist wrld state
        simplify-clause-pot-lst rcnst ttree)
  (let ((lst
         (linearize concl t type-alist
...">add-linear-lemma-finish</a>
  (concl force-flg
    rune
    rewritten-p
    term
    type-alist
    wrld
    state
    simplify-clause-pot-lst
    rcnst
    ttree)
  (let ((lst (linearize concl
         <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
         type-alist
         (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
         force-flg
         wrld
         (push-lemma rune ttree)
         state)))
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) rewritten-p) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil <span class="keyword">:null-lst</span> 'irrelevant 'irrelevant))
      ((cdr lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
          simplify-clause-pot-lst
          (if rewritten-p
            'linearize-rewritten-produced-disjunction
            'linearize-unrewritten-produced-disjunction)
          nil))
      ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lst) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil simplify-clause-pot-lst nil nil))
      ((new-and-ugly-linear-varsp (car lst)
         (<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> *max-linear-pot-loop-stopper-value*
           (loop-stopper-value-of-var term simplify-clause-pot-lst))
         term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil simplify-clause-pot-lst 'linear-possible-loop nil))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
          (add-polys (car lst)
            simplify-clause-pot-lst
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
            type-alist
            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
            force-flg
            wrld)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> contradictionp nil nil (car lst)))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                (set-loop-stopper-values (new-vars-in-pot-lst new-pot-lst
                    simplify-clause-pot-lst
                    nil)
                  new-pot-lst
                  term
                  (loop-stopper-value-of-var term simplify-clause-pot-lst))
                nil
                (car lst)))))))))</pre>
  </div>

<div class="form-block function" id="def-make-stack-from-alist" data-defines="MAKE-STACK-FROM-ALIST" data-references="APPEND,CONS,LIST,SET-DIFFERENCE-EQ,FREE,STRIP-CDRS,ACTUALS,STRIP-CARS,FORMALS,ALL-VARS,VARS-OF-TERM,LET*,IF,ALIST,TERM,DEFUN" data-used-by="REWRITE" data-part-name="MAKE-STACK-FROM-ALIST" data-part-args="ALIST,TERM" data-part-body="APPEND,CONS,LIST,SET-DIFFERENCE-EQ,FREE,STRIP-CDRS,ACTUALS,STRIP-CARS,FORMALS,TERM,ALL-VARS,VARS-OF-TERM,LET*,ALIST,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MAKE-STACK-FROM-ALIST">make-stack-from-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-make-stack-from-alist" data-sym="MAKE-STACK-FROM-ALIST" title="(defun make-stack-from-alist (term alist)
  (if alist
      (let* ((vars-of-term (all-vars term))
             (formals (strip-cars alist))
             (actuals (strip-cdrs alist))
...">make-stack-from-alist</a>
  (term alist)
  (if alist
    (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((vars-of-term (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> term)) (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-strip-cars" data-sym="STRIP-CARS">strip-cars</a> alist))
        (actuals (<a class="sym-link system" href="axioms.html#def-strip-cdrs" data-sym="STRIP-CDRS">strip-cdrs</a> alist))
        (free (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> vars-of-term <a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a>)))
      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> free <a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a>) (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> free actuals))))
    nil))</pre>
  </div>

<div class="form-block function" id="def-lambda-nest-hidep" data-defines="LAMBDA-NEST-HIDEP" data-references="T,HIDE,QUOTE,EQ,FQUOTEP,VARIABLEP,COND,FFN-SYMB,LAMBDA-BODY,BODY,LET,LAMBDA-APPLICATIONP,AND,TERM,DEFUN" data-used-by="REWRITE" data-part-name="LAMBDA-NEST-HIDEP" data-part-args="TERM" data-part-body="LAMBDA-NEST-HIDEP,T,HIDE,QUOTE,EQ,FQUOTEP,VARIABLEP,COND,FFN-SYMB,LAMBDA-BODY,BODY,LET,TERM,LAMBDA-APPLICATIONP,AND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LAMBDA-NEST-HIDEP">lambda-nest-hidep</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lambda-nest-hidep" data-sym="LAMBDA-NEST-HIDEP" title="(defun lambda-nest-hidep (term)
  (and (lambda-applicationp term)
       (let ((body (lambda-body (ffn-symb term))))
         (cond ((variablep body) nil) ((fquotep body) nil)
               ((eq (ffn-symb body) &#39;hide) t) (t (lambda-nest-hidep body))))))">lambda-nest-hidep</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-lambda-applicationp" data-sym="LAMBDA-APPLICATIONP">lambda-applicationp</a> term)
    (let ((<a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>) nil)
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>) nil)
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-lambda-nest-hidep" data-sym="LAMBDA-NEST-HIDEP" title="(defun lambda-nest-hidep (term)
  (and (lambda-applicationp term)
       (let ((body (lambda-body (ffn-symb term))))
         (cond ((variablep body) nil) ((fquotep body) nil)
               ((eq (ffn-symb body) &#39;hide) t) (t (lambda-nest-hidep body))))))">lambda-nest-hidep</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>))))))</pre>
  </div>

<div class="form-block function" id="def-lambda-nest-unhide" data-defines="LAMBDA-NEST-UNHIDE" data-references="FARGN,FARGS,LAMBDA-BODY,FFN-SYMB,LAMBDA-FORMALS,MAKE-LAMBDA-APPLICATION,LAMBDA-APPLICATIONP,IF,TERM,DEFUN" data-used-by="REWRITE" data-part-name="LAMBDA-NEST-UNHIDE" data-part-args="TERM" data-part-body="FARGN,FARGS,LAMBDA-BODY,LAMBDA-NEST-UNHIDE,FFN-SYMB,LAMBDA-FORMALS,MAKE-LAMBDA-APPLICATION,TERM,LAMBDA-APPLICATIONP,IF" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="LAMBDA-NEST-UNHIDE">lambda-nest-unhide</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-lambda-nest-unhide" data-sym="LAMBDA-NEST-UNHIDE" title="(defun lambda-nest-unhide (term)
  (if (lambda-applicationp term)
      (make-lambda-application (lambda-formals (ffn-symb term))
                               (lambda-nest-unhide
                                (lambda-body (ffn-symb term)))
...">lambda-nest-unhide</a>
  (term)
  (if (<a class="sym-link system" href="basis-b.html#def-lambda-applicationp" data-sym="LAMBDA-APPLICATIONP">lambda-applicationp</a> term)
    (make-lambda-application (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
      (<a class="sym-link local-def" href="#def-lambda-nest-unhide" data-sym="LAMBDA-NEST-UNHIDE" title="(defun lambda-nest-unhide (term)
  (if (lambda-applicationp term)
      (make-lambda-application (lambda-formals (ffn-symb term))
                               (lambda-nest-unhide
                                (lambda-body (ffn-symb term)))
...">lambda-nest-unhide</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
      (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term))
    (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)))</pre>
  </div>

<div class="form-block other" id="def-memo-activep" data-defines="MEMO-ACTIVEP" data-references="CONSP,EQ,OR,MEMO,DEFABBREV" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="MEMO-ACTIVEP">memo-activep</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-memo-activep" data-sym="MEMO-ACTIVEP" title="(defabbrev memo-activep (memo) (or (eq memo :start) (consp memo)))">memo-activep</a>
  (memo)
  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> memo <span class="keyword">:start</span>) (consp memo)))</pre>
  </div>

<div class="form-block other" id="def-activate-memo" data-defines="ACTIVATE-MEMO" data-references="T,EQ,IF,MEMO,DEFABBREV" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ACTIVATE-MEMO">activate-memo</span><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="basis-a.html#def-defabbrev" data-sym="DEFABBREV">defabbrev</a> <a class="sym-link local-def" href="#def-activate-memo" data-sym="ACTIVATE-MEMO" title="(defabbrev activate-memo (memo)
           (if (eq memo t)
               :start
               memo))">activate-memo</a>
  (memo)
  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> memo <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    <span class="keyword">:start</span> memo))</pre>
  </div>

<div class="form-block function" id="def-intersection1-eq" data-defines="INTERSECTION1-EQ" data-references="CDR,T,CAR,MEMBER-EQ,ENDP,COND,SYMBOL-LISTP,OR,TRUE-LISTP,AND,XARGS,DECLARE,Y,X,DEFUN" data-part-name="INTERSECTION1-EQ" data-part-args="Y,X" data-part-declare="SYMBOL-LISTP,OR,Y,X,TRUE-LISTP,AND,XARGS,DECLARE" data-part-body="CDR,INTERSECTION1-EQ,T,Y,CAR,MEMBER-EQ,X,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="INTERSECTION1-EQ">intersection1-eq</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-intersection1-eq" data-sym="INTERSECTION1-EQ" title="(defun intersection1-eq (x y)
  (declare
   (xargs :guard
    (and (true-listp x) (true-listp y)
         (or (symbol-listp x) (symbol-listp y)))))
...">intersection1-eq</a>
  (x y)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> x)
        (<a class="sym-link system" href="axioms.html#def-true-listp" data-sym="TRUE-LISTP">true-listp</a> y)
        (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> x) (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> y)))))
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> x) nil)
    ((<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> (car x) y) (car x))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-intersection1-eq" data-sym="INTERSECTION1-EQ" title="(defun intersection1-eq (x y)
  (declare
   (xargs :guard
    (and (true-listp x) (true-listp y)
         (or (symbol-listp x) (symbol-listp y)))))
...">intersection1-eq</a> (cdr x) y))))</pre>
  </div>

<div class="form-block function" id="def-forbidden-fns-in-term" data-defines="FORBIDDEN-FNS-IN-TERM" data-references="ALL-FNNAMES,INTERSECTION-EQ,FORBIDDEN-FNS,TERM,DEFUN" data-used-by="REWRITE" data-part-name="FORBIDDEN-FNS-IN-TERM" data-part-args="FORBIDDEN-FNS,TERM" data-part-body="FORBIDDEN-FNS,TERM,ALL-FNNAMES,INTERSECTION-EQ" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORBIDDEN-FNS-IN-TERM">forbidden-fns-in-term</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-forbidden-fns-in-term" data-sym="FORBIDDEN-FNS-IN-TERM" title="(defun forbidden-fns-in-term (term forbidden-fns)
  (intersection-eq (all-fnnames term) forbidden-fns))">forbidden-fns-in-term</a>
  (term <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>)
  (<a class="sym-link system" href="axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (all-fnnames term) <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>))</pre>
  </div>

<div class="form-block function" id="def-forbidden-fns-in-term-list" data-defines="FORBIDDEN-FNS-IN-TERM-LIST" data-references="ALL-FNNAMES-LST,INTERSECTION-EQ,FORBIDDEN-FNS,LST,DEFUN" data-part-name="FORBIDDEN-FNS-IN-TERM-LIST" data-part-args="FORBIDDEN-FNS,LST" data-part-body="FORBIDDEN-FNS,LST,ALL-FNNAMES-LST,INTERSECTION-EQ" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORBIDDEN-FNS-IN-TERM-LIST">forbidden-fns-in-term-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-forbidden-fns-in-term-list" data-sym="FORBIDDEN-FNS-IN-TERM-LIST" title="(defun forbidden-fns-in-term-list (lst forbidden-fns)
  (intersection-eq (all-fnnames-lst lst) forbidden-fns))">forbidden-fns-in-term-list</a>
  (lst <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>)
  (<a class="sym-link system" href="axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (all-fnnames-lst lst) <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>))</pre>
  </div>

<div class="form-block function" id="def-all-fnnames-lst-lst1" data-defines="ALL-FNNAMES-LST-LST1" data-references="CAR,ALL-FNNAMES1,CDR,T,ENDP,COND,ACC,CL-LST,DEFUN" data-used-by="FORBIDDEN-FNS-IN-TERM-LIST-LIST" data-part-name="ALL-FNNAMES-LST-LST1" data-part-args="ACC,CL-LST" data-part-body="CAR,ALL-FNNAMES1,CDR,ALL-FNNAMES-LST-LST1,T,ACC,CL-LST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-FNNAMES-LST-LST1">all-fnnames-lst-lst1</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-all-fnnames-lst-lst1" data-sym="ALL-FNNAMES-LST-LST1" title="(defun all-fnnames-lst-lst1 (cl-lst acc)
  (cond ((endp cl-lst) acc)
        (t
         (all-fnnames-lst-lst1 (cdr cl-lst)
                               (all-fnnames1 t (car cl-lst) acc)))))">all-fnnames-lst-lst1</a>
  (cl-lst acc)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> cl-lst) acc)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-all-fnnames-lst-lst1" data-sym="ALL-FNNAMES-LST-LST1" title="(defun all-fnnames-lst-lst1 (cl-lst acc)
  (cond ((endp cl-lst) acc)
        (t
         (all-fnnames-lst-lst1 (cdr cl-lst)
                               (all-fnnames1 t (car cl-lst) acc)))))">all-fnnames-lst-lst1</a> (cdr cl-lst)
        (all-fnnames1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (car cl-lst) acc)))))</pre>
  </div>

<div class="form-block function" id="def-forbidden-fns-in-term-list-list" data-defines="FORBIDDEN-FNS-IN-TERM-LIST-LIST" data-references="ALL-FNNAMES-LST-LST1,INTERSECTION-EQ,FORBIDDEN-FNS,CL-LST,DEFUN" data-part-name="FORBIDDEN-FNS-IN-TERM-LIST-LIST" data-part-args="FORBIDDEN-FNS,CL-LST" data-part-body="FORBIDDEN-FNS,CL-LST,ALL-FNNAMES-LST-LST1,INTERSECTION-EQ" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORBIDDEN-FNS-IN-TERM-LIST-LIST">forbidden-fns-in-term-list-list</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-forbidden-fns-in-term-list-list" data-sym="FORBIDDEN-FNS-IN-TERM-LIST-LIST" title="(defun forbidden-fns-in-term-list-list (cl-lst forbidden-fns)
  (intersection-eq (all-fnnames-lst-lst1 cl-lst nil) forbidden-fns))">forbidden-fns-in-term-list-list</a>
  (cl-lst <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>)
  (<a class="sym-link system" href="axioms.html#def-intersection-eq" data-sym="INTERSECTION-EQ">intersection-eq</a> (<a class="sym-link local-def" href="#def-all-fnnames-lst-lst1" data-sym="ALL-FNNAMES-LST-LST1" title="(defun all-fnnames-lst-lst1 (cl-lst acc)
  (cond ((endp cl-lst) acc)
        (t
         (all-fnnames-lst-lst1 (cdr cl-lst)
                               (all-fnnames1 t (car cl-lst) acc)))))">all-fnnames-lst-lst1</a> cl-lst nil)
    <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>))</pre>
  </div>

<div class="form-block function" id="def-forbidden-fns" data-defines="FORBIDDEN-FNS" data-references="*TTAG-FNS*,TTAG,NOT,AND,REVERSE-STRIP-CARS,UNTOUCHABLE-FNS,GLOBAL-VAL,SET-DIFFERENCE-EQ,T,TEMP-TOUCHABLE-FNS,QUOTE,F-GET-GLOBAL,EQ,COND,FORBIDDEN-FNS0,LET*,STATE,WRLD,DEFUN" data-used-by="FORBIDDEN-FNS-IN-TERM-LIST-LIST,FORBIDDEN-FNS-IN-TERM-LIST,FORBIDDEN-FNS-IN-TERM" data-part-name="FORBIDDEN-FNS" data-part-args="STATE,WRLD" data-part-body="*TTAG-FNS*,TTAG,NOT,AND,REVERSE-STRIP-CARS,WRLD,UNTOUCHABLE-FNS,GLOBAL-VAL,SET-DIFFERENCE-EQ,T,STATE,TEMP-TOUCHABLE-FNS,QUOTE,F-GET-GLOBAL,EQ,COND,FORBIDDEN-FNS0,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORBIDDEN-FNS">forbidden-fns</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-forbidden-fns" data-sym="FORBIDDEN-FNS" title="(defun forbidden-fns (wrld state)
  (let* ((forbidden-fns0
          (cond ((eq (f-get-global &#39;temp-touchable-fns state) t) nil)
                ((f-get-global &#39;temp-touchable-fns state)
                 (set-difference-eq (global-val &#39;untouchable-fns wrld)
...">forbidden-fns</a>
  (wrld state)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((forbidden-fns0 (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'temp-touchable-fns state) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) nil)
         ((<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'temp-touchable-fns state) (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'untouchable-fns wrld)
             (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'temp-touchable-fns state)))
         (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'untouchable-fns wrld)))))
    (<a class="sym-link system" href="axioms.html#def-reverse-strip-cars" data-sym="REVERSE-STRIP-CARS">reverse-strip-cars</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-ttag" data-sym="TTAG">ttag</a> wrld)) <a class="sym-link system" href="axioms.html#def-_2Attag-fns_2A" data-sym="*TTAG-FNS*">*ttag-fns*</a>)
      forbidden-fns0)))</pre>
  </div>

<div class="form-block other" id="form-447" typeof="Code">
    <div class="form-header"><span class="form-type">other</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-set-table-guard" data-sym="SET-TABLE-GUARD">set-table-guard</a> skip-meta-termp-checks-table
  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> val) (<a class="sym-link system" href="axioms.html#def-ttag" data-sym="TTAG">ttag</a> world))
    (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> key <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> val)))
  <span class="keyword">:topic</span> <a class="sym-link local-def" href="#def-set-skip-meta-termp-checks" data-sym="SET-SKIP-META-TERMP-CHECKS" title="(defmacro set-skip-meta-termp-checks (x)
  `(local (set-skip-meta-termp-checks! ,x)))">set-skip-meta-termp-checks</a>
  <span class="keyword">:coda</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> val
    (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-ttag" data-sym="TTAG">ttag</a> world))
    (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"An active trust tag is required for setting ~
                                  ~x0 except when clearing it."</span>
      'skip-meta-termp-checks-table)))</pre>
  </div>

<div class="form-block macro" id="def-set-skip-meta-termp-checks_21" data-defines="SET-SKIP-META-TERMP-CHECKS!" data-references="QUOTE,T,SKIP-META-TERMP-CHECKS-TABLE,TABLE,QUASIQUOTE,SYMBOL-LISTP,BOOLEANP,OR,XARGS,DECLARE,X,DEFMACRO" data-used-by="SET-SKIP-META-TERMP-CHECKS" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-SKIP-META-TERMP-CHECKS!">set-skip-meta-termp-checks!</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-skip-meta-termp-checks_21" data-sym="SET-SKIP-META-TERMP-CHECKS!" title="(defmacro set-skip-meta-termp-checks! (x)
  (declare (xargs :guard (or (booleanp x) (symbol-listp x))))
  `(table skip-meta-termp-checks-table t &#39;,x))">set-skip-meta-termp-checks!</a>
  (x)
  (declare (xargs <span class="keyword">:guard</span> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-booleanp" data-sym="BOOLEANP">booleanp</a> x) (<a class="sym-link system" href="axioms.html#def-symbol-listp" data-sym="SYMBOL-LISTP">symbol-listp</a> x))))
  `(<a class="sym-link system" href="axioms.html#def-table" data-sym="TABLE">table</a> skip-meta-termp-checks-table <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ',X))</pre>
  </div>

<div class="form-block macro" id="def-set-skip-meta-termp-checks" data-defines="SET-SKIP-META-TERMP-CHECKS" data-references="SET-SKIP-META-TERMP-CHECKS!,LOCAL,QUASIQUOTE,X,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="SET-SKIP-META-TERMP-CHECKS">set-skip-meta-termp-checks</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-set-skip-meta-termp-checks" data-sym="SET-SKIP-META-TERMP-CHECKS" title="(defmacro set-skip-meta-termp-checks (x)
  `(local (set-skip-meta-termp-checks! ,x)))">set-skip-meta-termp-checks</a>
  (x)
  `(<a class="sym-link system" href="axioms.html#def-local" data-sym="LOCAL">local</a> (<a class="sym-link local-def" href="#def-set-skip-meta-termp-checks_21" data-sym="SET-SKIP-META-TERMP-CHECKS!" title="(defmacro set-skip-meta-termp-checks! (x)
  (declare (xargs :guard (or (booleanp x) (symbol-listp x))))
  `(table skip-meta-termp-checks-table t &#39;,x))">set-skip-meta-termp-checks!</a> ,X)))</pre>
  </div>

<div class="form-block function" id="def-skip-meta-termp-checks" data-defines="SKIP-META-TERMP-CHECKS" data-references="MEMBER-EQ,AND,EQ,OR,SKIP-META-TERMP-CHECKS-TABLE,QUOTE,TABLE-ALIST,T,ASSOC-EQ,CDR,VAL,LET,WRLD,FN,DEFUN" data-used-by="REWRITE" data-part-name="SKIP-META-TERMP-CHECKS" data-part-args="WRLD,FN" data-part-body="FN,MEMBER-EQ,AND,EQ,OR,WRLD,SKIP-META-TERMP-CHECKS-TABLE,QUOTE,TABLE-ALIST,T,ASSOC-EQ,CDR,VAL,LET" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="SKIP-META-TERMP-CHECKS">skip-meta-termp-checks</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-skip-meta-termp-checks" data-sym="SKIP-META-TERMP-CHECKS" title="(defun skip-meta-termp-checks (fn wrld)
  (let ((val
         (cdr (assoc-eq t (table-alist &#39;skip-meta-termp-checks-table wrld)))))
    (or (eq val t) (and val (member-eq fn val)))))">skip-meta-termp-checks</a>
  (fn wrld)
  (let ((val (cdr (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
           (<a class="sym-link system" href="axioms.html#def-table-alist" data-sym="TABLE-ALIST">table-alist</a> 'skip-meta-termp-checks-table wrld)))))
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> val <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> val (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> fn val)))))</pre>
  </div>

<div class="form-block function" id="def-collect-bad-fn-arity-info" data-defines="COLLECT-BAD-FN-ARITY-INFO" data-references="PROGRAMP,EQL,NULL,CDR,CAR,ARITY,LET,T,REVERSE,CONS,OR,IF,ENDP,COND,NON-LOGIC-FNS,BAD-ARITY-ALIST,WRLD,ALIST,DEFUN" data-used-by="REWRITE" data-part-name="COLLECT-BAD-FN-ARITY-INFO" data-part-args="NON-LOGIC-FNS,BAD-ARITY-ALIST,WRLD,ALIST" data-part-body="PROGRAMP,EQL,NULL,CDR,COLLECT-BAD-FN-ARITY-INFO,WRLD,CAR,ARITY,LET,T,REVERSE,CONS,NON-LOGIC-FNS,BAD-ARITY-ALIST,OR,IF,ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-BAD-FN-ARITY-INFO">collect-bad-fn-arity-info</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-bad-fn-arity-info" data-sym="COLLECT-BAD-FN-ARITY-INFO" title="(defun collect-bad-fn-arity-info (alist wrld bad-arity-alist non-logic-fns)
  (cond
   ((endp alist)
    (if (or bad-arity-alist non-logic-fns)
        (cons (reverse bad-arity-alist) non-logic-fns)
...">collect-bad-fn-arity-info</a>
  (alist wrld bad-arity-alist non-logic-fns)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> alist) (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> bad-arity-alist non-logic-fns)
        (cons (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> bad-arity-alist) non-logic-fns)
        nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((<a class="sym-link system" href="basis-b.html#def-arity" data-sym="ARITY">arity</a> (<a class="sym-link system" href="basis-b.html#def-arity" data-sym="ARITY">arity</a> (car (car alist)) wrld)))
        (<a class="sym-link local-def" href="#def-collect-bad-fn-arity-info" data-sym="COLLECT-BAD-FN-ARITY-INFO" title="(defun collect-bad-fn-arity-info (alist wrld bad-arity-alist non-logic-fns)
  (cond
   ((endp alist)
    (if (or bad-arity-alist non-logic-fns)
        (cons (reverse bad-arity-alist) non-logic-fns)
...">collect-bad-fn-arity-info</a> (cdr alist)
          wrld
          (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="basis-b.html#def-arity" data-sym="ARITY">arity</a>) (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> <a class="sym-link system" href="basis-b.html#def-arity" data-sym="ARITY">arity</a> (cdr (car alist))))
            bad-arity-alist
            (cons (car alist) bad-arity-alist))
          (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="basis-b.html#def-arity" data-sym="ARITY">arity</a>) (<a class="sym-link system" href="axioms.html#def-programp" data-sym="PROGRAMP">programp</a> (car (car alist)) wrld))
            (cons (car (car alist)) non-logic-fns)
            non-logic-fns))))))</pre>
  </div>

<div class="form-block function" id="def-bad-arities-msg" data-defines="BAD-ARITIES-MSG" data-references="NULL,CDR,NON-LOGIC-FNS,CAR,BAD-ARITIES-ALIST,LET,LOGIC-TERM-LIST-LISTP,LOGIC-TERMP,QUOTE,AND,OR,EQ,IF,MSG,BAD-ARITY-INFO,WF-THM-NAME2,WF-THM-NAME1,HYP-FN,FN,TOKEN,NAME,DEFUN" data-used-by="REWRITE" data-part-name="BAD-ARITIES-MSG" data-part-args="BAD-ARITY-INFO,WF-THM-NAME2,WF-THM-NAME1,HYP-FN,FN,TOKEN,NAME" data-part-body="NULL,CDR,NON-LOGIC-FNS,BAD-ARITY-INFO,CAR,BAD-ARITIES-ALIST,LET,WF-THM-NAME2,WF-THM-NAME1,LOGIC-TERM-LIST-LISTP,LOGIC-TERMP,QUOTE,AND,HYP-FN,OR,FN,NAME,TOKEN,EQ,IF,MSG" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="BAD-ARITIES-MSG">bad-arities-msg</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-bad-arities-msg" data-sym="BAD-ARITIES-MSG" title="(defun bad-arities-msg
       (name token fn hyp-fn wf-thm-name1 wf-thm-name2 bad-arity-info)
  (msg
   &quot;The ~s0 ~x1 has a now-invalid well-formedness guarantee.  Its ~s2, ~x3, ~
    ~#4~[was proved in ~x7 to return a ~x6~/and its corresponding hypothesis ~
...">bad-arities-msg</a>
  (name token
    fn
    hyp-fn
    wf-thm-name1
    wf-thm-name2
    bad-arity-info)
  (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"The ~s0 ~x1 has a now-invalid well-formedness guarantee.  Its ~s2, ~x3, ~
    ~#4~[was proved in ~x7 to return a ~x6~/and its corresponding hypothesis ~
    metafunction, ~x5, were proved in ~x7 and ~x8 to return ~x6s~] under the ~
    assumption that certain function symbols were in :logic mode and had ~
    certain arities.  But that assumption is now invalid, presumably because of ~
    redefinition.  ~@9We cannot trust the well-formedness guarantee."</span>
    (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:meta</span>)
      <span class="string">"metatheorem"</span>
      <span class="string">"clause-processor correctness theorem"</span>)
    name
    (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:meta</span>)
      (if fn
        <span class="string">"metafunction"</span>
        <span class="string">"hypothesis metafunction"</span>)
      <span class="string">"clause-processor"</span>)
    (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> fn hyp-fn)
    (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> fn hyp-fn)
      <span class="number">1</span>
      <span class="number">0</span>)
    hyp-fn
    (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> token <span class="keyword">:meta</span>)
      'logic-termp
      'logic-term-list-listp)
    wf-thm-name1
    wf-thm-name2
    (let ((bad-arities-alist (car bad-arity-info)) (non-logic-fns (cdr bad-arity-info)))
      (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"~@0~@1"</span>
        (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> bad-arities-alist)
          <span class="string">""</span>
          (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"The following alist pairs function symbols with their ~
                  assumed arities: ~X01.  Each symbol had the specified arity ~
                  when ~x2 was proved but this is no longer the case.  "</span>
            bad-arities-alist
            nil
            name))
        (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> non-logic-fns)
          <span class="string">""</span>
          (<a class="sym-link system" href="axioms.html#def-msg" data-sym="MSG">msg</a> <span class="string">"The symbol~#0~[ ~x0 is no longer a :logic mode function ~
                  symbol~/s ~&amp;0 are no longer :logic mode function symbols~] ~
                  even though this was the case when ~x2 was proved.  "</span>
            non-logic-fns
            nil
            name))))))</pre>
  </div>

<div class="form-block macro" id="def-all-ffn-symbs" data-defines="ALL-FFN-SYMBS" data-references="ALL-FNNAMES1,QUASIQUOTE,ANS,TERM,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-FFN-SYMBS">all-ffn-symbs</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-all-ffn-symbs" data-sym="ALL-FFN-SYMBS" title="(defmacro all-ffn-symbs (term ans) `(all-fnnames1 nil ,term ,ans))">all-ffn-symbs</a>
  (term ans)
  `(all-fnnames1 nil ,TERM ,ANS))</pre>
  </div>

<div class="form-block macro" id="def-all-ffn-symbs-lst" data-defines="ALL-FFN-SYMBS-LST" data-references="T,ALL-FNNAMES1,QUASIQUOTE,ANS,LST,DEFMACRO" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="ALL-FFN-SYMBS-LST">all-ffn-symbs-lst</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-all-ffn-symbs-lst" data-sym="ALL-FFN-SYMBS-LST" title="(defmacro all-ffn-symbs-lst (lst ans) `(all-fnnames1 t ,lst ,ans))">all-ffn-symbs-lst</a>
  (lst ans)
  `(all-fnnames1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ,LST ,ANS))</pre>
  </div>

<div class="form-block function" id="def-apply_24-rule-name" data-defines="APPLY$-RULE-NAME" data-references="STRING,LIST,SYMBOL-NAME,QUOTE,APPEND,COERCE,INTERN-IN-PACKAGE-OF-SYMBOL,SYMBOLP,XARGS,DECLARE,FN,DEFUN" data-used-by="PUSH-WARRANTS" data-part-name="APPLY$-RULE-NAME" data-part-args="FN" data-part-declare="FN,SYMBOLP,XARGS,DECLARE" data-part-body="STRING,LIST,FN,SYMBOL-NAME,QUOTE,APPEND,COERCE,INTERN-IN-PACKAGE-OF-SYMBOL" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="APPLY$-RULE-NAME">apply$-rule-name</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-apply_24-rule-name" data-sym="APPLY$-RULE-NAME" title="(defun apply$-rule-name (fn)
  (declare (xargs :guard (symbolp fn)))
  (intern-in-package-of-symbol
   (coerce
    (append &#39;(#\A #\P #\P #\L #\Y #\$ #\-) (coerce (symbol-name fn) &#39;list))
...">apply$-rule-name</a>
  (fn)
  (declare (xargs <span class="keyword">:guard</span> (symbolp fn)))
  (intern-in-package-of-symbol (coerce (<a class="sym-link system" href="axioms.html#def-append" data-sym="APPEND">append</a> '(#\A #\P #\P #\L #\Y #\$ #\-)
        (coerce (symbol-name fn) '<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a>))
      '<a class="sym-link system" href="axioms.html#def-string" data-sym="STRING">string</a>)
    fn))</pre>
  </div>

<div class="form-block function" id="def-push-warrants" data-defines="PUSH-WARRANTS" data-references="IGNORE,DECLARE,FORCE-ASSUMPTION,FORCE-FLG,IMMEDIATEP,*IMMEDIATE-FORCE-MODEP-XNUME*,ENABLED-NUMEP,EQ,PUSH-LEMMA,CDR,NOT,KNOWN-WHETHER-NIL,NILP,KNOWNP,MV-LET,ENABLED-RUNEP,LOGICP,FUNCTION-SYMBOLP,AND,ASSERT$,LIST,FN-APPLY$-RULE,APPLY$-RULE-NAME,FCONS-TERM*,WARRANT,WARRANT-NAME,CAR,FN,LET*,T,MV,ENDP,COND,TTREE0,TTREE,OK-TO-FORCE,WRLD,ENS,TYPE-ALIST,TARGET,FNS,DEFUN" data-used-by="REWRITE" data-part-name="PUSH-WARRANTS" data-part-args="TTREE0,TTREE,OK-TO-FORCE,WRLD,ENS,TYPE-ALIST,TARGET,FNS" data-part-body="IGNORE,DECLARE,FORCE-ASSUMPTION,FORCE-FLG,IMMEDIATEP,*IMMEDIATE-FORCE-MODEP-XNUME*,ENABLED-NUMEP,EQ,TTREE0,PUSH-LEMMA,OK-TO-FORCE,TARGET,CDR,PUSH-WARRANTS,NOT,TYPE-ALIST,KNOWN-WHETHER-NIL,NILP,KNOWNP,MV-LET,ENS,ENABLED-RUNEP,LOGICP,WRLD,FUNCTION-SYMBOLP,AND,ASSERT$,LIST,FN-APPLY$-RULE,APPLY$-RULE-NAME,FCONS-TERM*,WARRANT,WARRANT-NAME,CAR,FN,LET*,T,TTREE,MV,FNS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PUSH-WARRANTS">push-warrants</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a>
  (fns target type-alist ens wrld <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> ttree ttree0)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> fns) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (car fns)) (warrant-name (warrant-name fn))
          (warrant (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> warrant-name))
          (<a class="sym-link local-def" href="#def-apply_24-rule-name" data-sym="APPLY$-RULE-NAME" title="(defun apply$-rule-name (fn)
  (declare (xargs :guard (symbolp fn)))
  (intern-in-package-of-symbol
   (coerce
    (append &#39;(#\A #\P #\P #\L #\Y #\$ #\-) (coerce (symbol-name fn) &#39;list))
...">apply$-rule-name</a> (<a class="sym-link local-def" href="#def-apply_24-rule-name" data-sym="APPLY$-RULE-NAME" title="(defun apply$-rule-name (fn)
  (declare (xargs :guard (symbolp fn)))
  (intern-in-package-of-symbol
   (coerce
    (append &#39;(#\A #\P #\P #\L #\Y #\$ #\-) (coerce (symbol-name fn) &#39;list))
...">apply$-rule-name</a> fn))
          (fn-apply$-rule (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <span class="keyword">:rewrite</span> <a class="sym-link local-def" href="#def-apply_24-rule-name" data-sym="APPLY$-RULE-NAME" title="(defun apply$-rule-name (fn)
  (declare (xargs :guard (symbolp fn)))
  (intern-in-package-of-symbol
   (coerce
    (append &#39;(#\A #\P #\P #\L #\Y #\$ #\-) (coerce (symbol-name fn) &#39;list))
...">apply$-rule-name</a>)))
        (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-function-symbolp" data-sym="FUNCTION-SYMBOLP">function-symbolp</a> warrant-name wrld)
            (<a class="sym-link system" href="axioms.html#def-logicp" data-sym="LOGICP">logicp</a> warrant-name wrld))
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((enabled-runep fn-apply$-rule ens wrld) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (knownp nilp ttree)
                (known-whether-nil warrant
                  type-alist
                  ens
                  nil
                  nil
                  wrld
                  ttree)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (knownp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> nilp) (<a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a> (cdr fns)
                          target
                          type-alist
                          ens
                          wrld
                          <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                          (push-lemma fn-apply$-rule ttree)
                          ttree0))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> fn ttree0))))
                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)) <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>)
                           ((enabled-numep <a class="sym-link system" href="axioms.html#def-_2Aimmediate-force-modep-xnume_2A" data-sym="*IMMEDIATE-FORCE-MODEP-XNUME*">*immediate-force-modep-xnume*</a> ens) <span class="keyword">:immediate</span>)
                           (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> <span class="keyword">:force</span>))) (immediatep (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> <span class="keyword">:immediate</span>)))
                      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                        (force-assumption fn-apply$-rule
                          target
                          warrant
                          type-alist
                          nil
                          immediatep
                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                          (push-lemma fn-apply$-rule ttree))
                        (declare (ignore force-flg))
                        (<a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a> (cdr fns)
                          target
                          type-alist
                          ens
                          wrld
                          <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                          ttree
                          ttree0))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> fn ttree0)))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> <a class="sym-link local-def" href="#def-apply_24-rule-name" data-sym="APPLY$-RULE-NAME" title="(defun apply$-rule-name (fn)
  (declare (xargs :guard (symbolp fn)))
  (intern-in-package-of-symbol
   (coerce
    (append &#39;(#\A #\P #\P #\L #\Y #\$ #\-) (coerce (symbol-name fn) &#39;list))
...">apply$-rule-name</a>) ttree0))))))))</pre>
  </div>

<div class="form-block constant" id="def-_2Afake-rune-for-cert-data_2A" data-defines="*FAKE-RUNE-FOR-CERT-DATA*" data-references="QUOTE,DEFCONST" data-used-by="*FAKE-RUNE-ALIST*" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*FAKE-RUNE-FOR-CERT-DATA*">*fake-rune-for-cert-data*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Afake-rune-for-cert-data_2A" data-sym="*FAKE-RUNE-FOR-CERT-DATA*" title="(defconst *fake-rune-for-cert-data* &#39;(:fake-rune-for-cert-data nil))">*fake-rune-for-cert-data*</a>
  '(<span class="keyword">:fake-rune-for-cert-data</span> nil))</pre>
  </div>

<div class="form-block constant" id="def-_2Afake-rune-alist_2A" data-defines="*FAKE-RUNE-ALIST*" data-references="*FAKE-RUNE-FOR-CERT-DATA*,*FAKE-RUNE-FOR-TYPE-SET*,*FAKE-RUNE-FOR-LINEAR-EQUALITIES*,*FAKE-RUNE-FOR-LINEAR*,CAR,CONS,LIST,DEFCONST" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*FAKE-RUNE-ALIST*">*fake-rune-alist*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Afake-rune-alist_2A" data-sym="*FAKE-RUNE-ALIST*" title="(defconst *fake-rune-alist*
          (list (cons (car *fake-rune-for-linear*) &quot;linear arithmetic&quot;)
                (cons (car *fake-rune-for-linear-equalities*)
                      &quot;equality generation from inequalities&quot;)
                (cons (car *fake-rune-for-type-set*)
...">*fake-rune-alist*</a>
  (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons (car <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear_2A" data-sym="*FAKE-RUNE-FOR-LINEAR*" title="(defconst *fake-rune-for-linear* &#39;(:fake-rune-for-linear nil))">*fake-rune-for-linear*</a>) <span class="string">"linear arithmetic"</span>)
    (cons (car <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear-equalities_2A" data-sym="*FAKE-RUNE-FOR-LINEAR-EQUALITIES*" title="(defconst *fake-rune-for-linear-equalities*
          &#39;(:fake-rune-for-linear-equalities nil))">*fake-rune-for-linear-equalities*</a>)
      <span class="string">"equality generation from inequalities"</span>)
    (cons (car *fake-rune-for-type-set*)
      <span class="string">"primitive type reasoning"</span>)
    (cons (car <a class="sym-link local-def" href="#def-_2Afake-rune-for-cert-data_2A" data-sym="*FAKE-RUNE-FOR-CERT-DATA*" title="(defconst *fake-rune-for-cert-data* &#39;(:fake-rune-for-cert-data nil))">*fake-rune-for-cert-data*</a>)
      <span class="string">"previously-computed data"</span>)))</pre>
  </div>

<div class="form-block function" id="def-merge-runes" data-defines="MERGE-RUNES" data-references="T,CDR,CONS,CAR,RUNE-<,NULL,COND,L2,L1,DEFUN" data-used-by="MERGE-SORT-RUNES" data-part-name="MERGE-RUNES" data-part-args="L2,L1" data-part-body="T,CDR,MERGE-RUNES,CONS,CAR,RUNE-<,L2,L1,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-RUNES">merge-runes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-runes" data-sym="MERGE-RUNES" title="(defun merge-runes (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((rune-&lt; (car l1) (car l2)) (cons (car l1) (merge-runes (cdr l1) l2)))
        (t (cons (car l2) (merge-runes l1 (cdr l2))))))">merge-runes</a>
  (l1 l2)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l1) l2)
    ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> l2) l1)
    ((rune-&lt; (car l1) (car l2)) (cons (car l1) (<a class="sym-link local-def" href="#def-merge-runes" data-sym="MERGE-RUNES" title="(defun merge-runes (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((rune-&lt; (car l1) (car l2)) (cons (car l1) (merge-runes (cdr l1) l2)))
        (t (cons (car l2) (merge-runes l1 (cdr l2))))))">merge-runes</a> (cdr l1) l2)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (car l2) (<a class="sym-link local-def" href="#def-merge-runes" data-sym="MERGE-RUNES" title="(defun merge-runes (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((rune-&lt; (car l1) (car l2)) (cons (car l1) (merge-runes (cdr l1) l2)))
        (t (cons (car l2) (merge-runes l1 (cdr l2))))))">merge-runes</a> l1 (cdr l2))))))</pre>
  </div>

<div class="form-block function" id="def-merge-sort-runes" data-defines="MERGE-SORT-RUNES" data-references="ODDS,EVENS,MERGE-RUNES,T,CDR,NULL,COND,L,DEFUN" data-used-by="REWRITE-LAMBDA-OBJECT-POST-WARNING" data-part-name="MERGE-SORT-RUNES" data-part-args="L" data-part-body="ODDS,EVENS,MERGE-SORT-RUNES,MERGE-RUNES,T,L,CDR,NULL,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="MERGE-SORT-RUNES">merge-sort-runes</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-merge-sort-runes" data-sym="MERGE-SORT-RUNES" title="(defun merge-sort-runes (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-runes (merge-sort-runes (evens l))
                      (merge-sort-runes (odds l))))))">merge-sort-runes</a>
  (l)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr l)) l)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-merge-runes" data-sym="MERGE-RUNES" title="(defun merge-runes (l1 l2)
  (cond ((null l1) l2) ((null l2) l1)
        ((rune-&lt; (car l1) (car l2)) (cons (car l1) (merge-runes (cdr l1) l2)))
        (t (cons (car l2) (merge-runes l1 (cdr l2))))))">merge-runes</a> (<a class="sym-link local-def" href="#def-merge-sort-runes" data-sym="MERGE-SORT-RUNES" title="(defun merge-sort-runes (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-runes (merge-sort-runes (evens l))
                      (merge-sort-runes (odds l))))))">merge-sort-runes</a> (<a class="sym-link system" href="axioms.html#def-evens" data-sym="EVENS">evens</a> l))
        (<a class="sym-link local-def" href="#def-merge-sort-runes" data-sym="MERGE-SORT-RUNES" title="(defun merge-sort-runes (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-runes (merge-sort-runes (evens l))
                      (merge-sort-runes (odds l))))))">merge-sort-runes</a> (<a class="sym-link system" href="axioms.html#def-odds" data-sym="ODDS">odds</a> l))))))</pre>
  </div>

<div class="form-block function" id="def-fn-slot-from-geneqvp" data-defines="FN-SLOT-FROM-GENEQVP" data-references="CDR,T,CAR,CONGRUENCE-RULE,ACCESS,FN-EQUAL,QUOTE,EQ,ENDP,COND,GENEQV,DEFUN" data-used-by="REWRITE" data-part-name="FN-SLOT-FROM-GENEQVP" data-part-args="GENEQV" data-part-body="CDR,FN-SLOT-FROM-GENEQVP,T,CAR,CONGRUENCE-RULE,ACCESS,FN-EQUAL,QUOTE,EQ,GENEQV,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FN-SLOT-FROM-GENEQVP">fn-slot-from-geneqvp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-fn-slot-from-geneqvp" data-sym="FN-SLOT-FROM-GENEQVP" title="(defun fn-slot-from-geneqvp (geneqv)
  (cond ((endp geneqv) nil)
        ((eq &#39;fn-equal (access congruence-rule (car geneqv) :equiv)) t)
        (t (fn-slot-from-geneqvp (cdr geneqv)))))">fn-slot-from-geneqvp</a>
  (geneqv)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> geneqv) nil)
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> 'fn-equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> congruence-rule (car geneqv) <span class="keyword">:equiv</span>)) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-fn-slot-from-geneqvp" data-sym="FN-SLOT-FROM-GENEQVP" title="(defun fn-slot-from-geneqvp (geneqv)
  (cond ((endp geneqv) nil)
        ((eq &#39;fn-equal (access congruence-rule (car geneqv) :equiv)) t)
        (t (fn-slot-from-geneqvp (cdr geneqv)))))">fn-slot-from-geneqvp</a> (cdr geneqv)))))</pre>
  </div>

<div class="form-block function" id="def-partition-userfns-by-warrantp" data-defines="PARTITION-USERFNS-BY-WARRANTP" data-references="T,ADD-TO-SET-EQ,GET-WARRANTP,CDR,*APPLY$-BOOT-FNS-BADGE-ALIST*,ASSOC-EQ,CONST,*BADGE-PRIM-FALIST*,QUOTE,GETPROPC,UNQUOTE,CAR,HONS-GET,OR,MV,ENDP,COND,HAVE-NOTS,HAVES,WRLD,FNS,DEFUN" data-used-by="REWRITE" data-part-name="PARTITION-USERFNS-BY-WARRANTP" data-part-args="HAVE-NOTS,HAVES,WRLD,FNS" data-part-body="T,ADD-TO-SET-EQ,GET-WARRANTP,CDR,PARTITION-USERFNS-BY-WARRANTP,*APPLY$-BOOT-FNS-BADGE-ALIST*,ASSOC-EQ,WRLD,CONST,*BADGE-PRIM-FALIST*,QUOTE,GETPROPC,UNQUOTE,CAR,HONS-GET,OR,HAVE-NOTS,HAVES,MV,FNS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="PARTITION-USERFNS-BY-WARRANTP">partition-userfns-by-warrantp</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a>
  (fns wrld haves have-nots)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> fns) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> haves have-nots))
    ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (hons-get (car fns)
         (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> '*badge-prim-falist* 'const nil wrld)))
       (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car fns)
         (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> '*apply$-boot-fns-badge-alist* 'const nil wrld)))) (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> (cdr fns)
        wrld
        haves
        have-nots))
    ((get-warrantp (car fns) wrld) (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> (cdr fns)
        wrld
        (<a class="sym-link system" href="axioms.html#def-add-to-set-eq" data-sym="ADD-TO-SET-EQ">add-to-set-eq</a> (car fns) haves)
        have-nots))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> (cdr fns)
        wrld
        haves
        (<a class="sym-link system" href="axioms.html#def-add-to-set-eq" data-sym="ADD-TO-SET-EQ">add-to-set-eq</a> (car fns) have-nots)))))</pre>
  </div>

<div class="form-block function" id="def-rewrite-lambda-object-pre-warning" data-defines="REWRITE-LAMBDA-OBJECT-PRE-WARNING" data-references="REWRITE-LAMBDA-OBJECT,QUOTE,WARNING$-CW1,DEFAULT-STATE-VARS,STATE-VARS,LET,IF,VIOLATIONS,LET*,WRLD,PRE-HAVE-NO-WARRANTS,PROGS,NOT-WELL-FORMEDP,EVG,DEFUN" data-used-by="REWRITE" data-part-name="REWRITE-LAMBDA-OBJECT-PRE-WARNING" data-part-args="WRLD,PRE-HAVE-NO-WARRANTS,PROGS,NOT-WELL-FORMEDP,EVG" data-part-body="EVG,REWRITE-LAMBDA-OBJECT,QUOTE,WARNING$-CW1,DEFAULT-STATE-VARS,STATE-VARS,LET,PRE-HAVE-NO-WARRANTS,PROGS,NOT-WELL-FORMEDP,IF,VIOLATIONS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-LAMBDA-OBJECT-PRE-WARNING">rewrite-lambda-object-pre-warning</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-lambda-object-pre-warning" data-sym="REWRITE-LAMBDA-OBJECT-PRE-WARNING" title="(defun rewrite-lambda-object-pre-warning
       (evg not-well-formedp progs pre-have-no-warrants wrld)
  (let* ((violations
          (if not-well-formedp
              0
...">rewrite-lambda-object-pre-warning</a>
  (evg not-well-formedp progs pre-have-no-warrants wrld)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((violations (if not-well-formedp
         <span class="number">0</span>
         (if progs
           <span class="number">1</span>
           (if pre-have-no-warrants
             <span class="number">2</span>
             <span class="number">3</span>)))))
    (let ((state-vars (<a class="sym-link system" href="basis-a.html#def-default-state-vars" data-sym="DEFAULT-STATE-VARS">default-state-vars</a> nil)))
      (warning$-cw1 'rewrite-lambda-object
        <span class="string">"rewrite-lambda-object"</span>
        <span class="string">"We refused to try to rewrite the quoted lambda-like ~
                     object~%~Y01because ~#2~[it is not well-formed (e.g., ~
                     contains free variables, has a body that is not a term, ~
                     or that contains unbadged function symbols)~/it contains ~
                     the :program mode function symbol~#3~[~/s~] ~&amp;3~/it ~
                     contains the function symbol~#4~[~/s~] ~&amp;4 for which no ~
                     warrant~#4~[ has~/s have~] been issued~/we didn&#39;t like ~
                     it but failed to record why~].  See :DOC ~
                     rewrite-lambda-object."</span>
        evg
        nil
        violations
        progs
        pre-have-no-warrants))))</pre>
  </div>

<div class="form-block function" id="def-rewrite-lambda-object-post-warning" data-defines="REWRITE-LAMBDA-OBJECT-POST-WARNING" data-references="ALL-RUNES-IN-TTREE,MERGE-SORT-RUNES,LAMBDA,QUASIQUOTE,REWRITE-LAMBDA-OBJECT,QUOTE,WARNING$-CW1,DEFAULT-STATE-VARS,STATE-VARS,LET,CDR,IF,VIOLATIONS,EXECUTABLE-TAMEP,NOT,UNTAMEP,LAMBDA-OBJECT-FORMALS,ALL-VARS,SET-DIFFERENCE-EQ,FREE-VARS,LET*,WRLD,TTREE,POST-HAVE-NO-WARRANTS,REWRITTEN-BODY,EVG,DEFUN" data-used-by="REWRITE" data-part-name="REWRITE-LAMBDA-OBJECT-POST-WARNING" data-part-args="WRLD,TTREE,POST-HAVE-NO-WARRANTS,REWRITTEN-BODY,EVG" data-part-body="TTREE,ALL-RUNES-IN-TTREE,MERGE-SORT-RUNES,LAMBDA,QUASIQUOTE,REWRITE-LAMBDA-OBJECT,QUOTE,WARNING$-CW1,DEFAULT-STATE-VARS,STATE-VARS,LET,POST-HAVE-NO-WARRANTS,CDR,IF,VIOLATIONS,WRLD,EXECUTABLE-TAMEP,NOT,UNTAMEP,EVG,LAMBDA-OBJECT-FORMALS,REWRITTEN-BODY,ALL-VARS,SET-DIFFERENCE-EQ,FREE-VARS,LET*" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-LAMBDA-OBJECT-POST-WARNING">rewrite-lambda-object-post-warning</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite-lambda-object-post-warning" data-sym="REWRITE-LAMBDA-OBJECT-POST-WARNING" title="(defun rewrite-lambda-object-post-warning
       (evg rewritten-body post-have-no-warrants ttree wrld)
  (let* ((free-vars
          (set-difference-eq (all-vars rewritten-body)
                             (lambda-object-formals evg)))
...">rewrite-lambda-object-post-warning</a>
  (evg rewritten-body post-have-no-warrants ttree wrld)
  (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((free-vars (<a class="sym-link system" href="axioms.html#def-set-difference-eq" data-sym="SET-DIFFERENCE-EQ">set-difference-eq</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> rewritten-body)
         (<a class="sym-link system" href="axioms.html#def-lambda-object-formals" data-sym="LAMBDA-OBJECT-FORMALS">lambda-object-formals</a> evg))) (untamep (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (executable-tamep rewritten-body wrld)))
      (violations (if free-vars
          (if (cdr free-vars)
            (if untamep
              <span class="number">0</span>
              <span class="number">1</span>)
            (if untamep
              <span class="number">2</span>
              <span class="number">3</span>))
          (if untamep
            <span class="number">4</span>
            (if post-have-no-warrants
              <span class="number">5</span>
              <span class="number">6</span>)))))
    (let ((state-vars (<a class="sym-link system" href="basis-a.html#def-default-state-vars" data-sym="DEFAULT-STATE-VARS">default-state-vars</a> nil)))
      (warning$-cw1 'rewrite-lambda-object
        <span class="string">"rewrite-lambda-object"</span>
        <span class="string">"The body of the well-formed (and tame) lambda ~
                     object~%~Y01rewrote to~%~Y21which was rejected because ~
                     ~#3~[it contains the variables ~&amp;4 not listed among the ~
                     formals, and it is not tame~/it contains the variables ~
                     ~&amp;4 not listed among the formals~/it contains the ~
                     variable ~&amp;4 not listed among the formals, and it is not ~
                     tame~/it contains the variable ~&amp;4 not listed among the ~
                     formals~/it is not tame~/it contains the function ~
                     symbol~#5~[ ~&amp;5 for which no warrant has~/s ~&amp;5 for ~
                     which no warrants have~] been issued~/some necessary ~
                     warrant is not assumed true in the current prover ~
                     environment~].  The following runes were used to produce ~
                     this rejected object: ~X61.  See :DOC ~
                     rewrite-lambda-object."</span>
        evg
        nil
        `(lambda ,(LAMBDA-OBJECT-FORMALS EVG) ,REWRITTEN-BODY)
        violations
        free-vars
        post-have-no-warrants
        (<a class="sym-link local-def" href="#def-merge-sort-runes" data-sym="MERGE-SORT-RUNES" title="(defun merge-sort-runes (l)
  (cond ((null (cdr l)) l)
        (t
         (merge-runes (merge-sort-runes (evens l))
                      (merge-sort-runes (odds l))))))">merge-sort-runes</a> (all-runes-in-ttree ttree nil))))))</pre>
  </div>

<div class="form-block function" id="def-collect-0-ary-hyps" data-defines="COLLECT-0-ARY-HYPS" data-references="T,CONS,CDR,NULL,CAR,CONSP,AND,ENDP,COND,TYPE-ALIST,DEFUN" data-used-by="REWRITE" data-part-name="COLLECT-0-ARY-HYPS" data-part-args="TYPE-ALIST" data-part-body="T,COLLECT-0-ARY-HYPS,CONS,CDR,NULL,CAR,CONSP,AND,TYPE-ALIST,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="COLLECT-0-ARY-HYPS">collect-0-ary-hyps</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-collect-0-ary-hyps" data-sym="COLLECT-0-ARY-HYPS" title="(defun collect-0-ary-hyps (type-alist)
  (cond ((endp type-alist) nil)
        ((and (consp (car (car type-alist)))
              (null (cdr (car (car type-alist)))))
         (cons (car type-alist) (collect-0-ary-hyps (cdr type-alist))))">collect-0-ary-hyps</a>
  (type-alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> type-alist) nil)
    ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp (car (car type-alist)))
       (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr (car (car type-alist))))) (cons (car type-alist)
        (<a class="sym-link local-def" href="#def-collect-0-ary-hyps" data-sym="COLLECT-0-ARY-HYPS" title="(defun collect-0-ary-hyps (type-alist)
  (cond ((endp type-alist) nil)
        ((and (consp (car (car type-alist)))
              (null (cdr (car (car type-alist)))))
         (cons (car type-alist) (collect-0-ary-hyps (cdr type-alist))))">collect-0-ary-hyps</a> (cdr type-alist))))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-collect-0-ary-hyps" data-sym="COLLECT-0-ARY-HYPS" title="(defun collect-0-ary-hyps (type-alist)
  (cond ((endp type-alist) nil)
        ((and (consp (car (car type-alist)))
              (null (cdr (car (car type-alist)))))
         (cons (car type-alist) (collect-0-ary-hyps (cdr type-alist))))">collect-0-ary-hyps</a> (cdr type-alist)))))</pre>
  </div>

<div class="form-block constant" id="def-_2Arewrite-lambda-modep-xrune_2A" data-defines="*REWRITE-LAMBDA-MODEP-XRUNE*" data-references="REWRITE-LAMBDA-MODEP,QUOTE,DEFCONST" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*REWRITE-LAMBDA-MODEP-XRUNE*">*rewrite-lambda-modep-xrune*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Arewrite-lambda-modep-xrune_2A" data-sym="*REWRITE-LAMBDA-MODEP-XRUNE*" title="(defconst *rewrite-lambda-modep-xrune*
          &#39;(:executable-counterpart rewrite-lambda-modep))">*rewrite-lambda-modep-xrune*</a>
  '(<span class="keyword">:executable-counterpart</span> <a class="sym-link system" href="axioms.html#def-rewrite-lambda-modep" data-sym="REWRITE-LAMBDA-MODEP">rewrite-lambda-modep</a>))</pre>
  </div>

<div class="form-block constant" id="def-_2Arewrite-lambda-modep-def-rune_2A" data-defines="*REWRITE-LAMBDA-MODEP-DEF-RUNE*" data-references="REWRITE-LAMBDA-MODEP,QUOTE,DEFCONST" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="*REWRITE-LAMBDA-MODEP-DEF-RUNE*">*rewrite-lambda-modep-def-rune*</span><span class="form-type">constant</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defconst" data-sym="DEFCONST">defconst</a> <a class="sym-link local-def" href="#def-_2Arewrite-lambda-modep-def-rune_2A" data-sym="*REWRITE-LAMBDA-MODEP-DEF-RUNE*" title="(defconst *rewrite-lambda-modep-def-rune* &#39;(:definition rewrite-lambda-modep))">*rewrite-lambda-modep-def-rune*</a>
  '(<span class="keyword">:definition</span> <a class="sym-link system" href="axioms.html#def-rewrite-lambda-modep" data-sym="REWRITE-LAMBDA-MODEP">rewrite-lambda-modep</a>))</pre>
  </div>

<div class="form-block function" id="def-formal-cons-to-components" data-defines="FORMAL-CONS-TO-COMPONENTS" data-references="FARGN,CONS,QUOTE,FFN-SYMB,EQ,CDR,CAR,KWOTE,T,CONSP,IF,UNQUOTE,EVG,LET,FQUOTEP,MV,VARIABLEP,COND,TERM,DEFUN" data-used-by="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" data-part-name="FORMAL-CONS-TO-COMPONENTS" data-part-args="TERM" data-part-body="FARGN,CONS,QUOTE,FFN-SYMB,EQ,CDR,CAR,KWOTE,T,CONSP,IF,UNQUOTE,EVG,LET,FQUOTEP,MV,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="FORMAL-CONS-TO-COMPONENTS">formal-cons-to-components</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-formal-cons-to-components" data-sym="FORMAL-CONS-TO-COMPONENTS" title="(defun formal-cons-to-components (term)
  (cond ((variablep term) (mv nil nil nil))
        ((fquotep term)
         (let ((evg (unquote term)))
           (if (consp evg)
...">formal-cons-to-components</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil))
    ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (let ((evg (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> term)))
        (if (consp evg)
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> (car evg)) (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> (cdr evg)))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil))))
    ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'cons) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil nil))))</pre>
  </div>

<div class="form-block function" id="def-recover-subst-from-formal-var-alist" data-defines="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" data-references="CONS,SIGMA,VARIABLE,QUOTE,UNQUOTE,LEGAL-VARIABLE-OR-CONSTANT-NAMEP,EQ,QUOTEP,AND,VAL,KEY,NULL,FORMAL-CONS-TO-COMPONENTS,REST,PAIR,FLG,MV-LET,T,*NIL*,EQUAL,MV,VARIABLEP,COND,TERM,DEFUN" data-used-by="REWRITE" data-part-name="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" data-part-args="TERM" data-part-body="CONS,RECOVER-SUBST-FROM-FORMAL-VAR-ALIST,SIGMA,VARIABLE,QUOTE,UNQUOTE,LEGAL-VARIABLE-OR-CONSTANT-NAMEP,EQ,QUOTEP,AND,VAL,KEY,NULL,FORMAL-CONS-TO-COMPONENTS,REST,PAIR,FLG,MV-LET,T,*NIL*,EQUAL,MV,TERM,VARIABLEP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST">recover-subst-from-formal-var-alist</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-recover-subst-from-formal-var-alist" data-sym="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" title="(defun recover-subst-from-formal-var-alist (term)
  (cond ((variablep term) (mv nil nil)) ((equal term *nil*) (mv t nil))
        (t
         (mv-let (flg pair rest) (formal-cons-to-components term)
                 (cond ((null flg) (mv nil nil))
...">recover-subst-from-formal-var-alist</a>
  (term)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
    ((equal term <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg pair <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
        (<a class="sym-link local-def" href="#def-formal-cons-to-components" data-sym="FORMAL-CONS-TO-COMPONENTS" title="(defun formal-cons-to-components (term)
  (cond ((variablep term) (mv nil nil nil))
        ((fquotep term)
         (let ((evg (unquote term)))
           (if (consp evg)
...">formal-cons-to-components</a> term)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg key val)
              (<a class="sym-link local-def" href="#def-formal-cons-to-components" data-sym="FORMAL-CONS-TO-COMPONENTS" title="(defun formal-cons-to-components (term)
  (cond ((variablep term) (mv nil nil nil))
        ((fquotep term)
         (let ((evg (unquote term)))
           (if (consp evg)
...">formal-cons-to-components</a> pair)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
                ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> key)
                   (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="basis-a.html#def-legal-variable-or-constant-namep" data-sym="LEGAL-VARIABLE-OR-CONSTANT-NAMEP">legal-variable-or-constant-namep</a> (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> key))
                     'variable)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg sigma)
                    (<a class="sym-link local-def" href="#def-recover-subst-from-formal-var-alist" data-sym="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" title="(defun recover-subst-from-formal-var-alist (term)
  (cond ((variablep term) (mv nil nil)) ((equal term *nil*) (mv t nil))
        (t
         (mv-let (flg pair rest) (formal-cons-to-components term)
                 (cond ((null flg) (mv nil nil))
...">recover-subst-from-formal-var-alist</a> <a class="sym-link system" href="axioms.html#def-rest" data-sym="REST">rest</a>)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> key) val) sigma))))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))))))))))</pre>
  </div>

<div class="form-block function" id="def-extend-subst-on-unbound-vars" data-defines="EXTEND-SUBST-ON-UNBOUND-VARS" data-references="*NIL*,CONS,T,CDR,CAR,ASSOC-EQ,ENDP,COND,ALIST,VARS,DEFUN" data-used-by="REWRITE" data-part-name="EXTEND-SUBST-ON-UNBOUND-VARS" data-part-args="ALIST,VARS" data-part-body="*NIL*,CONS,T,CDR,EXTEND-SUBST-ON-UNBOUND-VARS,CAR,ASSOC-EQ,ALIST,VARS,ENDP,COND" typeof="SoftwareSourceCode">
    <div class="form-header"><span class="form-name" property="name" data-sym="EXTEND-SUBST-ON-UNBOUND-VARS">extend-subst-on-unbound-vars</span><span class="form-type">function</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-extend-subst-on-unbound-vars" data-sym="EXTEND-SUBST-ON-UNBOUND-VARS" title="(defun extend-subst-on-unbound-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (extend-subst-on-unbound-vars (cdr vars) alist))
        (t
...">extend-subst-on-unbound-vars</a>
  (vars alist)
  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> vars) alist)
    ((<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car vars) alist) (<a class="sym-link local-def" href="#def-extend-subst-on-unbound-vars" data-sym="EXTEND-SUBST-ON-UNBOUND-VARS" title="(defun extend-subst-on-unbound-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (extend-subst-on-unbound-vars (cdr vars) alist))
        (t
...">extend-subst-on-unbound-vars</a> (cdr vars) alist))
    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (cons (cons (car vars) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
        (<a class="sym-link local-def" href="#def-extend-subst-on-unbound-vars" data-sym="EXTEND-SUBST-ON-UNBOUND-VARS" title="(defun extend-subst-on-unbound-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (extend-subst-on-unbound-vars (cdr vars) alist))
        (t
...">extend-subst-on-unbound-vars</a> (cdr vars) alist)))))</pre>
  </div>

<div class="form-block macro" id="def-rewrite-standard-exit" data-defines="REWRITE-STANDARD-EXIT" data-references="REWRITE-WITH-LEMMAS,REWRITE-PRIMITIVE,REWRITE-ENTRY,TTREE,REWRITTEN-TERM,SL-LET,QUASIQUOTE,REWRITTEN-ARGS,FN,DEFMACRO" data-used-by="REWRITE" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE-STANDARD-EXIT">rewrite-standard-exit</span><span class="form-type">macro</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-defmacro" data-sym="DEFMACRO">defmacro</a> <a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a>
  (fn rewritten-args)
  `(<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-term ttree)
    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-primitive ,FN ,REWRITTEN-ARGS))
    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas rewritten-term))))</pre>
  </div>

<div class="form-block mutual-recursion" id="def-rewrite" data-defines="REWRITE" data-references="REWRITE-LAMBDA-OBJECT-PRE-WARNING,*REWRITE-LAMBDA-MODEP-DEF-RUNE*,*REWRITE-LAMBDA-MODEP-XRUNE*,TTREE3,UNION-EQ,POST-HAVE-NO-WARRANTS,POST-HAVE-WARRANTS,REWRITE-LAMBDA-OBJECT-POST-WARNING,SUBSETP-EQ,LAMBDA,QUASIQUOTE,REMOVE-GUARD-HOLDERS-LAMP,CLEAN-UP-DIRTY-LAMBDA-OBJECT-BODY,NORMALIZE,TEMP-TTREE1,TEMP-REWRITTEN-BODY,*REWRITE-LAMBDA-MODEP-DEF-NUME*,PRE-HAVE-NO-WARRANTS,PRE-HAVE-WARRANTS,PROGS,FNS,COLLECT-0-ARY-HYPS,TYPE-ALIST1,LAMBDA-OBJECT-BODY,LAMBDA-OBJECT-DCL,DCL,LAMBDA-OBJECT-FORMALS,WELL-FORMED-LAMBDA-OBJECTP,*REWRITE-LAMBDA-MODEP-XNUME*,SYMBOLP,EVG,REWRITE-LAMBDA-OBJECT,EVG1,FN-SLOT-FROM-GENEQVP,REWRITE-QUOTED-CONSTANT-RULES,REWRITE-QUOTED-CONSTANT-WITH-LEMMAS,NORMALIZER-FAILED-TO-EVALUATE,NORMALIZER-RETURNED-SAME-CONSTANT,INTEGER,N,REWRITE-QUOTED-CONSTANT-WITH-LEMMA,IRRELEVANT-POT-LST,INEQUALITYP,BASIC-POT-LST,LINEARIZE-LST,POLY-LST,POSITIVEP,CHANGEDP,EQP,POT-LST0,TO-DO-LATER,SPLIT-LST,ADD-DISJUNCTS-POLYS-AND-LEMMAS,INFECT-NEW-POLYS,INFECT-POLYS,LST2,LST1,ADD-DISJUNCT-POLYS-AND-LEMMAS,DISJUNCTSP,LST,ADD-POLYS-AND-LEMMAS,ADD-POLYS-AND-LEMMAS1,NEW-VARS-IN-POT-LST,*NON-LINEAR-ROUNDS-VALUE*,CNT,ADD-POLYS-AND-LEMMAS1-NL,ADD-INVERSE-POLYS,ADD-POLYS-FROM-TYPE-SET,EXPANDED-NEW-VARS-IN-POT-LST,OLD-POT-LST,ADD-POLYS-AND-LEMMAS2-NL,NON-LINEAR-ARITHMETIC,NEW-POT-LST3,NEW-POT-LST2,GOOD-BOUNDS-IN-POT,NEW-POT-LST1,INVERT-VAR,INVERTED-VAR,NEW-VARS,NON-LINEAR-ARITHMETIC1,INVERSE-VAR,DEAL-WITH-DIVISION,PART-OF-POT-VAR,DEAL-WITH-FACTOR,FN-SYMB,NEW-VAR,DEAL-WITH-PRODUCT,NEW-POT-LIST,LINEAR-POT,PART-OF,NEW-PART-OF-NEW-VAR,*1*,POT-LST-TO-STEP-DOWN,PART-OF-NEW-VAR,DEAL-WITH-PRODUCT1,TOO-MANY-POLYSP,ADD-MULTIPLIED-POLYS,SORT-ARITH-TERM-ORDER,ADD-POLYS,POLYS-WITH-POTS,POLY-LIST2,PRODUCT-ALREADY-TRIEDP,PRODUCTS-ALREADY-TRIED,ADD-MULTIPLIED-POLYS-FILTER,MULTIPLY-POTS,POLYS-WITH-VAR,BOUNDS-POLYS-WITH-VAR,POLY-LIST1,MULTIPLY-POTS-FILTER,SHORTEST-POLYS-WITH-VAR,POT-LST-TO-LOOK-IN,VAR-LIST,MULTIPLY-POTS-SUPER-FILTER,NEW-NEW-POLY-LIST,POLY-LIST,MULTIPLY-POTS1,NEW-POLY-LIST,BIG-POLY-LIST,MULTIPLY-POTS2,NORMALIZE-POLY,<=,PRE-POLY,RATP2,PARENTS2,RATP1,PARENTS1,POLY2,POLY1,MULTIPLY-POLYS,TEMP-POLY2,MULTIPLY-ALIST-AND-CONST,EQL,TEMP-POLY1,REL2,CONST2,REL1,CONST1,MULTIPLY-POLYS1,ALIST1,MULTIPLY-ALISTS,TEMP-POLY,ALIST2,ALIST-ENTRY,MULTIPLY-ALISTS1,MARRY-PARENTS,ADD-LINEAR-TERM,NEW-POLY,NEW-ENTRY,BINARY-*,TEMP-ENTRY,*,COEFF,BINARY-*-TREE,TREE,MERGE-ARITH-TERM-ORDER,LEAVES,LEAVES2,BINARY-*-LEAVES,LEAVES1,ALIST-ENTRY2,ALIST-ENTRY1,MULTIPLY-ALISTS2,LINEAR-LEMMAS,ADD-LINEAR-LEMMAS,UNREWRITTEN-CONCL-TO-TRY,ADD-LINEAR-LEMMA-FINISH,BRR-RESULT,NEW-POT-LST,POT-LST,LINEAR-LEMMA,ONE-WAY-UNIFY,ADD-LINEAR-LEMMA,TTREE-LST,COLLECT-PARENTS,CLEANSE-TYPE-ALIST,TTREES,TERM-LST,REWRITE-LINEAR-TERM-LST,RCNST1,<,REWRITE-LINEAR-TERM,REWRITE-IF11,FINAL-TERM,SYMBOL-IN-CURRENT-PACKAGE-P,*FAKE-RUNE-ALIST*,HIDE-REASON,PUSH-SPLITTER?,REWRITTEN-NEW-TERM,REWRITE-WITH-LINEAR,EXPAND-PERMISSION-RESULT,TTREE2,CONTAINS-REWRITABLE-CALLP,REWRITE-FNCALLP,RESTORE-RW-CACHE-ANY-TAG,NEW-TTREE1,BASE-SYMBOL,TERM-OUT,NEW-FNSTACK,TOO-MANY-IFS-POST-REWRITE,REWRITTEN-BODY,VAR-COUNTS,TOO-MANY-IFS-PRE-REWRITE,RECURSIVE-FN-ON-FNSTACKP,MEMBER-EQ,FNSTACK-TERM-MEMBER,BODY,RULE,GLOBAL-ARITHMETIC-ENABLED-STRUCTURE,ENABLED-ARITH-NUMEP,ENABLED-NUMEP,NEAR-MISS,NEAR-MISS-BRKPT1,ONCEP,LOOP-STOPPER,LOOP-STOPPERP,BRKPT1,ONE-WAY-UNIFY-RESTRICTIONS,UNIFY-ANS,FFNNAMEP,SETTLED-DOWN,RECURSIVEP,BEING-OPENEDP,REWRITE-FNCALL,DEFINITION,REFINEMENT-FAILURE,BRKPT2,REFINEMENT-FAILURE-BRKPT1,PROGN$,PUSH-LEMMA+,LENGTH,MAKE-LIST,NATP,ASSERT$,BAD-SYNP-HYP-MSG-EXTRA,BAD-SYNP-HYP-MSG,RULE-BACKCHAIN-LIMIT,VARS,APPEND?,EXTRA-HYPS,QUOTE-NORMAL-FORM,FLATTEN-ANDS-IN-LIT,HYPS0,EVALED-HYP,EXTRA-EVALED-HYP,FORBIDDEN-FNS-IN-TERM,ALL-FFN-SYMBS,COLLECT-PROGRAMS,LOGIC-TERMP,BAD-ARITIES-MSG,HARD,ER,THM-NAME2,HYP-FN,THM-NAME1,NTH,NAME,COLLECT-BAD-FN-ARITY-INFO,BAD-ARITY-INFO,NOT-SKIPPED,WELL-FORMEDNESS-GUARANTEE,SKIP-META-TERMP-CHECKS,USER-SAYS-SKIP-TERMP-CHECKP,EV-FNCALL-META,LATCHES,COERCE-STATE-TO-OBJECT,METAFUNCTION-CONTEXT,MAKE,EXTENDED,META-FN,META,REWRITE-RULE,LEMMA,REWRITE-WITH-LEMMA,NOTE-RELIEVE-HYP-FAILURE,NOTE-RELIEVE-HYPS-FAILURE-FREE,RW-CACHE-DEBUG-ACTION,PROG2$,CHANGE,NEW-RW-CACHE-ALIST,OLD-RW-CACHE-ALIST,UNIFY-SUBST-SAVED,STEP-LIMIT-SAVED,RW-CACHE-DEBUG,DEBUG,FREE-FAILURE-P,CACHED-FAILURE-REASON-FREE-P,RW-CACHE-ENTRY,CACHED-FAILURE-REASON-RAW,RELIEVE-HYP-FAILURE-ENTRY,CACHED-FAILURE-ENTRY,RW-CACHE-ACTIVE-P,TTREE-SAVED,RELIEVE-HYPS,SEARCH-GROUND-UNITS1,REST-LEMMAS,WINP,BIND-FREE-VARS-TO-UNBOUND-FREE-VARS,FULLY-BOUND-UNIFY-SUBST,RELEVANT-GROUND-LEMMAS,RELIEVE-HYPS1-FREE-2,SEARCH-TYPE-ALIST+,NEW-REST-TYPE-ALIST,ANS,REST-TYPE-ALIST,SET-DIFFERENCE-ASSOC-EQ,RELIEVE-HYPS1-FREE-1,CASE-SPLIT,FORCE,NVARIABLEP,FREE-VARS,ACTIVATE-MEMO,FAILURE-REASON-LST,NEW-BACKCHAIN-LIMIT,THE,WITH-ACCUMULATED-PERSISTENCE,REWRITE-ENTRY-EXTENDING-FAILURE,ENDP,RW-CACHE-ADD-FAILURE-REASON,EXTEND-RW-CACHE-ALIST-FREE,RELIEVE-HYPS1,CACHED,INFERIOR-RW-CACHE-ALIST-NEW,UNIFY-SUBST1,RELIEVE-HYPS-ANS,RW-CACHED-FAILURE-PAIR,CACHED-FAILURE-REASON,CACHED-FAILURE-REASON-FREE,EXTEND-UNIFY-SUBST,NEW-UNIFY-SUBST,RW-CACHE-ALIST-NEW,RW-CACHE-ALIST,ALLP,UNIFY-SUBST0,BACKCHAIN-LIMIT-LST,HYPS,UNIFY-SUBST-LST,RELIEVE-HYPS1-UNIFY-SUBST-LST,LIST*,PUT-ASSOC-EQL,CONS-TAG-TREES-RW-CACHE-FIRST,IF-TAUTOLOGYP,REWROTE-TO,PUSH-ANCESTOR,REWRITTEN-ATM,STRIP-NOT,ATM,NOT-FLG,IMMEDIATE-FORCEP,FORCE-ASSUMPTION,BACKCHAIN-LIMIT-REACHEDP,ANCESTORS-CHECK,ASSUMED-TRUE,ON-ANCESTORSP,KNOWN-NIL,KNOWN-WHETHER-NIL,NILP-TTREE,NILP,KNOWNP,FORCEP,FORCE-FLG,FORCER-FN,INST-HYP,LOOKUP-HYP,LOOKUP-HYP-ANS,RW-CACHE,RELIEVE-HYP-ANS,CONS-TAG-TREES-RW-CACHE,ASSOC-EQUAL,OLD-ENTRY,RESTRICT-ALIST,RESTRICTED-UNIFY-SUBST,HYP-VARS,ASSOC,CONSP,MEMO-ENTRY,MEMO-ACTIVEP,MEMO-ACTIVE,TERM-AND-TYP-TO-LOOKUP,COMPOUND-REC-RUNE?,TYP,FREE-VARSP,MAKE-ANCESTOR-BINDING-HYP,DMRP,GSTACKP,F-GET-GLOBAL,REWRITTEN-RHS,HYP,BINDING-HYP-P,BIND-FLG,FORCEP1,RELIEVE-HYP-SYNP,FAILURE-REASON,WONP,SYNP,MEMO,UNIFY-SUBST,HYP0,TARGET,RELIEVE-HYP,ACCUMULATE-RW-CACHE,CDRS,EQUAL-CDRS,TTREE0,CARS,EQUAL-CARS,*TS-CONS*,EQUALITYP,MCONS-TERM*,*TS-BOOLEAN*,TS-SUBSETP,EQUAL-X-CONS-X-YP,TYPE-SET-EQUAL,TTREE-EQUALITY,TS-EQUALITY,TTREE+,TS-RHS,TYPE-SET,TTREE-LHS,TS-LHS,*TS-NIL*,*TS-T*,TS=,ASSOC-TYPE-ALIST,TTREE-LOOKUP,TS-LOOKUP,PUFFERT,RHS-ANCESTORS,LHS-ANCESTORS,RHS,LHS,REWRITE-RECOGNIZER,MOST-RECENT-ENABLED-RECOG-TUPLE,RECOG-TUPLE,REWRITE-EQUAL,FCONS-TERM,REWRITE-PRIMITIVE,1+,REWRITTEN-ARG,GENEQV-AND-PEQUIV-INFO-FOR-REWRITE,CHILD-PEQUIV-INFO,CHILD-GENEQV,REVERSE,PARENT-FN,PARENT-GENEQV,REWRITTEN-ARGS-REV,ARGS,FFN-SYMB-P,REWRITE-IF1,REWRITTEN-TERM,REWRITTEN-RIGHT,RW-CACHE-EXIT-CONTEXT,RW-CACHE-ENTER-CONTEXT,RW-LEFT,REWRITTEN-LEFT,NORMALIZE-RW-ANY-CACHE,CONS-TAG-TREES,SWAPPED-P,RIGHT,LEFT,UNREWRITTEN-TEST,REWRITE-IF-FINISH,FALSE-POT-LST,POLY,*FAKE-RUNE-FOR-LINEAR*,ADD-TERMS-AND-LEMMAS,TRUE-POT-LST,CONTRADICTIONP,TEST+,ASSUME-TRUE-FALSE,TS-TTREE,FALSE-TYPE-ALIST,TRUE-TYPE-ALIST,MUST-BE-FALSE,MUST-BE-TRUE,TEST,ASSUME-TRUE-FALSE-HEAVY-LINEARP,IGNORE,LEMMAS,REWRITE-WITH-LEMMAS1,TERM1,REWRITTENP,MEMBER-EQUAL,NEW-TTREE,NEW-TERM,EXPANSION,PUSH-LEMMA?,TTREE1,ALL-VARS,EXTEND-SUBST-ON-UNBOUND-VARS,NEW-ALIST,ALL-FNNAMES,PARTITION-USERFNS-BY-WARRANTP,UNWARRANTED-FNS,WARRANTED-FNS,EXECUTABLE-TAMEP,TERMP,REWRITE-STANDARD-EXIT,RECOVER-SUBST-FROM-FORMAL-VAR-ALIST,SIGMA,FLG,CADR,Y,X,CAR,EV$-OPENER,ACTIVE-RUNEP,PROJECTS/APPLY/BASE-INCLUDEDP,GLOBAL-VAL,EV$,KWOTE,CONS,HIDE-WITH-COMMENT,NEW-TERM2,NEW-TERM1,PUSH-WARRANTS,NULL,ERP2,STRIP-CADRS,EV-FNCALL+,PSTK,APPLY$ED-FNS,VAL,ERP,OK-TO-FORCE,LAMBDA-FORMALS,PAIRLIS$,LAMBDA-BODY,CONSTRAINEDP,GETPROPC,ENABLED-XFNP,FLAMBDA-APPLICATIONP,ALL-QUOTEPS,LOGICP,FLAMBDAP,GENEQV-LST,FARGS,REWRITE-ARGS,REWRITTEN-ARGS,PEQUIVS-FOR-REWRITE-ARGS,SHALLOW-PEQUIV-LST,DEEP-PEQUIV-LST,ENS,1+F,SIMPLIFIABLE-MV-NTH,MV-NTH,MV-NTH-REWRITEP,MV-NTH-RESULT,CONS-TERM,DO$,MV-LET,FN,REWRITE-SOLIDIFY,PREPEND-STEP-LIMIT,REWRITE-CONSTANT,ACCESS,NOT-TO-BE-REWRITTENP,DOUBLE-REWRITE,BBODY,LIST,FORMALS,SUBCOR-VAR,IFF,GENEQV-REFINEMENTP,RUNE,OR,DUMB-NEGATE-LIT,REWRITTEN-CONCL,*NIL*,IMPLIES,LAMBDA-NEST-UNHIDE,NEW-BODY,LAMBDA-NEST-HIDEP,REWRITE-WITH-LEMMAS,EXPAND-PERMISSION-P,NEW-RCNST,CDAR,CAAR,MAKE-LAMBDA-APPLICATION,FCONS-TERM*,INST-TERM,MAKE-STACK-FROM-ALIST,STACK,LET*,HIDE,FN-RUNE-NUME,PUSH-LEMMA,PROGN,RETURN-LAST,AND,REWRITE-IF,*GENEQV-IFF*,ARG3,NOT,UNQUOTE,QUOTEP,*T*,ARG2,?,REWRITTEN-TEST,SL-LET,FARGN,EQUAL,IF,FFN-SYMB,EQ,REWRITE-QUOTED-CONSTANT,FQUOTEP,T,CDR,ASSOC-EQ,TEMP,REWRITE-SOLIDIFY-PLUS,REWRITE-ENTRY,VARIABLEP,TIME-LIMIT5-REACHED-P,SUBLIS-VAR,MV,RDEPTH-ERROR,ZERO-DEPTHP,COND,ADJUST-RDEPTH,QUOTE,PUSH-GFRAME,LET,THE-MV,SIGNED-BYTE,UNSIGNED-BYTE,TYPE,DECLARE,TTREE,GSTACK,RCNST,SIMPLIFY-CLAUSE-POT-LST,BACKCHAIN-LIMIT,ANCESTORS,FNSTACK,STATE,WRLD,PEQUIV-INFO,GENEQV,OBJ,TYPE-ALIST,STEP-LIMIT,RDEPTH,BKPTR,ALIST,TERM,DEFUN,MUTUAL-RECURSION" data-used-by="RDEPTH-ERROR,CW-GFRAME,TILDE-@-BKPTR-PHRASE,REWRITE-ENTRY" typeof="Code">
    <div class="form-header"><span class="form-name" property="name" data-sym="REWRITE">rewrite</span><span class="form-type">mutual-recursion</span></div>
    <pre class="code" property="text">(<a class="sym-link system" href="axioms.html#def-mutual-recursion" data-sym="MUTUAL-RECURSION">mutual-recursion</a> (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> <a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a>
    (term alist
      bkptr
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (let ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> '<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> bkptr term alist obj geneqv)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth)))
        (declare (type (unsigned-byte <span class="number">60</span>) rdepth))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-zero-depthp" data-sym="ZERO-DEPTHP" title="(defmacro zero-depthp (depth) `(eql (the-fixnum ,depth) 0))">zero-depthp</a> rdepth) (<a class="sym-link local-def" href="#def-rdepth-error" data-sym="RDEPTH-ERROR" title="(defmacro rdepth-error (form &amp;optional preprocess-p)
  (if preprocess-p
      (let ((ctx &#39;&#39;preprocess))
        `(prog2$
          (er-hard ,ctx &quot;Call depth&quot;
...">rdepth-error</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> alist term) ttree)))
          ((<a class="sym-link system" href="axioms.html#def-time-limit5-reached-p" data-sym="TIME-LIMIT5-REACHED-P">time-limit5-reached-p</a> <span class="string">"Out of time in the rewriter (rewrite)."</span>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil nil))
          ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-solidify-plus (let ((temp (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> term alist)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (temp (cdr temp)) (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> term))))))
          ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-quoted-constant term)))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'if) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) alist <span class="number">2</span>)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-test ttree)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist <span class="number">1</span>)
                    <span class="keyword">:obj</span> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj '?) '?)
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((arg2 (if (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))
                               <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>
                               (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>))))
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg2) (if (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> arg2)
                                obj
                                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> obj)))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((arg3 (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)))
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> arg3) (if (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> arg3)
                                      (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> obj)
                                      obj))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> '?))))))))
                    <span class="keyword">:geneqv</span> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                    <span class="keyword">:pequiv-info</span> nil)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-if rewritten-test
                      (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                      (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                      (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)
                      alist))))))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-return-last" data-sym="RETURN-LAST">return-last</a>)
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) ''<a class="sym-link system" href="axioms.html#def-progn" data-sym="PROGN">progn</a>))) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>) alist <span class="number">3</span>)
              <span class="keyword">:ttree</span> (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-return-last" data-sym="RETURN-LAST">return-last</a> nil nil wrld) ttree)))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((stack (<a class="sym-link local-def" href="#def-make-stack-from-alist" data-sym="MAKE-STACK-FROM-ALIST" title="(defun make-stack-from-alist (term alist)
  (if alist
      (let* ((vars-of-term (all-vars term))
             (formals (strip-cars alist))
             (actuals (strip-cdrs alist))
...">make-stack-from-alist</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist)) (inst-term (if alist
                    (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
                      (make-lambda-application (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> stack)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                        (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> stack)))
                    term))
                (new-rcnst (<a class="sym-link local-def" href="#def-expand-permission-p" data-sym="EXPAND-PERMISSION-P" title="(defun expand-permission-p (term rcnst geneqv wrld)
  (mv-let (new-term hyp unify-subst rune new-rcnst)
          (expand-permission-result term rcnst geneqv wrld)
          (declare (ignore hyp unify-subst rune)) (and new-term new-rcnst)))">expand-permission-p</a> inst-term rcnst geneqv wrld)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (new-rcnst (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist <span class="number">1</span>)
                    <span class="keyword">:ttree</span> (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld) ttree)
                    <span class="keyword">:rcnst</span> new-rcnst))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas inst-term))))))
          ((<a class="sym-link local-def" href="#def-lambda-nest-hidep" data-sym="LAMBDA-NEST-HIDEP" title="(defun lambda-nest-hidep (term)
  (and (lambda-applicationp term)
       (let ((body (lambda-body (ffn-symb term))))
         (cond ((variablep body) nil) ((fquotep body) nil)
               ((eq (ffn-symb body) &#39;hide) t) (t (lambda-nest-hidep body))))))">lambda-nest-hidep</a> term) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((new-body (<a class="sym-link local-def" href="#def-lambda-nest-unhide" data-sym="LAMBDA-NEST-UNHIDE" title="(defun lambda-nest-unhide (term)
  (if (lambda-applicationp term)
      (make-lambda-application (lambda-formals (ffn-symb term))
                               (lambda-nest-unhide
                                (lambda-body (ffn-symb term)))
...">lambda-nest-unhide</a> term)) (stack (<a class="sym-link local-def" href="#def-make-stack-from-alist" data-sym="MAKE-STACK-FROM-ALIST" title="(defun make-stack-from-alist (term alist)
  (if alist
      (let* ((vars-of-term (all-vars term))
             (formals (strip-cars alist))
             (actuals (strip-cdrs alist))
...">make-stack-from-alist</a> new-body alist))
                (inst-term (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a>
                    (if alist
                      (make-lambda-application (<a class="sym-link system" href="axioms.html#def-caar" data-sym="CAAR">caar</a> stack) new-body (<a class="sym-link system" href="axioms.html#def-cdar" data-sym="CDAR">cdar</a> stack))
                      new-body)))
                (new-rcnst (<a class="sym-link local-def" href="#def-expand-permission-p" data-sym="EXPAND-PERMISSION-P" title="(defun expand-permission-p (term rcnst geneqv wrld)
  (mv-let (new-term hyp unify-subst rune new-rcnst)
          (expand-permission-result term rcnst geneqv wrld)
          (declare (ignore hyp unify-subst rune)) (and new-term new-rcnst)))">expand-permission-p</a> inst-term rcnst geneqv wrld)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (new-rcnst (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> inst-term <span class="number">1</span>) nil <span class="number">1</span>)
                    <span class="keyword">:ttree</span> (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld) ttree)
                    <span class="keyword">:rcnst</span> new-rcnst))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas inst-term))))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a>) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-test ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist <span class="number">1</span>)
                <span class="keyword">:obj</span> '?
                <span class="keyword">:geneqv</span> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                <span class="keyword">:pequiv-info</span> nil)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal rewritten-test <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-concl ttree)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>) alist <span class="number">2</span>)
                      <span class="keyword">:obj</span> '?
                      <span class="keyword">:geneqv</span> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                      <span class="keyword">:pequiv-info</span> nil)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal rewritten-concl <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> rewritten-test) ttree))
                      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> rewritten-concl)
                         (equal rewritten-test rewritten-concl)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree))
                      ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> rewritten-test) (let ((rune (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)))
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rune (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-concl (push-lemma rune ttree)))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> 'if rewritten-concl <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                                ttree)))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          (<a class="sym-link system" href="basis-b.html#def-subcor-var" data-sym="SUBCOR-VAR">subcor-var</a> (<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> '<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a> wrld)
                            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rewritten-test rewritten-concl)
                            (<a class="sym-link system" href="axioms.html#def-bbody" data-sym="BBODY">bbody</a> '<a class="sym-link system" href="axioms.html#def-implies" data-sym="IMPLIES">implies</a>))
                          ttree))))))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) '<a class="sym-link system" href="axioms.html#def-double-rewrite" data-sym="DOUBLE-REWRITE">double-rewrite</a>) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (term ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>) alist <span class="number">1</span>))
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> term nil bkptr)
                <span class="keyword">:ttree</span> (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-double-rewrite" data-sym="DOUBLE-REWRITE">double-rewrite</a> nil nil wrld)
                  ttree))))
          ((<a class="sym-link local-def" href="#def-not-to-be-rewrittenp" data-sym="NOT-TO-BE-REWRITTENP" title="(defun not-to-be-rewrittenp (term alist terms-to-be-ignored-by-rewrite)
  (cond
   ((not-to-be-rewrittenp1 (ffn-symb term) terms-to-be-ignored-by-rewrite)
    (member-equal-mod-alist term alist terms-to-be-ignored-by-rewrite))
   (t nil)))">not-to-be-rewrittenp</a> term
             alist
             (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant
               rcnst
               <span class="keyword">:terms-to-be-ignored-by-rewrite</span>)) (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
              (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> alist term)
                type-alist
                obj
                geneqv
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                wrld
                ttree
                simplify-clause-pot-lst
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term ttree)
                (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'do$)
                    (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">6</span>))
                    (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">6</span>)))
                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn
                      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">1</span>)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">2</span>)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">3</span>)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">4</span>)
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> term <span class="number">5</span>)
                        <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))
                    (push-lemma (fn-rune-nume 'do$ nil nil wrld) ttree))
                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> term ttree))
                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (mv-nth-result mv-nth-rewritep)
                  (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn '<a class="sym-link system" href="axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a>)
                    (<a class="sym-link local-def" href="#def-simplifiable-mv-nth" data-sym="SIMPLIFIABLE-MV-NTH" title="(defun simplifiable-mv-nth (term alist)
  (cond
   ((simplifiable-mv-nth-p)
    (let ((arg1
           (cond
...">simplifiable-mv-nth</a> term alist)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil nil))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (mv-nth-result (let ((ttree (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-mv-nth" data-sym="MV-NTH">mv-nth</a> nil nil wrld) ttree)) (step-limit (<a class="sym-link system" href="basis-a.html#def-1_2Bf" data-sym="1+F">1+f</a> step-limit)))
                        (declare (type (signed-byte <span class="number">61</span>) step-limit))
                        (if mv-nth-rewritep
                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> mv-nth-result alist <span class="number">2</span>))
                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-solidify-plus mv-nth-result)))))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)))
                        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (deep-pequiv-lst shallow-pequiv-lst)
                          (<a class="sym-link local-def" href="#def-pequivs-for-rewrite-args" data-sym="PEQUIVS-FOR-REWRITE-ARGS" title="(defun pequivs-for-rewrite-args (fn geneqv pequiv-info wrld ens)
  (cond ((flambdap fn) (mv nil nil))
        (t
         (let* ((prop (getpropc fn &#39;pequivs nil wrld))
                (shallow-pequiv-alist (pequivs-property-field prop :shallow)))
...">pequivs-for-rewrite-args</a> fn geneqv pequiv-info wrld ens)
                          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-args ttree)
                            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-args (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term)
                                alist
                                <span class="number">1</span>
                                nil
                                deep-pequiv-lst
                                shallow-pequiv-lst
                                geneqv
                                fn)
                              <span class="keyword">:obj</span> '?
                              <span class="keyword">:geneqv</span> (<a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a> fn geneqv ens wrld)
                              <span class="keyword">:pequiv-info</span> nil)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) (<a class="sym-link system" href="axioms.html#def-logicp" data-sym="LOGICP">logicp</a> fn wrld))
                                 (all-quoteps rewritten-args)
                                 (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term)
                                   (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (enabled-xfnp fn ens wrld)
                                     (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> fn 'constrainedp nil wrld))))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> fn)
                                        (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> fn) rewritten-args)
                                        '<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a>)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)))
                                      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val apply$ed-fns)
                                        (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-ev-fncall_2B" data-sym="EV-FNCALL+" title="(defun ev-fncall+ (fn args strictp state)
  (ev-fncall+-w fn args (w state) (f-get-global &#39;safe-mode state)
                (gc-off state) strictp))">ev-fncall+</a> fn (<a class="sym-link system" href="axioms.html#def-strip-cadrs" data-sym="STRIP-CADRS">strip-cadrs</a> rewritten-args) nil state))
                                        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp2 ttree)
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> erp (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> apply$ed-fns)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> erp ttree))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a> apply$ed-fns
                                                (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn rewritten-args)
                                                type-alist
                                                ens
                                                wrld
                                                <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                                                ttree
                                                ttree)))
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp2 (let ((new-term1 (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn rewritten-args)))
                                                (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (new-term2 ttree)
                                                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas new-term1))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal new-term1 new-term2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                        (<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a> (if erp
                                                            (cons <span class="keyword">:non-executable</span> erp)
                                                            (cons <span class="keyword">:missing-warrant</span> erp2))
                                                          new-term1
                                                          wrld
                                                          state)
                                                        (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld) ttree)))
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit new-term2 ttree))))))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> val)
                                                (push-lemma (fn-rune-nume fn nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld) ttree))))))))))
                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'ev$)
                                 (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'projects/apply/base-includedp wrld)
                                 (active-runep '(<span class="keyword">:rewrite</span> ev$-opener))
                                 (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> (car rewritten-args))) (let ((x (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> (car rewritten-args))) (y (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> rewritten-args)))
                                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (flg sigma)
                                    (<a class="sym-link local-def" href="#def-recover-subst-from-formal-var-alist" data-sym="RECOVER-SUBST-FROM-FORMAL-VAR-ALIST" title="(defun recover-subst-from-formal-var-alist (term)
  (cond ((variablep term) (mv nil nil)) ((equal term *nil*) (mv t nil))
        (t
         (mv-let (flg pair rest) (formal-cons-to-components term)
                 (cond ((null flg) (mv nil nil))
...">recover-subst-from-formal-var-alist</a> y)
                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> flg) (<a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a> fn rewritten-args))
                                      ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (termp x wrld) (executable-tamep x wrld))) (<a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a> fn rewritten-args))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (warranted-fns unwarranted-fns)
                                          (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> (all-fnnames x) wrld nil nil)
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (unwarranted-fns (<a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a> fn rewritten-args))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-alist (<a class="sym-link local-def" href="#def-extend-subst-on-unbound-vars" data-sym="EXTEND-SUBST-ON-UNBOUND-VARS" title="(defun extend-subst-on-unbound-vars (vars alist)
  (cond ((endp vars) alist)
        ((assoc-eq (car vars) alist)
         (extend-subst-on-unbound-vars (cdr vars) alist))
        (t
...">extend-subst-on-unbound-vars</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> x) sigma)))
                                                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp ttree1)
                                                  (<a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a> warranted-fns
                                                    term
                                                    type-alist
                                                    ens
                                                    wrld
                                                    (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                                                    (push-lemma? (active-runep '(<span class="keyword">:rewrite</span> ev$-opener)) ttree)
                                                    ttree)
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a> fn rewritten-args))
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> x new-alist 'expansion)
                                                        <span class="keyword">:ttree</span> ttree1)))))))))))))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-standard-exit" data-sym="REWRITE-STANDARD-EXIT" title="(defmacro rewrite-standard-exit (fn rewritten-args)
  `(sl-let (rewritten-term ttree)
           (rewrite-entry (rewrite-primitive ,fn ,rewritten-args))
           (rewrite-entry (rewrite-with-lemmas rewritten-term))))">rewrite-standard-exit</a> fn rewritten-args))))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-solidify-plus
    (term rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-term new-ttree)
        (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
          type-alist
          obj
          geneqv
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
          wrld
          ttree
          simplify-clause-pot-lst
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj '?)
             (<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> new-term)
             (<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> new-term)
             (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> new-term)
               (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant
                 rcnst
                 <span class="keyword">:fns-to-be-ignored-by-rewrite</span>))
             (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term)
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal geneqv <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>))
             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal term new-term))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit new-term new-ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp term1 ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas1 term
                  (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> new-term) 'lemmas nil wrld)))
              (declare (ignore rewrittenp))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term1 ttree)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> assume-true-false-heavy-linearp
    (test rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj))
    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (must-be-true must-be-false
        true-type-alist
        false-type-alist
        ts-ttree)
      (assume-true-false test
        nil
        (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
        nil
        type-alist
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
        wrld
        simplify-clause-pot-lst
        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
        nil)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> must-be-true must-be-false) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            must-be-true
            must-be-false
            true-type-alist
            false-type-alist
            simplify-clause-pot-lst
            simplify-clause-pot-lst
            ts-ttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((test+ (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> test)))
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp true-pot-lst)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-terms-and-lemmas test+ nil <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) <span class="keyword">:obj</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    nil
                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    nil
                    false-type-alist
                    nil
                    simplify-clause-pot-lst
                    (push-lemma <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear_2A" data-sym="*FAKE-RUNE-FOR-LINEAR*" title="(defconst *fake-rune-for-linear* &#39;(:fake-rune-for-linear nil))">*fake-rune-for-linear*</a>
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp false-pot-lst)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-terms-and-lemmas test+ nil nil)
                      <span class="keyword">:obj</span> nil)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                          nil
                          true-type-alist
                          nil
                          simplify-clause-pot-lst
                          nil
                          (push-lemma <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear_2A" data-sym="*FAKE-RUNE-FOR-LINEAR*" title="(defconst *fake-rune-for-linear* &#39;(:fake-rune-for-linear nil))">*fake-rune-for-linear*</a>
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          nil
                          nil
                          true-type-alist
                          false-type-alist
                          true-pot-lst
                          false-pot-lst
                          nil))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-if-finish
    (test unrewritten-test
      left
      right
      alist
      swapped-p
      must-be-true
      must-be-false
      true-type-alist
      false-type-alist
      true-pot-lst
      false-pot-lst
      ts-ttree
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (must-be-true (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unrewritten-test
            (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)
            (equal unrewritten-test left))
          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (cons-tag-trees ts-ttree ttree))
          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> left alist <span class="number">2</span>)
            <span class="keyword">:type-alist</span> true-type-alist
            <span class="keyword">:simplify-clause-pot-lst</span> true-pot-lst
            <span class="keyword">:ttree</span> (cons-tag-trees ts-ttree ttree))))
      (must-be-false (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> right alist <span class="number">3</span>)
          <span class="keyword">:type-alist</span> false-type-alist
          <span class="keyword">:simplify-clause-pot-lst</span> false-pot-lst
          <span class="keyword">:ttree</span> (cons-tag-trees ts-ttree ttree)))
      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ttree (<a class="sym-link local-def" href="#def-normalize-rw-any-cache" data-sym="NORMALIZE-RW-ANY-CACHE" title="(defun normalize-rw-any-cache (ttree)
  (let ((cache (tagged-objects &#39;rw-cache-any-tag ttree)))
    (cond ((or (null cache) (sorted-rw-cache-p cache)) ttree)
          (t
           (extend-tag-tree &#39;rw-cache-any-tag
...">normalize-rw-any-cache</a> ttree)))
          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-left ttree)
            (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unrewritten-test
                (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)
                (equal unrewritten-test left))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree)
              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rw-left ttree1)
                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> left alist <span class="number">2</span>)
                  <span class="keyword">:type-alist</span> true-type-alist
                  <span class="keyword">:simplify-clause-pot-lst</span> true-pot-lst
                  <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-rw-cache-enter-context" data-sym="RW-CACHE-ENTER-CONTEXT" title="(defun rw-cache-enter-context (ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-nil-tag ttree)
                         (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">rw-cache-enter-context</a> ttree))
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rw-left (<a class="sym-link local-def" href="#def-rw-cache-exit-context" data-sym="RW-CACHE-EXIT-CONTEXT" title="(defun rw-cache-exit-context (old-ttree new-ttree)
  (mv-let (flg new-any)
          (combine-rw-caches (tagged-objects &#39;rw-cache-any-tag new-ttree)
                             (tagged-objects &#39;rw-cache-any-tag old-ttree))
          (declare (ignore flg))
...">rw-cache-exit-context</a> ttree ttree1))))
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-right ttree1)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> right alist <span class="number">3</span>)
                <span class="keyword">:type-alist</span> false-type-alist
                <span class="keyword">:simplify-clause-pot-lst</span> false-pot-lst
                <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-rw-cache-enter-context" data-sym="RW-CACHE-ENTER-CONTEXT" title="(defun rw-cache-enter-context (ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-nil-tag ttree)
                         (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">rw-cache-enter-context</a> ttree))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (rewritten-term ttree)
                (<a class="sym-link local-def" href="#def-rewrite-if1" data-sym="REWRITE-IF1" title="(defun rewrite-if1
       (test left right swapped-p type-alist geneqv ens ok-to-force wrld ttree)
  (flet ((if-call (test left right swapped-p)
           (cond
            ((and swapped-p (rewrite-if-avoid-swap))
...">rewrite-if1</a> test
                  rewritten-left
                  rewritten-right
                  swapped-p
                  type-alist
                  geneqv
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                  wrld
                  (<a class="sym-link local-def" href="#def-rw-cache-exit-context" data-sym="RW-CACHE-EXIT-CONTEXT" title="(defun rw-cache-exit-context (old-ttree new-ttree)
  (mv-let (flg new-any)
          (combine-rw-caches (tagged-objects &#39;rw-cache-any-tag new-ttree)
                             (tagged-objects &#39;rw-cache-any-tag old-ttree))
          (declare (ignore flg))
...">rw-cache-exit-context</a> ttree ttree1))
                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas rewritten-term)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-if
    (test unrewritten-test
      left
      right
      alist
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (test unrewritten-test left right swapped-p)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> test 'if)
             (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">2</span>) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
             (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">3</span>) <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> test <span class="number">1</span>) nil right left <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> test unrewritten-test left right nil)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> test) (if (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> test)
              (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unrewritten-test
                  (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> '<a class="sym-link system" href="axioms.html#def-iff" data-sym="IFF">iff</a> geneqv wrld)
                  (equal unrewritten-test left))
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree)
                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> left alist <span class="number">2</span>)))
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> right alist <span class="number">3</span>))))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:heavy-linearp</span>) <span class="keyword">:heavy</span>) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (must-be-true must-be-false
                true-type-alist
                false-type-alist
                true-pot-lst
                false-pot-lst
                ts-ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (assume-true-false-heavy-linearp test))
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-if-finish test
                  unrewritten-test
                  left
                  right
                  alist
                  swapped-p
                  must-be-true
                  must-be-false
                  true-type-alist
                  false-type-alist
                  true-pot-lst
                  false-pot-lst
                  ts-ttree))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (must-be-true must-be-false
                true-type-alist
                false-type-alist
                ts-ttree)
              (if ancestors
                (assume-true-false test
                  nil
                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                  nil
                  type-alist
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                  wrld
                  simplify-clause-pot-lst
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
                  nil)
                (assume-true-false test
                  nil
                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                  nil
                  type-alist
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                  wrld
                  nil
                  nil
                  nil))
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-if-finish test
                  unrewritten-test
                  left
                  right
                  alist
                  swapped-p
                  must-be-true
                  must-be-false
                  true-type-alist
                  false-type-alist
                  simplify-clause-pot-lst
                  simplify-clause-pot-lst
                  ts-ttree))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-args
    (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> alist
      bkptr
      rewritten-args-rev
      deep-pequiv-lst
      shallow-pequiv-lst
      parent-geneqv
      parent-fn
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit)
      (ignore pequiv-info))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> rewritten-args-rev) ttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (child-geneqv child-pequiv-info)
            (<a class="sym-link local-def" href="#def-geneqv-and-pequiv-info-for-rewrite" data-sym="GENEQV-AND-PEQUIV-INFO-FOR-REWRITE" title="(defun geneqv-and-pequiv-info-for-rewrite
       (fn bkptr rewritten-args-rev args alist parent-geneqv child-geneqv
        deep-pequiv-lst shallow-pequiv-lst wrld)
  (mv
   (geneqv-for-rewrite shallow-pequiv-lst fn bkptr rewritten-args-rev
...">geneqv-and-pequiv-info-for-rewrite</a> parent-fn
              bkptr
              rewritten-args-rev
              <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
              alist
              parent-geneqv
              (car geneqv)
              deep-pequiv-lst
              shallow-pequiv-lst
              wrld)
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-arg ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) alist bkptr)
                <span class="keyword">:geneqv</span> child-geneqv
                <span class="keyword">:pequiv-info</span> child-pequiv-info)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-args (cdr <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                  alist
                  (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                  (cons rewritten-arg rewritten-args-rev)
                  deep-pequiv-lst
                  shallow-pequiv-lst
                  parent-geneqv
                  parent-fn)
                <span class="keyword">:pequiv-info</span> nil
                <span class="keyword">:geneqv</span> (cdr geneqv))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-primitive
    (fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore geneqv pequiv-info obj)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-fcons-term" data-sym="FCONS-TERM">fcons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))
        ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn 'equal) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-equal (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) nil nil)
            <span class="keyword">:obj</span> '?
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)) (recog-tuple (most-recent-enabled-recog-tuple fn wrld ens)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (recog-tuple (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                  (<a class="sym-link local-def" href="#def-rewrite-recognizer" data-sym="REWRITE-RECOGNIZER" title="(defun rewrite-recognizer
       (recog-tuple arg type-alist ens force-flg wrld ttree pot-lst pt)
  (mv-let (ts ttree+)
          (type-set arg force-flg nil type-alist ens wrld ttree pot-lst pt)
          (cond
...">rewrite-recognizer</a> recog-tuple
                    (car <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                    type-alist
                    ens
                    (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                    wrld
                    ttree
                    simplify-clause-pot-lst
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-cons-term" data-sym="CONS-TERM">cons-term</a> fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>) ttree))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-equal
    (lhs rhs
      lhs-ancestors
      rhs-ancestors
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal lhs rhs) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (puffert ttree)))
        ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> lhs) (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> rhs)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (puffert ttree)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts-lookup ttree-lookup)
            (assoc-type-alist (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> 'equal lhs rhs)
              type-alist
              wrld)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ts-lookup (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts-lookup *ts-t*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (cons-tag-trees ttree-lookup ttree)))
              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ts-lookup (<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts-lookup *ts-nil*)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (cons-tag-trees ttree-lookup ttree)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)) (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)))
                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts-lhs ttree-lhs)
                    (type-set lhs
                      <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                      nil
                      type-alist
                      ens
                      wrld
                      ttree
                      simplify-clause-pot-lst
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts-rhs ttree+)
                      (type-set rhs
                        <a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a>
                        nil
                        type-alist
                        ens
                        wrld
                        ttree-lhs
                        simplify-clause-pot-lst
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
                      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ts-equality ttree-equality)
                        (type-set-equal ts-lhs ts-rhs ttree+ ttree)
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts-equality *ts-t*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> ttree-equality))
                          ((<a class="sym-link system" href="basis-b.html#def-ts_3D" data-sym="TS=">ts=</a> ts-equality *ts-nil*) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> ttree-equality))
                          ((equal-x-cons-x-yp lhs rhs) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (puffert ttree)))
                          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts-lhs *ts-boolean*) (equal rhs <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit lhs (puffert ttree-lhs)))
                          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts-rhs *ts-boolean*) (equal lhs <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rhs (puffert ttree+)))
                          ((equal lhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if rhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                              (puffert ttree)))
                          ((equal rhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if lhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                              (puffert ttree)))
                          ((<a class="sym-link system" href="basis-b.html#def-equalityp" data-sym="EQUALITYP">equalityp</a> lhs) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if
                                lhs
                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'equal rhs <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if rhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>))
                              (puffert ttree)))
                          ((<a class="sym-link system" href="basis-b.html#def-equalityp" data-sym="EQUALITYP">equalityp</a> rhs) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if
                                rhs
                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'equal lhs <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'if lhs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>))
                              (puffert ttree)))
                          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (ts-subsetp ts-lhs *ts-cons*)
                             (ts-subsetp ts-rhs *ts-cons*)
                             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> lhs lhs-ancestors))
                             (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> rhs rhs-ancestors))) (let ((alist (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons 'lhs lhs) (cons 'rhs rhs))))
                              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (equal-cars new-ttree)
                                (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (cars ttree0)
                                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-args '((car lhs) (car rhs))
                                      alist
                                      <span class="number">1</span>
                                      nil
                                      nil
                                      nil
                                      nil
                                      'equal)
                                    <span class="keyword">:obj</span> '?
                                    <span class="keyword">:geneqv</span> nil
                                    <span class="keyword">:pequiv-info</span> nil
                                    <span class="keyword">:ttree</span> ttree+)
                                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-equal (car cars)
                                      (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> cars)
                                      (cons lhs lhs-ancestors)
                                      (cons rhs rhs-ancestors))
                                    <span class="keyword">:obj</span> nil
                                    <span class="keyword">:geneqv</span> nil
                                    <span class="keyword">:pequiv-info</span> nil
                                    <span class="keyword">:ttree</span> ttree0))
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal equal-cars <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (equal-cdrs new-ttree)
                                      (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (cdrs ttree0)
                                        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-args '((cdr lhs) (cdr rhs))
                                            alist
                                            <span class="number">1</span>
                                            nil
                                            nil
                                            nil
                                            nil
                                            'equal)
                                          <span class="keyword">:obj</span> '?
                                          <span class="keyword">:geneqv</span> nil
                                          <span class="keyword">:pequiv-info</span> nil
                                          <span class="keyword">:ttree</span> new-ttree)
                                        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-equal (car cdrs)
                                            (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> cdrs)
                                            (cons lhs lhs-ancestors)
                                            (cons rhs rhs-ancestors))
                                          <span class="keyword">:obj</span> nil
                                          <span class="keyword">:geneqv</span> nil
                                          <span class="keyword">:pequiv-info</span> nil
                                          <span class="keyword">:ttree</span> ttree0))
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal equal-cdrs <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> (puffert new-ttree)))
                                        ((equal equal-cdrs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (puffert new-ttree)))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                            (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'equal lhs rhs)
                                            (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree))))))
                                  ((equal equal-cars <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (puffert new-ttree)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ttree (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree)))
                                      (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (equal-cdrs new-ttree)
                                        (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (cdrs ttree0)
                                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-args '((cdr lhs) (cdr rhs))
                                              alist
                                              <span class="number">1</span>
                                              nil
                                              nil
                                              nil
                                              nil
                                              'equal)
                                            <span class="keyword">:obj</span> '?
                                            <span class="keyword">:geneqv</span> nil
                                            <span class="keyword">:pequiv-info</span> nil
                                            <span class="keyword">:ttree</span> ttree)
                                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-equal (car cdrs)
                                              (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> cdrs)
                                              (cons lhs lhs-ancestors)
                                              (cons rhs rhs-ancestors))
                                            <span class="keyword">:obj</span> nil
                                            <span class="keyword">:geneqv</span> nil
                                            <span class="keyword">:pequiv-info</span> nil
                                            <span class="keyword">:ttree</span> ttree0))
                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal equal-cdrs <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a> (puffert new-ttree)))
                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                              (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'equal lhs rhs)
                                              (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree)))))))))))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'equal lhs rhs) ttree))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyp
    (rune target
      hyp0
      unify-subst
      bkptr
      memo
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">6</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> hyp0 '<a class="sym-link system" href="axioms.html#def-synp" data-sym="SYNP">synp</a>) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (wonp failure-reason unify-subst ttree)
            (<a class="sym-link local-def" href="#def-relieve-hyp-synp" data-sym="RELIEVE-HYP-SYNP" title="(defun relieve-hyp-synp
       (rune hyp0 unify-subst rdepth type-alist wrld state fnstack ancestors
        backchain-limit simplify-clause-pot-lst rcnst gstack ttree bkptr)
  (let* ((synp-fn (car (get-evg (fargn hyp0 2) &#39;relieve-hyp)))
         (mfc
...">relieve-hyp-synp</a> rune
              hyp0
              unify-subst
              rdepth
              type-alist
              wrld
              state
              fnstack
              ancestors
              <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
              simplify-clause-pot-lst
              rcnst
              gstack
              ttree
              bkptr)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit wonp failure-reason unify-subst ttree memo)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (forcep1 bind-flg)
            (binding-hyp-p hyp0 unify-subst wrld)
            (let ((hyp (if forcep1
                   (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp0 <span class="number">1</span>)
                   hyp0)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bind-flg (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-rhs ttree)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">2</span>)
                        unify-subst
                        (if (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                            (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'dmrp state))
                          (cons 'rhs bkptr)
                          nil))
                      <span class="keyword">:obj</span> '?
                      <span class="keyword">:ancestors</span> (cons (make-ancestor-binding-hyp hyp unify-subst) ancestors)
                      <span class="keyword">:geneqv</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) 'equal))
                        (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (<a class="sym-link local-def" href="#def-geneqv-lst" data-sym="GENEQV-LST" title="(defun geneqv-lst (fn geneqv ens wrld)
  (cond ((flambdap fn) nil) ((eq fn &#39;if) (list *geneqv-iff* geneqv geneqv))
        (t
         (let ((congruences (getpropc fn &#39;congruences nil wrld)))
           (cond ((null congruences) nil)
...">geneqv-lst</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp)
                            <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                            wrld)))
                      <span class="keyword">:pequiv-info</span> nil)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                      nil
                      (cons (cons (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>) rewritten-rhs) unify-subst)
                      ttree
                      memo)))
                ((free-varsp hyp unify-subst) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (term typ compound-rec-rune?)
                    (term-and-typ-to-lookup hyp
                      wrld
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                      term
                      typ
                      unify-subst
                      (push-lemma? compound-rec-rune? ttree)
                      memo)))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((memo-active (<a class="sym-link local-def" href="#def-memo-activep" data-sym="MEMO-ACTIVEP" title="(defabbrev memo-activep (memo) (or (eq memo :start) (consp memo)))">memo-activep</a> memo)) (memo-entry (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp memo) (cdr (<a class="sym-link system" href="axioms.html#def-assoc" data-sym="ASSOC">assoc</a> bkptr memo))))
                      (hyp-vars (if memo-entry
                          (car memo-entry)
                          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> memo-active (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> hyp0))))
                      (restricted-unify-subst (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> memo-active (<a class="sym-link system" href="axioms.html#def-restrict-alist" data-sym="RESTRICT-ALIST">restrict-alist</a> hyp-vars unify-subst)))
                      (old-entry (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> memo-entry
                          (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> restricted-unify-subst (cdr memo-entry)))))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (old-entry (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                          nil
                          unify-subst
                          (<a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache" data-sym="CONS-TAG-TREES-RW-CACHE" title="(defun cons-tag-trees-rw-cache (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects &#39;rw-cache-any-tag ttree1))
        (rw-cache-any2 (tagged-objects &#39;rw-cache-any-tag ttree2))
        (rw-cache-nil1 (tagged-objects &#39;rw-cache-nil-tag ttree1))
        (rw-cache-nil2 (tagged-objects &#39;rw-cache-nil-tag ttree2)))
...">cons-tag-trees-rw-cache</a> (cdr old-entry) ttree)
                          memo))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyp-ans failure-reason unify-subst ttree0)
                          (let ((ttree (if memo-active
                                 (<a class="sym-link local-def" href="#def-rw-cache" data-sym="RW-CACHE" title="(defun rw-cache (ttree)
  (cond
   ((tag-tree-tags-subsetp ttree &#39;(rw-cache-nil-tag rw-cache-any-tag)) ttree)
   (t
    (maybe-extend-tag-tree &#39;rw-cache-any-tag
...">rw-cache</a> ttree)
                                 ttree)))
                            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (lookup-hyp-ans unify-subst ttree)
                              (lookup-hyp hyp
                                type-alist
                                wrld
                                unify-subst
                                ttree
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (lookup-hyp-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst ttree))
                                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((inst-hyp (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> unify-subst hyp)) (forcer-fn (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep1 (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp0)))
                                      (force-flg (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst))
                                      (forcep (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep1 force-flg)))
                                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (knownp nilp nilp-ttree)
                                      (known-whether-nil inst-hyp
                                        type-alist
                                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                        force-flg
                                        nil
                                        wrld
                                        ttree)
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (knownp (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (nilp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil 'known-nil unify-subst ttree))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst nilp-ttree))))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (on-ancestorsp assumed-true)
                                            (ancestors-check inst-hyp ancestors (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune))
                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> on-ancestorsp assumed-true) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst ttree))
                                              ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> on-ancestorsp
                                                 (backchain-limit-reachedp <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> ancestors)) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> forcep) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                                                        target
                                                        inst-hyp
                                                        type-alist
                                                        nil
                                                        (immediate-forcep forcer-fn
                                                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                                                        force-flg
                                                        ttree)))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst ttree))
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                        nil
                                                        (if on-ancestorsp
                                                          'ancestors
                                                          (cons '<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> ancestors))
                                                        unify-subst
                                                        ttree)))))
                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
                                                  (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> hyp)
                                                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-atm new-ttree)
                                                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> atm unify-subst bkptr)
                                                      <span class="keyword">:obj</span> (if not-flg
                                                        nil
                                                        <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                                                      <span class="keyword">:geneqv</span> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                                                      <span class="keyword">:pequiv-info</span> nil
                                                      <span class="keyword">:ancestors</span> (push-ancestor (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> inst-hyp)
                                                        (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> rune)
                                                        ancestors
                                                        bkptr))
                                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (not-flg (if (equal rewritten-atm <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)
                                                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst new-ttree)
                                                          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg new-ttree)
                                                            (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal rewritten-atm <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)))
                                                              (force-assumption rune
                                                                target
                                                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> rewritten-atm)
                                                                type-alist
                                                                (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> unify-subst atm))
                                                                (immediate-forcep forcer-fn
                                                                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                                                                force-flg
                                                                new-ttree)
                                                              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil new-ttree))
                                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst new-ttree))
                                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                                  nil
                                                                  (cons 'rewrote-to (<a class="sym-link system" href="basis-b.html#def-dumb-negate-lit" data-sym="DUMB-NEGATE-LIT">dumb-negate-lit</a> rewritten-atm))
                                                                  unify-subst
                                                                  (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree)))))))
                                                      ((<a class="sym-link local-def" href="#def-if-tautologyp" data-sym="IF-TAUTOLOGYP" title="(defun if-tautologyp (term)
  (declare (xargs :guard (pseudo-termp term)))
  (posp
   (if-interp (splice-instrs (if-compile term t nil nil)) nil nil nil nil
              100000)))">if-tautologyp</a> rewritten-atm) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst new-ttree))
                                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg new-ttree)
                                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal rewritten-atm <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>))) (force-assumption rune
                                                                target
                                                                rewritten-atm
                                                                type-alist
                                                                (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> unify-subst atm)
                                                                (immediate-forcep forcer-fn
                                                                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                                                                force-flg
                                                                new-ttree))
                                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil new-ttree)))
                                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst new-ttree))
                                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                                nil
                                                                (cons 'rewrote-to rewritten-atm)
                                                                unify-subst
                                                                (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree))))))))))))))))))))
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyp-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                relieve-hyp-ans
                                failure-reason
                                unify-subst
                                (if memo-active
                                  (<a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache-first" data-sym="CONS-TAG-TREES-RW-CACHE-FIRST" title="(defun cons-tag-trees-rw-cache-first (ttree1 ttree2)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-any-tag ttree1)
                         (maybe-extend-tag-tree &#39;rw-cache-nil-tag
                                                (tagged-objects
...">cons-tag-trees-rw-cache-first</a> ttree ttree0)
                                  ttree0)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (memo-entry (<a class="sym-link system" href="axioms.html#def-put-assoc-eql" data-sym="PUT-ASSOC-EQL">put-assoc-eql</a> bkptr
                                      (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> hyp-vars
                                        (cons (cons restricted-unify-subst ttree0) (cdr memo-entry)))
                                      memo))
                                  (memo-active (<a class="sym-link system" href="axioms.html#def-put-assoc-eql" data-sym="PUT-ASSOC-EQL">put-assoc-eql</a> bkptr
                                      (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> hyp-vars
                                        (cons (cons restricted-unify-subst ttree0) nil))
                                      (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> memo <span class="keyword">:start</span>)
                                        nil
                                        memo)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> memo))))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                relieve-hyp-ans
                                failure-reason
                                unify-subst
                                (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree0 ttree)
                                memo)))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyps1-unify-subst-lst
    (unify-subst-lst rune
      target
      hyps
      backchain-limit-lst
      unify-subst
      bkptr
      unify-subst0
      ttree0
      allp
      rw-cache-alist
      rw-cache-alist-new
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">7</span>
      (signed-byte <span class="number">61</span>)
      (let ((new-unify-subst (<a class="sym-link local-def" href="#def-extend-unify-subst" data-sym="EXTEND-UNIFY-SUBST" title="(defun extend-unify-subst (alist unify-subst)
  (append (pairlis$ (strip-cars alist) (quote-normal-form (strip-cdrs alist)))
          unify-subst))">extend-unify-subst</a> (car unify-subst-lst) unify-subst)))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cached-failure-reason-free cached-failure-reason)
          (<a class="sym-link local-def" href="#def-rw-cached-failure-pair" data-sym="RW-CACHED-FAILURE-PAIR" title="(defun rw-cached-failure-pair (unify-subst rw-cache-alist)
  (let* ((cached-failure-reason-raw
          (and rw-cache-alist (cdr (assoc-equal unify-subst rw-cache-alist))))
         (cached-failure-reason-free-p
          (and (consp cached-failure-reason-raw)
...">rw-cached-failure-pair</a> new-unify-subst rw-cache-alist)
          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason
              unify-subst1
              ttree1
              allp
              inferior-rw-cache-alist-new)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (cached-failure-reason (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                  nil
                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                    (cons 'cached cached-failure-reason))
                  unify-subst
                  ttree
                  allp
                  nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                    target
                    (cdr hyps)
                    (cdr backchain-limit-lst)
                    new-unify-subst
                    (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                    unify-subst0
                    ttree0
                    allp
                    (cdr cached-failure-reason-free)
                    nil)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil)))
            (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-extend-rw-cache-alist-free" data-sym="EXTEND-RW-CACHE-ALIST-FREE" title="(defun extend-rw-cache-alist-free
       (rcnst new-unify-subst inferior-rw-cache-alist-new rw-cache-alist-new)
  (cond
   ((and inferior-rw-cache-alist-new (rw-cache-active-p rcnst))
    (put-assoc-equal new-unify-subst
...">extend-rw-cache-alist-free</a> rcnst
                   new-unify-subst
                   inferior-rw-cache-alist-new
                   rw-cache-alist-new)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    relieve-hyps-ans
                    nil
                    unify-subst1
                    ttree1
                    allp
                    rw-cache-alist-new))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-rw-cache-add-failure-reason" data-sym="RW-CACHE-ADD-FAILURE-REASON" title="(defun rw-cache-add-failure-reason
       (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (cond
   ((and (rw-cache-active-p rcnst) failure-reason
         (rw-cacheable-failure-reason failure-reason))
...">rw-cache-add-failure-reason</a> rcnst
                         new-unify-subst
                         failure-reason
                         rw-cache-alist-new)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> (cdr unify-subst-lst)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          nil
                          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons new-unify-subst failure-reason)))
                          unify-subst0
                          (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree0)
                          nil
                          rw-cache-alist-new))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry-extending-failure" data-sym="REWRITE-ENTRY-EXTENDING-FAILURE" title="(defmacro rewrite-entry-extending-failure
          (unify-subst failure-reason form &amp;rest args)
  `(mv-let
    (step-limitxx relieve-hyps-ansxx failure-reason-lstxx unify-substxx ttreexx
     allpxx rw-cache-alist-newxx)
...">rewrite-entry-extending-failure</a> new-unify-subst
                          failure-reason
                          (relieve-hyps1-unify-subst-lst (cdr unify-subst-lst)
                            rune
                            target
                            hyps
                            backchain-limit-lst
                            unify-subst
                            bkptr
                            unify-subst0
                            ttree0
                            allp
                            rw-cache-alist
                            rw-cache-alist-new)
                          <span class="keyword">:obj</span> nil
                          <span class="keyword">:geneqv</span> nil
                          <span class="keyword">:pequiv-info</span> nil
                          <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree0)))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyps1
    (rune target
      hyps
      backchain-limit-lst
      unify-subst
      bkptr
      unify-subst0
      ttree0
      allp
      rw-cache-alist
      rw-cache-alist-new
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">7</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyps) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
            nil
            unify-subst
            ttree
            allp
            rw-cache-alist-new))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyp-ans failure-reason
              new-unify-subst
              new-ttree
              allp)
            (with-accumulated-persistence rune
              ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) relieve-hyp-ans
                failure-reason
                new-unify-subst
                new-ttree
                allp)
              relieve-hyp-ans
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyp rune target (car hyps) unify-subst bkptr allp)
                <span class="keyword">:backchain-limit</span> (new-backchain-limit (car backchain-limit-lst)
                  <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                  ancestors)
                <span class="keyword">:obj</span> nil
                <span class="keyword">:geneqv</span> nil
                <span class="keyword">:pequiv-info</span> nil)
              bkptr)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> relieve-hyp-ans <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                    target
                    (cdr hyps)
                    (cdr backchain-limit-lst)
                    new-unify-subst
                    (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                    unify-subst0
                    ttree0
                    allp
                    rw-cache-alist
                    rw-cache-alist-new)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> new-ttree))
              ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> relieve-hyp-ans <span class="keyword">:unify-subst-list</span>) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason-lst
                    unify-subst
                    ttree
                    allp
                    rw-cache-alist-new)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1-unify-subst-lst new-unify-subst
                      rune
                      target
                      hyps
                      backchain-limit-lst
                      unify-subst
                      bkptr
                      unify-subst0
                      ttree0
                      (<a class="sym-link local-def" href="#def-activate-memo" data-sym="ACTIVATE-MEMO" title="(defabbrev activate-memo (memo)
           (if (eq memo t)
               :start
               memo))">activate-memo</a> allp)
                      rw-cache-alist
                      rw-cache-alist-new)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil)
                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    relieve-hyps-ans
                    (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> relieve-hyps-ans)
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)) nil)
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> bkptr 'free-vars (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> failure-reason-lst)))))
                    unify-subst
                    ttree
                    allp
                    rw-cache-alist-new)))
              (relieve-hyp-ans (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((hyp (car hyps)) (forcep1 (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> hyp)
                        (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) '<a class="sym-link system" href="axioms.html#def-force" data-sym="FORCE">force</a>)
                          (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp) '<a class="sym-link system" href="axioms.html#def-case-split" data-sym="CASE-SPLIT">case-split</a>))))
                    (forcer-fn (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep1 (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> hyp)))
                    (hyp (if forcep1
                        (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> hyp <span class="number">1</span>)
                        (car hyps)))
                    (force-flg (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst))
                    (forcep (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> forcep1 force-flg)))
                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason-lst
                      unify-subst
                      ttree
                      allp
                      rw-cache-alist-new)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1-free-1 relieve-hyp-ans
                        failure-reason
                        hyp
                        type-alist
                        forcer-fn
                        forcep
                        force-flg
                        rune
                        target
                        hyps
                        backchain-limit-lst
                        unify-subst
                        bkptr
                        unify-subst0
                        ttree0
                        (<a class="sym-link local-def" href="#def-activate-memo" data-sym="ACTIVATE-MEMO" title="(defabbrev activate-memo (memo)
           (if (eq memo t)
               :start
               memo))">activate-memo</a> allp)
                        rw-cache-alist
                        rw-cache-alist-new)
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                      relieve-hyps-ans
                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> relieve-hyps-ans)
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)) nil)
                          (failure-reason-lst (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> bkptr 'free-vars failure-reason-lst))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> bkptr
                              'free-vars
                              'hyp-vars
                              (<a class="sym-link system" href="axioms.html#def-reverse" data-sym="REVERSE">reverse</a> (set-difference-assoc-eq (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> hyp) unify-subst))))))
                      unify-subst
                      ttree
                      allp
                      rw-cache-alist-new))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                  nil
                  (cons bkptr failure-reason)
                  unify-subst0
                  (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> new-ttree ttree0)
                  allp
                  rw-cache-alist-new))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyps1-free-1
    (term typ
      hyp
      rest-type-alist
      forcer-fn
      forcep
      force-flg
      rune
      target
      hyps
      backchain-limit-lst
      unify-subst
      bkptr
      unify-subst0
      ttree0
      allp
      rw-cache-alist
      rw-cache-alist-new
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">7</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (ans new-unify-subst new-ttree new-rest-type-alist)
        (<a class="sym-link local-def" href="#def-search-type-alist_2B" data-sym="SEARCH-TYPE-ALIST+" title="(defun search-type-alist+ (term typ type-alist unify-subst ttree wrld)
  (mv-let (term alt-term)
          (cond
           ((or (variablep term) (fquotep term)
                (not (equivalence-relationp (ffn-symb term) wrld)))
...">search-type-alist+</a> term
          typ
          rest-type-alist
          unify-subst
          ttree
          wrld)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (ans (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cached-failure-reason-free cached-failure-reason)
              (<a class="sym-link local-def" href="#def-rw-cached-failure-pair" data-sym="RW-CACHED-FAILURE-PAIR" title="(defun rw-cached-failure-pair (unify-subst rw-cache-alist)
  (let* ((cached-failure-reason-raw
          (and rw-cache-alist (cdr (assoc-equal unify-subst rw-cache-alist))))
         (cached-failure-reason-free-p
          (and (consp cached-failure-reason-raw)
...">rw-cached-failure-pair</a> new-unify-subst rw-cache-alist)
              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason
                  unify-subst1
                  ttree1
                  allp
                  inferior-rw-cache-alist-new)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (cached-failure-reason (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                      nil
                      (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                        (cons 'cached cached-failure-reason))
                      unify-subst
                      ttree
                      allp
                      nil))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                        target
                        (cdr hyps)
                        (cdr backchain-limit-lst)
                        new-unify-subst
                        (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                        unify-subst0
                        ttree0
                        allp
                        (cdr cached-failure-reason-free)
                        nil)
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:ttree</span> new-ttree)))
                (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-extend-rw-cache-alist-free" data-sym="EXTEND-RW-CACHE-ALIST-FREE" title="(defun extend-rw-cache-alist-free
       (rcnst new-unify-subst inferior-rw-cache-alist-new rw-cache-alist-new)
  (cond
   ((and inferior-rw-cache-alist-new (rw-cache-active-p rcnst))
    (put-assoc-equal new-unify-subst
...">extend-rw-cache-alist-free</a> rcnst
                       new-unify-subst
                       inferior-rw-cache-alist-new
                       rw-cache-alist-new)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                        relieve-hyps-ans
                        nil
                        unify-subst1
                        ttree1
                        allp
                        rw-cache-alist-new))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-rw-cache-add-failure-reason" data-sym="RW-CACHE-ADD-FAILURE-REASON" title="(defun rw-cache-add-failure-reason
       (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (cond
   ((and (rw-cache-active-p rcnst) failure-reason
         (rw-cacheable-failure-reason failure-reason))
...">rw-cache-add-failure-reason</a> rcnst
                             new-unify-subst
                             failure-reason
                             rw-cache-alist-new)))
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> allp) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                              nil
                              (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                                (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons new-unify-subst failure-reason)))
                              unify-subst0
                              (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree0)
                              nil
                              rw-cache-alist-new))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry-extending-failure" data-sym="REWRITE-ENTRY-EXTENDING-FAILURE" title="(defmacro rewrite-entry-extending-failure
          (unify-subst failure-reason form &amp;rest args)
  `(mv-let
    (step-limitxx relieve-hyps-ansxx failure-reason-lstxx unify-substxx ttreexx
     allpxx rw-cache-alist-newxx)
...">rewrite-entry-extending-failure</a> new-unify-subst
                              failure-reason
                              (relieve-hyps1-free-1 term
                                typ
                                hyp
                                new-rest-type-alist
                                forcer-fn
                                forcep
                                force-flg
                                rune
                                target
                                hyps
                                backchain-limit-lst
                                unify-subst
                                bkptr
                                unify-subst0
                                ttree0
                                allp
                                rw-cache-alist
                                rw-cache-alist-new)
                              <span class="keyword">:obj</span> nil
                              <span class="keyword">:geneqv</span> nil
                              <span class="keyword">:pequiv-info</span> nil
                              <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)))))))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1-free-2 hyp
                (<a class="sym-link local-def" href="#def-relevant-ground-lemmas" data-sym="RELEVANT-GROUND-LEMMAS" title="(defun relevant-ground-lemmas (hyp wrld)
  (mv-let (not-flg hyp) (strip-not hyp) (declare (ignore not-flg))
          (cond ((variablep hyp) nil) ((fquotep hyp) nil)
                ((flambda-applicationp hyp) nil)
                (t (getpropc (ffn-symb hyp) &#39;lemmas nil wrld)))))">relevant-ground-lemmas</a> hyp wrld)
                forcer-fn
                forcep
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                force-flg
                rune
                target
                hyps
                backchain-limit-lst
                unify-subst
                bkptr
                unify-subst0
                ttree0
                allp
                rw-cache-alist
                rw-cache-alist-new)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyps1-free-2
    (hyp lemmas
      forcer-fn
      forcep
      ens
      force-flg
      rune
      target
      hyps
      backchain-limit-lst
      unify-subst
      bkptr
      unify-subst0
      ttree0
      allp
      rw-cache-alist
      rw-cache-alist-new
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">7</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-endp" data-sym="ENDP">endp</a> lemmas) (let ((fully-bound-unify-subst (if force-flg
                 (bind-free-vars-to-unbound-free-vars (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> hyp)
                   unify-subst)
                 unify-subst)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (force-flg ttree)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> forcep) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil ttree))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (force-assumption rune
                    target
                    (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> fully-bound-unify-subst hyp)
                    type-alist
                    nil
                    (immediate-forcep forcer-fn
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                    force-flg
                    ttree)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (force-flg (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cached-failure-reason-free cached-failure-reason)
                    (<a class="sym-link local-def" href="#def-rw-cached-failure-pair" data-sym="RW-CACHED-FAILURE-PAIR" title="(defun rw-cached-failure-pair (unify-subst rw-cache-alist)
  (let* ((cached-failure-reason-raw
          (and rw-cache-alist (cdr (assoc-equal unify-subst rw-cache-alist))))
         (cached-failure-reason-free-p
          (and (consp cached-failure-reason-raw)
...">rw-cached-failure-pair</a> fully-bound-unify-subst
                      rw-cache-alist)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (cached-failure-reason (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          nil
                          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons fully-bound-unify-subst
                                (cons 'cached cached-failure-reason))))
                          unify-subst0
                          (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree ttree0)
                          allp
                          rw-cache-alist-new))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason
                            unify-subst1
                            ttree1
                            allp
                            inferior-rw-cache-alist-new)
                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                              target
                              (cdr hyps)
                              (cdr backchain-limit-lst)
                              fully-bound-unify-subst
                              (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                              unify-subst0
                              ttree0
                              allp
                              (cdr cached-failure-reason-free)
                              nil)
                            <span class="keyword">:obj</span> nil
                            <span class="keyword">:geneqv</span> nil
                            <span class="keyword">:pequiv-info</span> nil)
                          (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-extend-rw-cache-alist-free" data-sym="EXTEND-RW-CACHE-ALIST-FREE" title="(defun extend-rw-cache-alist-free
       (rcnst new-unify-subst inferior-rw-cache-alist-new rw-cache-alist-new)
  (cond
   ((and inferior-rw-cache-alist-new (rw-cache-active-p rcnst))
    (put-assoc-equal new-unify-subst
...">extend-rw-cache-alist-free</a> rcnst
                                 fully-bound-unify-subst
                                 inferior-rw-cache-alist-new
                                 rw-cache-alist-new)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  relieve-hyps-ans
                                  nil
                                  unify-subst1
                                  ttree1
                                  allp
                                  rw-cache-alist-new))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  nil
                                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                                    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons fully-bound-unify-subst failure-reason)))
                                  unify-subst0
                                  (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree0)
                                  allp
                                  (<a class="sym-link local-def" href="#def-rw-cache-add-failure-reason" data-sym="RW-CACHE-ADD-FAILURE-REASON" title="(defun rw-cache-add-failure-reason
       (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (cond
   ((and (rw-cache-active-p rcnst) failure-reason
         (rw-cacheable-failure-reason failure-reason))
...">rw-cache-add-failure-reason</a> rcnst
                                    fully-bound-unify-subst
                                    failure-reason
                                    rw-cache-alist-new))))))))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    nil
                    nil
                    unify-subst0
                    (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree ttree0)
                    allp
                    rw-cache-alist-new))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (winp new-unify-subst new-ttree rest-lemmas)
            (<a class="sym-link local-def" href="#def-search-ground-units1" data-sym="SEARCH-GROUND-UNITS1" title="(defun search-ground-units1
       (hyp unify-subst lemmas type-alist ens force-flg wrld ttree)
  (cond ((null lemmas) (mv nil unify-subst ttree nil))
        ((and (enabled-numep (access rewrite-rule (car lemmas) :nume) ens)
              (not (eq (access rewrite-rule (car lemmas) :subclass) &#39;meta))
...">search-ground-units1</a> hyp
              unify-subst
              lemmas
              type-alist
              ens
              force-flg
              wrld
              ttree)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (winp (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (cached-failure-reason-free cached-failure-reason)
                  (<a class="sym-link local-def" href="#def-rw-cached-failure-pair" data-sym="RW-CACHED-FAILURE-PAIR" title="(defun rw-cached-failure-pair (unify-subst rw-cache-alist)
  (let* ((cached-failure-reason-raw
          (and rw-cache-alist (cdr (assoc-equal unify-subst rw-cache-alist))))
         (cached-failure-reason-free-p
          (and (consp cached-failure-reason-raw)
...">rw-cached-failure-pair</a> new-unify-subst rw-cache-alist)
                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason
                      unify-subst1
                      ttree1
                      allp
                      inferior-rw-cache-alist-new)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (cached-failure-reason (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          nil
                          (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                            (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons new-unify-subst (cons 'cached cached-failure-reason))))
                          unify-subst
                          ttree
                          allp
                          nil))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                            target
                            (cdr hyps)
                            (cdr backchain-limit-lst)
                            new-unify-subst
                            (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> bkptr)
                            unify-subst0
                            ttree0
                            allp
                            (cdr cached-failure-reason-free)
                            nil)
                          <span class="keyword">:obj</span> nil
                          <span class="keyword">:geneqv</span> nil
                          <span class="keyword">:pequiv-info</span> nil
                          <span class="keyword">:ttree</span> new-ttree)))
                    (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-extend-rw-cache-alist-free" data-sym="EXTEND-RW-CACHE-ALIST-FREE" title="(defun extend-rw-cache-alist-free
       (rcnst new-unify-subst inferior-rw-cache-alist-new rw-cache-alist-new)
  (cond
   ((and inferior-rw-cache-alist-new (rw-cache-active-p rcnst))
    (put-assoc-equal new-unify-subst
...">extend-rw-cache-alist-free</a> rcnst
                           new-unify-subst
                           inferior-rw-cache-alist-new
                           rw-cache-alist-new)))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                            relieve-hyps-ans
                            nil
                            unify-subst1
                            ttree1
                            allp
                            rw-cache-alist-new))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((rw-cache-alist-new (<a class="sym-link local-def" href="#def-rw-cache-add-failure-reason" data-sym="RW-CACHE-ADD-FAILURE-REASON" title="(defun rw-cache-add-failure-reason
       (rcnst new-unify-subst failure-reason rw-cache-alist-new)
  (cond
   ((and (rw-cache-active-p rcnst) failure-reason
         (rw-cacheable-failure-reason failure-reason))
...">rw-cache-add-failure-reason</a> rcnst
                                 new-unify-subst
                                 failure-reason
                                 rw-cache-alist-new)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> allp) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  nil
                                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                                    (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons new-unify-subst failure-reason)))
                                  unify-subst0
                                  (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree0)
                                  nil
                                  rw-cache-alist-new))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry-extending-failure" data-sym="REWRITE-ENTRY-EXTENDING-FAILURE" title="(defmacro rewrite-entry-extending-failure
          (unify-subst failure-reason form &amp;rest args)
  `(mv-let
    (step-limitxx relieve-hyps-ansxx failure-reason-lstxx unify-substxx ttreexx
     allpxx rw-cache-alist-newxx)
...">rewrite-entry-extending-failure</a> new-unify-subst
                                  failure-reason
                                  (relieve-hyps1-free-2 hyp
                                    rest-lemmas
                                    forcer-fn
                                    forcep
                                    ens
                                    force-flg
                                    rune
                                    target
                                    hyps
                                    backchain-limit-lst
                                    unify-subst
                                    bkptr
                                    unify-subst0
                                    ttree0
                                    allp
                                    rw-cache-alist
                                    rw-cache-alist-new)
                                  <span class="keyword">:obj</span> nil
                                  <span class="keyword">:geneqv</span> nil
                                  <span class="keyword">:pequiv-info</span> nil
                                  <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)))))))))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1-free-2 hyp
                    nil
                    forcer-fn
                    forcep
                    ens
                    force-flg
                    rune
                    target
                    hyps
                    backchain-limit-lst
                    unify-subst
                    bkptr
                    unify-subst0
                    ttree0
                    allp
                    rw-cache-alist
                    rw-cache-alist-new)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> relieve-hyps
    (rune target
      hyps
      backchain-limit-lst
      unify-subst
      allp
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">5</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyps) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst ttree))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((ttree-saved ttree) (<a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a> (<a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a> rcnst))
              (cached-failure-entry (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> <a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a>
                  (<a class="sym-link local-def" href="#def-relieve-hyp-failure-entry" data-sym="RELIEVE-HYP-FAILURE-ENTRY" title="(defun relieve-hyp-failure-entry (rune unify-subst hyps ttree step-limit)
  (let* ((cache (tagged-objects &#39;rw-cache-any-tag ttree))
         (entry
          (and cache
               (rw-cache-list-lookup unify-subst hyps
...">relieve-hyp-failure-entry</a> rune
                    unify-subst
                    hyps
                    ttree
                    step-limit)))
              (cached-failure-reason-raw (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cached-failure-entry
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry cached-failure-entry <span class="keyword">:failure-reason</span>)))
              (cached-failure-reason-free-p (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp cached-failure-reason-raw)
                  (<a class="sym-link local-def" href="#def-free-failure-p" data-sym="FREE-FAILURE-P" title="(defmacro free-failure-p (r) `(eq (car ,r) :rw-cache-alist))">free-failure-p</a> cached-failure-reason-raw)))
              (cached-failure-reason-free (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cached-failure-reason-free-p
                  (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rw-cache-entry cached-failure-entry <span class="keyword">:hyp-info</span>)
                    hyps)
                  cached-failure-reason-raw))
              (cached-failure-reason (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> cached-failure-reason-free-p)
                  cached-failure-reason-raw))
              (debug (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cached-failure-reason
                  (rw-cache-debug rune
                    target
                    unify-subst
                    cached-failure-reason
                    step-limit))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> cached-failure-reason (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> debug)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                  nil
                  (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-f-get-global" data-sym="F-GET-GLOBAL">f-get-global</a> 'gstackp state)
                    (cons 'cached cached-failure-reason))
                  unify-subst
                  ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((step-limit-saved step-limit) (unify-subst-saved unify-subst)
                    (old-rw-cache-alist (cdr cached-failure-reason-free)))
                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason
                      unify-subst
                      ttree
                      allp
                      new-rw-cache-alist)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps1 rune
                        target
                        hyps
                        backchain-limit-lst
                        unify-subst
                        <span class="number">1</span>
                        unify-subst
                        ttree
                        allp
                        old-rw-cache-alist
                        nil)
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:rcnst</span> (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:active-theory</span>)
                          <span class="keyword">:standard</span>)
                        rcnst
                        (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rewrite-constant rcnst <span class="keyword">:active-theory</span> <span class="keyword">:standard</span>)))
                    (declare (ignore allp))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> debug relieve-hyps-ans) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (rw-cache-debug-action rune
                            target
                            unify-subst-saved
                            cached-failure-reason
                            step-limit-saved)
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                            nil
                            cached-failure-reason
                            unify-subst-saved
                            ttree-saved)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                          relieve-hyps-ans
                          failure-reason
                          unify-subst
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> relieve-hyps-ans
                               <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> <a class="sym-link local-def" href="#def-rw-cache-active-p" data-sym="RW-CACHE-ACTIVE-P" title="(defmacro rw-cache-active-p (rcnst)
  `(member-eq (access rewrite-constant ,rcnst :rw-cache-state) &#39;(t :atom)))">rw-cache-active-p</a>)) ttree)
                            (new-rw-cache-alist (<a class="sym-link local-def" href="#def-note-relieve-hyps-failure-free" data-sym="NOTE-RELIEVE-HYPS-FAILURE-FREE" title="(defun note-relieve-hyps-failure-free
       (rune unify-subst hyps ttree old-entry old-rw-cache-alist
        new-rw-cache-alist step-limit)
  (assert$ new-rw-cache-alist
           (mv-let (flg alist)
...">note-relieve-hyps-failure-free</a> rune
                                unify-subst
                                hyps
                                ttree
                                cached-failure-entry
                                old-rw-cache-alist
                                new-rw-cache-alist
                                step-limit-saved))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-note-relieve-hyp-failure" data-sym="NOTE-RELIEVE-HYP-FAILURE" title="(defun note-relieve-hyp-failure
       (rune unify-subst failure-reason ttree hyps step-limit)
  (cond
   ((and failure-reason (rw-cacheable-failure-reason failure-reason))
    (let* ((hyp (nth (1- (car failure-reason)) hyps))
...">note-relieve-hyp-failure</a> rune
                                unify-subst
                                failure-reason
                                ttree
                                hyps
                                step-limit-saved)))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-with-lemma
    (term lemma
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (let ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> 'rewrite-with-lemma nil term lemma geneqv)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth)))
        (declare (type (unsigned-byte <span class="number">60</span>) rdepth))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-zero-depthp" data-sym="ZERO-DEPTHP" title="(defmacro zero-depthp (depth) `(eql (the-fixnum ,depth) 0))">zero-depthp</a> rdepth) (<a class="sym-link local-def" href="#def-rdepth-error" data-sym="RDEPTH-ERROR" title="(defmacro rdepth-error (form &amp;optional preprocess-p)
  (if preprocess-p
      (let ((ctx &#39;&#39;preprocess))
        `(prog2$
          (er-hard ,ctx &quot;Call depth&quot;
...">rdepth-error</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:subclass</span>) 'meta) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
                 geneqv
                 wrld) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((meta-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:lhs</span>)) (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>) 'extended) (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> term
                            (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> metafunction-context
                              <span class="keyword">:rdepth</span> rdepth
                              <span class="keyword">:type-alist</span> type-alist
                              <span class="keyword">:obj</span> obj
                              <span class="keyword">:geneqv</span> geneqv
                              <span class="keyword">:wrld</span> wrld
                              <span class="keyword">:fnstack</span> fnstack
                              <span class="keyword">:ancestors</span> ancestors
                              <span class="keyword">:backchain-limit</span> <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
                              <span class="keyword">:simplify-clause-pot-lst</span> simplify-clause-pot-lst
                              <span class="keyword">:rcnst</span> rcnst
                              <span class="keyword">:gstack</span> gstack
                              <span class="keyword">:ttree</span> ttree
                              <span class="keyword">:unify-subst</span> nil)
                            (<a class="sym-link system" href="axioms.html#def-coerce-state-to-object" data-sym="COERCE-STATE-TO-OBJECT">coerce-state-to-object</a> state)))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> term))))
                    (rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rune</span>)))
                  (with-accumulated-persistence rune
                    ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) flg term ttree)
                    flg
                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp val latches)
                      (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-ev-fncall-meta" data-sym="EV-FNCALL-META" title="(defun ev-fncall-meta (fn args state)
  (declare (xargs :guard (and (symbolp fn) (function-symbolp fn (w state)))))
  (let ()
    (cond
     ((eq (symbol-class fn (w state)) :common-lisp-compliant)
...">ev-fncall-meta</a> meta-fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> state))
                      (declare (ignore latches))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
                        ((equal term val) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((user-says-skip-termp-checkp (<a class="sym-link local-def" href="#def-skip-meta-termp-checks" data-sym="SKIP-META-TERMP-CHECKS" title="(defun skip-meta-termp-checks (fn wrld)
  (let ((val
         (cdr (assoc-eq t (table-alist &#39;skip-meta-termp-checks-table wrld)))))
    (or (eq val t) (and val (member-eq fn val)))))">skip-meta-termp-checks</a> meta-fn wrld)) (well-formedness-guarantee (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:heuristic-info</span>))
                              (not-skipped (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> user-says-skip-termp-checkp)
                                  (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> well-formedness-guarantee)))
                              (bad-arity-info (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> well-formedness-guarantee
                                    (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> user-says-skip-termp-checkp))
                                  (<a class="sym-link local-def" href="#def-collect-bad-fn-arity-info" data-sym="COLLECT-BAD-FN-ARITY-INFO" title="(defun collect-bad-fn-arity-info (alist wrld bad-arity-alist non-logic-fns)
  (cond
   ((endp alist)
    (if (or bad-arity-alist non-logic-fns)
        (cons (reverse bad-arity-alist) non-logic-fns)
...">collect-bad-fn-arity-info</a> (cdr well-formedness-guarantee)
                                    wrld
                                    nil
                                    nil)
                                  nil)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bad-arity-info (let ((name (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">0</span> (car well-formedness-guarantee))) (fn (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">1</span> (car well-formedness-guarantee)))
                                    (thm-name1 (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">2</span> (car well-formedness-guarantee)))
                                    (hyp-fn (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">3</span> (car well-formedness-guarantee)))
                                    (thm-name2 (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">4</span> (car well-formedness-guarantee))))
                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                    (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                      'rewrite-with-lemma
                                      <span class="string">"~@0"</span>
                                      (<a class="sym-link local-def" href="#def-bad-arities-msg" data-sym="BAD-ARITIES-MSG" title="(defun bad-arities-msg
       (name token fn hyp-fn wf-thm-name1 wf-thm-name2 bad-arity-info)
  (msg
   &quot;The ~s0 ~x1 has a now-invalid well-formedness guarantee.  Its ~s2, ~x3, ~
    ~#4~[was proved in ~x7 to return a ~x6~/and its corresponding hypothesis ~
...">bad-arities-msg</a> name
                                        <span class="keyword">:meta</span> fn
                                        hyp-fn
                                        thm-name1
                                        thm-name2
                                        bad-arity-info))
                                    term
                                    ttree)))
                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (termp val wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                    'rewrite-with-lemma
                                    <span class="string">"The metafunction ~x0 produced the non-termp ~
                                 ~x1 on the input term ~x2. The proof of the ~
                                 correctness of ~x0 establishes that the ~
                                 quotations of these two s-expressions have ~
                                 the same value, but our implementation ~
                                 additionally requires that ~x0 produce a ~
                                 term.  See :DOC termp.  You might consider ~
                                 proving a well-formedness guarantee to avoid ~
                                 this runtime test altogether.  See :DOC ~
                                 well-formedness-guarantee."</span>
                                    meta-fn
                                    val
                                    term)
                                  term
                                  ttree))
                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (logic-termp val wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                    'rewrite-with-lemma
                                    <span class="string">"The metafunction ~x0 produced the termp ~x1 ~
                                 on the input term ~x2.  The proof of the ~
                                 correctness of ~x0 establishes that the ~
                                 quotations of these two s-expressions have ~
                                 the same value, but our implementation ~
                                 additionally requires that ~x0 produce a ~
                                 term with no :program mode function symbols. ~
                                 ~ The term produced has :program mode ~
                                 function symbol~#3~[~/s~] ~&amp;3.  You might ~
                                 consider proving a well-formedness guarantee ~
                                 to avoid this runtime test altogether.  See ~
                                 :DOC well-formedness-guarantee."</span>
                                    meta-fn
                                    val
                                    term
                                    (collect-programs (<a class="sym-link local-def" href="#def-all-ffn-symbs" data-sym="ALL-FFN-SYMBS" title="(defmacro all-ffn-symbs (term ans) `(all-fnnames1 nil ,term ,ans))">all-ffn-symbs</a> val nil) wrld))
                                  term
                                  ttree))
                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped
                                 (<a class="sym-link local-def" href="#def-forbidden-fns-in-term" data-sym="FORBIDDEN-FNS-IN-TERM" title="(defun forbidden-fns-in-term (term forbidden-fns)
  (intersection-eq (all-fnnames term) forbidden-fns))">forbidden-fns-in-term</a> val
                                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:forbidden-fns</span>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                    'rewrite-with-lemma
                                    <span class="string">"The metafunction ~x0 produced the termp ~x1 ~
                                 on the input term ~x2.  The proof of the ~
                                 correctness of ~x0 establishes that the ~
                                 quotations of these two s-expressions have ~
                                 the same value, but our implementation ~
                                 additionally requires that certain forbidden ~
                                 function symbols not be called.  However, ~
                                 the forbidden function symbol~#3~[ ~&amp;3 is~/s ~
                                 ~&amp;3 are~] called in the term produced by ~
                                 ~x0.  See :DOC meta and :DOC ~
                                 set-skip-meta-termp-checks and :DOC ~
                                 well-formedness-guarantee."</span>
                                    meta-fn
                                    val
                                    term
                                    (<a class="sym-link local-def" href="#def-forbidden-fns-in-term" data-sym="FORBIDDEN-FNS-IN-TERM" title="(defun forbidden-fns-in-term (term forbidden-fns)
  (intersection-eq (all-fnnames term) forbidden-fns))">forbidden-fns-in-term</a> val
                                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:forbidden-fns</span>)))
                                  term
                                  ttree))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (extra-evaled-hyp val)
                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="basis-b.html#def-ffn-symb-p" data-sym="FFN-SYMB-P">ffn-symb-p</a> val 'if) (equal (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> val <span class="number">3</span>) term)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> val <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> val <span class="number">2</span>)))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> val)))
                                  (let ((hyp-fn (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>)))
                                    (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp evaled-hyp latches)
                                      (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> hyp-fn nil)
                                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a> nil)
                                        (<a class="sym-link system" href="basis-b.html#def-pstk" data-sym="PSTK">pstk</a> (<a class="sym-link local-def" href="#def-ev-fncall-meta" data-sym="EV-FNCALL-META" title="(defun ev-fncall-meta (fn args state)
  (declare (xargs :guard (and (symbolp fn) (function-symbolp fn (w state)))))
  (let ()
    (cond
     ((eq (symbol-class fn (w state)) :common-lisp-compliant)
...">ev-fncall-meta</a> hyp-fn <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> state)))
                                      (declare (ignore latches))
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((user-says-skip-termp-checkp (<a class="sym-link local-def" href="#def-skip-meta-termp-checks" data-sym="SKIP-META-TERMP-CHECKS" title="(defun skip-meta-termp-checks (fn wrld)
  (let ((val
         (cdr (assoc-eq t (table-alist &#39;skip-meta-termp-checks-table wrld)))))
    (or (eq val t) (and val (member-eq fn val)))))">skip-meta-termp-checks</a> hyp-fn wrld)) (not-skipped (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> user-says-skip-termp-checkp)
                                                  (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> well-formedness-guarantee)))
                                              (bad-arity-info (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> well-formedness-guarantee
                                                    (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> user-says-skip-termp-checkp))
                                                  (<a class="sym-link local-def" href="#def-collect-bad-fn-arity-info" data-sym="COLLECT-BAD-FN-ARITY-INFO" title="(defun collect-bad-fn-arity-info (alist wrld bad-arity-alist non-logic-fns)
  (cond
   ((endp alist)
    (if (or bad-arity-alist non-logic-fns)
        (cons (reverse bad-arity-alist) non-logic-fns)
...">collect-bad-fn-arity-info</a> (cdr well-formedness-guarantee)
                                                    wrld
                                                    nil
                                                    nil)
                                                  nil)))
                                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (bad-arity-info (let ((name (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">0</span> (car well-formedness-guarantee))) (hyp-fn (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">3</span> (car well-formedness-guarantee)))
                                                    (thm-name2 (<a class="sym-link system" href="axioms.html#def-nth" data-sym="NTH">nth</a> <span class="number">4</span> (car well-formedness-guarantee))))
                                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                    (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                      'rewrite-with-lemma
                                                      <span class="string">"~@0"</span>
                                                      (<a class="sym-link local-def" href="#def-bad-arities-msg" data-sym="BAD-ARITIES-MSG" title="(defun bad-arities-msg
       (name token fn hyp-fn wf-thm-name1 wf-thm-name2 bad-arity-info)
  (msg
   &quot;The ~s0 ~x1 has a now-invalid well-formedness guarantee.  Its ~s2, ~x3, ~
    ~#4~[was proved in ~x7 to return a ~x6~/and its corresponding hypothesis ~
...">bad-arities-msg</a> name
                                                        <span class="keyword">:meta</span> nil
                                                        hyp-fn
                                                        thm-name2
                                                        nil
                                                        bad-arity-info))
                                                    term
                                                    ttree)))
                                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (termp evaled-hyp wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                    'rewrite-with-lemma
                                                    <span class="string">"The hypothesis metafunction ~x0 ~
                                           produced the non-termp ~x1 on the ~
                                           input term ~x2.  Our ~
                                           implementation requires that ~x0 ~
                                           produce a term.  See :DOC termp.  ~
                                           You might consider proving a ~
                                           well-formedness guarantee.  See ~
                                           :DOC well-formedness-guarantee to ~
                                           avoid this runtime check ~
                                           altogether.  See :DOC ~
                                           well-formedness-guarantee."</span>
                                                    hyp-fn
                                                    evaled-hyp
                                                    term)
                                                  term
                                                  ttree))
                                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (logic-termp evaled-hyp wrld))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                    'rewrite-with-lemma
                                                    <span class="string">"The hypothesis metafunction ~x0 ~
                                           produced the termp ~x1 on the ~
                                           input term ~x2.  The proof of the ~
                                           correctness of ~x0 establishes ~
                                           that the quotations of these two ~
                                           s-expressions have the same value, ~
                                           but our implementation ~
                                           additionally requires that ~x0 ~
                                           produce a term with no :program ~
                                           mode function symbols.  The term ~
                                           produced has :program mode ~
                                           function symbol~#3~[~/s~] ~&amp;3.  ~
                                           You might consider proving a ~
                                           well-formedness guarantee to avoid ~
                                           this runtime test altogether.  See ~
                                           :DOC well-formedness-guarantee."</span>
                                                    hyp-fn
                                                    evaled-hyp
                                                    term
                                                    (collect-programs (<a class="sym-link local-def" href="#def-all-ffn-symbs" data-sym="ALL-FFN-SYMBS" title="(defmacro all-ffn-symbs (term ans) `(all-fnnames1 nil ,term ,ans))">all-ffn-symbs</a> evaled-hyp nil) wrld))
                                                  term
                                                  ttree))
                                              ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> not-skipped
                                                 (<a class="sym-link local-def" href="#def-forbidden-fns-in-term" data-sym="FORBIDDEN-FNS-IN-TERM" title="(defun forbidden-fns-in-term (term forbidden-fns)
  (intersection-eq (all-fnnames term) forbidden-fns))">forbidden-fns-in-term</a> evaled-hyp
                                                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:forbidden-fns</span>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                  (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                    'rewrite-with-lemma
                                                    <span class="string">"The hypothesis metafunction ~x0 ~
                                           produced the termp ~x1 on the ~
                                           input term ~x2.  Our ~
                                           implementation additionally ~
                                           requires that certain forbidden ~
                                           function symbols not be called.  ~
                                           However, the forbidden function ~
                                           symbol~#3~[ ~&amp;3 is~/s ~&amp;3 are~] ~
                                           called in the term produced by ~
                                           ~x0.  See :DOC meta and :DOC ~
                                           set-skip-meta-termp-checks and ~
                                           :DOC well-formedness-guarantee."</span>
                                                    hyp-fn
                                                    evaled-hyp
                                                    term
                                                    (<a class="sym-link local-def" href="#def-forbidden-fns-in-term" data-sym="FORBIDDEN-FNS-IN-TERM" title="(defun forbidden-fns-in-term (term forbidden-fns)
  (intersection-eq (all-fnnames term) forbidden-fns))">forbidden-fns-in-term</a> evaled-hyp
                                                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:forbidden-fns</span>)))
                                                  term
                                                  ttree))
                                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((hyps0 (flatten-ands-in-lit (quote-normal-form evaled-hyp))) (extra-hyps (flatten-ands-in-lit (quote-normal-form extra-evaled-hyp)))
                                                    (hyps (<a class="sym-link system" href="axioms.html#def-append_3F" data-sym="APPEND?">append?</a> hyps0 extra-hyps))
                                                    (vars (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyps (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> term)))
                                                    (rule-backchain-limit (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:backchain-limit-lst</span>))
                                                    (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyps0 (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> hyps0 vars nil wrld)))
                                                    (bad-synp-hyp-msg-extra (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> extra-hyps (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> extra-hyps vars nil wrld))))
                                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (<a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                        (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                          'rewrite-with-lemma
                                                          <span class="string">"The hypothesis metafunction ~
                                               ~x0, when applied to the input ~
                                               term ~x1, produced a term ~
                                               whose use of synp is illegal ~
                                               because ~@2"</span>
                                                          hyp-fn
                                                          term
                                                          <a class="sym-link local-def" href="#def-bad-synp-hyp-msg" data-sym="BAD-SYNP-HYP-MSG" title="(defun bad-synp-hyp-msg (hyps bound-vars all-vars-bound-p wrld)
  (if (null hyps)
      nil
      (mv-let (bad-synp-hyp-msg bound-vars all-vars-bound-p)
              (bad-synp-hyp-msg1 (car hyps) bound-vars all-vars-bound-p wrld)
...">bad-synp-hyp-msg</a>)
                                                        term
                                                        ttree))
                                                    (bad-synp-hyp-msg-extra (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                        (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                                                          'rewrite-with-lemma
                                                          <span class="string">"The metafunction ~x0, when ~
                                               applied to the input term ~x1, ~
                                               produced a term with an ~
                                               implicit hypothesis (see :DOC ~
                                               meta-implicit-hypothesis), ~
                                               whose use of synp is illegal ~
                                               because ~@2"</span>
                                                          meta-fn
                                                          term
                                                          bad-synp-hyp-msg-extra)
                                                        term
                                                        ttree))
                                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason unify-subst ttree)
                                                        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps rune
                                                            term
                                                            hyps
                                                            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rule-backchain-limit
                                                              (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-natp" data-sym="NATP">natp</a> rule-backchain-limit)
                                                                (<a class="sym-link system" href="axioms.html#def-make-list" data-sym="MAKE-LIST">make-list</a> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> hyps)
                                                                  <span class="keyword">:initial-element</span> rule-backchain-limit)))
                                                            (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyps (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> vars vars))
                                                            nil)
                                                          <span class="keyword">:obj</span> nil
                                                          <span class="keyword">:geneqv</span> nil
                                                          <span class="keyword">:pequiv-info</span> nil)
                                                        (declare (ignore failure-reason))
                                                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-rhs ttree)
                                                              (with-accumulated-persistence rune
                                                                ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) rewritten-rhs ttree)
                                                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (quote-normal-form val) unify-subst 'meta))
                                                                <span class="keyword">:conc</span> hyps)
                                                              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                                rewritten-rhs
                                                                (push-lemma (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
                                                                    geneqv
                                                                    wrld)
                                                                  (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune ttree rcnst ancestors val rewritten-rhs)))))
                                                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))))))))))))))))))))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))
          ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
               geneqv
               wrld)) (<a class="sym-link system" href="axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> (<a class="sym-link local-def" href="#def-refinement-failure-brkpt1" data-sym="REFINEMENT-FAILURE-BRKPT1" title="(defun refinement-failure-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">refinement-failure-brkpt1</a> lemma
                term
                type-alist
                geneqv
                ancestors
                ttree
                gstack
                rcnst
                simplify-clause-pot-lst
                state)
              (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                'refinement-failure
                nil
                gstack
                nil
                nil
                rcnst
                ancestors
                state)
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))
          ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:subclass</span>) 'definition) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-term ttree)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-fncall lemma term))
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal term rewritten-term))
                rewritten-term
                ttree)))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>) <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>)))
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-being-openedp" data-sym="BEING-OPENEDP" title="(defmacro being-openedp (fn fnstack clique settled-down-p)
  (declare (xargs :guard (symbolp fnstack)))
  `(and ,fnstack
        (let ((clique ,clique))
          (and
...">being-openedp</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
                   fnstack
                   (recursivep (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> wrld)
                   (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:rewriter-state</span>)
                     'settled-down)))
               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (ffnnamep (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>))))) (let ((lhs (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:lhs</span>)) (rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rune</span>)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
                (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> lhs
                  term
                  (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> rune
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:restrictions-alist</span>))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unify-ans
                     (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-brkpt1" data-sym="BRKPT1" title="(defun brkpt1
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst simplify-clause-pot-lst state)
  (cond
   (t
...">brkpt1</a> lemma
                         term
                         unify-subst
                         type-alist
                         geneqv
                         ancestors
                         ttree
                         gstack
                         rcnst
                         simplify-clause-pot-lst
                         state))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-loop-stopperp" data-sym="LOOP-STOPPERP" title="(defun loop-stopperp (loop-stopper sbst wrld)
  (or (null loop-stopper) (loop-stopperp-rec loop-stopper sbst wrld)))">loop-stopperp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:heuristic-info</span>)
                           unify-subst
                           wrld)) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                            '<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>
                            unify-subst
                            gstack
                            nil
                            nil
                            rcnst
                            ancestors
                            state)
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (with-accumulated-persistence rune
                          ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) flg term ttree)
                          flg
                          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason unify-subst ttree)
                            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps rune
                                term
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>)
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:backchain-limit-lst</span>)
                                unify-subst
                                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-oncep" data-sym="ONCEP" title="(defun oncep (nume-runes match-free rune nume)
  (if (or (eq nume-runes :clear) (&lt;= (car nume-runes) nume))
      (eq match-free :once)
      (member-equal rune (cdr nume-runes))))">oncep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:oncep-override</span>)
                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:match-free</span>)
                                    rune
                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:nume</span>))))
                              <span class="keyword">:obj</span> nil
                              <span class="keyword">:geneqv</span> nil
                              <span class="keyword">:pequiv-info</span> nil)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-rhs ttree)
                                  (with-accumulated-persistence rune
                                    ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) rewritten-rhs ttree)
                                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>) unify-subst 'rhs))
                                    <span class="keyword">:conc</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>))
                                  (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                      nil
                                      unify-subst
                                      gstack
                                      rewritten-rhs
                                      ttree
                                      rcnst
                                      ancestors
                                      state)
                                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                      <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                      rewritten-rhs
                                      (push-lemma (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
                                          geneqv
                                          wrld)
                                        (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune
                                          ttree
                                          rcnst
                                          ancestors
                                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>)
                                          rewritten-rhs))))))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                    failure-reason
                                    unify-subst
                                    gstack
                                    nil
                                    nil
                                    rcnst
                                    ancestors
                                    state)
                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))))))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> (<a class="sym-link local-def" href="#def-near-miss-brkpt1" data-sym="NEAR-MISS-BRKPT1" title="(defun near-miss-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">near-miss-brkpt1</a> lemma
                        term
                        type-alist
                        geneqv
                        ancestors
                        ttree
                        gstack
                        rcnst
                        simplify-clause-pot-lst
                        state)
                      (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                        'near-miss
                        unify-subst
                        gstack
                        nil
                        nil
                        rcnst
                        ancestors
                        state)
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-with-lemmas1
    (term lemmas
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lemmas) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
        ((if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:active-theory</span>)
             <span class="keyword">:standard</span>)
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:nume</span>)
               (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)))
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (enabled-arith-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:nume</span>)
               (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'global-arithmetic-enabled-structure wrld)))) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas1 term (cdr lemmas))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp rewritten-term ttree)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemma term (car lemmas)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rewrittenp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> rewritten-term ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas1 term (cdr lemmas))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-fncall
    (rule term
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((fn (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)) (<a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> (<a class="sym-link system" href="axioms.html#def-fargs" data-sym="FARGS">fargs</a> term))
          (<a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> rule)
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a> fn)
                (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                  'rewrite-fncall
                  <span class="string">"We had thought that a lambda function symbol ~
                             always has a non-nil lambda-body, but the ~
                             following lambda does not: ~x0"</span>
                  fn))
              (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:rhs</span>)
                <span class="string">"We had thought that a rewrite-rule always has a non-nil ~
                      :rhs, but the following rewrite rule does not: ~x0"</span>)))
          (recursivep (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rule (car (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:heuristic-info</span>)))))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-flambdap" data-sym="FLAMBDAP">flambdap</a> fn))
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link local-def" href="#def-being-openedp" data-sym="BEING-OPENEDP" title="(defmacro being-openedp (fn fnstack clique settled-down-p)
  (declare (xargs :guard (symbolp fnstack)))
  `(and ,fnstack
        (let ((clique ,clique))
          (and
...">being-openedp</a> fn
                 fnstack
                 recursivep
                 (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:rewriter-state</span>)
                   'settled-down))
               (<a class="sym-link local-def" href="#def-fnstack-term-member" data-sym="FNSTACK-TERM-MEMBER" title="(defun fnstack-term-member (term fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (eq (caar fnstack) :term)
              (equal (cdar fnstack) term))
         t)">fnstack-term-member</a> term fnstack)
               (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> recursivep (<a class="sym-link system" href="axioms.html#def-member-eq" data-sym="MEMBER-EQ">member-eq</a> <span class="keyword">:rewrite-lambda-object</span> fnstack)))) (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
              (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                type-alist
                obj
                geneqv
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                wrld
                ttree
                simplify-clause-pot-lst
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
          ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> rule) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a> fnstack))
                 (too-many-ifs-pre-rewrite <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
                   (<a class="sym-link local-def" href="#def-var-counts" data-sym="VAR-COUNTS" title="(defun var-counts (lhs-args rhs)
  (declare (xargs :guard (and (true-listp lhs-args) (pseudo-termp rhs))))
  (cond ((endp lhs-args) nil)
        (t
         (cons (var-counts1 (car lhs-args) rhs 0)">var-counts</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> fn) <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>))) (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                  (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                    type-alist
                    obj
                    geneqv
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                    wrld
                    ttree
                    simplify-clause-pot-lst
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-body ttree1)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                      (<a class="sym-link system" href="axioms.html#def-pairlis_24" data-sym="PAIRLIS$">pairlis$</a> (<a class="sym-link system" href="basis-b.html#def-lambda-formals" data-sym="LAMBDA-FORMALS">lambda-formals</a> fn) <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>)
                      '<a class="sym-link system" href="basis-b.html#def-lambda-body" data-sym="LAMBDA-BODY">lambda-body</a>)
                    <span class="keyword">:fnstack</span> fnstack)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a> fnstack))
                       (too-many-ifs-post-rewrite <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> rewritten-body)) (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                        (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                          type-alist
                          obj
                          geneqv
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                          wrld
                          (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)
                          simplify-clause-pot-lst
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-body ttree1)))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((new-fnstack (cons (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> recursivep fn) fnstack)) (rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:rune</span>)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
                (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:lhs</span>)
                  term
                  (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> rune
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:restrictions-alist</span>))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unify-ans
                     (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-brkpt1" data-sym="BRKPT1" title="(defun brkpt1
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst simplify-clause-pot-lst state)
  (cond
   (t
...">brkpt1</a> rule
                         term
                         unify-subst
                         type-alist
                         geneqv
                         ancestors
                         ttree
                         gstack
                         rcnst
                         simplify-clause-pot-lst
                         state))) (with-accumulated-persistence (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:rune</span>)
                      ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) term-out ttree)
                      (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> term term-out))
                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> recursivep)
                           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a> fnstack))
                           (too-many-ifs-pre-rewrite <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a>
                             (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:var-info</span>))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                              'too-many-ifs-pre-rewrite
                              unify-subst
                              gstack
                              <span class="keyword">:rewritten-rhs-avoided</span> ttree
                              rcnst
                              ancestors
                              state)
                            (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                              (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                                type-alist
                                obj
                                geneqv
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                wrld
                                ttree
                                simplify-clause-pot-lst
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)))))
                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason unify-subst ttree1)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> fn (base-symbol rune))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil unify-subst ttree))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps rune
                                    term
                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:hyps</span>)
                                    nil
                                    unify-subst
                                    nil)
                                  <span class="keyword">:obj</span> nil
                                  <span class="keyword">:geneqv</span> nil
                                  <span class="keyword">:pequiv-info</span> nil)))
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (with-accumulated-persistence rune
                                  ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) term-out ttree)
                                  <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-body new-ttree1)
                                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> unify-subst '<a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>)
                                      <span class="keyword">:fnstack</span> new-fnstack
                                      <span class="keyword">:ttree</span> ttree1)
                                    (let ((ttree1 (<a class="sym-link local-def" href="#def-restore-rw-cache-any-tag" data-sym="RESTORE-RW-CACHE-ANY-TAG" title="(defun restore-rw-cache-any-tag (new-ttree old-ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-any-tag old-ttree)
                         (maybe-extend-tag-tree &#39;rw-cache-nil-tag
                                                (tagged-objects
...">restore-rw-cache-any-tag</a> new-ttree1 ttree1)))
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> recursivep) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-recursive-fn-on-fnstackp" data-sym="RECURSIVE-FN-ON-FNSTACKP" title="(defun recursive-fn-on-fnstackp (fnstack)
  (cond ((null fnstack) nil)
        ((and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t)
        (t (recursive-fn-on-fnstackp (cdr fnstack)))))">recursive-fn-on-fnstackp</a> fnstack))
                                               (too-many-ifs-post-rewrite <a class="sym-link system" href="defuns.html#def-args" data-sym="ARGS">args</a> rewritten-body)) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                                  'too-many-ifs-post-rewrite
                                                  unify-subst
                                                  gstack
                                                  rewritten-body
                                                  ttree1
                                                  rcnst
                                                  ancestors
                                                  state)
                                                (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                                                  (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                                                    type-alist
                                                    obj
                                                    geneqv
                                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                                    wrld
                                                    (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)
                                                    simplify-clause-pot-lst
                                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)))))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                  nil
                                                  unify-subst
                                                  gstack
                                                  rewritten-body
                                                  ttree1
                                                  rcnst
                                                  ancestors
                                                  state)
                                                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                  rewritten-body
                                                  (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune
                                                    ttree1
                                                    rcnst
                                                    ancestors
                                                    <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                                                    rewritten-body))))))
                                        ((<a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a> term
                                           rewritten-body
                                           (if (cdr recursivep)
                                             recursivep
                                             nil)
                                           (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:top-clause</span>)
                                           (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-clause</span>)
                                           (cdr (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:heuristic-info</span>))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-contains-rewritable-callp" data-sym="CONTAINS-REWRITABLE-CALLP" title="(mutual-recursion
 (defun contains-rewritable-callp
        (fn term cliquep terms-to-be-ignored-by-rewrite)
   (cond ((variablep term) nil) ((fquotep term) nil)
         ((flambda-applicationp term)
...">contains-rewritable-callp</a> fn
                                               rewritten-body
                                               (if (cdr recursivep)
                                                 recursivep
                                                 nil)
                                               (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant
                                                 rcnst
                                                 <span class="keyword">:terms-to-be-ignored-by-rewrite</span>)) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-body ttree2)
                                                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> rewritten-body nil 'rewritten-body)
                                                  <span class="keyword">:fnstack</span> (cons (cons <span class="keyword">:term</span> term) fnstack)
                                                  <span class="keyword">:ttree</span> ttree1)
                                                (let ((ttree2 (<a class="sym-link local-def" href="#def-restore-rw-cache-any-tag" data-sym="RESTORE-RW-CACHE-ANY-TAG" title="(defun restore-rw-cache-any-tag (new-ttree old-ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-any-tag old-ttree)
                         (maybe-extend-tag-tree &#39;rw-cache-nil-tag
                                                (tagged-objects
...">restore-rw-cache-any-tag</a> (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune
                                                         ttree2
                                                         rcnst
                                                         ancestors
                                                         <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                                                         rewritten-body)
                                                       ttree1)))
                                                  (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                      nil
                                                      unify-subst
                                                      gstack
                                                      rewritten-body
                                                      ttree2
                                                      rcnst
                                                      ancestors
                                                      state)
                                                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-body ttree2)))))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                                  nil
                                                  unify-subst
                                                  gstack
                                                  rewritten-body
                                                  ttree1
                                                  rcnst
                                                  ancestors
                                                  state)
                                                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                  rewritten-body
                                                  (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune
                                                    ttree1
                                                    rcnst
                                                    ancestors
                                                    <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                                                    rewritten-body))))))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                              '<a class="sym-link local-def" href="#def-rewrite-fncallp" data-sym="REWRITE-FNCALLP" title="(mutual-recursion
 (defun rewrite-fncallp
        (call result cliquep top-clause current-clause controller-alist)
   (cond ((variablep result) t) ((fquotep result) t)
         ((flambda-applicationp result)
...">rewrite-fncallp</a>
                                              unify-subst
                                              gstack
                                              rewritten-body
                                              ttree1
                                              rcnst
                                              ancestors
                                              state)
                                            (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                                              (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                                                type-alist
                                                obj
                                                geneqv
                                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                                wrld
                                                (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)
                                                simplify-clause-pot-lst
                                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))))))
                                  <span class="keyword">:conc</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule rule <span class="keyword">:hyps</span>)))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                    failure-reason
                                    unify-subst
                                    gstack
                                    nil
                                    nil
                                    rcnst
                                    ancestors
                                    state)
                                  (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                                    (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                                      type-alist
                                      obj
                                      geneqv
                                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                      wrld
                                      (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree1 ttree)
                                      simplify-clause-pot-lst
                                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)))))))))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> (<a class="sym-link local-def" href="#def-near-miss-brkpt1" data-sym="NEAR-MISS-BRKPT1" title="(defun near-miss-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">near-miss-brkpt1</a> rule
                        term
                        type-alist
                        geneqv
                        ancestors
                        ttree
                        gstack
                        rcnst
                        simplify-clause-pot-lst
                        state)
                      (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                        'near-miss
                        unify-subst
                        gstack
                        nil
                        nil
                        rcnst
                        ancestors
                        state)
                      (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                        (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                          type-alist
                          obj
                          geneqv
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                          wrld
                          ttree
                          simplify-clause-pot-lst
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-with-lemmas
    (term rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-variablep" data-sym="VARIABLEP">variablep</a> term) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-solidify-plus term)))
        ((<a class="sym-link system" href="axioms.html#def-fquotep" data-sym="FQUOTEP">fquotep</a> term) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term ttree))
        ((<a class="sym-link system" href="axioms.html#def-member-equal" data-sym="MEMBER-EQUAL">member-equal</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term)
           (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant
             rcnst
             <span class="keyword">:fns-to-be-ignored-by-rewrite</span>)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term ttree))
        ((<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> term) (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-term hyp unify-subst rune rcnst)
            (<a class="sym-link local-def" href="#def-expand-permission-result" data-sym="EXPAND-PERMISSION-RESULT" title="(defun expand-permission-result (term rcnst geneqv wrld)
  (let ((expand-lst (access rewrite-constant rcnst :expand-lst)))
    (mv-let (new-term hyp unify-subst rune posn-from-end)
            (expand-permission-result1 term expand-lst geneqv wrld)
            (cond
...">expand-permission-result</a> term rcnst geneqv wrld)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (new-term (<a class="sym-link system" href="axioms.html#def-assert_24" data-sym="ASSERT$">assert$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> rune) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> hyp))
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> new-term unify-subst 'expansion))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-fncall nil term))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp rewritten-term ttree)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-linear term)
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rewrittenp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-term ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp rewritten-term ttree)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-with-lemmas1 term
                      (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> term) 'lemmas nil wrld)))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rewrittenp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-term ttree))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (new-term hyp alist rune rcnst)
                        (<a class="sym-link local-def" href="#def-expand-permission-result" data-sym="EXPAND-PERMISSION-RESULT" title="(defun expand-permission-result (term rcnst geneqv wrld)
  (let ((expand-lst (access rewrite-constant rcnst :expand-lst)))
    (mv-let (new-term hyp unify-subst rune posn-from-end)
            (expand-permission-result1 term expand-lst geneqv wrld)
            (cond
...">expand-permission-result</a> term rcnst geneqv wrld)
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> hyp new-term) (with-accumulated-persistence rune
                              ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) new-term ttree)
                              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-test ttree)
                                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> hyp alist 'expansion)
                                  <span class="keyword">:geneqv</span> <a class="sym-link local-def" href="#def-_2Ageneqv-iff_2A" data-sym="*GENEQV-IFF*" title="(defconst *geneqv-iff*
          (list
           (make congruence-rule :rune *fake-rune-for-anonymous-enabled-rule*
                 :nume nil :equiv &#39;iff)))">*geneqv-iff*</a>
                                  <span class="keyword">:pequiv-info</span> nil
                                  <span class="keyword">:obj</span> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                  <span class="keyword">:ttree</span> (push-lemma? rune ttree))
                                (let ((ens (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)))
                                  (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (must-be-true must-be-false
                                      true-type-alist
                                      false-type-alist
                                      ts-ttree)
                                    (assume-true-false rewritten-test
                                      nil
                                      (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                                      nil
                                      type-alist
                                      ens
                                      wrld
                                      nil
                                      nil
                                      <span class="keyword">:fta</span>)
                                    (declare (ignore false-type-alist))
                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (must-be-true (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-new-term ttree)
                                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> new-term alist 'expansion)
                                            <span class="keyword">:type-alist</span> true-type-alist
                                            <span class="keyword">:ttree</span> (cons-tag-trees ts-ttree ttree))
                                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                            rewritten-new-term
                                            (<a class="sym-link local-def" href="#def-push-splitter_3F" data-sym="PUSH-SPLITTER?" title="(defmacro push-splitter? (rune ttree rcnst ancestors rhs rewritten-rhs)
  (declare (xargs :guard (symbolp rune)))
  `(cond
    ((and ,rune (null ,ancestors)
          (access rewrite-constant ,rcnst :splitter-output)
...">push-splitter?</a> rune
                                              ttree
                                              rcnst
                                              ancestors
                                              new-term
                                              rewritten-new-term))))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((hide-reason (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> rune
                                               (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-assoc-eq" data-sym="ASSOC-EQ">assoc-eq</a> (car rune) <a class="sym-link local-def" href="#def-_2Afake-rune-alist_2A" data-sym="*FAKE-RUNE-ALIST*" title="(defconst *fake-rune-alist*
          (list (cons (car *fake-rune-for-linear*) &quot;linear arithmetic&quot;)
                (cons (car *fake-rune-for-linear-equalities*)
                      &quot;equality generation from inequalities&quot;)
                (cons (car *fake-rune-for-type-set*)
...">*fake-rune-alist*</a>))
                                               (<a class="sym-link system" href="axioms.html#def-list_2A" data-sym="LIST*">list*</a> <span class="keyword">:expand</span> rune
                                                 (<a class="sym-link system" href="axioms.html#def-symbol-in-current-package-p" data-sym="SYMBOL-IN-CURRENT-PACKAGE-P">symbol-in-current-package-p</a> (base-symbol rune) state)))))
                                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (must-be-false (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                (<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a> hide-reason term wrld state)
                                                (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld)
                                                  (cons-tag-trees ts-ttree ttree))))
                                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-left ttree1)
                                                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> new-term alist <span class="number">2</span>)
                                                  <span class="keyword">:type-alist</span> true-type-alist
                                                  <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-rw-cache-enter-context" data-sym="RW-CACHE-ENTER-CONTEXT" title="(defun rw-cache-enter-context (ttree)
  (maybe-extend-tag-tree &#39;rw-cache-any-tag
                         (tagged-objects &#39;rw-cache-nil-tag ttree)
                         (remove-tag-from-tag-tree &#39;rw-cache-any-tag ttree)))">rw-cache-enter-context</a> ttree))
                                                (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (final-term ttree)
                                                  (<a class="sym-link local-def" href="#def-rewrite-if11" data-sym="REWRITE-IF11" title="(defun rewrite-if11 (term type-alist geneqv wrld ttree)
  (mv-let (ts ts-ttree) (look-in-type-alist term type-alist wrld)
          (cond ((ts= ts *ts-nil*) (mv *nil* (cons-tag-trees ts-ttree ttree)))
                ((and (equal geneqv *geneqv-iff*) (ts-disjointp ts *ts-nil*))
                 (mv *t* (cons-tag-trees ts-ttree ttree)))">rewrite-if11</a> (<a class="sym-link system" href="axioms.html#def-fcons-term_2A" data-sym="FCONS-TERM*">fcons-term*</a> 'if
                                                      rewritten-test
                                                      rewritten-left
                                                      (<a class="sym-link local-def" href="#def-hide-with-comment" data-sym="HIDE-WITH-COMMENT" title="(defun hide-with-comment (reason term wrld state)
  (declare (xargs :mode :program :stobjs state))
  (cond
   ((or (null reason) (null (hide-with-comment-p))) (fcons-term* &#39;hide term))
   (t
...">hide-with-comment</a> hide-reason term wrld state))
                                                    type-alist
                                                    geneqv
                                                    wrld
                                                    (push-lemma (fn-rune-nume '<a class="sym-link system" href="axioms.html#def-hide" data-sym="HIDE">hide</a> nil nil wrld)
                                                      (<a class="sym-link local-def" href="#def-rw-cache-exit-context" data-sym="RW-CACHE-EXIT-CONTEXT" title="(defun rw-cache-exit-context (old-ttree new-ttree)
  (mv-let (flg new-any)
          (combine-rw-caches (tagged-objects &#39;rw-cache-any-tag new-ttree)
                             (tagged-objects &#39;rw-cache-any-tag old-ttree))
          (declare (ignore flg))
...">rw-cache-exit-context</a> ttree ttree1)))
                                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                                    final-term
                                                    (<a class="sym-link local-def" href="#def-push-splitter_3F" data-sym="PUSH-SPLITTER?" title="(defmacro push-splitter? (rune ttree rcnst ancestors rhs rewritten-rhs)
  (declare (xargs :guard (symbolp rune)))
  `(cond
    ((and ,rune (null ,ancestors)
          (access rewrite-constant ,rcnst :splitter-output)
...">push-splitter?</a> rune
                                                      ttree
                                                      rcnst
                                                      ancestors
                                                      new-term
                                                      final-term))))))))))))))
                          (new-term (with-accumulated-persistence rune
                              ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) new-term ttree)
                              <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (final-term ttree)
                                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> new-term alist 'expansion)
                                  <span class="keyword">:ttree</span> (push-lemma? rune ttree))
                                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                  final-term
                                  (<a class="sym-link local-def" href="#def-push-splitter_3F" data-sym="PUSH-SPLITTER?" title="(defmacro push-splitter? (rune ttree rcnst ancestors rhs rewritten-rhs)
  (declare (xargs :guard (symbolp rune)))
  `(cond
    ((and ,rune (null ,ancestors)
          (access rewrite-constant ,rcnst :splitter-output)
...">push-splitter?</a> rune
                                    ttree
                                    rcnst
                                    ancestors
                                    new-term
                                    final-term)))))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-prepend-step-limit" data-sym="PREPEND-STEP-LIMIT" title="(defmacro prepend-step-limit (n form)
  (let ((vars
         (if (consp n)
             n
             (make-var-lst &#39;x n))))">prepend-step-limit</a> <span class="number">2</span>
                              (<a class="sym-link local-def" href="#def-rewrite-solidify" data-sym="REWRITE-SOLIDIFY" title="(defun rewrite-solidify (term type-alist obj geneqv ens wrld ttree pot-lst pt)
  (rewrite-solidify-rec *rewrite-equiv-solidify-iteration-bound* term
                        type-alist obj geneqv ens wrld ttree pot-lst pt))">rewrite-solidify</a> term
                                type-alist
                                obj
                                geneqv
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                wrld
                                ttree
                                simplify-clause-pot-lst
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-linear-term
    (term alist
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
        (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> term)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> atm)
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> atm) '&lt;) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> atm) 'equal))) (let ((rcnst1 (if (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
                   (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rewrite-constant rcnst <span class="keyword">:active-theory</span> <span class="keyword">:arithmetic</span>)
                   rcnst)))
              (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (lhs ttree)
                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> atm <span class="number">1</span>) alist <span class="number">1</span>)
                  <span class="keyword">:obj</span> '?
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:rcnst</span> rcnst1)
                (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rhs ttree)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> (<a class="sym-link system" href="axioms.html#def-fargn" data-sym="FARGN">fargn</a> atm <span class="number">2</span>) alist <span class="number">2</span>)
                    <span class="keyword">:obj</span> '?
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:rcnst</span> rcnst1)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (not-flg (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                        (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> '<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> atm) lhs rhs))
                        ttree))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> atm) lhs rhs) ttree)))))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> alist term) ttree))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-linear-term-lst
    (term-lst ttrees
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> term-lst)
        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil nil)
        (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (term1 ttree1)
          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-linear-term (car term-lst) nil)
            <span class="keyword">:obj</span> nil
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil
            <span class="keyword">:type-alist</span> (cleanse-type-alist type-alist
              (collect-parents (car ttrees)))
            <span class="keyword">:ttree</span> (car ttrees))
          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (term-lst ttree-lst)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-linear-term-lst (cdr term-lst) (cdr ttrees))
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
              (cons term1 term-lst)
              (cons ttree1 ttree-lst)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-linear-lemma
    (term lemma
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (let ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> 'add-linear-lemma nil term lemma)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth)))
        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
          (one-way-unify (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:max-term</span>) term)
          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unify-ans
               (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-brkpt1" data-sym="BRKPT1" title="(defun brkpt1
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst simplify-clause-pot-lst state)
  (cond
   (t
...">brkpt1</a> lemma
                   term
                   unify-subst
                   type-alist
                   nil
                   ancestors
                   nil
                   gstack
                   rcnst
                   simplify-clause-pot-lst
                   state))) (let ((rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:rune</span>)))
                (with-accumulated-persistence rune
                  ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) contradictionp pot-lst)
                  (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> contradictionp
                    (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> pot-lst simplify-clause-pot-lst)))
                  (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason unify-subst ttree1)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps rune
                        term
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:hyps</span>)
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:backchain-limit-lst</span>)
                        unify-subst
                        (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-oncep" data-sym="ONCEP" title="(defun oncep (nume-runes match-free rune nume)
  (if (or (eq nume-runes :clear) (&lt;= (car nume-runes) nume))
      (eq match-free :once)
      (member-equal rune (cdr nume-runes))))">oncep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:oncep-override</span>)
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:match-free</span>)
                            rune
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:nume</span>))))
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:ttree</span> nil)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-concl ttree2)
                          (with-accumulated-persistence rune
                            ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) rewritten-concl ttree2)
                            <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-linear-term (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:concl</span>)
                                unify-subst)
                              <span class="keyword">:obj</span> nil
                              <span class="keyword">:geneqv</span> nil
                              <span class="keyword">:pequiv-info</span> nil
                              <span class="keyword">:ttree</span> ttree1)
                            <span class="keyword">:conc</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:hyps</span>))
                          (let ((force-flg (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)))
                            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst failure-reason <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>)
                              (<a class="sym-link local-def" href="#def-add-linear-lemma-finish" data-sym="ADD-LINEAR-LEMMA-FINISH" title="(defun add-linear-lemma-finish
       (concl force-flg rune rewritten-p term type-alist wrld state
        simplify-clause-pot-lst rcnst ttree)
  (let ((lst
         (linearize concl t type-alist
...">add-linear-lemma-finish</a> rewritten-concl
                                force-flg
                                rune
                                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                term
                                type-alist
                                wrld
                                state
                                simplify-clause-pot-lst
                                rcnst
                                ttree2)
                              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                      nil
                                      unify-subst
                                      gstack
                                      <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                                      nil
                                      rcnst
                                      ancestors
                                      state)
                                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil)))
                                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst failure-reason <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>)
                                    (let ((unrewritten-concl-to-try (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> new-pot-lst <span class="keyword">:null-lst</span>)
                                             (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:rewriter-state</span>)
                                               'settled-down))
                                           (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> unify-subst (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma lemma <span class="keyword">:concl</span>)))))
                                      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unrewritten-concl-to-try
                                           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal rewritten-concl unrewritten-concl-to-try))) (<a class="sym-link local-def" href="#def-add-linear-lemma-finish" data-sym="ADD-LINEAR-LEMMA-FINISH" title="(defun add-linear-lemma-finish
       (concl force-flg rune rewritten-p term type-alist wrld state
        simplify-clause-pot-lst rcnst ttree)
  (let ((lst
         (linearize concl t type-alist
...">add-linear-lemma-finish</a> unrewritten-concl-to-try
                                            force-flg
                                            rune
                                            nil
                                            term
                                            type-alist
                                            wrld
                                            state
                                            (if (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> new-pot-lst <span class="keyword">:null-lst</span>)
                                              simplify-clause-pot-lst
                                              new-pot-lst)
                                            rcnst
                                            (push-lemma rune (<a class="sym-link local-def" href="#def-accumulate-rw-cache" data-sym="ACCUMULATE-RW-CACHE" title="(defun accumulate-rw-cache (replace-p new-ttree old-ttree)
  (let ((ttree1
         (or
          (accumulate-rw-cache1 replace-p &#39;rw-cache-nil-tag new-ttree
                                old-ttree)
...">accumulate-rw-cache</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> ttree2 ttree1))))
                                        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil new-pot-lst failure-reason <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>))))
                                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                            nil
                                            unify-subst
                                            gstack
                                            <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                                            nil
                                            rcnst
                                            ancestors
                                            state)
                                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil)))
                                      (failure-reason (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                            failure-reason
                                            unify-subst
                                            gstack
                                            <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                                            nil
                                            rcnst
                                            ancestors
                                            state)
                                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil new-pot-lst)))
                                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                            nil
                                            unify-subst
                                            gstack
                                            <a class="sym-link local-def" href="#def-brr-result" data-sym="BRR-RESULT" title="(defun brr-result (state)
  (let ((result (get-brr-local &#39;brr-result state)))
    (cond
     ((eq (record-type (get-brr-local &#39;lemma state)) &#39;linear-lemma)
      (show-poly-lst result))">brr-result</a>
                                            nil
                                            rcnst
                                            ancestors
                                            state)
                                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil new-pot-lst)))))))))))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                            failure-reason
                            unify-subst
                            gstack
                            nil
                            nil
                            rcnst
                            ancestors
                            state)
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))))))))
            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-progn_24" data-sym="PROGN$">progn$</a> (<a class="sym-link local-def" href="#def-near-miss-brkpt1" data-sym="NEAR-MISS-BRKPT1" title="(defun near-miss-brkpt1
       (lemma target type-alist geneqv ancestors initial-ttree gstack rcnst
        simplify-clause-pot-lst state)
  (cond ((not (f-get-global &#39;gstackp state)) nil)
        (t
...">near-miss-brkpt1</a> lemma
                  term
                  type-alist
                  nil
                  ancestors
                  nil
                  gstack
                  rcnst
                  simplify-clause-pot-lst
                  state)
                (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                  'near-miss
                  unify-subst
                  gstack
                  nil
                  nil
                  rcnst
                  ancestors
                  state)
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-linear-lemmas
    (term linear-lemmas
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> linear-lemmas) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
        ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-lemma (car linear-lemmas) <span class="keyword">:nume</span>)
             (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-linear-lemmas term (cdr linear-lemmas))
            <span class="keyword">:obj</span> nil
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil
            <span class="keyword">:ttree</span> nil))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-linear-lemma term (car linear-lemmas))
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-linear-lemmas term (cdr linear-lemmas))
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil
                  <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-alists2
    (alist-entry1 alist-entry2
      poly
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((leaves1 (binary-*-leaves (car alist-entry1))) (leaves2 (binary-*-leaves (car alist-entry2)))
          (leaves (merge-arith-term-order leaves1 leaves2))
          (tree (binary-*-tree leaves))
          (coeff (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> (cdr alist-entry1) (cdr alist-entry2)))
          (temp-entry (<a class="sym-link system" href="basis-b.html#def-mcons-term_2A" data-sym="MCONS-TERM*">mcons-term*</a> 'binary-* (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> coeff) tree)))
        (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (new-entry new-ttree)
          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> temp-entry nil 'multiply-alists2)
            <span class="keyword">:obj</span> '?
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil
            <span class="keyword">:rcnst</span> (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> rewrite-constant rcnst <span class="keyword">:active-theory</span> <span class="keyword">:arithmetic</span>)
            <span class="keyword">:ttree</span> nil)
          (let ((new-poly (add-linear-term new-entry 'rhs poly)))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
              (<a class="sym-link system" href="basis-a.html#def-change" data-sym="CHANGE">change</a> poly
                new-poly
                <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache" data-sym="CONS-TAG-TREES-RW-CACHE" title="(defun cons-tag-trees-rw-cache (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects &#39;rw-cache-any-tag ttree1))
        (rw-cache-any2 (tagged-objects &#39;rw-cache-any-tag ttree2))
        (rw-cache-nil1 (tagged-objects &#39;rw-cache-nil-tag ttree1))
        (rw-cache-nil2 (tagged-objects &#39;rw-cache-nil-tag ttree2)))
...">cons-tag-trees-rw-cache</a> new-ttree
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly new-poly <span class="keyword">:ttree</span>))
                <span class="keyword">:parents</span> (marry-parents (collect-parents new-ttree)
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly new-poly <span class="keyword">:parents</span>)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-alists1
    (alist-entry alist2
      poly
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist2) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit poly))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (temp-poly)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-alists2 alist-entry (car alist2) poly)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-alists1 alist-entry (cdr alist2) temp-poly)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-alists
    (alist1 alist2
      poly
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> alist1) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit poly))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (temp-poly)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-alists1 (car alist1) alist2 poly)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-alists (cdr alist1) alist2 temp-poly)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-polys1
    (alist1 const1
      rel1
      alist2
      const2
      rel2
      poly
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree rel1 rel2)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((temp-poly1 (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> const2 <span class="number">0</span>)
             poly
             (multiply-alist-and-const alist1 const2 poly))) (temp-poly2 (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> const1 <span class="number">0</span>)
              temp-poly1
              (multiply-alist-and-const alist2 const1 temp-poly1))))
        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-alists alist1 alist2 temp-poly2)
          <span class="keyword">:obj</span> nil
          <span class="keyword">:geneqv</span> nil
          <span class="keyword">:pequiv-info</span> nil
          <span class="keyword">:ttree</span> nil))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-polys
    (poly1 poly2
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (let ((alist1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:alist</span>)) (ttree1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:ttree</span>))
          (const1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:constant</span>))
          (rel1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:relation</span>))
          (parents1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:parents</span>))
          (ratp1 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly1 <span class="keyword">:rational-poly-p</span>))
          (alist2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:alist</span>))
          (ttree2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:ttree</span>))
          (const2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:constant</span>))
          (rel2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:relation</span>))
          (parents2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:parents</span>))
          (ratp2 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly2 <span class="keyword">:rational-poly-p</span>)))
        (let ((pre-poly (<a class="sym-link system" href="basis-a.html#def-make" data-sym="MAKE">make</a> poly
               <span class="keyword">:alist</span> nil
               <span class="keyword">:ttree</span> (<a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache" data-sym="CONS-TAG-TREES-RW-CACHE" title="(defun cons-tag-trees-rw-cache (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects &#39;rw-cache-any-tag ttree1))
        (rw-cache-any2 (tagged-objects &#39;rw-cache-any-tag ttree2))
        (rw-cache-nil1 (tagged-objects &#39;rw-cache-nil-tag ttree1))
        (rw-cache-nil2 (tagged-objects &#39;rw-cache-nil-tag ttree2)))
...">cons-tag-trees-rw-cache</a> ttree1 ttree2)
               <span class="keyword">:parents</span> (marry-parents parents1 parents2)
               <span class="keyword">:constant</span> (<a class="sym-link system" href="axioms.html#def-_2A" data-sym="*">*</a> const1 const2)
               <span class="keyword">:relation</span> (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> rel1 '&lt;) (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> rel2 '&lt;))
                 '&lt;
                 '<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a>)
               <span class="keyword">:rational-poly-p</span> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> ratp1 ratp2))))
          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (poly)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-polys1 alist1
                const1
                rel1
                alist2
                const2
                rel2
                pre-poly)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (normalize-poly poly)))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-pots2
    (poly big-poly-list
      new-poly-list
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> big-poly-list) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit new-poly-list))
        ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly poly <span class="keyword">:rational-poly-p</span>)
           (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly (car big-poly-list) <span class="keyword">:rational-poly-p</span>)) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (new-poly)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-polys poly (car big-poly-list))
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots2 poly
                (cdr big-poly-list)
                (cons new-poly new-poly-list))
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots2 poly (cdr big-poly-list) new-poly-list)
            <span class="keyword">:obj</span> nil
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil
            <span class="keyword">:ttree</span> nil)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-pots1
    (poly-list big-poly-list
      new-poly-list
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> poly-list) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit new-poly-list))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (new-new-poly-list)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots2 (car poly-list) big-poly-list new-poly-list)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots1 (cdr poly-list)
                big-poly-list
                new-new-poly-list)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-pots-super-filter
    (var-list pot-lst-to-look-in
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> var-list) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil))
        ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr var-list)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            (shortest-polys-with-var (car var-list)
              pot-lst-to-look-in
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (big-poly-list)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots-super-filter (cdr var-list)
                pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots1 (shortest-polys-with-var (car var-list)
                  pot-lst-to-look-in
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
                big-poly-list
                nil)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-pots-filter
    (var-list pot-lst-to-look-in
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (poly-list1)
        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots1 (bounds-polys-with-var (car var-list)
              pot-lst-to-look-in
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
            (polys-with-var (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> var-list) pot-lst-to-look-in)
            nil)
          <span class="keyword">:obj</span> nil
          <span class="keyword">:geneqv</span> nil
          <span class="keyword">:pequiv-info</span> nil
          <span class="keyword">:ttree</span> nil)
        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots1 (bounds-polys-with-var (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> var-list)
              pot-lst-to-look-in
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
            (polys-with-var (car var-list) pot-lst-to-look-in)
            poly-list1)
          <span class="keyword">:obj</span> nil
          <span class="keyword">:geneqv</span> nil
          <span class="keyword">:pequiv-info</span> nil
          <span class="keyword">:ttree</span> nil))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> multiply-pots
    (var-list pot-lst-to-look-in
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">2</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> var-list) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil))
        ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr var-list)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            (polys-with-var (car var-list) pot-lst-to-look-in)))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (big-poly-list)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots (cdr var-list) pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots1 (polys-with-var (car var-list) pot-lst-to-look-in)
                big-poly-list
                nil)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-multiplied-polys-filter
    (var-list products-already-tried
      pot-lst-to-look-in
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((product-already-triedp var-list products-already-tried) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (poly-list1)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots-filter var-list pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (let ((poly-list2 (polys-with-pots poly-list1 simplify-clause-pot-lst nil)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
                (add-polys poly-list2
                  simplify-clause-pot-lst
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
                  type-alist
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                  wrld)
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                  contradictionp
                  new-pot-lst
                  (cons (sort-arith-term-order var-list)
                    products-already-tried)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-multiplied-polys
    (var-list products-already-tried
      pot-lst-to-look-in
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr var-list)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        ((product-already-triedp var-list products-already-tried) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (too-many-polysp var-list pot-lst-to-look-in <span class="number">1</span>)
           (&lt; <span class="number">4</span> (<a class="sym-link system" href="axioms.html#def-length" data-sym="LENGTH">length</a> var-list))) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (poly-list)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots-super-filter var-list pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
              (add-polys poly-list
                simplify-clause-pot-lst
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
                type-alist
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                wrld)
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                contradictionp
                new-pot-lst
                (cons (sort-arith-term-order var-list)
                  products-already-tried)))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (poly-list)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (multiply-pots var-list pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
              (add-polys poly-list
                simplify-clause-pot-lst
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
                type-alist
                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                wrld)
              (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                contradictionp
                new-pot-lst
                (cons (sort-arith-term-order var-list)
                  products-already-tried))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> deal-with-product1
    (part-of-new-var var-list
      pot-lst-to-look-in
      pot-lst-to-step-down
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal part-of-new-var <a class="sym-link system" href="axioms.html#def-_2A1_2A" data-sym="*1*">*1*</a>) (if (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (cdr var-list))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
              nil
              simplify-clause-pot-lst
              products-already-tried)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-multiplied-polys var-list
                products-already-tried
                pot-lst-to-look-in)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)))
        ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst-to-step-down) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-part-of-new-var (part-of (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>)
                 part-of-new-var)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (new-part-of-new-var (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-list products-already-tried)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product1 new-part-of-new-var
                      (cons (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>)
                        var-list)
                      pot-lst-to-look-in
                      pot-lst-to-look-in
                      products-already-tried)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:ttree</span> nil)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil products-already-tried))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product1 part-of-new-var
                          var-list
                          pot-lst-to-look-in
                          (cdr pot-lst-to-step-down)
                          products-already-tried)
                        <span class="keyword">:obj</span> nil
                        <span class="keyword">:geneqv</span> nil
                        <span class="keyword">:pequiv-info</span> nil
                        <span class="keyword">:ttree</span> nil
                        <span class="keyword">:simplify-clause-pot-lst</span> new-pot-list)))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product1 part-of-new-var
                    var-list
                    pot-lst-to-look-in
                    (cdr pot-lst-to-step-down)
                    products-already-tried)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> deal-with-product
    (new-var pot-lst-to-look-in
      pot-lst-to-step-down
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-fn-symb" data-sym="FN-SYMB">fn-symb</a> new-var) 'binary-*) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product1 new-var
              nil
              pot-lst-to-look-in
              pot-lst-to-step-down
              products-already-tried)
            <span class="keyword">:obj</span> nil
            <span class="keyword">:geneqv</span> nil
            <span class="keyword">:pequiv-info</span> nil
            <span class="keyword">:ttree</span> nil))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> deal-with-factor
    (new-var pot-lst-to-look-in
      pot-lst-to-step-down
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst-to-step-down) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((part-of-pot-var (part-of new-var
                 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> part-of-pot-var
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal new-var
                     (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>)))) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-list products-already-tried)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product1 part-of-pot-var
                      (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> new-var)
                      pot-lst-to-look-in
                      pot-lst-to-look-in
                      products-already-tried)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:ttree</span> nil)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil products-already-tried))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-factor new-var
                          pot-lst-to-look-in
                          (cdr pot-lst-to-step-down)
                          products-already-tried)
                        <span class="keyword">:obj</span> nil
                        <span class="keyword">:geneqv</span> nil
                        <span class="keyword">:pequiv-info</span> nil
                        <span class="keyword">:ttree</span> nil
                        <span class="keyword">:simplify-clause-pot-lst</span> new-pot-list)))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-factor new-var
                    pot-lst-to-look-in
                    (cdr pot-lst-to-step-down)
                    products-already-tried)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> deal-with-division
    (new-var inverse-var
      pot-lst-to-look-in
      pot-lst-to-step-down
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pot-lst-to-step-down) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
            nil
            simplify-clause-pot-lst
            products-already-tried))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((part-of (part-of inverse-var
                 (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>))))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (part-of (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst products-already-tried)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-multiplied-polys-filter (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> new-var
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> linear-pot (car pot-lst-to-step-down) <span class="keyword">:var</span>))
                      products-already-tried
                      pot-lst-to-look-in)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:ttree</span> nil)
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil nil))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-division new-var
                          inverse-var
                          pot-lst-to-look-in
                          (cdr pot-lst-to-step-down)
                          products-already-tried)
                        <span class="keyword">:obj</span> nil
                        <span class="keyword">:geneqv</span> nil
                        <span class="keyword">:pequiv-info</span> nil
                        <span class="keyword">:ttree</span> nil
                        <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst)))))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-division new-var
                    inverse-var
                    pot-lst-to-look-in
                    (cdr pot-lst-to-step-down)
                    products-already-tried)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> non-linear-arithmetic1
    (new-vars pot-lst
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((inverted-var (invert-var (car new-vars))))
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst1 products-already-tried)
              (if (good-bounds-in-pot inverted-var
                  pot-lst
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
                (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-division (car new-vars)
                    inverted-var
                    pot-lst
                    pot-lst
                    products-already-tried)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil)
                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                  nil
                  simplify-clause-pot-lst
                  products-already-tried))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst2 products-already-tried)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-product (car new-vars)
                        pot-lst
                        pot-lst
                        products-already-tried)
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:ttree</span> nil
                      <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst1)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst3 products-already-tried)
                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (deal-with-factor (car new-vars)
                              pot-lst
                              pot-lst
                              products-already-tried)
                            <span class="keyword">:obj</span> nil
                            <span class="keyword">:geneqv</span> nil
                            <span class="keyword">:pequiv-info</span> nil
                            <span class="keyword">:ttree</span> nil
                            <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst2)
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (non-linear-arithmetic1 (cdr new-vars)
                                  pot-lst
                                  products-already-tried)
                                <span class="keyword">:obj</span> nil
                                <span class="keyword">:geneqv</span> nil
                                <span class="keyword">:pequiv-info</span> nil
                                <span class="keyword">:ttree</span> nil
                                <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst3)))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> non-linear-arithmetic
    (new-vars pot-lst
      products-already-tried
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> 'non-linear-arithmetic nil new-vars)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth)))
            (declare (type (unsigned-byte <span class="number">60</span>) rdepth))
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (non-linear-arithmetic1 new-vars
                pot-lst
                products-already-tried)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-polys-and-lemmas2-nl
    (new-vars old-pot-lst
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (let ((new-vars (expanded-new-vars-in-pot-lst simplify-clause-pot-lst
                 old-pot-lst)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas2-nl new-vars simplify-clause-pot-lst)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil)))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
            (add-polys-from-type-set (car new-vars)
              simplify-clause-pot-lst
              type-alist
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
              (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
              wrld)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst)
                  (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-nvariablep" data-sym="NVARIABLEP">nvariablep</a> (car new-vars))
                      (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> (car new-vars)))
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:heavy-linearp</span>))
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-linear-lemmas (car new-vars)
                        (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car new-vars)) 'linear-lemmas nil wrld))
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:ttree</span> nil
                      <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil new-pot-lst))
                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
                        (add-inverse-polys (car new-vars)
                          type-alist
                          wrld
                          new-pot-lst
                          (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>))
                        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas2-nl (cdr new-vars) old-pot-lst)
                              <span class="keyword">:obj</span> nil
                              <span class="keyword">:geneqv</span> nil
                              <span class="keyword">:pequiv-info</span> nil
                              <span class="keyword">:ttree</span> nil
                              <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-polys-and-lemmas1-nl
    (old-pot-lst cnt
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-_3C_3D" data-sym="&lt;=">&lt;=</a> <a class="sym-link system" href="axioms.html#def-_2Anon-linear-rounds-value_2A" data-sym="*NON-LINEAR-ROUNDS-VALUE*">*non-linear-rounds-value*</a> cnt) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-vars (expanded-new-vars-in-pot-lst simplify-clause-pot-lst
                 old-pot-lst)))
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst1)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas2-nl new-vars old-pot-lst)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:ttree</span> nil)))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((new-vars (new-vars-in-pot-lst new-pot-lst1 old-pot-lst <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil new-pot-lst1))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst2)
                          (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (non-linear-arithmetic new-vars new-pot-lst1 nil)
                            <span class="keyword">:obj</span> nil
                            <span class="keyword">:geneqv</span> nil
                            <span class="keyword">:pequiv-info</span> nil
                            <span class="keyword">:ttree</span> nil
                            <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst1)
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1-nl new-pot-lst1 (<a class="sym-link system" href="axioms.html#def-1_2B" data-sym="1+">1+</a> cnt))
                                <span class="keyword">:obj</span> nil
                                <span class="keyword">:geneqv</span> nil
                                <span class="keyword">:pequiv-info</span> nil
                                <span class="keyword">:ttree</span> nil
                                <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst2)))))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-polys-and-lemmas1
    (new-vars old-pot-lst
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (let ((new-vars (new-vars-in-pot-lst simplify-clause-pot-lst
                 old-pot-lst
                 nil)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> new-vars) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1 new-vars simplify-clause-pot-lst)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil)))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-flambda-applicationp" data-sym="FLAMBDA-APPLICATIONP">flambda-applicationp</a> (car new-vars))
                 (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:heavy-linearp</span>))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-linear-lemmas (car new-vars)
                    (<a class="sym-link system" href="axioms.html#def-getpropc" data-sym="GETPROPC">getpropc</a> (<a class="sym-link system" href="axioms.html#def-ffn-symb" data-sym="FFN-SYMB">ffn-symb</a> (car new-vars)) 'linear-lemmas nil wrld))
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1 (cdr new-vars) old-pot-lst)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil
                  <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-polys-and-lemmas
    (lst disjunctsp
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (contradictionp new-pot-lst)
        (add-polys lst
          simplify-clause-pot-lst
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:pt</span>)
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
          type-alist
          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
          (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
          wrld)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
          ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
             (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> disjunctsp) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> ancestors))) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1-nl simplify-clause-pot-lst <span class="number">0</span>)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil
              <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1 (new-vars-in-pot-lst new-pot-lst
                  simplify-clause-pot-lst
                  nil)
                new-pot-lst)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil
              <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-disjunct-polys-and-lemmas
    (lst1 lst2
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst1)
        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas lst1 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
          <span class="keyword">:obj</span> nil
          <span class="keyword">:geneqv</span> nil
          <span class="keyword">:pequiv-info</span> nil
          <span class="keyword">:ttree</span> nil)
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas (infect-polys lst2
                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>)
                  (collect-parents (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>)))
                <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst2)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas lst2 <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>)
                <span class="keyword">:obj</span> nil
                <span class="keyword">:geneqv</span> nil
                <span class="keyword">:pequiv-info</span> nil
                <span class="keyword">:ttree</span> nil)
              (declare (ignore new-pot-lst2))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    nil
                    (infect-new-polys new-pot-lst1
                      simplify-clause-pot-lst
                      (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst)))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-disjuncts-polys-and-lemmas
    (split-lst to-do-later
      pot-lst0
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore obj geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> split-lst) (let ((eqp (equal pot-lst0 simplify-clause-pot-lst)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> eqp (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> to-do-later)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil simplify-clause-pot-lst (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> eqp)))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp pot-lst changedp)
                  (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-disjuncts-polys-and-lemmas to-do-later
                      nil
                      simplify-clause-pot-lst)
                    <span class="keyword">:obj</span> nil
                    <span class="keyword">:geneqv</span> nil
                    <span class="keyword">:pequiv-info</span> nil
                    <span class="keyword">:ttree</span> nil)
                  (declare (ignore changedp))
                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp pot-lst <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-disjunct-polys-and-lemmas (car (car split-lst))
                (<a class="sym-link system" href="axioms.html#def-cadr" data-sym="CADR">cadr</a> (car split-lst)))
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil nil))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-disjuncts-polys-and-lemmas (cdr split-lst)
                    (if (equal new-pot-lst simplify-clause-pot-lst)
                      (cons (car split-lst) to-do-later)
                      to-do-later)
                    pot-lst0)
                  <span class="keyword">:obj</span> nil
                  <span class="keyword">:geneqv</span> nil
                  <span class="keyword">:pequiv-info</span> nil
                  <span class="keyword">:ttree</span> nil
                  <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> add-terms-and-lemmas
    (term-lst ttrees
      positivep
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore geneqv pequiv-info ttree)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (let ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> 'add-terms-and-lemmas nil term-lst obj)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth)))
        (declare (type (unsigned-byte <span class="number">60</span>) rdepth))
        (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (term-lst ttree-lst)
          (if (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:nonlinearp</span>)
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:heavy-linearp</span>))
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-linear-term-lst term-lst ttrees)
              <span class="keyword">:obj</span> nil
              <span class="keyword">:geneqv</span> nil
              <span class="keyword">:pequiv-info</span> nil
              <span class="keyword">:ttree</span> nil)
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term-lst ttrees))
          (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (poly-lst split-lst)
            (linearize-lst term-lst
              ttree-lst
              positivep
              type-alist
              (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
              (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
              wrld
              state)
            (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp basic-pot-lst)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas poly-lst nil)
                <span class="keyword">:obj</span> nil
                <span class="keyword">:geneqv</span> nil
                <span class="keyword">:pequiv-info</span> nil
                <span class="keyword">:ttree</span> nil)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp new-pot-lst changedp)
                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-disjuncts-polys-and-lemmas split-lst nil basic-pot-lst)
                      <span class="keyword">:obj</span> nil
                      <span class="keyword">:geneqv</span> nil
                      <span class="keyword">:pequiv-info</span> nil
                      <span class="keyword">:ttree</span> nil
                      <span class="keyword">:simplify-clause-pot-lst</span> basic-pot-lst)
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit contradictionp nil))
                      ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> changedp
                         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj '?)
                         (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:rewriter-state</span>)
                           'settled-down)) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-polys-and-lemmas1 (new-vars-in-pot-lst new-pot-lst nil nil)
                            new-pot-lst)
                          <span class="keyword">:obj</span> nil
                          <span class="keyword">:geneqv</span> nil
                          <span class="keyword">:pequiv-info</span> nil
                          <span class="keyword">:ttree</span> nil
                          <span class="keyword">:simplify-clause-pot-lst</span> new-pot-lst))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil new-pot-lst))))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-with-linear
    (term rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (ignore geneqv pequiv-info)
      (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (let ((positivep (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj nil)))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> obj '?))
             (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (not-flg atm)
               (<a class="sym-link system" href="basis-b.html#def-strip-not" data-sym="STRIP-NOT">strip-not</a> term)
               (declare (ignore not-flg))
               (<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="basis-b.html#def-equalityp" data-sym="EQUALITYP">equalityp</a> atm) (<a class="sym-link system" href="basis-b.html#def-inequalityp" data-sym="INEQUALITYP">inequalityp</a> atm)))) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (contradictionp irrelevant-pot-lst)
              (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (add-terms-and-lemmas (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> term) nil positivep)
                <span class="keyword">:geneqv</span> nil
                <span class="keyword">:pequiv-info</span> nil
                <span class="keyword">:ttree</span> nil)
              (declare (ignore irrelevant-pot-lst))
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (contradictionp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                    (if positivep
                      <a class="sym-link system" href="axioms.html#def-_2Anil_2A" data-sym="*NIL*">*nil*</a>
                      <a class="sym-link system" href="axioms.html#def-_2At_2A" data-sym="*T*">*t*</a>)
                    (push-lemma <a class="sym-link local-def" href="#def-_2Afake-rune-for-linear_2A" data-sym="*FAKE-RUNE-FOR-LINEAR*" title="(defconst *fake-rune-for-linear* &#39;(:fake-rune-for-linear nil))">*fake-rune-for-linear*</a>
                      (<a class="sym-link local-def" href="#def-cons-tag-trees-rw-cache" data-sym="CONS-TAG-TREES-RW-CACHE" title="(defun cons-tag-trees-rw-cache (ttree1 ttree2)
  (let ((rw-cache-any1 (tagged-objects &#39;rw-cache-any-tag ttree1))
        (rw-cache-any2 (tagged-objects &#39;rw-cache-any-tag ttree2))
        (rw-cache-nil1 (tagged-objects &#39;rw-cache-nil-tag ttree1))
        (rw-cache-nil2 (tagged-objects &#39;rw-cache-nil-tag ttree2)))
...">cons-tag-trees-rw-cache</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> poly contradictionp <span class="keyword">:ttree</span>)
                        ttree))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-quoted-constant-with-lemma
    (term lemma
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((gstack (<a class="sym-link local-def" href="#def-push-gframe" data-sym="PUSH-GFRAME" title="(defmacro push-gframe (sys-fn bkptr &amp;rest args)
  `(cond
    ((or (f-get-global &#39;gstackp state) (f-get-global &#39;dmrp state))
     (cons (make gframe :sys-fn ,sys-fn :bkptr ,bkptr :args (list* ,@args))
           gstack))">push-gframe</a> 'rewrite-quoted-constant-with-lemma
             nil
             term
             lemma
             geneqv)) (rdepth (<a class="sym-link local-def" href="#def-adjust-rdepth" data-sym="ADJUST-RDEPTH" title="(defmacro adjust-rdepth (rdepth) `(|1-F| ,rdepth))">adjust-rdepth</a> rdepth))
          (temp (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:heuristic-info</span>))
          (n (car temp))
          (<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a> (cdr temp)))
        (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
          (type integer n))
        (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link local-def" href="#def-zero-depthp" data-sym="ZERO-DEPTHP" title="(defmacro zero-depthp (depth) `(eql (the-fixnum ,depth) 0))">zero-depthp</a> rdepth) (<a class="sym-link local-def" href="#def-rdepth-error" data-sym="RDEPTH-ERROR" title="(defmacro rdepth-error (form &amp;optional preprocess-p)
  (if preprocess-p
      (let ((ctx &#39;&#39;preprocess))
        `(prog2$
          (er-hard ,ctx &quot;Call depth&quot;
...">rdepth-error</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))
          ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
               geneqv
               wrld)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((lhs (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">2</span>)
                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>)
                   (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:lhs</span>))) (rhs (if (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">2</span>)
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:lhs</span>)
                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rhs</span>)))
                (rune (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:rune</span>)))
              (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (unify-ans unify-subst)
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">1</span>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> (equal term lhs) nil))
                  ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">2</span>) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (cons lhs term))))
                  ((<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">3</span>) (<a class="sym-link local-def" href="#def-one-way-unify-restrictions" data-sym="ONE-WAY-UNIFY-RESTRICTIONS" title="(defun one-way-unify-restrictions (pat term restrictions)
  (declare
   (xargs :guard
    (and (pseudo-termp pat) (pseudo-termp term) (alistp-listp restrictions))))
  (cond ((null restrictions) (one-way-unify pat term))">one-way-unify-restrictions</a> lhs
                      term
                      (cdr (<a class="sym-link system" href="axioms.html#def-assoc-equal" data-sym="ASSOC-EQUAL">assoc-equal</a> rune
                          (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:restrictions-alist</span>)))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> nil
                      (<a class="sym-link system" href="axioms.html#def-er" data-sym="ER">er</a> hard
                        'rewrite-quoted-constant-with-lemma
                        <span class="string">"We&#39;ve encountered a :rewrite-quoted-constant ~
                             rule, namely ~x0, with an unrecognized form ~
                             number, ~x1."</span>
                        rune
                        n))))
                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> unify-ans
                     (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-brkpt1" data-sym="BRKPT1" title="(defun brkpt1
       (lemma target unify-subst type-alist geneqv ancestors initial-ttree
        gstack rcnst simplify-clause-pot-lst state)
  (cond
   (t
...">brkpt1</a> lemma
                         term
                         unify-subst
                         type-alist
                         geneqv
                         ancestors
                         ttree
                         gstack
                         rcnst
                         simplify-clause-pot-lst
                         state))) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> (<a class="sym-link local-def" href="#def-loop-stopperp" data-sym="LOOP-STOPPERP" title="(defun loop-stopperp (loop-stopper sbst wrld)
  (or (null loop-stopper) (loop-stopperp-rec loop-stopper sbst wrld)))">loop-stopperp</a> <a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a> unify-subst wrld)) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                            '<a class="sym-link system" href="defthm.html#def-loop-stopper" data-sym="LOOP-STOPPER">loop-stopper</a>
                            unify-subst
                            gstack
                            nil
                            nil
                            rcnst
                            ancestors
                            state)
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (with-accumulated-persistence rune
                          ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) flg term ttree)
                          flg
                          (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (relieve-hyps-ans failure-reason unify-subst ttree)
                            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (relieve-hyps rune
                                term
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>)
                                (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:backchain-limit-lst</span>)
                                unify-subst
                                (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link local-def" href="#def-oncep" data-sym="ONCEP" title="(defun oncep (nume-runes match-free rune nume)
  (if (or (eq nume-runes :clear) (&lt;= (car nume-runes) nume))
      (eq match-free :once)
      (member-equal rune (cdr nume-runes))))">oncep</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:oncep-override</span>)
                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:match-free</span>)
                                    rune
                                    (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:nume</span>))))
                              <span class="keyword">:obj</span> nil
                              <span class="keyword">:geneqv</span> nil
                              <span class="keyword">:pequiv-info</span> nil)
                            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (relieve-hyps-ans (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-rhs ttree)
                                  (with-accumulated-persistence rune
                                    ((<a class="sym-link system" href="axioms.html#def-the" data-sym="THE">the</a> (signed-byte <span class="number">61</span>) step-limit) rewritten-rhs ttree)
                                    <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                    (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> rhs unify-subst 'rhs))
                                    <span class="keyword">:conc</span> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:hyps</span>))
                                  (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">1</span>)
                                       (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">2</span>)
                                         (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> rewritten-rhs)
                                         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (equal term rewritten-rhs)))
                                       (<a class="sym-link system" href="axioms.html#def-eql" data-sym="EQL">eql</a> n <span class="number">3</span>)) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                          nil
                                          unify-subst
                                          gstack
                                          rewritten-rhs
                                          ttree
                                          rcnst
                                          ancestors
                                          state)
                                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                          <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a>
                                          rewritten-rhs
                                          (push-lemma (<a class="sym-link local-def" href="#def-geneqv-refinementp" data-sym="GENEQV-REFINEMENTP" title="(defun geneqv-refinementp (equiv geneqv wrld)
  (cond ((eq equiv &#39;equal) *fake-rune-for-anonymous-enabled-rule*)
        ((null geneqv) nil)
        (t
         (geneqv-refinementp1 (getpropc equiv &#39;coarsenings nil wrld) geneqv))))">geneqv-refinementp</a> (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule lemma <span class="keyword">:equiv</span>)
                                              geneqv
                                              wrld)
                                            (<a class="sym-link local-def" href="#def-push-lemma_2B" data-sym="PUSH-LEMMA+" title="(defmacro push-lemma+ (rune ttree rcnst ancestors rhs rewritten-rhs)
  `(cond
    ((and (null ,ancestors) (access rewrite-constant ,rcnst :splitter-output)
          (ffnnamep-hide &#39;if ,rhs t) (ffnnamep-hide &#39;if ,rewritten-rhs t))
     (let ((rune ,rune) (ttree ,ttree))
...">push-lemma+</a> rune ttree rcnst ancestors rhs rewritten-rhs)))))
                                    (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                          (<a class="sym-link system" href="axioms.html#def-list" data-sym="LIST">list</a> (if (<a class="sym-link system" href="axioms.html#def-quotep" data-sym="QUOTEP">quotep</a> rewritten-rhs)
                                              'normalizer-returned-same-constant
                                              'normalizer-failed-to-evaluate)
                                            (<a class="sym-link system" href="basis-b.html#def-sublis-var" data-sym="SUBLIS-VAR">sublis-var</a> unify-subst rhs)
                                            rewritten-rhs)
                                          unify-subst
                                          gstack
                                          nil
                                          nil
                                          rcnst
                                          ancestors
                                          state)
                                        (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))))
                              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-brkpt2" data-sym="BRKPT2" title="(defun brkpt2
       (wonp failure-reason unify-subst gstack brr-result final-ttree rcnst
        ancestors state)
  (cond
   (t
...">brkpt2</a> nil
                                    failure-reason
                                    unify-subst
                                    gstack
                                    nil
                                    nil
                                    rcnst
                                    ancestors
                                    state)
                                  (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree)))))))))
                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-quoted-constant-with-lemmas
    (term lemmas
      rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">4</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> lemmas) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit nil term ttree))
        ((<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (enabled-numep (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-rule (car lemmas) <span class="keyword">:nume</span>)
             (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))) (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-quoted-constant-with-lemmas term (cdr lemmas))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp rewritten-term ttree)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-quoted-constant-with-lemma term (car lemmas)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rewrittenp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> rewritten-term ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-quoted-constant-with-lemmas term (cdr lemmas))))))))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-quoted-constant
    (term rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewrittenp rewritten-term ttree1)
      (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-quoted-constant-with-lemmas term
          (<a class="sym-link system" href="axioms.html#def-global-val" data-sym="GLOBAL-VAL">global-val</a> 'rewrite-quoted-constant-rules wrld)))
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (rewrittenp (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit rewritten-term ttree1))
        ((<a class="sym-link local-def" href="#def-fn-slot-from-geneqvp" data-sym="FN-SLOT-FROM-GENEQVP" title="(defun fn-slot-from-geneqvp (geneqv)
  (cond ((endp geneqv) nil)
        ((eq &#39;fn-equal (access congruence-rule (car geneqv) :equiv)) t)
        (t (fn-slot-from-geneqvp (cdr geneqv)))))">fn-slot-from-geneqvp</a> geneqv) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (evg1 ttree1)
            (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (rewrite-lambda-object (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> term)))
            (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal evg1 (<a class="sym-link system" href="axioms.html#def-unquote" data-sym="UNQUOTE">unquote</a> term)) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term ttree))
              (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit (<a class="sym-link system" href="axioms.html#def-kwote" data-sym="KWOTE">kwote</a> evg1) (cons-tag-trees ttree1 ttree))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit term ttree)))))
  (<a class="sym-link system" href="axioms.html#def-defun" data-sym="DEFUN">defun</a> rewrite-lambda-object
    (evg rdepth
      step-limit
      type-alist
      obj
      geneqv
      pequiv-info
      wrld
      state
      fnstack
      ancestors
      <a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a>
      simplify-clause-pot-lst
      rcnst
      gstack
      ttree)
    (declare (type (unsigned-byte <span class="number">60</span>) rdepth)
      (type (signed-byte <span class="number">61</span>) step-limit)
      (ignore obj
        geneqv
        pequiv-info
        ancestors
        simplify-clause-pot-lst))
    (<a class="sym-link system" href="axioms.html#def-the-mv" data-sym="THE-MV">the-mv</a> <span class="number">3</span>
      (signed-byte <span class="number">61</span>)
      (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (symbolp evg)
           (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (enabled-numep <a class="sym-link system" href="axioms.html#def-_2Arewrite-lambda-modep-xnume_2A" data-sym="*REWRITE-LAMBDA-MODEP-XNUME*">*rewrite-lambda-modep-xnume*</a>
               (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)))) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree))
        ((well-formed-lambda-objectp evg wrld) (<a class="sym-link system" href="axioms.html#def-let_2A" data-sym="LET*">let*</a> ((<a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a> (<a class="sym-link system" href="axioms.html#def-lambda-object-formals" data-sym="LAMBDA-OBJECT-FORMALS">lambda-object-formals</a> evg)) (dcl (<a class="sym-link system" href="axioms.html#def-lambda-object-dcl" data-sym="LAMBDA-OBJECT-DCL">lambda-object-dcl</a> evg))
              (<a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> (<a class="sym-link system" href="axioms.html#def-lambda-object-body" data-sym="LAMBDA-OBJECT-BODY">lambda-object-body</a> evg))
              (type-alist1 (<a class="sym-link local-def" href="#def-collect-0-ary-hyps" data-sym="COLLECT-0-ARY-HYPS" title="(defun collect-0-ary-hyps (type-alist)
  (cond ((endp type-alist) nil)
        ((and (consp (car (car type-alist)))
              (null (cdr (car (car type-alist)))))
         (cons (car type-alist) (collect-0-ary-hyps (cdr type-alist))))">collect-0-ary-hyps</a> type-alist))
              (fns (all-fnnames <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>))
              (progs (collect-programs fns wrld)))
            (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (pre-have-warrants pre-have-no-warrants)
              (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> fns wrld nil nil)
              (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> progs) (<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> pre-have-no-warrants)) (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (rewritten-body ttree1)
                    (if (enabled-numep <a class="sym-link system" href="axioms.html#def-_2Arewrite-lambda-modep-def-nume_2A" data-sym="*REWRITE-LAMBDA-MODEP-DEF-NUME*">*rewrite-lambda-modep-def-nume*</a>
                        (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                      (<a class="sym-link local-def" href="#def-sl-let" data-sym="SL-LET" title="(defmacro sl-let (vars form &amp;rest rest)
  (let ((new-vars (cons &#39;step-limit vars)))
    `(mv-let ,new-vars ,form (declare (type (signed-byte 61) step-limit))
             ,@rest)))">sl-let</a> (temp-rewritten-body temp-ttree1)
                        (<a class="sym-link local-def" href="#def-rewrite-entry" data-sym="REWRITE-ENTRY" title="(defmacro rewrite-entry (&amp;rest args)
  (declare
   (xargs :guard
    (and (true-listp args) (consp (car args))
         (keyword-value-listp (cdr args)))))
...">rewrite-entry</a> (<a class="sym-link local-def" href="#def-rewrite" data-sym="REWRITE" title="(mutual-recursion
 (defun rewrite
        (term alist bkptr rdepth step-limit type-alist obj geneqv pequiv-info
         wrld state fnstack ancestors backchain-limit simplify-clause-pot-lst
         rcnst gstack ttree)
...">rewrite</a> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a> nil '<a class="sym-link system" href="axioms.html#def-lambda-object-body" data-sym="LAMBDA-OBJECT-BODY">lambda-object-body</a>)
                          <span class="keyword">:fnstack</span> (cons <span class="keyword">:rewrite-lambda-object</span> fnstack)
                          <span class="keyword">:type-alist</span> type-alist1
                          <span class="keyword">:obj</span> '?
                          <span class="keyword">:geneqv</span> nil
                          <span class="keyword">:pequiv-info</span> nil
                          <span class="keyword">:ancestors</span> nil
                          <span class="keyword">:simplify-clause-pot-lst</span> nil
                          <span class="keyword">:ttree</span> nil)
                        (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (temp-rewritten-body temp-ttree1)
                          (normalize temp-rewritten-body
                            nil
                            nil
                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                            wrld
                            temp-ttree1
                            (<a class="sym-link system" href="axioms.html#def-backchain-limit" data-sym="BACKCHAIN-LIMIT">backchain-limit</a> wrld <span class="keyword">:ts</span>))
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit temp-rewritten-body temp-ttree1)))
                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                        (clean-up-dirty-lambda-object-body <span class="keyword">:all</span> <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                          wrld
                          (remove-guard-holders-lamp))
                        ttree))
                    (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((equal rewritten-body <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>) (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> ((<a class="sym-link system" href="axioms.html#def-null" data-sym="NULL">null</a> dcl) (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree))
                          (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit `(lambda ,FORMALS ,BODY) ttree))))
                      ((<a class="sym-link system" href="axioms.html#def-or" data-sym="OR">or</a> (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (<a class="sym-link system" href="axioms.html#def-subsetp-eq" data-sym="SUBSETP-EQ">subsetp-eq</a> (<a class="sym-link system" href="axioms.html#def-all-vars" data-sym="ALL-VARS">all-vars</a> rewritten-body) <a class="sym-link system" href="basis-b.html#def-formals" data-sym="FORMALS">formals</a>))
                         (<a class="sym-link system" href="axioms.html#def-not" data-sym="NOT">not</a> (executable-tamep rewritten-body wrld))) (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-rewrite-lambda-object-post-warning" data-sym="REWRITE-LAMBDA-OBJECT-POST-WARNING" title="(defun rewrite-lambda-object-post-warning
       (evg rewritten-body post-have-no-warrants ttree wrld)
  (let* ((free-vars
          (set-difference-eq (all-vars rewritten-body)
                             (lambda-object-formals evg)))
...">rewrite-lambda-object-post-warning</a> evg
                            rewritten-body
                            nil
                            ttree1
                            wrld)
                          (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree)))
                      (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (post-have-warrants post-have-no-warrants)
                          (<a class="sym-link local-def" href="#def-partition-userfns-by-warrantp" data-sym="PARTITION-USERFNS-BY-WARRANTP" title="(defun partition-userfns-by-warrantp (fns wrld haves have-nots)
  (cond ((endp fns) (mv haves have-nots))
        ((or
          (hons-get (car fns)
                    (unquote (getpropc &#39;*badge-prim-falist* &#39;const nil wrld)))
...">partition-userfns-by-warrantp</a> (all-fnnames rewritten-body)
                            wrld
                            nil
                            nil)
                          (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (post-have-no-warrants (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-rewrite-lambda-object-post-warning" data-sym="REWRITE-LAMBDA-OBJECT-POST-WARNING" title="(defun rewrite-lambda-object-post-warning
       (evg rewritten-body post-have-no-warrants ttree wrld)
  (let* ((free-vars
          (set-difference-eq (all-vars rewritten-body)
                             (lambda-object-formals evg)))
...">rewrite-lambda-object-post-warning</a> evg
                                  rewritten-body
                                  post-have-no-warrants
                                  ttree1
                                  wrld)
                                (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree)))
                            (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-mv-let" data-sym="MV-LET">mv-let</a> (erp ttree2)
                                (<a class="sym-link local-def" href="#def-push-warrants" data-sym="PUSH-WARRANTS" title="(defun push-warrants (fns target type-alist ens wrld ok-to-force ttree ttree0)
  (cond ((endp fns) (mv nil ttree))
        (t
         (let* ((fn (car fns))
                (warrant-name (warrant-name fn))
...">push-warrants</a> (<a class="sym-link system" href="axioms.html#def-union-eq" data-sym="UNION-EQ">union-eq</a> pre-have-warrants post-have-warrants)
                                  <a class="sym-link system" href="basis-b.html#def-body" data-sym="BODY">body</a>
                                  type-alist1
                                  (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>)
                                  wrld
                                  (<a class="sym-link local-def" href="#def-ok-to-force" data-sym="OK-TO-FORCE" title="(defun ok-to-force (rcnst)
  (let ((force-info (access rewrite-constant rcnst :force-info)))
    (cond
     ((eq force-info t)
      (and
...">ok-to-force</a> rcnst)
                                  ttree1
                                  ttree)
                                (<a class="sym-link system" href="axioms.html#def-cond" data-sym="COND">cond</a> (erp (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-rewrite-lambda-object-post-warning" data-sym="REWRITE-LAMBDA-OBJECT-POST-WARNING" title="(defun rewrite-lambda-object-post-warning
       (evg rewritten-body post-have-no-warrants ttree wrld)
  (let* ((free-vars
          (set-difference-eq (all-vars rewritten-body)
                             (lambda-object-formals evg)))
...">rewrite-lambda-object-post-warning</a> evg
                                        rewritten-body
                                        nil
                                        ttree1
                                        wrld)
                                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree)))
                                  (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (let ((ttree3 (push-lemma <a class="sym-link local-def" href="#def-_2Arewrite-lambda-modep-xrune_2A" data-sym="*REWRITE-LAMBDA-MODEP-XRUNE*" title="(defconst *rewrite-lambda-modep-xrune*
          &#39;(:executable-counterpart rewrite-lambda-modep))">*rewrite-lambda-modep-xrune*</a>
                                           (cons-tag-trees ttree2 ttree))))
                                      (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit
                                        `(lambda ,FORMALS ,REWRITTEN-BODY)
                                        (if (enabled-numep <a class="sym-link system" href="axioms.html#def-_2Arewrite-lambda-modep-def-nume_2A" data-sym="*REWRITE-LAMBDA-MODEP-DEF-NUME*">*rewrite-lambda-modep-def-nume*</a>
                                            (<a class="sym-link system" href="axioms.html#def-access" data-sym="ACCESS">access</a> rewrite-constant rcnst <span class="keyword">:current-enabled-structure</span>))
                                          (push-lemma <a class="sym-link local-def" href="#def-_2Arewrite-lambda-modep-def-rune_2A" data-sym="*REWRITE-LAMBDA-MODEP-DEF-RUNE*" title="(defconst *rewrite-lambda-modep-def-rune* &#39;(:definition rewrite-lambda-modep))">*rewrite-lambda-modep-def-rune*</a> ttree3)
                                          ttree3)))))))))))))
                (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link local-def" href="#def-rewrite-lambda-object-pre-warning" data-sym="REWRITE-LAMBDA-OBJECT-PRE-WARNING" title="(defun rewrite-lambda-object-pre-warning
       (evg not-well-formedp progs pre-have-no-warrants wrld)
  (let* ((violations
          (if not-well-formedp
              0
...">rewrite-lambda-object-pre-warning</a> evg
                      nil
                      progs
                      pre-have-no-warrants
                      wrld)
                    (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree)))))))
        (<a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> (<a class="sym-link system" href="axioms.html#def-prog2_24" data-sym="PROG2$">prog2$</a> (<a class="sym-link system" href="axioms.html#def-and" data-sym="AND">and</a> (consp evg)
              (<a class="sym-link system" href="axioms.html#def-eq" data-sym="EQ">eq</a> (car evg) 'lambda)
              (<a class="sym-link local-def" href="#def-rewrite-lambda-object-pre-warning" data-sym="REWRITE-LAMBDA-OBJECT-PRE-WARNING" title="(defun rewrite-lambda-object-pre-warning
       (evg not-well-formedp progs pre-have-no-warrants wrld)
  (let* ((violations
          (if not-well-formedp
              0
...">rewrite-lambda-object-pre-warning</a> evg <a class="sym-link system" href="axioms.html#def-t" data-sym="T">t</a> nil nil wrld))
            (<a class="sym-link system" href="axioms.html#def-mv" data-sym="MV">mv</a> step-limit evg ttree)))))))</pre>
  </div>


  </main>
  
<script>
// ACL2 Book HTML Documentation - Interactive Features
// Generated by cert2 - build2 system

// State
let activeFilter = null;
let activePartFilter = null;
let activeNameFilter = null;
let currentFontSize = 14;

// Theme management
function getStoredTheme() {
  return localStorage.getItem('acl2-theme') || 'dark';
}

function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '🌙';
  } else {
    document.documentElement.removeAttribute('data-theme');
    document.getElementById('theme-toggle').textContent = '☀️';
  }
  localStorage.setItem('acl2-theme', theme);
}

function toggleTheme() {
  const current = getStoredTheme();
  setTheme(current === 'dark' ? 'light' : 'dark');
}

// Font size management
function getStoredFontSize() {
  return parseInt(localStorage.getItem('acl2-fontsize') || '14', 10);
}

function setFontSize(size) {
  size = Math.max(10, Math.min(24, size)); // Clamp between 10-24
  currentFontSize = size;
  document.body.style.fontSize = size + 'px';
  localStorage.setItem('acl2-fontsize', size.toString());
}

function increaseFontSize() {
  setFontSize(currentFontSize + 2);
}

function decreaseFontSize() {
  setFontSize(currentFontSize - 2);
}

// Get all form blocks
function getFormBlocks() {
  return document.querySelectorAll('.form-block');
}

// Clear all filters
function clearFilter() {
  activeFilter = null;
  activePartFilter = null;
  activeNameFilter = null;
  getFormBlocks().forEach(b => {
    b.classList.remove('hidden', 'dimmed');
  });
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  const status = document.querySelector('.filter-status');
  status.classList.remove('active');
  // Slide name filter back to original position
  document.querySelector('.controls-left').style.transform = '';
  // Clear the name filter input
  const nameInput = document.getElementById('name-filter');
  if (nameInput) nameInput.value = '';
}

// Show filter status and slide name filter right
function showFilterStatus(text) {
  const status = document.querySelector('.filter-status');
  status.classList.add('active');
  status.querySelector('.filter-text').textContent = text;
  // Slide name filter to the right to make room
  setTimeout(() => {
    const statusWidth = status.offsetWidth;
    document.querySelector('.controls-left').style.transform = `translateX(${statusWidth + 15}px)`;
  }, 10);
}

// Filter to show only forms that define or reference a symbol
function filterBySymbol(symName, showUsedBy) {
  clearFilter();
  activeFilter = symName;
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines;
    const references = (block.dataset.references || '').split(',');
    const usedBy = (block.dataset.usedBy || '').split(',');
    
    let show = false;
    if (showUsedBy) {
      // Show forms that USE this symbol
      show = references.includes(symName) || definesName === symName;
    } else {
      // Show forms that this symbol USES
      show = usedBy.includes(symName) || definesName === symName;
    }
    
    if (show) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering by: ${symName} (${visibleCount} items)`);
}

// Filter by defthm part (term, hints, rule-classes, etc.)
function filterByPart(formId, partName) {
  clearFilter();
  activePartFilter = { formId, partName };
  
  // Get the part's referenced symbols
  // data-part-term becomes dataset.partTerm, data-part-hints becomes dataset.partHints, etc.
  const block = document.getElementById(formId);
  const datasetKey = 'part' + partName.charAt(0).toUpperCase() + partName.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const partData = block.dataset[datasetKey];
  if (!partData) return;
  
  const partSyms = partData.split(',').filter(s => s);
  
  // Highlight the button
  block.querySelector(`.part-btn[data-part="${partName}"]`).classList.add('active');
  
  // Hide forms not referenced by this part
  getFormBlocks().forEach(b => {
    const definesName = b.dataset.defines;
    if (b.id === formId || partSyms.includes(definesName)) {
      b.classList.remove('hidden');
    } else {
      b.classList.add('hidden');
    }
  });
  
  // Update status
  showFilterStatus(`Filtering ${formId} :${partName} (${partSyms.length} references)`);
}

// Filter by name (substring or regex)
function filterByName(pattern, useRegex) {
  // Clear other filters but keep the input value
  activeFilter = null;
  activePartFilter = null;
  document.querySelectorAll('.part-btn').forEach(b => b.classList.remove('active'));
  
  if (!pattern || pattern.trim() === '') {
    // Empty pattern - show all
    activeNameFilter = null;
    getFormBlocks().forEach(b => b.classList.remove('hidden'));
    const status = document.querySelector('.filter-status');
    status.classList.remove('active');
    document.querySelector('.controls-left').style.transform = '';
    return;
  }
  
  activeNameFilter = pattern;
  
  let matcher;
  let isValidRegex = true;
  
  if (useRegex) {
    try {
      matcher = new RegExp(pattern, 'i');
    } catch (e) {
      // Invalid regex - show error in status and don't filter
      showFilterStatus(`Invalid regex: ${e.message}`);
      return;
    }
  } else {
    // Plain substring match (case-insensitive)
    const lowerPattern = pattern.toLowerCase();
    matcher = { test: (s) => s.toLowerCase().includes(lowerPattern) };
  }
  
  const blocks = getFormBlocks();
  let visibleCount = 0;
  
  blocks.forEach(block => {
    const definesName = block.dataset.defines || '';
    if (matcher.test(definesName)) {
      block.classList.remove('hidden');
      visibleCount++;
    } else {
      block.classList.add('hidden');
    }
  });
  
  // Update status
  const modeText = useRegex ? 'regex' : 'name';
  showFilterStatus(`Filtering by ${modeText}: "${pattern}" (${visibleCount} matches)`);
}

// Click on a name to show what references it
function handleNameClick(symName) {
  if (activeFilter === symName) {
    clearFilter();
  } else {
    filterBySymbol(symName, true);
  }
}

// Navigate to a definition (same file or different)
function navigateTo(symName, file) {
  if (file) {
    // External file - navigate
    window.location.href = file + '.html#def-' + symName.toLowerCase();
  } else {
    // Same file - scroll
    const target = document.getElementById('def-' + symName.toLowerCase());
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 400);
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  // Part buttons
  document.querySelectorAll('.part-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const formId = btn.closest('.form-block').id;
      const partName = btn.dataset.part;
      if (activePartFilter && activePartFilter.formId === formId && 
          activePartFilter.partName === partName) {
        clearFilter();
      } else {
        filterByPart(formId, partName);
      }
    });
  });
  
  // Clear filter button
  document.querySelector('.clear-filter').addEventListener('click', clearFilter);
  
  // Name filter input
  const nameFilter = document.getElementById('name-filter');
  const regexToggle = document.getElementById('regex-toggle');
  
  let filterTimeout = null;
  nameFilter.addEventListener('input', () => {
    // Debounce the filter to avoid excessive updates while typing
    clearTimeout(filterTimeout);
    filterTimeout = setTimeout(() => {
      filterByName(nameFilter.value, regexToggle.checked);
    }, 150);
  });
  
  // Re-filter when regex toggle changes
  regexToggle.addEventListener('change', () => {
    if (nameFilter.value) {
      filterByName(nameFilter.value, regexToggle.checked);
    }
  });
  
  // Allow Escape key to clear filter when in input
  nameFilter.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearFilter();
      nameFilter.blur();
    }
  });
  
  // Symbol references (old span-based refs)
  document.querySelectorAll('.sym-ref').forEach(ref => {
    ref.addEventListener('click', (e) => {
      e.stopPropagation();
      const sym = ref.dataset.sym;
      const file = ref.dataset.file;
      if (file) {
        navigateTo(sym, file);
      } else {
        handleNameClick(sym);
      }
    });
  });
  
  // Symbol links (new anchor-based links)
  // These use standard <a> tags so navigation happens automatically
  // But we need to clear filters if target would be hidden
  document.querySelectorAll('.sym-link').forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        // Local link - check if target is hidden by filter
        const targetId = href.substring(1);
        const target = document.getElementById(targetId);
        if (target) {
          // If target is hidden, clear the filter first
          if (target.classList.contains('hidden')) {
            clearFilter();
          }
          // Add highlight effect after a short delay
          setTimeout(() => {
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 400);
          }, 100);
        }
      }
      // For external links, default behavior handles navigation
    });
  });
  
  // Form names (show what uses them)
  document.querySelectorAll('.form-name').forEach(name => {
    name.addEventListener('click', (e) => {
      handleNameClick(name.dataset.sym);
    });
  });
  
  // Handle hash navigation (when arriving at page with #anchor)
  if (window.location.hash) {
    const target = document.querySelector(window.location.hash);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 400);
      }, 200);
    }
  }
  
  // Initialize theme from storage
  setTheme(getStoredTheme());
  
  // Initialize font size from storage
  currentFontSize = getStoredFontSize();
  setFontSize(currentFontSize);
  
  // Theme toggle button
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Font size buttons
  document.getElementById('font-larger').addEventListener('click', increaseFontSize);
  document.getElementById('font-smaller').addEventListener('click', decreaseFontSize);
});

</script>

</body>
</html>